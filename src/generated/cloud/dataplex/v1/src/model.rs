// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Environment represents a user-visible compute infrastructure for analytics
/// within a lake.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Environment {
    /// Output only. The relative resource name of the environment, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}
    pub name: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the environment. This
    /// ID will be different if the environment is deleted and re-created with the
    /// same name.
    pub uid: std::string::String,

    /// Output only. Environment creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the environment was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the environment.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the environment.
    pub description: std::string::String,

    /// Output only. Current state of the environment.
    pub state: crate::model::State,

    /// Required. Infrastructure specification for the Environment.
    pub infrastructure_spec: std::option::Option<crate::model::environment::InfrastructureSpec>,

    /// Optional. Configuration for sessions created for this environment.
    pub session_spec: std::option::Option<crate::model::environment::SessionSpec>,

    /// Output only. Status of sessions created for this environment.
    pub session_status: std::option::Option<crate::model::environment::SessionStatus>,

    /// Output only. URI Endpoints to access sessions associated with the
    /// Environment.
    pub endpoints: std::option::Option<crate::model::environment::Endpoints>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Environment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Environment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Environment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Environment::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Environment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Environment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Environment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Environment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Environment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Environment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Environment::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [infrastructure_spec][crate::model::Environment::infrastructure_spec].
    pub fn set_infrastructure_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::environment::InfrastructureSpec>,
    {
        self.infrastructure_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [infrastructure_spec][crate::model::Environment::infrastructure_spec].
    pub fn set_or_clear_infrastructure_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::environment::InfrastructureSpec>,
    {
        self.infrastructure_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_spec][crate::model::Environment::session_spec].
    pub fn set_session_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::environment::SessionSpec>,
    {
        self.session_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_spec][crate::model::Environment::session_spec].
    pub fn set_or_clear_session_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::environment::SessionSpec>,
    {
        self.session_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_status][crate::model::Environment::session_status].
    pub fn set_session_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::environment::SessionStatus>,
    {
        self.session_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_status][crate::model::Environment::session_status].
    pub fn set_or_clear_session_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::environment::SessionStatus>,
    {
        self.session_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpoints][crate::model::Environment::endpoints].
    pub fn set_endpoints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::environment::Endpoints>,
    {
        self.endpoints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoints][crate::model::Environment::endpoints].
    pub fn set_or_clear_endpoints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::environment::Endpoints>,
    {
        self.endpoints = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Environment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Environment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Environment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __create_time,
            __update_time,
            __labels,
            __description,
            __state,
            __infrastructure_spec,
            __session_spec,
            __session_status,
            __endpoints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Environment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "infrastructureSpec" => Ok(__FieldTag::__infrastructure_spec),
                            "infrastructure_spec" => Ok(__FieldTag::__infrastructure_spec),
                            "sessionSpec" => Ok(__FieldTag::__session_spec),
                            "session_spec" => Ok(__FieldTag::__session_spec),
                            "sessionStatus" => Ok(__FieldTag::__session_status),
                            "session_status" => Ok(__FieldTag::__session_status),
                            "endpoints" => Ok(__FieldTag::__endpoints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Environment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Environment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__infrastructure_spec => {
                            if !fields.insert(__FieldTag::__infrastructure_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for infrastructure_spec",
                                ));
                            }
                            result.infrastructure_spec = map.next_value::<std::option::Option<
                                crate::model::environment::InfrastructureSpec,
                            >>()?;
                        }
                        __FieldTag::__session_spec => {
                            if !fields.insert(__FieldTag::__session_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_spec",
                                ));
                            }
                            result.session_spec = map.next_value::<std::option::Option<crate::model::environment::SessionSpec>>()?
                                ;
                        }
                        __FieldTag::__session_status => {
                            if !fields.insert(__FieldTag::__session_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_status",
                                ));
                            }
                            result.session_status = map.next_value::<std::option::Option<crate::model::environment::SessionStatus>>()?
                                ;
                        }
                        __FieldTag::__endpoints => {
                            if !fields.insert(__FieldTag::__endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints",
                                ));
                            }
                            result.endpoints = map.next_value::<std::option::Option<crate::model::environment::Endpoints>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Environment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.infrastructure_spec.is_some() {
            state.serialize_entry("infrastructureSpec", &self.infrastructure_spec)?;
        }
        if self.session_spec.is_some() {
            state.serialize_entry("sessionSpec", &self.session_spec)?;
        }
        if self.session_status.is_some() {
            state.serialize_entry("sessionStatus", &self.session_status)?;
        }
        if self.endpoints.is_some() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Environment].
pub mod environment {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the underlying infrastructure used to run workloads.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InfrastructureSpec {
        /// Hardware config
        pub resources:
            std::option::Option<crate::model::environment::infrastructure_spec::Resources>,

        /// Software config
        pub runtime: std::option::Option<crate::model::environment::infrastructure_spec::Runtime>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfrastructureSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resources][crate::model::environment::InfrastructureSpec::resources].
        ///
        /// Note that all the setters affecting `resources` are mutually
        /// exclusive.
        pub fn set_resources<
            T: std::convert::Into<
                    std::option::Option<crate::model::environment::infrastructure_spec::Resources>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = v.into();
            self
        }

        /// The value of [resources][crate::model::environment::InfrastructureSpec::resources]
        /// if it holds a `Compute`, `None` if the field is not set or
        /// holds a different branch.
        pub fn compute(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::environment::infrastructure_spec::ComputeResources>,
        > {
            #[allow(unreachable_patterns)]
            self.resources.as_ref().and_then(|v| match v {
                crate::model::environment::infrastructure_spec::Resources::Compute(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resources][crate::model::environment::InfrastructureSpec::resources]
        /// to hold a `Compute`.
        ///
        /// Note that all the setters affecting `resources` are
        /// mutually exclusive.
        pub fn set_compute<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::environment::infrastructure_spec::ComputeResources,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = std::option::Option::Some(
                crate::model::environment::infrastructure_spec::Resources::Compute(v.into()),
            );
            self
        }

        /// Sets the value of [runtime][crate::model::environment::InfrastructureSpec::runtime].
        ///
        /// Note that all the setters affecting `runtime` are mutually
        /// exclusive.
        pub fn set_runtime<
            T: std::convert::Into<
                    std::option::Option<crate::model::environment::infrastructure_spec::Runtime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = v.into();
            self
        }

        /// The value of [runtime][crate::model::environment::InfrastructureSpec::runtime]
        /// if it holds a `OsImage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn os_image(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::environment::infrastructure_spec::OsImageRuntime>,
        > {
            #[allow(unreachable_patterns)]
            self.runtime.as_ref().and_then(|v| match v {
                crate::model::environment::infrastructure_spec::Runtime::OsImage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [runtime][crate::model::environment::InfrastructureSpec::runtime]
        /// to hold a `OsImage`.
        ///
        /// Note that all the setters affecting `runtime` are
        /// mutually exclusive.
        pub fn set_os_image<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::environment::infrastructure_spec::OsImageRuntime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = std::option::Option::Some(
                crate::model::environment::infrastructure_spec::Runtime::OsImage(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for InfrastructureSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.InfrastructureSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InfrastructureSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __compute,
                __os_image,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InfrastructureSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "compute" => Ok(__FieldTag::__compute),
                                "osImage" => Ok(__FieldTag::__os_image),
                                "os_image" => Ok(__FieldTag::__os_image),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InfrastructureSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InfrastructureSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__compute => {
                                if !fields.insert(__FieldTag::__compute) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compute",
                                    ));
                                }
                                if result.resources.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `resources`, a oneof with full ID .google.cloud.dataplex.v1.Environment.InfrastructureSpec.compute, latest field was compute",
                                    ));
                                }
                                result.resources = std::option::Option::Some(
                                    crate::model::environment::infrastructure_spec::Resources::Compute(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::environment::infrastructure_spec::ComputeResources>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__os_image => {
                                if !fields.insert(__FieldTag::__os_image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for os_image",
                                    ));
                                }
                                if result.runtime.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `runtime`, a oneof with full ID .google.cloud.dataplex.v1.Environment.InfrastructureSpec.os_image, latest field was osImage",
                                    ));
                                }
                                result.runtime = std::option::Option::Some(
                                    crate::model::environment::infrastructure_spec::Runtime::OsImage(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::environment::infrastructure_spec::OsImageRuntime>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InfrastructureSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.compute() {
                state.serialize_entry("compute", value)?;
            }
            if let Some(value) = self.os_image() {
                state.serialize_entry("osImage", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [InfrastructureSpec].
    pub mod infrastructure_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Compute resources associated with the analyze interactive workloads.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ComputeResources {
            /// Optional. Size in GB of the disk. Default is 100 GB.
            pub disk_size_gb: i32,

            /// Optional. Total number of nodes in the sessions created for this
            /// environment.
            pub node_count: i32,

            /// Optional. Max configurable nodes.
            /// If max_node_count > node_count, then auto-scaling is enabled.
            pub max_node_count: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ComputeResources {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [disk_size_gb][crate::model::environment::infrastructure_spec::ComputeResources::disk_size_gb].
            pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.disk_size_gb = v.into();
                self
            }

            /// Sets the value of [node_count][crate::model::environment::infrastructure_spec::ComputeResources::node_count].
            pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.node_count = v.into();
                self
            }

            /// Sets the value of [max_node_count][crate::model::environment::infrastructure_spec::ComputeResources::max_node_count].
            pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_node_count = v.into();
                self
            }
        }

        impl wkt::message::Message for ComputeResources {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Environment.InfrastructureSpec.ComputeResources"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ComputeResources {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __disk_size_gb,
                    __node_count,
                    __max_node_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ComputeResources")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                                    "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                                    "nodeCount" => Ok(__FieldTag::__node_count),
                                    "node_count" => Ok(__FieldTag::__node_count),
                                    "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                                    "max_node_count" => Ok(__FieldTag::__max_node_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ComputeResources;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ComputeResources")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__disk_size_gb => {
                                    if !fields.insert(__FieldTag::__disk_size_gb) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disk_size_gb",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.disk_size_gb =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__node_count => {
                                    if !fields.insert(__FieldTag::__node_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for node_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.node_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__max_node_count => {
                                    if !fields.insert(__FieldTag::__max_node_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_node_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_node_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ComputeResources {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.disk_size_gb) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
                }
                if !wkt::internal::is_default(&self.node_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("nodeCount", &__With(&self.node_count))?;
                }
                if !wkt::internal::is_default(&self.max_node_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Software Runtime Configuration to run Analyze.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct OsImageRuntime {
            /// Required. Dataplex Image version.
            pub image_version: std::string::String,

            /// Optional. List of Java jars to be included in the runtime environment.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            pub java_libraries: std::vec::Vec<std::string::String>,

            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            pub python_packages: std::vec::Vec<std::string::String>,

            /// Optional. Spark properties to provide configuration for use in sessions
            /// created for this environment. The properties to set on daemon config
            /// files. Property keys are specified in `prefix:property` format. The
            /// prefix must be "spark".
            pub properties: std::collections::HashMap<std::string::String, std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl OsImageRuntime {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [image_version][crate::model::environment::infrastructure_spec::OsImageRuntime::image_version].
            pub fn set_image_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.image_version = v.into();
                self
            }

            /// Sets the value of [java_libraries][crate::model::environment::infrastructure_spec::OsImageRuntime::java_libraries].
            pub fn set_java_libraries<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.java_libraries = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [python_packages][crate::model::environment::infrastructure_spec::OsImageRuntime::python_packages].
            pub fn set_python_packages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.python_packages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [properties][crate::model::environment::infrastructure_spec::OsImageRuntime::properties].
            pub fn set_properties<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for OsImageRuntime {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Environment.InfrastructureSpec.OsImageRuntime"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for OsImageRuntime {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __image_version,
                    __java_libraries,
                    __python_packages,
                    __properties,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for OsImageRuntime")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "imageVersion" => Ok(__FieldTag::__image_version),
                                    "image_version" => Ok(__FieldTag::__image_version),
                                    "javaLibraries" => Ok(__FieldTag::__java_libraries),
                                    "java_libraries" => Ok(__FieldTag::__java_libraries),
                                    "pythonPackages" => Ok(__FieldTag::__python_packages),
                                    "python_packages" => Ok(__FieldTag::__python_packages),
                                    "properties" => Ok(__FieldTag::__properties),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = OsImageRuntime;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct OsImageRuntime")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__image_version => {
                                    if !fields.insert(__FieldTag::__image_version) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for image_version",
                                            ),
                                        );
                                    }
                                    result.image_version = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__java_libraries => {
                                    if !fields.insert(__FieldTag::__java_libraries) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for java_libraries",
                                            ),
                                        );
                                    }
                                    result.java_libraries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__python_packages => {
                                    if !fields.insert(__FieldTag::__python_packages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for python_packages",
                                            ),
                                        );
                                    }
                                    result.python_packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__properties => {
                                    if !fields.insert(__FieldTag::__properties) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for properties",
                                            ),
                                        );
                                    }
                                    result.properties = map
                                        .next_value::<std::option::Option<
                                            std::collections::HashMap<
                                                std::string::String,
                                                std::string::String,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for OsImageRuntime {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.image_version.is_empty() {
                    state.serialize_entry("imageVersion", &self.image_version)?;
                }
                if !self.java_libraries.is_empty() {
                    state.serialize_entry("javaLibraries", &self.java_libraries)?;
                }
                if !self.python_packages.is_empty() {
                    state.serialize_entry("pythonPackages", &self.python_packages)?;
                }
                if !self.properties.is_empty() {
                    state.serialize_entry("properties", &self.properties)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Hardware config
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Resources {
            /// Optional. Compute resources needed for analyze interactive workloads.
            Compute(
                std::boxed::Box<crate::model::environment::infrastructure_spec::ComputeResources>,
            ),
        }

        /// Software config
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Runtime {
            /// Required. Software Runtime Configuration for analyze interactive
            /// workloads.
            OsImage(
                std::boxed::Box<crate::model::environment::infrastructure_spec::OsImageRuntime>,
            ),
        }
    }

    /// Configuration for sessions created for this environment.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SessionSpec {
        /// Optional. The idle time configuration of the session. The session will be
        /// auto-terminated at the end of this period.
        pub max_idle_duration: std::option::Option<wkt::Duration>,

        /// Optional. If True, this causes sessions to be pre-created and available
        /// for faster startup to enable interactive exploration use-cases. This
        /// defaults to False to avoid additional billed charges. These can only be
        /// set to True for the environment with name set to "default", and with
        /// default configuration.
        pub enable_fast_startup: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_idle_duration][crate::model::environment::SessionSpec::max_idle_duration].
        pub fn set_max_idle_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.max_idle_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_idle_duration][crate::model::environment::SessionSpec::max_idle_duration].
        pub fn set_or_clear_max_idle_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.max_idle_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [enable_fast_startup][crate::model::environment::SessionSpec::enable_fast_startup].
        pub fn set_enable_fast_startup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_fast_startup = v.into();
            self
        }
    }

    impl wkt::message::Message for SessionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.SessionSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SessionSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __max_idle_duration,
                __enable_fast_startup,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SessionSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "maxIdleDuration" => Ok(__FieldTag::__max_idle_duration),
                                "max_idle_duration" => Ok(__FieldTag::__max_idle_duration),
                                "enableFastStartup" => Ok(__FieldTag::__enable_fast_startup),
                                "enable_fast_startup" => Ok(__FieldTag::__enable_fast_startup),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SessionSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SessionSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__max_idle_duration => {
                                if !fields.insert(__FieldTag::__max_idle_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_idle_duration",
                                    ));
                                }
                                result.max_idle_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__enable_fast_startup => {
                                if !fields.insert(__FieldTag::__enable_fast_startup) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_fast_startup",
                                    ));
                                }
                                result.enable_fast_startup = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SessionSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.max_idle_duration.is_some() {
                state.serialize_entry("maxIdleDuration", &self.max_idle_duration)?;
            }
            if !wkt::internal::is_default(&self.enable_fast_startup) {
                state.serialize_entry("enableFastStartup", &self.enable_fast_startup)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Status of sessions created for this environment.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SessionStatus {
        /// Output only. Queries over sessions to mark whether the environment is
        /// currently active or not
        pub active: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [active][crate::model::environment::SessionStatus::active].
        pub fn set_active<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.active = v.into();
            self
        }
    }

    impl wkt::message::Message for SessionStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.SessionStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SessionStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __active,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SessionStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "active" => Ok(__FieldTag::__active),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SessionStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SessionStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__active => {
                                if !fields.insert(__FieldTag::__active) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for active",
                                    ));
                                }
                                result.active = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SessionStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.active) {
                state.serialize_entry("active", &self.active)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// URI Endpoints to access sessions associated with the Environment.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Endpoints {
        /// Output only. URI to serve notebook APIs
        pub notebooks: std::string::String,

        /// Output only. URI to serve SQL APIs
        pub sql: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Endpoints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [notebooks][crate::model::environment::Endpoints::notebooks].
        pub fn set_notebooks<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.notebooks = v.into();
            self
        }

        /// Sets the value of [sql][crate::model::environment::Endpoints::sql].
        pub fn set_sql<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.sql = v.into();
            self
        }
    }

    impl wkt::message::Message for Endpoints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.Endpoints"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Endpoints {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __notebooks,
                __sql,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Endpoints")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "notebooks" => Ok(__FieldTag::__notebooks),
                                "sql" => Ok(__FieldTag::__sql),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Endpoints;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Endpoints")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__notebooks => {
                                if !fields.insert(__FieldTag::__notebooks) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for notebooks",
                                    ));
                                }
                                result.notebooks = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__sql => {
                                if !fields.insert(__FieldTag::__sql) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql",
                                    ));
                                }
                                result.sql = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Endpoints {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.notebooks.is_empty() {
                state.serialize_entry("notebooks", &self.notebooks)?;
            }
            if !self.sql.is_empty() {
                state.serialize_entry("sql", &self.sql)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Content represents a user-visible notebook or a sql script
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Content {
    /// Output only. The relative resource name of the content, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the content. This ID
    /// will be different if the content is deleted and re-created with the same
    /// name.
    pub uid: std::string::String,

    /// Required. The path for the Content file, represented as directory
    /// structure. Unique within a lake. Limited to alphanumerics, hyphens,
    /// underscores, dots and slashes.
    pub path: std::string::String,

    /// Output only. Content creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the content was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the content.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the content.
    pub description: std::string::String,

    /// Only returned in `GetContent` requests and not in `ListContent` request.
    pub data: std::option::Option<crate::model::content::Data>,

    /// Types of content
    pub content: std::option::Option<crate::model::content::Content>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Content {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Content::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Content::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Content::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Content::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Content::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Content::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Content::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Content::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Content::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [data][crate::model::Content::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::content::Data>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::Content::data]
    /// if it holds a `DataText`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::content::Data::DataText(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::Content::data]
    /// to hold a `DataText`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_data_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data = std::option::Option::Some(crate::model::content::Data::DataText(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Content::content].
    ///
    /// Note that all the setters affecting `content` are mutually
    /// exclusive.
    pub fn set_content<
        T: std::convert::Into<std::option::Option<crate::model::content::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Content::content]
    /// if it holds a `SqlScript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_script(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::content::SqlScript>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::content::Content::SqlScript(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Content::content]
    /// to hold a `SqlScript`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_sql_script<
        T: std::convert::Into<std::boxed::Box<crate::model::content::SqlScript>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::content::Content::SqlScript(v.into()));
        self
    }

    /// The value of [content][crate::model::Content::content]
    /// if it holds a `Notebook`, `None` if the field is not set or
    /// holds a different branch.
    pub fn notebook(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::content::Notebook>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::content::Content::Notebook(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Content::content]
    /// to hold a `Notebook`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_notebook<T: std::convert::Into<std::boxed::Box<crate::model::content::Notebook>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::content::Content::Notebook(v.into()));
        self
    }
}

impl wkt::message::Message for Content {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Content"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Content {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __path,
            __create_time,
            __update_time,
            __labels,
            __description,
            __data_text,
            __sql_script,
            __notebook,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Content")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "path" => Ok(__FieldTag::__path),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "dataText" => Ok(__FieldTag::__data_text),
                            "data_text" => Ok(__FieldTag::__data_text),
                            "sqlScript" => Ok(__FieldTag::__sql_script),
                            "sql_script" => Ok(__FieldTag::__sql_script),
                            "notebook" => Ok(__FieldTag::__notebook),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Content;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Content")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_text => {
                            if !fields.insert(__FieldTag::__data_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_text",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.dataplex.v1.Content.data_text, latest field was dataText",
                                ));
                            }
                            result.data =
                                std::option::Option::Some(crate::model::content::Data::DataText(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__sql_script => {
                            if !fields.insert(__FieldTag::__sql_script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_script",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.cloud.dataplex.v1.Content.sql_script, latest field was sqlScript",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::content::Content::SqlScript(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::content::SqlScript>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__notebook => {
                            if !fields.insert(__FieldTag::__notebook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notebook",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.cloud.dataplex.v1.Content.notebook, latest field was notebook",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::content::Content::Notebook(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::content::Notebook>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Content {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.data_text() {
            state.serialize_entry("dataText", value)?;
        }
        if let Some(value) = self.sql_script() {
            state.serialize_entry("sqlScript", value)?;
        }
        if let Some(value) = self.notebook() {
            state.serialize_entry("notebook", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Content].
pub mod content {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the Sql Script content.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlScript {
        /// Required. Query Engine to be used for the Sql Query.
        pub engine: crate::model::content::sql_script::QueryEngine,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlScript {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [engine][crate::model::content::SqlScript::engine].
        pub fn set_engine<T: std::convert::Into<crate::model::content::sql_script::QueryEngine>>(
            mut self,
            v: T,
        ) -> Self {
            self.engine = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlScript {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Content.SqlScript"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlScript {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __engine,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlScript")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "engine" => Ok(__FieldTag::__engine),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlScript;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlScript")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__engine => {
                                if !fields.insert(__FieldTag::__engine) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for engine",
                                    ));
                                }
                                result.engine = map
                                    .next_value::<std::option::Option<
                                        crate::model::content::sql_script::QueryEngine,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlScript {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.engine) {
                state.serialize_entry("engine", &self.engine)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SqlScript].
    pub mod sql_script {
        #[allow(unused_imports)]
        use super::*;

        /// Query Engine Type of the SQL Script.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum QueryEngine {
            /// Value was unspecified.
            Unspecified,
            /// Spark SQL Query.
            Spark,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [QueryEngine::value] or
            /// [QueryEngine::name].
            UnknownValue(query_engine::UnknownValue),
        }

        #[doc(hidden)]
        pub mod query_engine {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl QueryEngine {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Spark => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("QUERY_ENGINE_UNSPECIFIED"),
                    Self::Spark => std::option::Option::Some("SPARK"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for QueryEngine {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for QueryEngine {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for QueryEngine {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    2 => Self::Spark,
                    _ => Self::UnknownValue(query_engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for QueryEngine {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "QUERY_ENGINE_UNSPECIFIED" => Self::Unspecified,
                    "SPARK" => Self::Spark,
                    _ => Self::UnknownValue(query_engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for QueryEngine {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Spark => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for QueryEngine {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<QueryEngine>::new(
                    ".google.cloud.dataplex.v1.Content.SqlScript.QueryEngine",
                ))
            }
        }
    }

    /// Configuration for Notebook content.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Notebook {
        /// Required. Kernel Type of the notebook.
        pub kernel_type: crate::model::content::notebook::KernelType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Notebook {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kernel_type][crate::model::content::Notebook::kernel_type].
        pub fn set_kernel_type<
            T: std::convert::Into<crate::model::content::notebook::KernelType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kernel_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Notebook {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Content.Notebook"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Notebook {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kernel_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Notebook")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kernelType" => Ok(__FieldTag::__kernel_type),
                                "kernel_type" => Ok(__FieldTag::__kernel_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Notebook;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Notebook")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kernel_type => {
                                if !fields.insert(__FieldTag::__kernel_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kernel_type",
                                    ));
                                }
                                result.kernel_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::content::notebook::KernelType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Notebook {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.kernel_type) {
                state.serialize_entry("kernelType", &self.kernel_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Notebook].
    pub mod notebook {
        #[allow(unused_imports)]
        use super::*;

        /// Kernel Type of the Jupyter notebook.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum KernelType {
            /// Kernel Type unspecified.
            Unspecified,
            /// Python 3 Kernel.
            Python3,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [KernelType::value] or
            /// [KernelType::name].
            UnknownValue(kernel_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod kernel_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl KernelType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Python3 => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("KERNEL_TYPE_UNSPECIFIED"),
                    Self::Python3 => std::option::Option::Some("PYTHON3"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for KernelType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for KernelType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for KernelType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Python3,
                    _ => Self::UnknownValue(kernel_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for KernelType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "KERNEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "PYTHON3" => Self::Python3,
                    _ => Self::UnknownValue(kernel_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for KernelType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Python3 => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for KernelType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<KernelType>::new(
                    ".google.cloud.dataplex.v1.Content.Notebook.KernelType",
                ))
            }
        }
    }

    /// Only returned in `GetContent` requests and not in `ListContent` request.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Data {
        /// Required. Content data in string format.
        DataText(std::string::String),
    }

    /// Types of content
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Content {
        /// Sql Script related configurations.
        SqlScript(std::boxed::Box<crate::model::content::SqlScript>),
        /// Notebook related configurations.
        Notebook(std::boxed::Box<crate::model::content::Notebook>),
    }
}

/// Represents an active analyze session running for a user.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Session {
    /// Output only. The relative resource name of the content, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}/sessions/{session_id}
    pub name: std::string::String,

    /// Output only. Email of user running the session.
    pub user_id: std::string::String,

    /// Output only. Session start time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of Session
    pub state: crate::model::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Session {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Session::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::Session::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Session::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Session::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Session::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Session {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Session"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Session {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __user_id,
            __create_time,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Session")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Session;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Session")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            result.user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Session {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.user_id.is_empty() {
            state.serialize_entry("userId", &self.user_id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AspectType is a template for creating Aspects, and represents the
/// JSON-schema for a given Entry, for example, BigQuery Table Schema.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AspectType {
    /// Output only. The relative resource name of the AspectType, of the form:
    /// projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the AspectType.
    /// If you delete and recreate the AspectType with the same name, then this ID
    /// will be different.
    pub uid: std::string::String,

    /// Output only. The time when the AspectType was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the AspectType was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the AspectType.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the AspectType.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The service computes this checksum. The client may send it on update and
    /// delete requests to ensure it has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Immutable. Defines the Authorization for this type.
    pub authorization: std::option::Option<crate::model::aspect_type::Authorization>,

    /// Required. MetadataTemplate of the aspect.
    pub metadata_template: std::option::Option<crate::model::aspect_type::MetadataTemplate>,

    /// Output only. Denotes the transfer status of the Aspect Type. It is
    /// unspecified for Aspect Types created from Dataplex API.
    pub transfer_status: crate::model::TransferStatus,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AspectType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AspectType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AspectType::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AspectType::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AspectType::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AspectType::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AspectType::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::AspectType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AspectType::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AspectType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::AspectType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [authorization][crate::model::AspectType::authorization].
    pub fn set_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::aspect_type::Authorization>,
    {
        self.authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization][crate::model::AspectType::authorization].
    pub fn set_or_clear_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::aspect_type::Authorization>,
    {
        self.authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata_template][crate::model::AspectType::metadata_template].
    pub fn set_metadata_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
    {
        self.metadata_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata_template][crate::model::AspectType::metadata_template].
    pub fn set_or_clear_metadata_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
    {
        self.metadata_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transfer_status][crate::model::AspectType::transfer_status].
    pub fn set_transfer_status<T: std::convert::Into<crate::model::TransferStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_status = v.into();
        self
    }
}

impl wkt::message::Message for AspectType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.AspectType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AspectType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __labels,
            __etag,
            __authorization,
            __metadata_template,
            __transfer_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AspectType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "authorization" => Ok(__FieldTag::__authorization),
                            "metadataTemplate" => Ok(__FieldTag::__metadata_template),
                            "metadata_template" => Ok(__FieldTag::__metadata_template),
                            "transferStatus" => Ok(__FieldTag::__transfer_status),
                            "transfer_status" => Ok(__FieldTag::__transfer_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AspectType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AspectType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authorization => {
                            if !fields.insert(__FieldTag::__authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization",
                                ));
                            }
                            result.authorization = map.next_value::<std::option::Option<crate::model::aspect_type::Authorization>>()?
                                ;
                        }
                        __FieldTag::__metadata_template => {
                            if !fields.insert(__FieldTag::__metadata_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_template",
                                ));
                            }
                            result.metadata_template =
                                map.next_value::<std::option::Option<
                                    crate::model::aspect_type::MetadataTemplate,
                                >>()?;
                        }
                        __FieldTag::__transfer_status => {
                            if !fields.insert(__FieldTag::__transfer_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_status",
                                ));
                            }
                            result.transfer_status = map
                                .next_value::<std::option::Option<crate::model::TransferStatus>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AspectType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.authorization.is_some() {
            state.serialize_entry("authorization", &self.authorization)?;
        }
        if self.metadata_template.is_some() {
            state.serialize_entry("metadataTemplate", &self.metadata_template)?;
        }
        if !wkt::internal::is_default(&self.transfer_status) {
            state.serialize_entry("transferStatus", &self.transfer_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AspectType].
pub mod aspect_type {
    #[allow(unused_imports)]
    use super::*;

    /// Autorization for an AspectType.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Authorization {
        /// Immutable. The IAM permission grantable on the EntryGroup to allow access
        /// to instantiate Aspects of Dataplex owned AspectTypes, only settable for
        /// Dataplex owned Types.
        pub alternate_use_permission: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Authorization {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [alternate_use_permission][crate::model::aspect_type::Authorization::alternate_use_permission].
        pub fn set_alternate_use_permission<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.alternate_use_permission = v.into();
            self
        }
    }

    impl wkt::message::Message for Authorization {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.AspectType.Authorization"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Authorization {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __alternate_use_permission,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Authorization")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "alternateUsePermission" => {
                                    Ok(__FieldTag::__alternate_use_permission)
                                }
                                "alternate_use_permission" => {
                                    Ok(__FieldTag::__alternate_use_permission)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Authorization;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Authorization")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__alternate_use_permission => {
                                if !fields.insert(__FieldTag::__alternate_use_permission) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for alternate_use_permission",
                                    ));
                                }
                                result.alternate_use_permission = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Authorization {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.alternate_use_permission.is_empty() {
                state.serialize_entry("alternateUsePermission", &self.alternate_use_permission)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// MetadataTemplate definition for an AspectType.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MetadataTemplate {
        /// Optional. Index is used to encode Template messages. The value of index
        /// can range between 1 and 2,147,483,647. Index must be unique within all
        /// fields in a Template. (Nested Templates can reuse indexes). Once a
        /// Template is defined, the index cannot be changed, because it identifies
        /// the field in the actual storage format. Index is a mandatory field, but
        /// it is optional for top level fields, and map/array "values" definitions.
        pub index: i32,

        /// Required. The name of the field.
        pub name: std::string::String,

        /// Required. The datatype of this field. The following values are supported:
        ///
        /// Primitive types:
        ///
        /// * string
        /// * integer
        /// * boolean
        /// * double
        /// * datetime. Must be of the format RFC3339 UTC "Zulu" (Examples:
        ///   "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z").
        ///
        /// Complex types:
        ///
        /// * enum
        /// * array
        /// * map
        /// * record
        pub r#type: std::string::String,

        /// Optional. Field definition. You must specify it if the type is record. It
        /// defines the nested fields.
        pub record_fields: std::vec::Vec<crate::model::aspect_type::MetadataTemplate>,

        /// Optional. The list of values for an enum type. You must define it if the
        /// type is enum.
        pub enum_values: std::vec::Vec<crate::model::aspect_type::metadata_template::EnumValue>,

        /// Optional. If the type is map, set map_items. map_items can refer to a
        /// primitive field or a complex (record only) field. To specify a primitive
        /// field, you only need to set name and type in the nested
        /// MetadataTemplate. The recommended value for the name field is item, as
        /// this isn't used in the actual payload.
        pub map_items:
            std::option::Option<std::boxed::Box<crate::model::aspect_type::MetadataTemplate>>,

        /// Optional. If the type is array, set array_items. array_items can refer
        /// to a primitive field or a complex (record only) field. To specify a
        /// primitive field, you only need to set name and type in the nested
        /// MetadataTemplate. The recommended value for the name field is item, as
        /// this isn't used in the actual payload.
        pub array_items:
            std::option::Option<std::boxed::Box<crate::model::aspect_type::MetadataTemplate>>,

        /// Optional. You can use type id if this definition of the field needs to be
        /// reused later. The type id must be unique across the entire template. You
        /// can only specify it if the field type is record.
        pub type_id: std::string::String,

        /// Optional. A reference to another field definition (not an inline
        /// definition). The value must be equal to the value of an id field defined
        /// elsewhere in the MetadataTemplate. Only fields with record type can
        /// refer to other fields.
        pub type_ref: std::string::String,

        /// Optional. Specifies the constraints on this field.
        pub constraints:
            std::option::Option<crate::model::aspect_type::metadata_template::Constraints>,

        /// Optional. Specifies annotations on this field.
        pub annotations:
            std::option::Option<crate::model::aspect_type::metadata_template::Annotations>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MetadataTemplate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index][crate::model::aspect_type::MetadataTemplate::index].
        pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.index = v.into();
            self
        }

        /// Sets the value of [name][crate::model::aspect_type::MetadataTemplate::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::aspect_type::MetadataTemplate::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [record_fields][crate::model::aspect_type::MetadataTemplate::record_fields].
        pub fn set_record_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
        {
            use std::iter::Iterator;
            self.record_fields = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [enum_values][crate::model::aspect_type::MetadataTemplate::enum_values].
        pub fn set_enum_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::aspect_type::metadata_template::EnumValue>,
        {
            use std::iter::Iterator;
            self.enum_values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [map_items][crate::model::aspect_type::MetadataTemplate::map_items].
        pub fn set_map_items<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
        {
            self.map_items = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [map_items][crate::model::aspect_type::MetadataTemplate::map_items].
        pub fn set_or_clear_map_items<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
        {
            self.map_items = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }

        /// Sets the value of [array_items][crate::model::aspect_type::MetadataTemplate::array_items].
        pub fn set_array_items<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
        {
            self.array_items = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [array_items][crate::model::aspect_type::MetadataTemplate::array_items].
        pub fn set_or_clear_array_items<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
        {
            self.array_items = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }

        /// Sets the value of [type_id][crate::model::aspect_type::MetadataTemplate::type_id].
        pub fn set_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.type_id = v.into();
            self
        }

        /// Sets the value of [type_ref][crate::model::aspect_type::MetadataTemplate::type_ref].
        pub fn set_type_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.type_ref = v.into();
            self
        }

        /// Sets the value of [constraints][crate::model::aspect_type::MetadataTemplate::constraints].
        pub fn set_constraints<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::metadata_template::Constraints>,
        {
            self.constraints = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [constraints][crate::model::aspect_type::MetadataTemplate::constraints].
        pub fn set_or_clear_constraints<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::metadata_template::Constraints>,
        {
            self.constraints = v.map(|x| x.into());
            self
        }

        /// Sets the value of [annotations][crate::model::aspect_type::MetadataTemplate::annotations].
        pub fn set_annotations<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::metadata_template::Annotations>,
        {
            self.annotations = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [annotations][crate::model::aspect_type::MetadataTemplate::annotations].
        pub fn set_or_clear_annotations<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::aspect_type::metadata_template::Annotations>,
        {
            self.annotations = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MetadataTemplate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MetadataTemplate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __index,
                __name,
                __type,
                __record_fields,
                __enum_values,
                __map_items,
                __array_items,
                __type_id,
                __type_ref,
                __constraints,
                __annotations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MetadataTemplate")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "index" => Ok(__FieldTag::__index),
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                "recordFields" => Ok(__FieldTag::__record_fields),
                                "record_fields" => Ok(__FieldTag::__record_fields),
                                "enumValues" => Ok(__FieldTag::__enum_values),
                                "enum_values" => Ok(__FieldTag::__enum_values),
                                "mapItems" => Ok(__FieldTag::__map_items),
                                "map_items" => Ok(__FieldTag::__map_items),
                                "arrayItems" => Ok(__FieldTag::__array_items),
                                "array_items" => Ok(__FieldTag::__array_items),
                                "typeId" => Ok(__FieldTag::__type_id),
                                "type_id" => Ok(__FieldTag::__type_id),
                                "typeRef" => Ok(__FieldTag::__type_ref),
                                "type_ref" => Ok(__FieldTag::__type_ref),
                                "constraints" => Ok(__FieldTag::__constraints),
                                "annotations" => Ok(__FieldTag::__annotations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MetadataTemplate;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MetadataTemplate")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__index => {
                                if !fields.insert(__FieldTag::__index) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for index",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__record_fields => {
                                if !fields.insert(__FieldTag::__record_fields) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for record_fields",
                                    ));
                                }
                                result.record_fields = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::aspect_type::MetadataTemplate>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enum_values => {
                                if !fields.insert(__FieldTag::__enum_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enum_values",
                                    ));
                                }
                                result.enum_values = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::aspect_type::metadata_template::EnumValue,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__map_items => {
                                if !fields.insert(__FieldTag::__map_items) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for map_items",
                                    ));
                                }
                                result.map_items = map.next_value::<std::option::Option<
                                    std::boxed::Box<crate::model::aspect_type::MetadataTemplate>,
                                >>()?;
                            }
                            __FieldTag::__array_items => {
                                if !fields.insert(__FieldTag::__array_items) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for array_items",
                                    ));
                                }
                                result.array_items = map.next_value::<std::option::Option<
                                    std::boxed::Box<crate::model::aspect_type::MetadataTemplate>,
                                >>()?;
                            }
                            __FieldTag::__type_id => {
                                if !fields.insert(__FieldTag::__type_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type_id",
                                    ));
                                }
                                result.type_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type_ref => {
                                if !fields.insert(__FieldTag::__type_ref) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type_ref",
                                    ));
                                }
                                result.type_ref = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__constraints => {
                                if !fields.insert(__FieldTag::__constraints) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for constraints",
                                    ));
                                }
                                result.constraints = map.next_value::<std::option::Option<
                                    crate::model::aspect_type::metadata_template::Constraints,
                                >>()?;
                            }
                            __FieldTag::__annotations => {
                                if !fields.insert(__FieldTag::__annotations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for annotations",
                                    ));
                                }
                                result.annotations = map.next_value::<std::option::Option<
                                    crate::model::aspect_type::metadata_template::Annotations,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MetadataTemplate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.index) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("index", &__With(&self.index))?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.record_fields.is_empty() {
                state.serialize_entry("recordFields", &self.record_fields)?;
            }
            if !self.enum_values.is_empty() {
                state.serialize_entry("enumValues", &self.enum_values)?;
            }
            if self.map_items.is_some() {
                state.serialize_entry("mapItems", &self.map_items)?;
            }
            if self.array_items.is_some() {
                state.serialize_entry("arrayItems", &self.array_items)?;
            }
            if !self.type_id.is_empty() {
                state.serialize_entry("typeId", &self.type_id)?;
            }
            if !self.type_ref.is_empty() {
                state.serialize_entry("typeRef", &self.type_ref)?;
            }
            if self.constraints.is_some() {
                state.serialize_entry("constraints", &self.constraints)?;
            }
            if self.annotations.is_some() {
                state.serialize_entry("annotations", &self.annotations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [MetadataTemplate].
    pub mod metadata_template {
        #[allow(unused_imports)]
        use super::*;

        /// Definition of Enumvalue, to be used for enum fields.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct EnumValue {
            /// Required. Index for the enum value. It can't be modified.
            pub index: i32,

            /// Required. Name of the enumvalue. This is the actual value that the
            /// aspect can contain.
            pub name: std::string::String,

            /// Optional. You can set this message if you need to deprecate an enum
            /// value.
            pub deprecated: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EnumValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [index][crate::model::aspect_type::metadata_template::EnumValue::index].
            pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.index = v.into();
                self
            }

            /// Sets the value of [name][crate::model::aspect_type::metadata_template::EnumValue::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [deprecated][crate::model::aspect_type::metadata_template::EnumValue::deprecated].
            pub fn set_deprecated<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.deprecated = v.into();
                self
            }
        }

        impl wkt::message::Message for EnumValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate.EnumValue"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for EnumValue {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __index,
                    __name,
                    __deprecated,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for EnumValue")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "index" => Ok(__FieldTag::__index),
                                    "name" => Ok(__FieldTag::__name),
                                    "deprecated" => Ok(__FieldTag::__deprecated),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = EnumValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct EnumValue")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__index => {
                                    if !fields.insert(__FieldTag::__index) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for index"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.index =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__deprecated => {
                                    if !fields.insert(__FieldTag::__deprecated) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for deprecated",
                                            ),
                                        );
                                    }
                                    result.deprecated = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for EnumValue {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.index) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("index", &__With(&self.index))?;
                }
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self.deprecated.is_empty() {
                    state.serialize_entry("deprecated", &self.deprecated)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Definition of the constraints of a field.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Constraints {
            /// Optional. Marks this field as optional or required.
            pub required: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Constraints {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [required][crate::model::aspect_type::metadata_template::Constraints::required].
            pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.required = v.into();
                self
            }
        }

        impl wkt::message::Message for Constraints {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate.Constraints"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Constraints {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __required,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Constraints")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "required" => Ok(__FieldTag::__required),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Constraints;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Constraints")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__required => {
                                    if !fields.insert(__FieldTag::__required) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for required",
                                            ),
                                        );
                                    }
                                    result.required = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Constraints {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.required) {
                    state.serialize_entry("required", &self.required)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Definition of the annotations of a field.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Annotations {
            /// Optional. Marks a field as deprecated. You can include a deprecation
            /// message.
            pub deprecated: std::string::String,

            /// Optional. Display name for a field.
            pub display_name: std::string::String,

            /// Optional. Description for a field.
            pub description: std::string::String,

            /// Optional. Display order for a field. You can use this to reorder where
            /// a field is rendered.
            pub display_order: i32,

            /// Optional. You can use String Type annotations to specify special
            /// meaning to string fields. The following values are supported:
            ///
            /// * richText: The field must be interpreted as a rich text field.
            /// * url: A fully qualified URL link.
            /// * resource: A service qualified resource reference.
            pub string_type: std::string::String,

            /// Optional. Suggested hints for string fields. You can use them to
            /// suggest values to users through console.
            pub string_values: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Annotations {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [deprecated][crate::model::aspect_type::metadata_template::Annotations::deprecated].
            pub fn set_deprecated<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.deprecated = v.into();
                self
            }

            /// Sets the value of [display_name][crate::model::aspect_type::metadata_template::Annotations::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [description][crate::model::aspect_type::metadata_template::Annotations::description].
            pub fn set_description<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.description = v.into();
                self
            }

            /// Sets the value of [display_order][crate::model::aspect_type::metadata_template::Annotations::display_order].
            pub fn set_display_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.display_order = v.into();
                self
            }

            /// Sets the value of [string_type][crate::model::aspect_type::metadata_template::Annotations::string_type].
            pub fn set_string_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.string_type = v.into();
                self
            }

            /// Sets the value of [string_values][crate::model::aspect_type::metadata_template::Annotations::string_values].
            pub fn set_string_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.string_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Annotations {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate.Annotations"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Annotations {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __deprecated,
                    __display_name,
                    __description,
                    __display_order,
                    __string_type,
                    __string_values,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Annotations")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "deprecated" => Ok(__FieldTag::__deprecated),
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "description" => Ok(__FieldTag::__description),
                                    "displayOrder" => Ok(__FieldTag::__display_order),
                                    "display_order" => Ok(__FieldTag::__display_order),
                                    "stringType" => Ok(__FieldTag::__string_type),
                                    "string_type" => Ok(__FieldTag::__string_type),
                                    "stringValues" => Ok(__FieldTag::__string_values),
                                    "string_values" => Ok(__FieldTag::__string_values),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Annotations;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Annotations")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__deprecated => {
                                    if !fields.insert(__FieldTag::__deprecated) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for deprecated",
                                            ),
                                        );
                                    }
                                    result.deprecated = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__description => {
                                    if !fields.insert(__FieldTag::__description) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for description",
                                            ),
                                        );
                                    }
                                    result.description = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__display_order => {
                                    if !fields.insert(__FieldTag::__display_order) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_order",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.display_order =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__string_type => {
                                    if !fields.insert(__FieldTag::__string_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for string_type",
                                            ),
                                        );
                                    }
                                    result.string_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__string_values => {
                                    if !fields.insert(__FieldTag::__string_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for string_values",
                                            ),
                                        );
                                    }
                                    result.string_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Annotations {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.deprecated.is_empty() {
                    state.serialize_entry("deprecated", &self.deprecated)?;
                }
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.description.is_empty() {
                    state.serialize_entry("description", &self.description)?;
                }
                if !wkt::internal::is_default(&self.display_order) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("displayOrder", &__With(&self.display_order))?;
                }
                if !self.string_type.is_empty() {
                    state.serialize_entry("stringType", &self.string_type)?;
                }
                if !self.string_values.is_empty() {
                    state.serialize_entry("stringValues", &self.string_values)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// An Entry Group represents a logical grouping of one or more Entries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntryGroup {
    /// Output only. The relative resource name of the EntryGroup, in the format
    /// projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the EntryGroup. If you
    /// delete and recreate the EntryGroup with the same name, this ID will be
    /// different.
    pub uid: std::string::String,

    /// Output only. The time when the EntryGroup was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the EntryGroup was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the EntryGroup.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the EntryGroup.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// This checksum is computed by the service, and might be sent on update and
    /// delete requests to ensure the client has an up-to-date value before
    /// proceeding.
    pub etag: std::string::String,

    /// Output only. Denotes the transfer status of the Entry Group. It is
    /// unspecified for Entry Group created from Dataplex API.
    pub transfer_status: crate::model::TransferStatus,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntryGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::EntryGroup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EntryGroup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::EntryGroup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::EntryGroup::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::EntryGroup::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::EntryGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntryGroup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntryGroup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::EntryGroup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [transfer_status][crate::model::EntryGroup::transfer_status].
    pub fn set_transfer_status<T: std::convert::Into<crate::model::TransferStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_status = v.into();
        self
    }
}

impl wkt::message::Message for EntryGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntryGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntryGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __labels,
            __etag,
            __transfer_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntryGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "transferStatus" => Ok(__FieldTag::__transfer_status),
                            "transfer_status" => Ok(__FieldTag::__transfer_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntryGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntryGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_status => {
                            if !fields.insert(__FieldTag::__transfer_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_status",
                                ));
                            }
                            result.transfer_status = map
                                .next_value::<std::option::Option<crate::model::TransferStatus>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntryGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.transfer_status) {
            state.serialize_entry("transferStatus", &self.transfer_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Entry Type is a template for creating Entries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntryType {
    /// Output only. The relative resource name of the EntryType, of the form:
    /// projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the EntryType. This ID
    /// will be different if the EntryType is deleted and re-created with the same
    /// name.
    pub uid: std::string::String,

    /// Output only. The time when the EntryType was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the EntryType was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the EntryType.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the EntryType.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This checksum is computed by the service, and might be sent on
    /// update and delete requests to ensure the client has an up-to-date value
    /// before proceeding.
    pub etag: std::string::String,

    /// Optional. Indicates the classes this Entry Type belongs to, for example,
    /// TABLE, DATABASE, MODEL.
    pub type_aliases: std::vec::Vec<std::string::String>,

    /// Optional. The platform that Entries of this type belongs to.
    pub platform: std::string::String,

    /// Optional. The system that Entries of this type belongs to. Examples include
    /// CloudSQL, MariaDB etc
    pub system: std::string::String,

    /// AspectInfo for the entry type.
    pub required_aspects: std::vec::Vec<crate::model::entry_type::AspectInfo>,

    /// Immutable. Authorization defined for this type.
    pub authorization: std::option::Option<crate::model::entry_type::Authorization>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntryType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::EntryType::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EntryType::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::EntryType::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::EntryType::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::EntryType::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::EntryType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntryType::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntryType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::EntryType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [type_aliases][crate::model::EntryType::type_aliases].
    pub fn set_type_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.type_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [platform][crate::model::EntryType::platform].
    pub fn set_platform<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [system][crate::model::EntryType::system].
    pub fn set_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [required_aspects][crate::model::EntryType::required_aspects].
    pub fn set_required_aspects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entry_type::AspectInfo>,
    {
        use std::iter::Iterator;
        self.required_aspects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [authorization][crate::model::EntryType::authorization].
    pub fn set_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::entry_type::Authorization>,
    {
        self.authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization][crate::model::EntryType::authorization].
    pub fn set_or_clear_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::entry_type::Authorization>,
    {
        self.authorization = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EntryType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntryType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntryType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __labels,
            __etag,
            __type_aliases,
            __platform,
            __system,
            __required_aspects,
            __authorization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntryType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "typeAliases" => Ok(__FieldTag::__type_aliases),
                            "type_aliases" => Ok(__FieldTag::__type_aliases),
                            "platform" => Ok(__FieldTag::__platform),
                            "system" => Ok(__FieldTag::__system),
                            "requiredAspects" => Ok(__FieldTag::__required_aspects),
                            "required_aspects" => Ok(__FieldTag::__required_aspects),
                            "authorization" => Ok(__FieldTag::__authorization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntryType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntryType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type_aliases => {
                            if !fields.insert(__FieldTag::__type_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type_aliases",
                                ));
                            }
                            result.type_aliases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform",
                                ));
                            }
                            result.platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__system => {
                            if !fields.insert(__FieldTag::__system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system",
                                ));
                            }
                            result.system = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__required_aspects => {
                            if !fields.insert(__FieldTag::__required_aspects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required_aspects",
                                ));
                            }
                            result.required_aspects = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entry_type::AspectInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authorization => {
                            if !fields.insert(__FieldTag::__authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization",
                                ));
                            }
                            result.authorization = map.next_value::<std::option::Option<crate::model::entry_type::Authorization>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntryType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.type_aliases.is_empty() {
            state.serialize_entry("typeAliases", &self.type_aliases)?;
        }
        if !self.platform.is_empty() {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self.system.is_empty() {
            state.serialize_entry("system", &self.system)?;
        }
        if !self.required_aspects.is_empty() {
            state.serialize_entry("requiredAspects", &self.required_aspects)?;
        }
        if self.authorization.is_some() {
            state.serialize_entry("authorization", &self.authorization)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EntryType].
pub mod entry_type {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AspectInfo {
        /// Required aspect type for the entry type.
        pub r#type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AspectInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::entry_type::AspectInfo::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for AspectInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EntryType.AspectInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AspectInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AspectInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AspectInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AspectInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AspectInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Authorization for an Entry Type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Authorization {
        /// Immutable. The IAM permission grantable on the Entry Group to allow
        /// access to instantiate Entries of Dataplex owned Entry Types, only
        /// settable for Dataplex owned Types.
        pub alternate_use_permission: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Authorization {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [alternate_use_permission][crate::model::entry_type::Authorization::alternate_use_permission].
        pub fn set_alternate_use_permission<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.alternate_use_permission = v.into();
            self
        }
    }

    impl wkt::message::Message for Authorization {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EntryType.Authorization"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Authorization {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __alternate_use_permission,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Authorization")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "alternateUsePermission" => {
                                    Ok(__FieldTag::__alternate_use_permission)
                                }
                                "alternate_use_permission" => {
                                    Ok(__FieldTag::__alternate_use_permission)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Authorization;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Authorization")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__alternate_use_permission => {
                                if !fields.insert(__FieldTag::__alternate_use_permission) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for alternate_use_permission",
                                    ));
                                }
                                result.alternate_use_permission = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Authorization {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.alternate_use_permission.is_empty() {
                state.serialize_entry("alternateUsePermission", &self.alternate_use_permission)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// An aspect is a single piece of metadata describing an entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Aspect {
    /// Output only. The resource name of the type used to create this Aspect.
    pub aspect_type: std::string::String,

    /// Output only. The path in the entry under which the aspect is attached.
    pub path: std::string::String,

    /// Output only. The time when the Aspect was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the Aspect was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The content of the aspect, according to its aspect type schema.
    /// The maximum size of the field is 120KB (encoded as UTF-8).
    pub data: std::option::Option<wkt::Struct>,

    /// Optional. Information related to the source system of the aspect.
    pub aspect_source: std::option::Option<crate::model::AspectSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Aspect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_type][crate::model::Aspect::aspect_type].
    pub fn set_aspect_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aspect_type = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Aspect::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Aspect::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Aspect::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Aspect::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Aspect::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data][crate::model::Aspect::data].
    pub fn set_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data][crate::model::Aspect::data].
    pub fn set_or_clear_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aspect_source][crate::model::Aspect::aspect_source].
    pub fn set_aspect_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AspectSource>,
    {
        self.aspect_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aspect_source][crate::model::Aspect::aspect_source].
    pub fn set_or_clear_aspect_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AspectSource>,
    {
        self.aspect_source = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Aspect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Aspect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Aspect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aspect_type,
            __path,
            __create_time,
            __update_time,
            __data,
            __aspect_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Aspect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aspectType" => Ok(__FieldTag::__aspect_type),
                            "aspect_type" => Ok(__FieldTag::__aspect_type),
                            "path" => Ok(__FieldTag::__path),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "data" => Ok(__FieldTag::__data),
                            "aspectSource" => Ok(__FieldTag::__aspect_source),
                            "aspect_source" => Ok(__FieldTag::__aspect_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Aspect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Aspect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aspect_type => {
                            if !fields.insert(__FieldTag::__aspect_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_type",
                                ));
                            }
                            result.aspect_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            result.data = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__aspect_source => {
                            if !fields.insert(__FieldTag::__aspect_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_source",
                                ));
                            }
                            result.aspect_source = map
                                .next_value::<std::option::Option<crate::model::AspectSource>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Aspect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aspect_type.is_empty() {
            state.serialize_entry("aspectType", &self.aspect_type)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.data.is_some() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.aspect_source.is_some() {
            state.serialize_entry("aspectSource", &self.aspect_source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information related to the source system of the aspect.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AspectSource {
    /// The time the aspect was created in the source system.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the aspect was last updated in the source system.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The version of the data format used to produce this data. This field is
    /// used to indicated when the underlying data format changes (e.g., schema
    /// modifications, changes to the source URL format definition, etc).
    pub data_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AspectSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::AspectSource::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AspectSource::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AspectSource::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AspectSource::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_version][crate::model::AspectSource::data_version].
    pub fn set_data_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_version = v.into();
        self
    }
}

impl wkt::message::Message for AspectSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.AspectSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AspectSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __data_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AspectSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "dataVersion" => Ok(__FieldTag::__data_version),
                            "data_version" => Ok(__FieldTag::__data_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AspectSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AspectSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__data_version => {
                            if !fields.insert(__FieldTag::__data_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_version",
                                ));
                            }
                            result.data_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AspectSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.data_version.is_empty() {
            state.serialize_entry("dataVersion", &self.data_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An entry is a representation of a data resource that can be described by
/// various metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Entry {
    /// Identifier. The relative resource name of the entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}/entries/{entry_id}`.
    pub name: std::string::String,

    /// Required. Immutable. The relative resource name of the entry type that was
    /// used to create this entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    pub entry_type: std::string::String,

    /// Output only. The time when the entry was created in Dataplex.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the entry was last updated in Dataplex.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The aspects that are attached to the entry. Depending on how the
    /// aspect is attached to the entry, the format of the aspect key can be one of
    /// the following:
    ///
    /// * If the aspect is attached directly to the entry:
    ///   `{project_id_or_number}.{location_id}.{aspect_type_id}`
    /// * If the aspect is attached to an entry's path:
    ///   `{project_id_or_number}.{location_id}.{aspect_type_id}@{path}`
    pub aspects: std::collections::HashMap<std::string::String, crate::model::Aspect>,

    /// Optional. Immutable. The resource name of the parent entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}/entries/{entry_id}`.
    pub parent_entry: std::string::String,

    /// Optional. A name for the entry that can be referenced by an external
    /// system. For more information, see [Fully qualified
    /// names](https://cloud.google.com/data-catalog/docs/fully-qualified-names).
    /// The maximum size of the field is 4000 characters.
    pub fully_qualified_name: std::string::String,

    /// Optional. Information related to the source system of the data resource
    /// that is represented by the entry.
    pub entry_source: std::option::Option<crate::model::EntrySource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type].
    pub fn set_entry_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Entry::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Entry::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Entry::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Entry::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aspects][crate::model::Entry::aspects].
    pub fn set_aspects<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Aspect>,
    {
        use std::iter::Iterator;
        self.aspects = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [parent_entry][crate::model::Entry::parent_entry].
    pub fn set_parent_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entry = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::Entry::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [entry_source][crate::model::Entry::entry_source].
    pub fn set_entry_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntrySource>,
    {
        self.entry_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_source][crate::model::Entry::entry_source].
    pub fn set_or_clear_entry_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntrySource>,
    {
        self.entry_source = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Entry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Entry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __entry_type,
            __create_time,
            __update_time,
            __aspects,
            __parent_entry,
            __fully_qualified_name,
            __entry_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "entryType" => Ok(__FieldTag::__entry_type),
                            "entry_type" => Ok(__FieldTag::__entry_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "aspects" => Ok(__FieldTag::__aspects),
                            "parentEntry" => Ok(__FieldTag::__parent_entry),
                            "parent_entry" => Ok(__FieldTag::__parent_entry),
                            "fullyQualifiedName" => Ok(__FieldTag::__fully_qualified_name),
                            "fully_qualified_name" => Ok(__FieldTag::__fully_qualified_name),
                            "entrySource" => Ok(__FieldTag::__entry_source),
                            "entry_source" => Ok(__FieldTag::__entry_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_type => {
                            if !fields.insert(__FieldTag::__entry_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_type",
                                ));
                            }
                            result.entry_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__aspects => {
                            if !fields.insert(__FieldTag::__aspects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspects",
                                ));
                            }
                            result.aspects = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Aspect,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_entry => {
                            if !fields.insert(__FieldTag::__parent_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_entry",
                                ));
                            }
                            result.parent_entry = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fully_qualified_name => {
                            if !fields.insert(__FieldTag::__fully_qualified_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_qualified_name",
                                ));
                            }
                            result.fully_qualified_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_source => {
                            if !fields.insert(__FieldTag::__entry_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_source",
                                ));
                            }
                            result.entry_source =
                                map.next_value::<std::option::Option<crate::model::EntrySource>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.entry_type.is_empty() {
            state.serialize_entry("entryType", &self.entry_type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.aspects.is_empty() {
            state.serialize_entry("aspects", &self.aspects)?;
        }
        if !self.parent_entry.is_empty() {
            state.serialize_entry("parentEntry", &self.parent_entry)?;
        }
        if !self.fully_qualified_name.is_empty() {
            state.serialize_entry("fullyQualifiedName", &self.fully_qualified_name)?;
        }
        if self.entry_source.is_some() {
            state.serialize_entry("entrySource", &self.entry_source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information related to the source system of the data resource that is
/// represented by the entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntrySource {
    /// The name of the resource in the source system.
    /// Maximum length is 4,000 characters.
    pub resource: std::string::String,

    /// The name of the source system.
    /// Maximum length is 64 characters.
    pub system: std::string::String,

    /// The platform containing the source system.
    /// Maximum length is 64 characters.
    pub platform: std::string::String,

    /// A user-friendly display name.
    /// Maximum length is 500 characters.
    pub display_name: std::string::String,

    /// A description of the data resource.
    /// Maximum length is 2,000 characters.
    pub description: std::string::String,

    /// User-defined labels.
    /// The maximum size of keys and values is 128 characters each.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. The entries representing the ancestors of the data resource in
    /// the source system.
    pub ancestors: std::vec::Vec<crate::model::entry_source::Ancestor>,

    /// The time when the resource was created in the source system.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the resource was last updated in the source system. If the
    /// entry exists in the system and its `EntrySource` has `update_time`
    /// populated, further updates to the `EntrySource` of the entry must provide
    /// incremental updates to its `update_time`.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Location of the resource in the source system. You can search
    /// the entry by this location. By default, this should match the location of
    /// the entry group containing this entry. A different value allows capturing
    /// the source location for data external to Google Cloud.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntrySource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::EntrySource::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [system][crate::model::EntrySource::system].
    pub fn set_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [platform][crate::model::EntrySource::platform].
    pub fn set_platform<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntrySource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntrySource::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntrySource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [ancestors][crate::model::EntrySource::ancestors].
    pub fn set_ancestors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entry_source::Ancestor>,
    {
        use std::iter::Iterator;
        self.ancestors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::EntrySource::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::EntrySource::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::EntrySource::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::EntrySource::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::EntrySource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for EntrySource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntrySource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntrySource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __system,
            __platform,
            __display_name,
            __description,
            __labels,
            __ancestors,
            __create_time,
            __update_time,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntrySource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "system" => Ok(__FieldTag::__system),
                            "platform" => Ok(__FieldTag::__platform),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "ancestors" => Ok(__FieldTag::__ancestors),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntrySource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntrySource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__system => {
                            if !fields.insert(__FieldTag::__system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system",
                                ));
                            }
                            result.system = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform",
                                ));
                            }
                            result.platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ancestors => {
                            if !fields.insert(__FieldTag::__ancestors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ancestors",
                                ));
                            }
                            result.ancestors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entry_source::Ancestor>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntrySource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.system.is_empty() {
            state.serialize_entry("system", &self.system)?;
        }
        if !self.platform.is_empty() {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.ancestors.is_empty() {
            state.serialize_entry("ancestors", &self.ancestors)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EntrySource].
pub mod entry_source {
    #[allow(unused_imports)]
    use super::*;

    /// Information about individual items in the hierarchy that is associated with
    /// the data resource.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Ancestor {
        /// Optional. The name of the ancestor resource.
        pub name: std::string::String,

        /// Optional. The type of the ancestor resource.
        pub r#type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Ancestor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::entry_source::Ancestor::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::entry_source::Ancestor::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Ancestor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EntrySource.Ancestor"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Ancestor {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Ancestor")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Ancestor;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Ancestor")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Ancestor {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Create EntryGroup Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntryGroupRequest {
    /// Required. The resource name of the entryGroup, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Required. EntryGroup identifier.
    pub entry_group_id: std::string::String,

    /// Required. EntryGroup Resource.
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_group_id][crate::model::CreateEntryGroupRequest::entry_group_id].
    pub fn set_entry_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_group_id = v.into();
        self
    }

    /// Sets the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_or_clear_entry_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEntryGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entry_group_id,
            __entry_group,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entryGroupId" => Ok(__FieldTag::__entry_group_id),
                            "entry_group_id" => Ok(__FieldTag::__entry_group_id),
                            "entryGroup" => Ok(__FieldTag::__entry_group),
                            "entry_group" => Ok(__FieldTag::__entry_group),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_group_id => {
                            if !fields.insert(__FieldTag::__entry_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_group_id",
                                ));
                            }
                            result.entry_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_group => {
                            if !fields.insert(__FieldTag::__entry_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_group",
                                ));
                            }
                            result.entry_group =
                                map.next_value::<std::option::Option<crate::model::EntryGroup>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entry_group_id.is_empty() {
            state.serialize_entry("entryGroupId", &self.entry_group_id)?;
        }
        if self.entry_group.is_some() {
            state.serialize_entry("entryGroup", &self.entry_group)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update EntryGroup Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntryGroupRequest {
    /// Required. EntryGroup Resource.
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The service validates the request, without performing any
    /// mutations. The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_or_clear_entry_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEntryGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_group,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryGroup" => Ok(__FieldTag::__entry_group),
                            "entry_group" => Ok(__FieldTag::__entry_group),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_group => {
                            if !fields.insert(__FieldTag::__entry_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_group",
                                ));
                            }
                            result.entry_group =
                                map.next_value::<std::option::Option<crate::model::EntryGroup>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entry_group.is_some() {
            state.serialize_entry("entryGroup", &self.entry_group)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete EntryGroup Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntryGroupRequest {
    /// Required. The resource name of the EntryGroup:
    /// `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteEntryGroupRequest method returns an ABORTED error
    /// response.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEntryGroupRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List entryGroups request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryGroupsRequest {
    /// Required. The resource name of the entryGroup location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    pub parent: std::string::String,

    /// Optional. Maximum number of EntryGroups to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// EntryGroups. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntryGroups` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provide to `ListEntryGroups` must match the call that
    /// provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntryGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntryGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntryGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntryGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntryGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntryGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntryGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntryGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntryGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntryGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List entry groups response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryGroupsResponse {
    /// Entry groups under the given parent location.
    pub entry_groups: std::vec::Vec<crate::model::EntryGroup>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_groups][crate::model::ListEntryGroupsResponse::entry_groups].
    pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntryGroup>,
    {
        use std::iter::Iterator;
        self.entry_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntryGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListEntryGroupsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntryGroupsResponse {
    type PageItem = crate::model::EntryGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entry_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntryGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_groups,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntryGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryGroups" => Ok(__FieldTag::__entry_groups),
                            "entry_groups" => Ok(__FieldTag::__entry_groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntryGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntryGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_groups => {
                            if !fields.insert(__FieldTag::__entry_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_groups",
                                ));
                            }
                            result.entry_groups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntryGroup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntryGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entry_groups.is_empty() {
            state.serialize_entry("entryGroups", &self.entry_groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get EntryGroup request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntryGroupRequest {
    /// Required. The resource name of the EntryGroup:
    /// `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create EntryType Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntryTypeRequest {
    /// Required. The resource name of the EntryType, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a Google Cloud region.
    pub parent: std::string::String,

    /// Required. EntryType identifier.
    pub entry_type_id: std::string::String,

    /// Required. EntryType Resource.
    pub entry_type: std::option::Option<crate::model::EntryType>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_type_id][crate::model::CreateEntryTypeRequest::entry_type_id].
    pub fn set_entry_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_type_id = v.into();
        self
    }

    /// Sets the value of [entry_type][crate::model::CreateEntryTypeRequest::entry_type].
    pub fn set_entry_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryType>,
    {
        self.entry_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_type][crate::model::CreateEntryTypeRequest::entry_type].
    pub fn set_or_clear_entry_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryType>,
    {
        self.entry_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEntryTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntryTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntryTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entry_type_id,
            __entry_type,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntryTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entryTypeId" => Ok(__FieldTag::__entry_type_id),
                            "entry_type_id" => Ok(__FieldTag::__entry_type_id),
                            "entryType" => Ok(__FieldTag::__entry_type),
                            "entry_type" => Ok(__FieldTag::__entry_type),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntryTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntryTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_type_id => {
                            if !fields.insert(__FieldTag::__entry_type_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_type_id",
                                ));
                            }
                            result.entry_type_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_type => {
                            if !fields.insert(__FieldTag::__entry_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_type",
                                ));
                            }
                            result.entry_type =
                                map.next_value::<std::option::Option<crate::model::EntryType>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEntryTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entry_type_id.is_empty() {
            state.serialize_entry("entryTypeId", &self.entry_type_id)?;
        }
        if self.entry_type.is_some() {
            state.serialize_entry("entryType", &self.entry_type)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update EntryType Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntryTypeRequest {
    /// Required. EntryType Resource.
    pub entry_type: std::option::Option<crate::model::EntryType>,

    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_type][crate::model::UpdateEntryTypeRequest::entry_type].
    pub fn set_entry_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryType>,
    {
        self.entry_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_type][crate::model::UpdateEntryTypeRequest::entry_type].
    pub fn set_or_clear_entry_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryType>,
    {
        self.entry_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntryTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEntryTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntryTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntryTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_type,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntryTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryType" => Ok(__FieldTag::__entry_type),
                            "entry_type" => Ok(__FieldTag::__entry_type),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntryTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntryTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_type => {
                            if !fields.insert(__FieldTag::__entry_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_type",
                                ));
                            }
                            result.entry_type =
                                map.next_value::<std::option::Option<crate::model::EntryType>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntryTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entry_type.is_some() {
            state.serialize_entry("entryType", &self.entry_type)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delele EntryType Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntryTypeRequest {
    /// Required. The resource name of the EntryType:
    /// `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteEntryTypeRequest method returns an ABORTED error response.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEntryTypeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntryTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntryTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntryTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntryTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntryTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntryTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List EntryTypes request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryTypesRequest {
    /// Required. The resource name of the EntryType location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    pub parent: std::string::String,

    /// Optional. Maximum number of EntryTypes to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// EntryTypes. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntryTypes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provided to `ListEntryTypes` must match the call that
    /// provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * labels.key1 = "value1"
    /// * labels:key1
    /// * name = "value"
    ///
    /// These restrictions can be conjoined with AND, OR, and NOT conjunctions.
    pub filter: std::string::String,

    /// Optional. Orders the result by `name` or `create_time` fields.
    /// If not specified, the ordering is undefined.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntryTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntryTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntryTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntryTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntryTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntryTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntryTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntryTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntryTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntryTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List EntryTypes response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryTypesResponse {
    /// EntryTypes under the given parent location.
    pub entry_types: std::vec::Vec<crate::model::EntryType>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_types][crate::model::ListEntryTypesResponse::entry_types].
    pub fn set_entry_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntryType>,
    {
        use std::iter::Iterator;
        self.entry_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntryTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListEntryTypesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntryTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntryTypesResponse {
    type PageItem = crate::model::EntryType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entry_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntryTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_types,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntryTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryTypes" => Ok(__FieldTag::__entry_types),
                            "entry_types" => Ok(__FieldTag::__entry_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntryTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntryTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_types => {
                            if !fields.insert(__FieldTag::__entry_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_types",
                                ));
                            }
                            result.entry_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntryType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntryTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entry_types.is_empty() {
            state.serialize_entry("entryTypes", &self.entry_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get EntryType request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntryTypeRequest {
    /// Required. The resource name of the EntryType:
    /// `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntryTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntryTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntryTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntryTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntryTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEntryTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create AspectType Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAspectTypeRequest {
    /// Required. The resource name of the AspectType, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a Google Cloud region.
    pub parent: std::string::String,

    /// Required. AspectType identifier.
    pub aspect_type_id: std::string::String,

    /// Required. AspectType Resource.
    pub aspect_type: std::option::Option<crate::model::AspectType>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAspectTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [aspect_type_id][crate::model::CreateAspectTypeRequest::aspect_type_id].
    pub fn set_aspect_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aspect_type_id = v.into();
        self
    }

    /// Sets the value of [aspect_type][crate::model::CreateAspectTypeRequest::aspect_type].
    pub fn set_aspect_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AspectType>,
    {
        self.aspect_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aspect_type][crate::model::CreateAspectTypeRequest::aspect_type].
    pub fn set_or_clear_aspect_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AspectType>,
    {
        self.aspect_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAspectTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateAspectTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAspectTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __aspect_type_id,
            __aspect_type,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAspectTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "aspectTypeId" => Ok(__FieldTag::__aspect_type_id),
                            "aspect_type_id" => Ok(__FieldTag::__aspect_type_id),
                            "aspectType" => Ok(__FieldTag::__aspect_type),
                            "aspect_type" => Ok(__FieldTag::__aspect_type),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAspectTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAspectTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aspect_type_id => {
                            if !fields.insert(__FieldTag::__aspect_type_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_type_id",
                                ));
                            }
                            result.aspect_type_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aspect_type => {
                            if !fields.insert(__FieldTag::__aspect_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_type",
                                ));
                            }
                            result.aspect_type =
                                map.next_value::<std::option::Option<crate::model::AspectType>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAspectTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.aspect_type_id.is_empty() {
            state.serialize_entry("aspectTypeId", &self.aspect_type_id)?;
        }
        if self.aspect_type.is_some() {
            state.serialize_entry("aspectType", &self.aspect_type)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update AspectType Request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAspectTypeRequest {
    /// Required. AspectType Resource
    pub aspect_type: std::option::Option<crate::model::AspectType>,

    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_type][crate::model::UpdateAspectTypeRequest::aspect_type].
    pub fn set_aspect_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AspectType>,
    {
        self.aspect_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aspect_type][crate::model::UpdateAspectTypeRequest::aspect_type].
    pub fn set_or_clear_aspect_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AspectType>,
    {
        self.aspect_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAspectTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAspectTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAspectTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateAspectTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAspectTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aspect_type,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAspectTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aspectType" => Ok(__FieldTag::__aspect_type),
                            "aspect_type" => Ok(__FieldTag::__aspect_type),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAspectTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAspectTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aspect_type => {
                            if !fields.insert(__FieldTag::__aspect_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_type",
                                ));
                            }
                            result.aspect_type =
                                map.next_value::<std::option::Option<crate::model::AspectType>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAspectTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aspect_type.is_some() {
            state.serialize_entry("aspectType", &self.aspect_type)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delele AspectType Request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAspectTypeRequest {
    /// Required. The resource name of the AspectType:
    /// `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteAspectTypeRequest method returns an ABORTED error
    /// response.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAspectTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAspectTypeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteAspectTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAspectTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAspectTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAspectTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAspectTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAspectTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List AspectTypes request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAspectTypesRequest {
    /// Required. The resource name of the AspectType location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    pub parent: std::string::String,

    /// Optional. Maximum number of AspectTypes to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// AspectTypes. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListAspectTypes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provide to `ListAspectTypes` must match the call that
    /// provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * labels.key1 = "value1"
    /// * labels:key1
    /// * name = "value"
    ///
    /// These restrictions can be conjoined with AND, OR, and NOT conjunctions.
    pub filter: std::string::String,

    /// Optional. Orders the result by `name` or `create_time` fields.
    /// If not specified, the ordering is undefined.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAspectTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAspectTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAspectTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAspectTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAspectTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAspectTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAspectTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAspectTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAspectTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAspectTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAspectTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAspectTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAspectTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List AspectTypes response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAspectTypesResponse {
    /// AspectTypes under the given parent location.
    pub aspect_types: std::vec::Vec<crate::model::AspectType>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAspectTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_types][crate::model::ListAspectTypesResponse::aspect_types].
    pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AspectType>,
    {
        use std::iter::Iterator;
        self.aspect_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAspectTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListAspectTypesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAspectTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAspectTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAspectTypesResponse {
    type PageItem = crate::model::AspectType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.aspect_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAspectTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aspect_types,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAspectTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aspectTypes" => Ok(__FieldTag::__aspect_types),
                            "aspect_types" => Ok(__FieldTag::__aspect_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAspectTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAspectTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aspect_types => {
                            if !fields.insert(__FieldTag::__aspect_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_types",
                                ));
                            }
                            result.aspect_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AspectType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAspectTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aspect_types.is_empty() {
            state.serialize_entry("aspectTypes", &self.aspect_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get AspectType request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAspectTypeRequest {
    /// Required. The resource name of the AspectType:
    /// `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAspectTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetAspectTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAspectTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAspectTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAspectTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAspectTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAspectTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create Entry request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntryRequest {
    /// Required. The resource name of the parent Entry Group:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
    pub parent: std::string::String,

    /// Required. Entry identifier. It has to be unique within an Entry Group.
    ///
    /// Entries corresponding to Google Cloud resources use an Entry ID format
    /// based on [full resource
    /// names](https://cloud.google.com/apis/design/resource_names#full_resource_name).
    /// The format is a full resource name of the resource without the
    /// prefix double slashes in the API service name part of the full resource
    /// name. This allows retrieval of entries using their associated resource
    /// name.
    ///
    /// For example, if the full resource name of a resource is
    /// `//library.googleapis.com/shelves/shelf1/books/book2`,
    /// then the suggested entry_id is
    /// `library.googleapis.com/shelves/shelf1/books/book2`.
    ///
    /// It is also suggested to follow the same convention for entries
    /// corresponding to resources from providers or systems other than Google
    /// Cloud.
    ///
    /// The maximum size of the field is 4000 characters.
    pub entry_id: std::string::String,

    /// Required. Entry resource.
    pub entry: std::option::Option<crate::model::Entry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_id][crate::model::CreateEntryRequest::entry_id].
    pub fn set_entry_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_id = v.into();
        self
    }

    /// Sets the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_or_clear_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entry_id,
            __entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entryId" => Ok(__FieldTag::__entry_id),
                            "entry_id" => Ok(__FieldTag::__entry_id),
                            "entry" => Ok(__FieldTag::__entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_id => {
                            if !fields.insert(__FieldTag::__entry_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_id",
                                ));
                            }
                            result.entry_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry => {
                            if !fields.insert(__FieldTag::__entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry",
                                ));
                            }
                            result.entry =
                                map.next_value::<std::option::Option<crate::model::Entry>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entry_id.is_empty() {
            state.serialize_entry("entryId", &self.entry_id)?;
        }
        if self.entry.is_some() {
            state.serialize_entry("entry", &self.entry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update Entry request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntryRequest {
    /// Required. Entry resource.
    pub entry: std::option::Option<crate::model::Entry>,

    /// Optional. Mask of fields to update. To update Aspects, the update_mask must
    /// contain the value "aspects".
    ///
    /// If the update_mask is empty, the service will update all modifiable fields
    /// present in the request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true and the entry doesn't exist, the service will
    /// create it.
    pub allow_missing: bool,

    /// Optional. If set to true and the aspect_keys specify aspect ranges, the
    /// service deletes any existing aspects from that range that weren't provided
    /// in the request.
    pub delete_missing_aspects: bool,

    /// Optional. The map keys of the Aspects which the service should modify. It
    /// supports the following syntaxes:
    ///
    /// * `<aspect_type_reference>` - matches an aspect of the given type and empty
    ///   path.
    /// * `<aspect_type_reference>@path` - matches an aspect of the given type and
    ///   specified path. For example, to attach an aspect to a field that is
    ///   specified by the `schema` aspect, the path should have the format
    ///   `Schema.<field_name>`.
    /// * `<aspect_type_reference>@*` - matches aspects of the given type for all
    ///   paths.
    /// * `*@path` - matches aspects of all types on the given path.
    ///
    /// The service will not remove existing aspects matching the syntax unless
    /// `delete_missing_aspects` is set to true.
    ///
    /// If this field is left empty, the service treats it as specifying
    /// exactly those Aspects present in the request.
    pub aspect_keys: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_or_clear_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateEntryRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [delete_missing_aspects][crate::model::UpdateEntryRequest::delete_missing_aspects].
    pub fn set_delete_missing_aspects<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.delete_missing_aspects = v.into();
        self
    }

    /// Sets the value of [aspect_keys][crate::model::UpdateEntryRequest::aspect_keys].
    pub fn set_aspect_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpdateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry,
            __update_mask,
            __allow_missing,
            __delete_missing_aspects,
            __aspect_keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entry" => Ok(__FieldTag::__entry),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "deleteMissingAspects" => Ok(__FieldTag::__delete_missing_aspects),
                            "delete_missing_aspects" => Ok(__FieldTag::__delete_missing_aspects),
                            "aspectKeys" => Ok(__FieldTag::__aspect_keys),
                            "aspect_keys" => Ok(__FieldTag::__aspect_keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry => {
                            if !fields.insert(__FieldTag::__entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry",
                                ));
                            }
                            result.entry =
                                map.next_value::<std::option::Option<crate::model::Entry>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_missing_aspects => {
                            if !fields.insert(__FieldTag::__delete_missing_aspects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_missing_aspects",
                                ));
                            }
                            result.delete_missing_aspects = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aspect_keys => {
                            if !fields.insert(__FieldTag::__aspect_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_keys",
                                ));
                            }
                            result.aspect_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entry.is_some() {
            state.serialize_entry("entry", &self.entry)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.delete_missing_aspects) {
            state.serialize_entry("deleteMissingAspects", &self.delete_missing_aspects)?;
        }
        if !self.aspect_keys.is_empty() {
            state.serialize_entry("aspectKeys", &self.aspect_keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete Entry request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntryRequest {
    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List Entries request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntriesRequest {
    /// Required. The resource name of the parent Entry Group:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
    pub parent: std::string::String,

    /// Optional. Number of items to return per page. If there are remaining
    /// results, the service returns a next_page_token. If unspecified, the service
    /// returns at most 10 Entries. The maximum value is 100; values above 100 will
    /// be coerced to 100.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntries` call. Provide
    /// this to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. A filter on the entries to return. Filters are case-sensitive.
    /// You can filter the request by the following fields:
    ///
    /// * entry_type
    /// * entry_source.display_name
    ///
    /// The comparison operators are =, !=, <, >, <=, >=. The service compares
    /// strings according to lexical order.
    ///
    /// You can use the logical operators AND, OR, NOT in the filter.
    ///
    /// You can use Wildcard "*", but for entry_type you need to provide the
    /// full project id or number.
    ///
    /// Example filter expressions:
    ///
    /// * "entry_source.display_name=AnExampleDisplayName"
    /// * "entry_type=projects/example-project/locations/global/entryTypes/example-entry_type"
    /// * "entry_type=projects/example-project/locations/us/entryTypes/a* OR
    ///   entry_type=projects/another-project/locations/*"
    /// * "NOT entry_source.display_name=AnotherExampleDisplayName"
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List Entries response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntriesResponse {
    /// The list of entries under the given parent location.
    pub entries: std::vec::Vec<crate::model::Entry>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::ListEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntriesResponse {
    type PageItem = crate::model::Entry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get Entry request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntryRequest {
    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    pub name: std::string::String,

    /// Optional. View to control which parts of an entry the service should
    /// return.
    pub view: crate::model::EntryView,

    /// Optional. Limits the aspects returned to the provided aspect types.
    /// It only works for CUSTOM view.
    pub aspect_types: std::vec::Vec<std::string::String>,

    /// Optional. Limits the aspects returned to those associated with the provided
    /// paths within the Entry. It only works for CUSTOM view.
    pub paths: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetEntryRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::EntryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [aspect_types][crate::model::GetEntryRequest::aspect_types].
    pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paths][crate::model::GetEntryRequest::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GetEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            __aspect_types,
            __paths,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            "aspectTypes" => Ok(__FieldTag::__aspect_types),
                            "aspect_types" => Ok(__FieldTag::__aspect_types),
                            "paths" => Ok(__FieldTag::__paths),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::EntryView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aspect_types => {
                            if !fields.insert(__FieldTag::__aspect_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_types",
                                ));
                            }
                            result.aspect_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self.aspect_types.is_empty() {
            state.serialize_entry("aspectTypes", &self.aspect_types)?;
        }
        if !self.paths.is_empty() {
            state.serialize_entry("paths", &self.paths)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Lookup Entry request using permissions in the source system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupEntryRequest {
    /// Required. The project to which the request should be attributed in the
    /// following form: `projects/{project}/locations/{location}`.
    pub name: std::string::String,

    /// Optional. View to control which parts of an entry the service should
    /// return.
    pub view: crate::model::EntryView,

    /// Optional. Limits the aspects returned to the provided aspect types.
    /// It only works for CUSTOM view.
    pub aspect_types: std::vec::Vec<std::string::String>,

    /// Optional. Limits the aspects returned to those associated with the provided
    /// paths within the Entry. It only works for CUSTOM view.
    pub paths: std::vec::Vec<std::string::String>,

    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    pub entry: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LookupEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::LookupEntryRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::EntryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [aspect_types][crate::model::LookupEntryRequest::aspect_types].
    pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paths][crate::model::LookupEntryRequest::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entry][crate::model::LookupEntryRequest::entry].
    pub fn set_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry = v.into();
        self
    }
}

impl wkt::message::Message for LookupEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.LookupEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            __aspect_types,
            __paths,
            __entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            "aspectTypes" => Ok(__FieldTag::__aspect_types),
                            "aspect_types" => Ok(__FieldTag::__aspect_types),
                            "paths" => Ok(__FieldTag::__paths),
                            "entry" => Ok(__FieldTag::__entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::EntryView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aspect_types => {
                            if !fields.insert(__FieldTag::__aspect_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_types",
                                ));
                            }
                            result.aspect_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entry => {
                            if !fields.insert(__FieldTag::__entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry",
                                ));
                            }
                            result.entry = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self.aspect_types.is_empty() {
            state.serialize_entry("aspectTypes", &self.aspect_types)?;
        }
        if !self.paths.is_empty() {
            state.serialize_entry("paths", &self.paths)?;
        }
        if !self.entry.is_empty() {
            state.serialize_entry("entry", &self.entry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchEntriesRequest {
    /// Required. The project to which the request should be attributed in the
    /// following form: `projects/{project}/locations/{location}`.
    pub name: std::string::String,

    /// Required. The query against which entries in scope should be matched.
    /// The query syntax is defined in [Search syntax for Dataplex
    /// Catalog](https://cloud.google.com/dataplex/docs/search-syntax).
    pub query: std::string::String,

    /// Optional. Number of results in the search page. If <=0, then defaults
    /// to 10. Max limit for page_size is 1000. Throws an invalid argument for
    /// page_size > 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `SearchEntries` call. Provide
    /// this to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. Specifies the ordering of results.
    /// Supported values are:
    ///
    /// * `relevance` (default)
    /// * `last_modified_timestamp`
    /// * `last_modified_timestamp asc`
    pub order_by: std::string::String,

    /// Optional. The scope under which the search should be operating. It must
    /// either be `organizations/<org_id>` or `projects/<project_ref>`. If it is
    /// unspecified, it defaults to the organization where the project provided in
    /// `name` is located.
    pub scope: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SearchEntriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchEntriesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchEntriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::SearchEntriesRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for SearchEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __query,
            __page_size,
            __page_token,
            __order_by,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "query" => Ok(__FieldTag::__query),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single result of a SearchEntries request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchEntriesResult {
    /// Linked resource name.
    #[deprecated]
    pub linked_resource: std::string::String,

    pub dataplex_entry: std::option::Option<crate::model::Entry>,

    /// Snippets.
    #[deprecated]
    pub snippets: std::option::Option<crate::model::search_entries_result::Snippets>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntriesResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [linked_resource][crate::model::SearchEntriesResult::linked_resource].
    #[deprecated]
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [dataplex_entry][crate::model::SearchEntriesResult::dataplex_entry].
    pub fn set_dataplex_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.dataplex_entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_entry][crate::model::SearchEntriesResult::dataplex_entry].
    pub fn set_or_clear_dataplex_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.dataplex_entry = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snippets][crate::model::SearchEntriesResult::snippets].
    #[deprecated]
    pub fn set_snippets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_entries_result::Snippets>,
    {
        self.snippets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snippets][crate::model::SearchEntriesResult::snippets].
    #[deprecated]
    pub fn set_or_clear_snippets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_entries_result::Snippets>,
    {
        self.snippets = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchEntriesResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchEntriesResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __linked_resource,
            __dataplex_entry,
            __snippets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchEntriesResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "linkedResource" => Ok(__FieldTag::__linked_resource),
                            "linked_resource" => Ok(__FieldTag::__linked_resource),
                            "dataplexEntry" => Ok(__FieldTag::__dataplex_entry),
                            "dataplex_entry" => Ok(__FieldTag::__dataplex_entry),
                            "snippets" => Ok(__FieldTag::__snippets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchEntriesResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchEntriesResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__linked_resource => {
                            if !fields.insert(__FieldTag::__linked_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_resource",
                                ));
                            }
                            result.linked_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataplex_entry => {
                            if !fields.insert(__FieldTag::__dataplex_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataplex_entry",
                                ));
                            }
                            result.dataplex_entry =
                                map.next_value::<std::option::Option<crate::model::Entry>>()?;
                        }
                        __FieldTag::__snippets => {
                            if !fields.insert(__FieldTag::__snippets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snippets",
                                ));
                            }
                            result.snippets = map.next_value::<std::option::Option<
                                crate::model::search_entries_result::Snippets,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchEntriesResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.linked_resource.is_empty() {
            state.serialize_entry("linkedResource", &self.linked_resource)?;
        }
        if self.dataplex_entry.is_some() {
            state.serialize_entry("dataplexEntry", &self.dataplex_entry)?;
        }
        if self.snippets.is_some() {
            state.serialize_entry("snippets", &self.snippets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchEntriesResult].
pub mod search_entries_result {
    #[allow(unused_imports)]
    use super::*;

    /// Snippets for the entry, contains HTML-style highlighting for
    /// matched tokens, will be used in UI.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    #[deprecated]
    pub struct Snippets {
        /// Entry
        #[deprecated]
        pub dataplex_entry: std::option::Option<crate::model::Entry>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Snippets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataplex_entry][crate::model::search_entries_result::Snippets::dataplex_entry].
        #[deprecated]
        pub fn set_dataplex_entry<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Entry>,
        {
            self.dataplex_entry = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [dataplex_entry][crate::model::search_entries_result::Snippets::dataplex_entry].
        #[deprecated]
        pub fn set_or_clear_dataplex_entry<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Entry>,
        {
            self.dataplex_entry = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Snippets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesResult.Snippets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Snippets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataplex_entry,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Snippets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dataplexEntry" => Ok(__FieldTag::__dataplex_entry),
                                "dataplex_entry" => Ok(__FieldTag::__dataplex_entry),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Snippets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Snippets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataplex_entry => {
                                if !fields.insert(__FieldTag::__dataplex_entry) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataplex_entry",
                                    ));
                                }
                                result.dataplex_entry =
                                    map.next_value::<std::option::Option<crate::model::Entry>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Snippets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.dataplex_entry.is_some() {
                state.serialize_entry("dataplexEntry", &self.dataplex_entry)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchEntriesResponse {
    /// The results matching the search query.
    pub results: std::vec::Vec<crate::model::SearchEntriesResult>,

    /// The estimated total number of matching entries. This number isn't
    /// guaranteed to be accurate.
    pub total_size: i32,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach. Search results don't include
    /// data from these locations.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchEntriesResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchEntriesResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_size][crate::model::SearchEntriesResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::SearchEntriesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchEntriesResponse {
    type PageItem = crate::model::SearchEntriesResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __total_size,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SearchEntriesResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An object that describes the values that you want to set for an entry and its
/// attached aspects when you import metadata. Used when you run a metadata
/// import job. See
/// [CreateMetadataJob][google.cloud.dataplex.v1.CatalogService.CreateMetadataJob].
///
/// You provide a collection of import items in a metadata import file. For more
/// information about how to create a metadata import file, see [Metadata import
/// file](https://cloud.google.com/dataplex/docs/import-metadata#metadata-import-file).
///
/// [google.cloud.dataplex.v1.CatalogService.CreateMetadataJob]: crate::client::CatalogService::create_metadata_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportItem {
    /// Information about an entry and its attached aspects.
    pub entry: std::option::Option<crate::model::Entry>,

    /// The fields to update, in paths that are relative to the `Entry` resource.
    /// Separate each field with a comma.
    ///
    /// In `FULL` entry sync mode, Dataplex includes the paths of all of the fields
    /// for an entry that can be modified, including aspects. This means that
    /// Dataplex replaces the existing entry with the entry in the metadata import
    /// file. All modifiable fields are updated, regardless of the fields that are
    /// listed in the update mask, and regardless of whether a field is present
    /// in the `entry` object.
    ///
    /// The `update_mask` field is ignored when an entry is created or re-created.
    ///
    /// In an aspect-only metadata job (when entry sync mode is `NONE`), set this
    /// value to `aspects`.
    ///
    /// Dataplex also determines which entries and aspects to modify by comparing
    /// the values and timestamps that you provide in the metadata import file with
    /// the values and timestamps that exist in your project. For more information,
    /// see [Comparison
    /// logic](https://cloud.google.com/dataplex/docs/import-metadata#data-modification-logic).
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The aspects to modify. Supports the following syntaxes:
    ///
    /// * `{aspect_type_reference}`: matches aspects that belong to the specified
    ///   aspect type and are attached directly to the entry.
    /// * `{aspect_type_reference}@{path}`: matches aspects that belong to the
    ///   specified aspect type and path.
    /// * `{aspect_type_reference}@*` : matches aspects of the given type for all
    ///   paths.
    /// * `*@path` : matches aspects of all types on the given path.
    ///
    /// Replace `{aspect_type_reference}` with a reference to the aspect type, in
    /// the format
    /// `{project_id_or_number}.{location_id}.{aspect_type_id}`.
    ///
    /// In `FULL` entry sync mode, if you leave this field empty, it is treated as
    /// specifying exactly those aspects that are present within the specified
    /// entry. Dataplex implicitly adds the keys for all of the required aspects of
    /// an entry.
    pub aspect_keys: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::ImportItem::entry].
    pub fn set_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry][crate::model::ImportItem::entry].
    pub fn set_or_clear_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::ImportItem::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::ImportItem::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aspect_keys][crate::model::ImportItem::aspect_keys].
    pub fn set_aspect_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ImportItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry,
            __update_mask,
            __aspect_keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entry" => Ok(__FieldTag::__entry),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "aspectKeys" => Ok(__FieldTag::__aspect_keys),
                            "aspect_keys" => Ok(__FieldTag::__aspect_keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry => {
                            if !fields.insert(__FieldTag::__entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry",
                                ));
                            }
                            result.entry =
                                map.next_value::<std::option::Option<crate::model::Entry>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__aspect_keys => {
                            if !fields.insert(__FieldTag::__aspect_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_keys",
                                ));
                            }
                            result.aspect_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entry.is_some() {
            state.serialize_entry("entry", &self.entry)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.aspect_keys.is_empty() {
            state.serialize_entry("aspectKeys", &self.aspect_keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create metadata job request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMetadataJobRequest {
    /// Required. The resource name of the parent location, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}`
    pub parent: std::string::String,

    /// Required. The metadata job resource.
    pub metadata_job: std::option::Option<crate::model::MetadataJob>,

    /// Optional. The metadata job ID. If not provided, a unique ID is generated
    /// with the prefix `metadata-job-`.
    pub metadata_job_id: std::string::String,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMetadataJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMetadataJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metadata_job][crate::model::CreateMetadataJobRequest::metadata_job].
    pub fn set_metadata_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MetadataJob>,
    {
        self.metadata_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata_job][crate::model::CreateMetadataJobRequest::metadata_job].
    pub fn set_or_clear_metadata_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MetadataJob>,
    {
        self.metadata_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata_job_id][crate::model::CreateMetadataJobRequest::metadata_job_id].
    pub fn set_metadata_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metadata_job_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateMetadataJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateMetadataJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateMetadataJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMetadataJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __metadata_job,
            __metadata_job_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMetadataJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "metadataJob" => Ok(__FieldTag::__metadata_job),
                            "metadata_job" => Ok(__FieldTag::__metadata_job),
                            "metadataJobId" => Ok(__FieldTag::__metadata_job_id),
                            "metadata_job_id" => Ok(__FieldTag::__metadata_job_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMetadataJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMetadataJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata_job => {
                            if !fields.insert(__FieldTag::__metadata_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_job",
                                ));
                            }
                            result.metadata_job =
                                map.next_value::<std::option::Option<crate::model::MetadataJob>>()?;
                        }
                        __FieldTag::__metadata_job_id => {
                            if !fields.insert(__FieldTag::__metadata_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_job_id",
                                ));
                            }
                            result.metadata_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMetadataJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.metadata_job.is_some() {
            state.serialize_entry("metadataJob", &self.metadata_job)?;
        }
        if !self.metadata_job_id.is_empty() {
            state.serialize_entry("metadataJobId", &self.metadata_job_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get metadata job request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMetadataJobRequest {
    /// Required. The resource name of the metadata job, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMetadataJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetadataJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetadataJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetMetadataJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMetadataJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMetadataJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMetadataJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMetadataJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMetadataJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List metadata jobs request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMetadataJobsRequest {
    /// Required. The resource name of the parent location, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}`
    pub parent: std::string::String,

    /// Optional. The maximum number of metadata jobs to return. The service might
    /// return fewer jobs than this value. If unspecified, at most 10 jobs are
    /// returned. The maximum value is 1,000.
    pub page_size: i32,

    /// Optional. The page token received from a previous `ListMetadataJobs` call.
    /// Provide this token to retrieve the subsequent page of results. When
    /// paginating, all other parameters that are provided to the
    /// `ListMetadataJobs` request must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * `labels.key1 = "value1"`
    /// * `labels:key1`
    /// * `name = "value"`
    ///
    /// You can combine filters with `AND`, `OR`, and `NOT` operators.
    pub filter: std::string::String,

    /// Optional. The field to sort the results by, either `name` or `create_time`.
    /// If not specified, the ordering is undefined.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMetadataJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMetadataJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetadataJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetadataJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMetadataJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMetadataJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMetadataJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListMetadataJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMetadataJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMetadataJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMetadataJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMetadataJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMetadataJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List metadata jobs response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMetadataJobsResponse {
    /// Metadata jobs under the specified parent location.
    pub metadata_jobs: std::vec::Vec<crate::model::MetadataJob>,

    /// A token to retrieve the next page of results. If there are no more results
    /// in the list, the value is empty.
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMetadataJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata_jobs][crate::model::ListMetadataJobsResponse::metadata_jobs].
    pub fn set_metadata_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetadataJob>,
    {
        use std::iter::Iterator;
        self.metadata_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMetadataJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListMetadataJobsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMetadataJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListMetadataJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMetadataJobsResponse {
    type PageItem = crate::model::MetadataJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metadata_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMetadataJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metadata_jobs,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMetadataJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metadataJobs" => Ok(__FieldTag::__metadata_jobs),
                            "metadata_jobs" => Ok(__FieldTag::__metadata_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMetadataJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMetadataJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metadata_jobs => {
                            if !fields.insert(__FieldTag::__metadata_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_jobs",
                                ));
                            }
                            result.metadata_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MetadataJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMetadataJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metadata_jobs.is_empty() {
            state.serialize_entry("metadataJobs", &self.metadata_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cancel metadata job request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelMetadataJobRequest {
    /// Required. The resource name of the job, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelMetadataJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelMetadataJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelMetadataJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CancelMetadataJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelMetadataJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelMetadataJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelMetadataJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelMetadataJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelMetadataJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A metadata job resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MetadataJob {
    /// Output only. Identifier. The name of the resource that the configuration is
    /// applied to, in the format
    /// `projects/{project_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`.
    pub name: std::string::String,

    /// Output only. A system-generated, globally unique ID for the metadata job.
    /// If the metadata job is deleted and then re-created with the same name, this
    /// ID is different.
    pub uid: std::string::String,

    /// Output only. The time when the metadata job was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the metadata job was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-defined labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Metadata job type.
    pub r#type: crate::model::metadata_job::Type,

    /// Output only. Metadata job status.
    pub status: std::option::Option<crate::model::metadata_job::Status>,

    pub spec: std::option::Option<crate::model::metadata_job::Spec>,

    pub result: std::option::Option<crate::model::metadata_job::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetadataJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MetadataJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::MetadataJob::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MetadataJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MetadataJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MetadataJob::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MetadataJob::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::MetadataJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::MetadataJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::metadata_job::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [status][crate::model::MetadataJob::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::metadata_job::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::MetadataJob::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::metadata_job::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [spec][crate::model::MetadataJob::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<
        T: std::convert::Into<std::option::Option<crate::model::metadata_job::Spec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::MetadataJob::spec]
    /// if it holds a `ImportSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ImportJobSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Spec::ImportSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::MetadataJob::spec]
    /// to hold a `ImportSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_import_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ImportJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::metadata_job::Spec::ImportSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::MetadataJob::spec]
    /// if it holds a `ExportSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn export_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ExportJobSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Spec::ExportSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::MetadataJob::spec]
    /// to hold a `ExportSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_export_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ExportJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::metadata_job::Spec::ExportSpec(v.into()));
        self
    }

    /// Sets the value of [result][crate::model::MetadataJob::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::metadata_job::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::MetadataJob::result]
    /// if it holds a `ImportResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ImportJobResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Result::ImportResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::MetadataJob::result]
    /// to hold a `ImportResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_import_result<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ImportJobResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::metadata_job::Result::ImportResult(v.into()));
        self
    }

    /// The value of [result][crate::model::MetadataJob::result]
    /// if it holds a `ExportResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn export_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ExportJobResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Result::ExportResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::MetadataJob::result]
    /// to hold a `ExportResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_export_result<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ExportJobResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::metadata_job::Result::ExportResult(v.into()));
        self
    }
}

impl wkt::message::Message for MetadataJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MetadataJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __labels,
            __type,
            __import_spec,
            __export_spec,
            __import_result,
            __export_result,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetadataJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "type" => Ok(__FieldTag::__type),
                            "importSpec" => Ok(__FieldTag::__import_spec),
                            "import_spec" => Ok(__FieldTag::__import_spec),
                            "exportSpec" => Ok(__FieldTag::__export_spec),
                            "export_spec" => Ok(__FieldTag::__export_spec),
                            "importResult" => Ok(__FieldTag::__import_result),
                            "import_result" => Ok(__FieldTag::__import_result),
                            "exportResult" => Ok(__FieldTag::__export_result),
                            "export_result" => Ok(__FieldTag::__export_result),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MetadataJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetadataJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::metadata_job::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__import_spec => {
                            if !fields.insert(__FieldTag::__import_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.MetadataJob.import_spec, latest field was importSpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::metadata_job::Spec::ImportSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::metadata_job::ImportJobSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__export_spec => {
                            if !fields.insert(__FieldTag::__export_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.MetadataJob.export_spec, latest field was exportSpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::metadata_job::Spec::ExportSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::metadata_job::ExportJobSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__import_result => {
                            if !fields.insert(__FieldTag::__import_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.MetadataJob.import_result, latest field was importResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::metadata_job::Result::ImportResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::metadata_job::ImportJobResult,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__export_result => {
                            if !fields.insert(__FieldTag::__export_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.MetadataJob.export_result, latest field was exportResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::metadata_job::Result::ExportResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::metadata_job::ExportJobResult,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::metadata_job::Status>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MetadataJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.import_spec() {
            state.serialize_entry("importSpec", value)?;
        }
        if let Some(value) = self.export_spec() {
            state.serialize_entry("exportSpec", value)?;
        }
        if let Some(value) = self.import_result() {
            state.serialize_entry("importResult", value)?;
        }
        if let Some(value) = self.export_result() {
            state.serialize_entry("exportResult", value)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MetadataJob].
pub mod metadata_job {
    #[allow(unused_imports)]
    use super::*;

    /// Results from a metadata import job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ImportJobResult {
        /// Output only. The total number of entries that were deleted.
        pub deleted_entries: i64,

        /// Output only. The total number of entries that were updated.
        pub updated_entries: i64,

        /// Output only. The total number of entries that were created.
        pub created_entries: i64,

        /// Output only. The total number of entries that were unchanged.
        pub unchanged_entries: i64,

        /// Output only. The total number of entries that were recreated.
        pub recreated_entries: i64,

        /// Output only. The time when the status was updated.
        pub update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImportJobResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [deleted_entries][crate::model::metadata_job::ImportJobResult::deleted_entries].
        pub fn set_deleted_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.deleted_entries = v.into();
            self
        }

        /// Sets the value of [updated_entries][crate::model::metadata_job::ImportJobResult::updated_entries].
        pub fn set_updated_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.updated_entries = v.into();
            self
        }

        /// Sets the value of [created_entries][crate::model::metadata_job::ImportJobResult::created_entries].
        pub fn set_created_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.created_entries = v.into();
            self
        }

        /// Sets the value of [unchanged_entries][crate::model::metadata_job::ImportJobResult::unchanged_entries].
        pub fn set_unchanged_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.unchanged_entries = v.into();
            self
        }

        /// Sets the value of [recreated_entries][crate::model::metadata_job::ImportJobResult::recreated_entries].
        pub fn set_recreated_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.recreated_entries = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::metadata_job::ImportJobResult::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::metadata_job::ImportJobResult::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ImportJobResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ImportJobResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ImportJobResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __deleted_entries,
                __updated_entries,
                __created_entries,
                __unchanged_entries,
                __recreated_entries,
                __update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ImportJobResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "deletedEntries" => Ok(__FieldTag::__deleted_entries),
                                "deleted_entries" => Ok(__FieldTag::__deleted_entries),
                                "updatedEntries" => Ok(__FieldTag::__updated_entries),
                                "updated_entries" => Ok(__FieldTag::__updated_entries),
                                "createdEntries" => Ok(__FieldTag::__created_entries),
                                "created_entries" => Ok(__FieldTag::__created_entries),
                                "unchangedEntries" => Ok(__FieldTag::__unchanged_entries),
                                "unchanged_entries" => Ok(__FieldTag::__unchanged_entries),
                                "recreatedEntries" => Ok(__FieldTag::__recreated_entries),
                                "recreated_entries" => Ok(__FieldTag::__recreated_entries),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ImportJobResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ImportJobResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__deleted_entries => {
                                if !fields.insert(__FieldTag::__deleted_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deleted_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.deleted_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__updated_entries => {
                                if !fields.insert(__FieldTag::__updated_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for updated_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.updated_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__created_entries => {
                                if !fields.insert(__FieldTag::__created_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for created_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.created_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__unchanged_entries => {
                                if !fields.insert(__FieldTag::__unchanged_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for unchanged_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.unchanged_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__recreated_entries => {
                                if !fields.insert(__FieldTag::__recreated_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recreated_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.recreated_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ImportJobResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.deleted_entries) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("deletedEntries", &__With(&self.deleted_entries))?;
            }
            if !wkt::internal::is_default(&self.updated_entries) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("updatedEntries", &__With(&self.updated_entries))?;
            }
            if !wkt::internal::is_default(&self.created_entries) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("createdEntries", &__With(&self.created_entries))?;
            }
            if !wkt::internal::is_default(&self.unchanged_entries) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("unchangedEntries", &__With(&self.unchanged_entries))?;
            }
            if !wkt::internal::is_default(&self.recreated_entries) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("recreatedEntries", &__With(&self.recreated_entries))?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Summary results from a metadata export job. The results are a snapshot of
    /// the metadata at the time when the job was created. The exported entries are
    /// saved to a Cloud Storage bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExportJobResult {
        /// Output only. The number of entries that were exported.
        pub exported_entries: i64,

        /// Output only. The error message if the metadata export job failed.
        pub error_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExportJobResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [exported_entries][crate::model::metadata_job::ExportJobResult::exported_entries].
        pub fn set_exported_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.exported_entries = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::metadata_job::ExportJobResult::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ExportJobResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ExportJobResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExportJobResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __exported_entries,
                __error_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExportJobResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "exportedEntries" => Ok(__FieldTag::__exported_entries),
                                "exported_entries" => Ok(__FieldTag::__exported_entries),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExportJobResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExportJobResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__exported_entries => {
                                if !fields.insert(__FieldTag::__exported_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exported_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.exported_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExportJobResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.exported_entries) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("exportedEntries", &__With(&self.exported_entries))?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Job specification for a metadata import job.
    ///
    /// You can run the following kinds of metadata import jobs:
    ///
    /// * Full sync of entries with incremental import of their aspects.
    ///   Supported for custom entries.
    /// * Incremental import of aspects only. Supported for aspects that belong
    ///   to custom entries and system entries. For custom entries, you can modify
    ///   both optional aspects and required aspects. For system entries, you can
    ///   modify optional aspects.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ImportJobSpec {
        /// Optional. The URI of a Cloud Storage bucket or folder (beginning with
        /// `gs://` and ending with `/`) that contains the metadata import files for
        /// this job.
        ///
        /// A metadata import file defines the values to set for each of the entries
        /// and aspects in a metadata import job. For more information about how to
        /// create a metadata import file and the file requirements, see [Metadata
        /// import
        /// file](https://cloud.google.com/dataplex/docs/import-metadata#metadata-import-file).
        ///
        /// You can provide multiple metadata import files in the same metadata job.
        /// The bucket or folder must contain at least one metadata import file, in
        /// JSON Lines format (either `.json` or `.jsonl` file extension).
        ///
        /// In `FULL` entry sync mode, don't save the metadata import file in a
        /// folder named `SOURCE_STORAGE_URI/deletions/`.
        ///
        /// **Caution**: If the metadata import file contains no data, all entries
        /// and aspects that belong to the job's scope are deleted.
        pub source_storage_uri: std::string::String,

        /// Optional. The time when the process that created the metadata import
        /// files began.
        pub source_create_time: std::option::Option<wkt::Timestamp>,

        /// Required. A boundary on the scope of impact that the metadata import job
        /// can have.
        pub scope: std::option::Option<crate::model::metadata_job::import_job_spec::ImportJobScope>,

        /// Required. The sync mode for entries.
        pub entry_sync_mode: crate::model::metadata_job::import_job_spec::SyncMode,

        /// Required. The sync mode for aspects.
        pub aspect_sync_mode: crate::model::metadata_job::import_job_spec::SyncMode,

        /// Optional. The level of logs to write to Cloud Logging for this job.
        ///
        /// Debug-level logs provide highly-detailed information for
        /// troubleshooting, but their increased verbosity could incur [additional
        /// costs](https://cloud.google.com/stackdriver/pricing) that might not be
        /// merited for all jobs.
        ///
        /// If unspecified, defaults to `INFO`.
        pub log_level: crate::model::metadata_job::import_job_spec::LogLevel,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImportJobSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_storage_uri][crate::model::metadata_job::ImportJobSpec::source_storage_uri].
        pub fn set_source_storage_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_storage_uri = v.into();
            self
        }

        /// Sets the value of [source_create_time][crate::model::metadata_job::ImportJobSpec::source_create_time].
        pub fn set_source_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.source_create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_create_time][crate::model::metadata_job::ImportJobSpec::source_create_time].
        pub fn set_or_clear_source_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.source_create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [scope][crate::model::metadata_job::ImportJobSpec::scope].
        pub fn set_scope<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::ImportJobScope>,
        {
            self.scope = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [scope][crate::model::metadata_job::ImportJobSpec::scope].
        pub fn set_or_clear_scope<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::ImportJobScope>,
        {
            self.scope = v.map(|x| x.into());
            self
        }

        /// Sets the value of [entry_sync_mode][crate::model::metadata_job::ImportJobSpec::entry_sync_mode].
        pub fn set_entry_sync_mode<
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::SyncMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entry_sync_mode = v.into();
            self
        }

        /// Sets the value of [aspect_sync_mode][crate::model::metadata_job::ImportJobSpec::aspect_sync_mode].
        pub fn set_aspect_sync_mode<
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::SyncMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aspect_sync_mode = v.into();
            self
        }

        /// Sets the value of [log_level][crate::model::metadata_job::ImportJobSpec::log_level].
        pub fn set_log_level<
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::LogLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.log_level = v.into();
            self
        }
    }

    impl wkt::message::Message for ImportJobSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ImportJobSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ImportJobSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_storage_uri,
                __source_create_time,
                __scope,
                __entry_sync_mode,
                __aspect_sync_mode,
                __log_level,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ImportJobSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceStorageUri" => Ok(__FieldTag::__source_storage_uri),
                                "source_storage_uri" => Ok(__FieldTag::__source_storage_uri),
                                "sourceCreateTime" => Ok(__FieldTag::__source_create_time),
                                "source_create_time" => Ok(__FieldTag::__source_create_time),
                                "scope" => Ok(__FieldTag::__scope),
                                "entrySyncMode" => Ok(__FieldTag::__entry_sync_mode),
                                "entry_sync_mode" => Ok(__FieldTag::__entry_sync_mode),
                                "aspectSyncMode" => Ok(__FieldTag::__aspect_sync_mode),
                                "aspect_sync_mode" => Ok(__FieldTag::__aspect_sync_mode),
                                "logLevel" => Ok(__FieldTag::__log_level),
                                "log_level" => Ok(__FieldTag::__log_level),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ImportJobSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ImportJobSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_storage_uri => {
                                if !fields.insert(__FieldTag::__source_storage_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_storage_uri",
                                    ));
                                }
                                result.source_storage_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__source_create_time => {
                                if !fields.insert(__FieldTag::__source_create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_create_time",
                                    ));
                                }
                                result.source_create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__scope => {
                                if !fields.insert(__FieldTag::__scope) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scope",
                                    ));
                                }
                                result.scope = map.next_value::<std::option::Option<
                                    crate::model::metadata_job::import_job_spec::ImportJobScope,
                                >>()?;
                            }
                            __FieldTag::__entry_sync_mode => {
                                if !fields.insert(__FieldTag::__entry_sync_mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entry_sync_mode",
                                    ));
                                }
                                result.entry_sync_mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::metadata_job::import_job_spec::SyncMode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__aspect_sync_mode => {
                                if !fields.insert(__FieldTag::__aspect_sync_mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aspect_sync_mode",
                                    ));
                                }
                                result.aspect_sync_mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::metadata_job::import_job_spec::SyncMode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__log_level => {
                                if !fields.insert(__FieldTag::__log_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_level",
                                    ));
                                }
                                result.log_level = map
                                    .next_value::<std::option::Option<
                                        crate::model::metadata_job::import_job_spec::LogLevel,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ImportJobSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source_storage_uri.is_empty() {
                state.serialize_entry("sourceStorageUri", &self.source_storage_uri)?;
            }
            if self.source_create_time.is_some() {
                state.serialize_entry("sourceCreateTime", &self.source_create_time)?;
            }
            if self.scope.is_some() {
                state.serialize_entry("scope", &self.scope)?;
            }
            if !wkt::internal::is_default(&self.entry_sync_mode) {
                state.serialize_entry("entrySyncMode", &self.entry_sync_mode)?;
            }
            if !wkt::internal::is_default(&self.aspect_sync_mode) {
                state.serialize_entry("aspectSyncMode", &self.aspect_sync_mode)?;
            }
            if !wkt::internal::is_default(&self.log_level) {
                state.serialize_entry("logLevel", &self.log_level)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ImportJobSpec].
    pub mod import_job_spec {
        #[allow(unused_imports)]
        use super::*;

        /// A boundary on the scope of impact that the metadata import job can have.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ImportJobScope {
            /// Required. The entry group that is in scope for the import job,
            /// specified as a relative resource name in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/entryGroups/{entry_group_id}`.
            /// Only entries and aspects that belong to the specified entry group are
            /// affected by the job.
            ///
            /// Must contain exactly one element. The entry group and the job
            /// must be in the same location.
            pub entry_groups: std::vec::Vec<std::string::String>,

            /// Required. The entry types that are in scope for the import job,
            /// specified as relative resource names in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/entryTypes/{entry_type_id}`.
            /// The job modifies only the entries and aspects that belong to these
            /// entry types.
            ///
            /// If the metadata import file attempts to modify an entry whose type
            /// isn't included in this list, the import job is halted before modifying
            /// any entries or aspects.
            ///
            /// The location of an entry type must either match the location of the
            /// job, or the entry type must be global.
            pub entry_types: std::vec::Vec<std::string::String>,

            /// Optional. The aspect types that are in scope for the import job,
            /// specified as relative resource names in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
            /// The job modifies only the aspects that belong to these aspect types.
            ///
            /// This field is required when creating an aspect-only import job.
            ///
            /// If the metadata import file attempts to modify an aspect whose type
            /// isn't included in this list, the import job is halted before modifying
            /// any entries or aspects.
            ///
            /// The location of an aspect type must either match the location of the
            /// job, or the aspect type must be global.
            pub aspect_types: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ImportJobScope {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [entry_groups][crate::model::metadata_job::import_job_spec::ImportJobScope::entry_groups].
            pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_groups = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [entry_types][crate::model::metadata_job::import_job_spec::ImportJobScope::entry_types].
            pub fn set_entry_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_types = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [aspect_types][crate::model::metadata_job::import_job_spec::ImportJobScope::aspect_types].
            pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.aspect_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ImportJobScope {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ImportJobSpec.ImportJobScope"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ImportJobScope {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __entry_groups,
                    __entry_types,
                    __aspect_types,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ImportJobScope")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "entryGroups" => Ok(__FieldTag::__entry_groups),
                                    "entry_groups" => Ok(__FieldTag::__entry_groups),
                                    "entryTypes" => Ok(__FieldTag::__entry_types),
                                    "entry_types" => Ok(__FieldTag::__entry_types),
                                    "aspectTypes" => Ok(__FieldTag::__aspect_types),
                                    "aspect_types" => Ok(__FieldTag::__aspect_types),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ImportJobScope;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ImportJobScope")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__entry_groups => {
                                    if !fields.insert(__FieldTag::__entry_groups) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for entry_groups",
                                            ),
                                        );
                                    }
                                    result.entry_groups = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__entry_types => {
                                    if !fields.insert(__FieldTag::__entry_types) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for entry_types",
                                            ),
                                        );
                                    }
                                    result.entry_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__aspect_types => {
                                    if !fields.insert(__FieldTag::__aspect_types) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for aspect_types",
                                            ),
                                        );
                                    }
                                    result.aspect_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ImportJobScope {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.entry_groups.is_empty() {
                    state.serialize_entry("entryGroups", &self.entry_groups)?;
                }
                if !self.entry_types.is_empty() {
                    state.serialize_entry("entryTypes", &self.entry_types)?;
                }
                if !self.aspect_types.is_empty() {
                    state.serialize_entry("aspectTypes", &self.aspect_types)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Specifies how the entries and aspects in a metadata import job are
        /// updated. For more information, see [Sync
        /// mode](https://cloud.google.com/dataplex/docs/import-metadata#sync-mode).
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SyncMode {
            /// Sync mode unspecified.
            Unspecified,
            /// All resources in the job's scope are modified. If a resource exists in
            /// Dataplex but isn't included in the metadata import file, the resource
            /// is deleted when you run the metadata job. Use this mode to perform a
            /// full sync of the set of entries in the job scope.
            ///
            /// This sync mode is supported for entries.
            Full,
            /// Only the resources that are explicitly included in the
            /// metadata import file are modified. Use this mode to modify a subset of
            /// resources while leaving unreferenced resources unchanged.
            ///
            /// This sync mode is supported for aspects.
            Incremental,
            /// If entry sync mode is `NONE`, then aspects are modified according
            /// to the aspect sync mode. Other metadata that belongs to entries in the
            /// job's scope isn't modified.
            ///
            /// This sync mode is supported for entries.
            None,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SyncMode::value] or
            /// [SyncMode::name].
            UnknownValue(sync_mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod sync_mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SyncMode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Full => std::option::Option::Some(1),
                    Self::Incremental => std::option::Option::Some(2),
                    Self::None => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SYNC_MODE_UNSPECIFIED"),
                    Self::Full => std::option::Option::Some("FULL"),
                    Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                    Self::None => std::option::Option::Some("NONE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SyncMode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SyncMode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SyncMode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Full,
                    2 => Self::Incremental,
                    3 => Self::None,
                    _ => Self::UnknownValue(sync_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SyncMode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SYNC_MODE_UNSPECIFIED" => Self::Unspecified,
                    "FULL" => Self::Full,
                    "INCREMENTAL" => Self::Incremental,
                    "NONE" => Self::None,
                    _ => Self::UnknownValue(sync_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SyncMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Full => serializer.serialize_i32(1),
                    Self::Incremental => serializer.serialize_i32(2),
                    Self::None => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SyncMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SyncMode>::new(
                    ".google.cloud.dataplex.v1.MetadataJob.ImportJobSpec.SyncMode",
                ))
            }
        }

        /// The level of logs to write to Cloud Logging for this job.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LogLevel {
            /// Log level unspecified.
            Unspecified,
            /// Debug-level logging. Captures detailed logs for each import item. Use
            /// debug-level logging to troubleshoot issues with specific import items.
            /// For example, use debug-level logging to identify resources that are
            /// missing from the job scope, entries or aspects that don't conform to
            /// the associated entry type or aspect type, or other misconfigurations
            /// with the metadata import file.
            ///
            /// Depending on the size of your metadata job and the number of logs that
            /// are generated, debug-level logging might incur
            /// [additional costs](https://cloud.google.com/stackdriver/pricing).
            Debug,
            /// Info-level logging. Captures logs at the overall job level. Includes
            /// aggregate logs about import items, but doesn't specify which import
            /// item has an error.
            Info,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LogLevel::value] or
            /// [LogLevel::name].
            UnknownValue(log_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod log_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LogLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Debug => std::option::Option::Some(1),
                    Self::Info => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LOG_LEVEL_UNSPECIFIED"),
                    Self::Debug => std::option::Option::Some("DEBUG"),
                    Self::Info => std::option::Option::Some("INFO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LogLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LogLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LogLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Debug,
                    2 => Self::Info,
                    _ => Self::UnknownValue(log_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LogLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOG_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "DEBUG" => Self::Debug,
                    "INFO" => Self::Info,
                    _ => Self::UnknownValue(log_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LogLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Debug => serializer.serialize_i32(1),
                    Self::Info => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LogLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogLevel>::new(
                    ".google.cloud.dataplex.v1.MetadataJob.ImportJobSpec.LogLevel",
                ))
            }
        }
    }

    /// Job specification for a metadata export job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExportJobSpec {
        /// Required. The scope of the export job.
        pub scope: std::option::Option<crate::model::metadata_job::export_job_spec::ExportJobScope>,

        /// Required. The root path of the Cloud Storage bucket to export the
        /// metadata to, in the format `gs://{bucket}/`. You can optionally specify a
        /// custom prefix after the bucket name, in the format
        /// `gs://{bucket}/{prefix}/`. The maximum length of the custom prefix is 128
        /// characters. Dataplex constructs the object path for the exported files by
        /// using the bucket name and prefix that you provide, followed by a
        /// system-generated path.
        ///
        /// The bucket must be in the same VPC Service Controls perimeter as the job.
        pub output_path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExportJobSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scope][crate::model::metadata_job::ExportJobSpec::scope].
        pub fn set_scope<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::metadata_job::export_job_spec::ExportJobScope>,
        {
            self.scope = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [scope][crate::model::metadata_job::ExportJobSpec::scope].
        pub fn set_or_clear_scope<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::metadata_job::export_job_spec::ExportJobScope>,
        {
            self.scope = v.map(|x| x.into());
            self
        }

        /// Sets the value of [output_path][crate::model::metadata_job::ExportJobSpec::output_path].
        pub fn set_output_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.output_path = v.into();
            self
        }
    }

    impl wkt::message::Message for ExportJobSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ExportJobSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExportJobSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __scope,
                __output_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExportJobSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "scope" => Ok(__FieldTag::__scope),
                                "outputPath" => Ok(__FieldTag::__output_path),
                                "output_path" => Ok(__FieldTag::__output_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExportJobSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExportJobSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__scope => {
                                if !fields.insert(__FieldTag::__scope) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scope",
                                    ));
                                }
                                result.scope = map.next_value::<std::option::Option<
                                    crate::model::metadata_job::export_job_spec::ExportJobScope,
                                >>()?;
                            }
                            __FieldTag::__output_path => {
                                if !fields.insert(__FieldTag::__output_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_path",
                                    ));
                                }
                                result.output_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExportJobSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.scope.is_some() {
                state.serialize_entry("scope", &self.scope)?;
            }
            if !self.output_path.is_empty() {
                state.serialize_entry("outputPath", &self.output_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ExportJobSpec].
    pub mod export_job_spec {
        #[allow(unused_imports)]
        use super::*;

        /// The scope of the export job.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ExportJobScope {
            /// Whether the metadata export job is an organization-level export job.
            ///
            /// - If `true`, the job exports the entries from the same organization and
            ///   VPC Service Controls perimeter as the job. The project that the job
            ///   belongs to determines the VPC Service Controls perimeter. If you set
            ///   the job scope to be at the organization level, then don't provide a
            ///   list of projects or entry groups.
            /// - If `false`, you must specify a list of projects or a list of entry
            ///   groups whose entries you want to export.
            ///
            /// The default is `false`.
            pub organization_level: bool,

            /// The projects whose metadata you want to export, in the format
            /// `projects/{project_id_or_number}`. Only the entries from
            /// the specified projects are exported.
            ///
            /// The projects must be in the same organization and VPC Service Controls
            /// perimeter as the job.
            ///
            /// If you set the job scope to be a list of projects, then set the
            /// organization-level export flag to false and don't provide a list of
            /// entry groups.
            pub projects: std::vec::Vec<std::string::String>,

            /// The entry groups whose metadata you want to export, in the format
            /// `projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
            /// Only the entries in the specified entry groups are exported.
            ///
            /// The entry groups must be in the same location and the same VPC Service
            /// Controls perimeter as the job.
            ///
            /// If you set the job scope to be a list of entry groups, then set the
            /// organization-level export flag to false and don't provide a list of
            /// projects.
            pub entry_groups: std::vec::Vec<std::string::String>,

            /// The entry types that are in scope for the export job, specified as
            /// relative resource names in the format
            /// `projects/{project_id_or_number}/locations/{location}/entryTypes/{entry_type_id}`.
            /// Only entries that belong to the specified entry types are affected by
            /// the job.
            pub entry_types: std::vec::Vec<std::string::String>,

            /// The aspect types that are in scope for the export job, specified as
            /// relative resource names in the format
            /// `projects/{project_id_or_number}/locations/{location}/aspectTypes/{aspect_type_id}`.
            /// Only aspects that belong to the specified aspect types are affected by
            /// the job.
            pub aspect_types: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ExportJobScope {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [organization_level][crate::model::metadata_job::export_job_spec::ExportJobScope::organization_level].
            pub fn set_organization_level<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.organization_level = v.into();
                self
            }

            /// Sets the value of [projects][crate::model::metadata_job::export_job_spec::ExportJobScope::projects].
            pub fn set_projects<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.projects = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [entry_groups][crate::model::metadata_job::export_job_spec::ExportJobScope::entry_groups].
            pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_groups = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [entry_types][crate::model::metadata_job::export_job_spec::ExportJobScope::entry_types].
            pub fn set_entry_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_types = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [aspect_types][crate::model::metadata_job::export_job_spec::ExportJobScope::aspect_types].
            pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.aspect_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ExportJobScope {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ExportJobSpec.ExportJobScope"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ExportJobScope {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __organization_level,
                    __projects,
                    __entry_groups,
                    __entry_types,
                    __aspect_types,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ExportJobScope")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "organizationLevel" => Ok(__FieldTag::__organization_level),
                                    "organization_level" => Ok(__FieldTag::__organization_level),
                                    "projects" => Ok(__FieldTag::__projects),
                                    "entryGroups" => Ok(__FieldTag::__entry_groups),
                                    "entry_groups" => Ok(__FieldTag::__entry_groups),
                                    "entryTypes" => Ok(__FieldTag::__entry_types),
                                    "entry_types" => Ok(__FieldTag::__entry_types),
                                    "aspectTypes" => Ok(__FieldTag::__aspect_types),
                                    "aspect_types" => Ok(__FieldTag::__aspect_types),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ExportJobScope;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ExportJobScope")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__organization_level => {
                                    if !fields.insert(__FieldTag::__organization_level) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for organization_level",
                                            ),
                                        );
                                    }
                                    result.organization_level = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__projects => {
                                    if !fields.insert(__FieldTag::__projects) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for projects",
                                            ),
                                        );
                                    }
                                    result.projects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__entry_groups => {
                                    if !fields.insert(__FieldTag::__entry_groups) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for entry_groups",
                                            ),
                                        );
                                    }
                                    result.entry_groups = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__entry_types => {
                                    if !fields.insert(__FieldTag::__entry_types) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for entry_types",
                                            ),
                                        );
                                    }
                                    result.entry_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__aspect_types => {
                                    if !fields.insert(__FieldTag::__aspect_types) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for aspect_types",
                                            ),
                                        );
                                    }
                                    result.aspect_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ExportJobScope {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.organization_level) {
                    state.serialize_entry("organizationLevel", &self.organization_level)?;
                }
                if !self.projects.is_empty() {
                    state.serialize_entry("projects", &self.projects)?;
                }
                if !self.entry_groups.is_empty() {
                    state.serialize_entry("entryGroups", &self.entry_groups)?;
                }
                if !self.entry_types.is_empty() {
                    state.serialize_entry("entryTypes", &self.entry_types)?;
                }
                if !self.aspect_types.is_empty() {
                    state.serialize_entry("aspectTypes", &self.aspect_types)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Metadata job status.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Status {
        /// Output only. State of the metadata job.
        pub state: crate::model::metadata_job::status::State,

        /// Output only. Message relating to the progression of a metadata job.
        pub message: std::string::String,

        /// Output only. Progress tracking.
        pub completion_percent: i32,

        /// Output only. The time when the status was updated.
        pub update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Status {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::metadata_job::Status::state].
        pub fn set_state<T: std::convert::Into<crate::model::metadata_job::status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::metadata_job::Status::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [completion_percent][crate::model::metadata_job::Status::completion_percent].
        pub fn set_completion_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.completion_percent = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::metadata_job::Status::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::metadata_job::Status::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Status {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.Status"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __message,
                __completion_percent,
                __update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Status")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "message" => Ok(__FieldTag::__message),
                                "completionPercent" => Ok(__FieldTag::__completion_percent),
                                "completion_percent" => Ok(__FieldTag::__completion_percent),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Status;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Status")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state =
                                    map.next_value::<std::option::Option<
                                        crate::model::metadata_job::status::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__message => {
                                if !fields.insert(__FieldTag::__message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message",
                                    ));
                                }
                                result.message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__completion_percent => {
                                if !fields.insert(__FieldTag::__completion_percent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for completion_percent",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.completion_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.message.is_empty() {
                state.serialize_entry("message", &self.message)?;
            }
            if !wkt::internal::is_default(&self.completion_percent) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("completionPercent", &__With(&self.completion_percent))?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Status].
    pub mod status {
        #[allow(unused_imports)]
        use super::*;

        /// State of a metadata job.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State unspecified.
            Unspecified,
            /// The job is queued.
            Queued,
            /// The job is running.
            Running,
            /// The job is being canceled.
            Canceling,
            /// The job is canceled.
            Canceled,
            /// The job succeeded.
            Succeeded,
            /// The job failed.
            Failed,
            /// The job completed with some errors.
            SucceededWithErrors,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Queued => std::option::Option::Some(1),
                    Self::Running => std::option::Option::Some(2),
                    Self::Canceling => std::option::Option::Some(3),
                    Self::Canceled => std::option::Option::Some(4),
                    Self::Succeeded => std::option::Option::Some(5),
                    Self::Failed => std::option::Option::Some(6),
                    Self::SucceededWithErrors => std::option::Option::Some(7),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Queued => std::option::Option::Some("QUEUED"),
                    Self::Running => std::option::Option::Some("RUNNING"),
                    Self::Canceling => std::option::Option::Some("CANCELING"),
                    Self::Canceled => std::option::Option::Some("CANCELED"),
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::SucceededWithErrors => std::option::Option::Some("SUCCEEDED_WITH_ERRORS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Queued,
                    2 => Self::Running,
                    3 => Self::Canceling,
                    4 => Self::Canceled,
                    5 => Self::Succeeded,
                    6 => Self::Failed,
                    7 => Self::SucceededWithErrors,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "QUEUED" => Self::Queued,
                    "RUNNING" => Self::Running,
                    "CANCELING" => Self::Canceling,
                    "CANCELED" => Self::Canceled,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    "SUCCEEDED_WITH_ERRORS" => Self::SucceededWithErrors,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Queued => serializer.serialize_i32(1),
                    Self::Running => serializer.serialize_i32(2),
                    Self::Canceling => serializer.serialize_i32(3),
                    Self::Canceled => serializer.serialize_i32(4),
                    Self::Succeeded => serializer.serialize_i32(5),
                    Self::Failed => serializer.serialize_i32(6),
                    Self::SucceededWithErrors => serializer.serialize_i32(7),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.MetadataJob.Status.State",
                ))
            }
        }
    }

    /// Metadata job type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified.
        Unspecified,
        /// Import job.
        Import,
        /// Export job.
        Export,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Import => std::option::Option::Some(1),
                Self::Export => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Import => std::option::Option::Some("IMPORT"),
                Self::Export => std::option::Option::Some("EXPORT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Import,
                2 => Self::Export,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMPORT" => Self::Import,
                "EXPORT" => Self::Export,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Import => serializer.serialize_i32(1),
                Self::Export => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.MetadataJob.Type",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Spec {
        /// Import job specification.
        ImportSpec(std::boxed::Box<crate::model::metadata_job::ImportJobSpec>),
        /// Export job specification.
        ExportSpec(std::boxed::Box<crate::model::metadata_job::ExportJobSpec>),
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Output only. Import job result.
        ImportResult(std::boxed::Box<crate::model::metadata_job::ImportJobResult>),
        /// Output only. Export job result.
        ExportResult(std::boxed::Box<crate::model::metadata_job::ExportJobResult>),
    }
}

/// A Resource designed to manage encryption configurations for customers to
/// support Customer Managed Encryption Keys (CMEK).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// Identifier. The resource name of the EncryptionConfig.
    /// Format:
    /// organizations/{organization}/locations/{location}/encryptionConfigs/{encryption_config}
    /// Global location is not supported.
    pub name: std::string::String,

    /// Optional. If a key is chosen, it means that the customer is using CMEK.
    /// If a key is not chosen, it means that the customer is using Google managed
    /// encryption.
    pub key: std::string::String,

    /// Output only. The time when the Encryption configuration was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the Encryption configuration was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of encryption of the databases.
    pub encryption_state: crate::model::encryption_config::EncryptionState,

    /// Etag of the EncryptionConfig. This is a strong etag.
    pub etag: std::string::String,

    /// Output only. Details of the failure if anything related to Cmek db fails.
    pub failure_details: std::option::Option<crate::model::encryption_config::FailureDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptionConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [key][crate::model::EncryptionConfig::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EncryptionConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::EncryptionConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::EncryptionConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::EncryptionConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_state][crate::model::EncryptionConfig::encryption_state].
    pub fn set_encryption_state<
        T: std::convert::Into<crate::model::encryption_config::EncryptionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::EncryptionConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [failure_details][crate::model::EncryptionConfig::failure_details].
    pub fn set_failure_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::encryption_config::FailureDetails>,
    {
        self.failure_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failure_details][crate::model::EncryptionConfig::failure_details].
    pub fn set_or_clear_failure_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::encryption_config::FailureDetails>,
    {
        self.failure_details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EncryptionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __key,
            __create_time,
            __update_time,
            __encryption_state,
            __etag,
            __failure_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "key" => Ok(__FieldTag::__key),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "encryptionState" => Ok(__FieldTag::__encryption_state),
                            "encryption_state" => Ok(__FieldTag::__encryption_state),
                            "etag" => Ok(__FieldTag::__etag),
                            "failureDetails" => Ok(__FieldTag::__failure_details),
                            "failure_details" => Ok(__FieldTag::__failure_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__encryption_state => {
                            if !fields.insert(__FieldTag::__encryption_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_state",
                                ));
                            }
                            result.encryption_state = map
                                .next_value::<std::option::Option<
                                    crate::model::encryption_config::EncryptionState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_details => {
                            if !fields.insert(__FieldTag::__failure_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_details",
                                ));
                            }
                            result.failure_details = map.next_value::<std::option::Option<
                                crate::model::encryption_config::FailureDetails,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.encryption_state) {
            state.serialize_entry("encryptionState", &self.encryption_state)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.failure_details.is_some() {
            state.serialize_entry("failureDetails", &self.failure_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EncryptionConfig].
pub mod encryption_config {
    #[allow(unused_imports)]
    use super::*;

    /// Details of the failure if anything related to Cmek db fails.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FailureDetails {
        /// Output only. The error code for the failure.
        pub error_code: crate::model::encryption_config::failure_details::ErrorCode,

        /// Output only. The error message will be shown to the user. Set only if the
        /// error code is REQUIRE_USER_ACTION.
        pub error_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailureDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_code][crate::model::encryption_config::FailureDetails::error_code].
        pub fn set_error_code<
            T: std::convert::Into<crate::model::encryption_config::failure_details::ErrorCode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.error_code = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::encryption_config::FailureDetails::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for FailureDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EncryptionConfig.FailureDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FailureDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __error_code,
                __error_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FailureDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "errorCode" => Ok(__FieldTag::__error_code),
                                "error_code" => Ok(__FieldTag::__error_code),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FailureDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FailureDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__error_code => {
                                if !fields.insert(__FieldTag::__error_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_code",
                                    ));
                                }
                                result.error_code = map
                                    .next_value::<std::option::Option<
                                        crate::model::encryption_config::failure_details::ErrorCode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FailureDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.error_code) {
                state.serialize_entry("errorCode", &self.error_code)?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [FailureDetails].
    pub mod failure_details {
        #[allow(unused_imports)]
        use super::*;

        /// Error code for the failure if anything related to Cmek db fails.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ErrorCode {
            /// The error code is not specified
            Unknown,
            /// Error because of internal server error, will be retried automatically.
            InternalError,
            /// User action is required to resolve the error.
            RequireUserAction,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ErrorCode::value] or
            /// [ErrorCode::name].
            UnknownValue(error_code::UnknownValue),
        }

        #[doc(hidden)]
        pub mod error_code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ErrorCode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unknown => std::option::Option::Some(0),
                    Self::InternalError => std::option::Option::Some(1),
                    Self::RequireUserAction => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                    Self::RequireUserAction => std::option::Option::Some("REQUIRE_USER_ACTION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ErrorCode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ErrorCode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ErrorCode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unknown,
                    1 => Self::InternalError,
                    2 => Self::RequireUserAction,
                    _ => Self::UnknownValue(error_code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ErrorCode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN" => Self::Unknown,
                    "INTERNAL_ERROR" => Self::InternalError,
                    "REQUIRE_USER_ACTION" => Self::RequireUserAction,
                    _ => Self::UnknownValue(error_code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ErrorCode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unknown => serializer.serialize_i32(0),
                    Self::InternalError => serializer.serialize_i32(1),
                    Self::RequireUserAction => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ErrorCode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                    ".google.cloud.dataplex.v1.EncryptionConfig.FailureDetails.ErrorCode",
                ))
            }
        }
    }

    /// State of encryption of the databases when EncryptionConfig is created or
    /// updated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EncryptionState {
        /// State is not specified.
        Unspecified,
        /// The encryption state of the database when the EncryptionConfig is created
        /// or updated. If the encryption fails, it is retried indefinitely and the
        /// state is shown as ENCRYPTING.
        Encrypting,
        /// The encryption of data has completed successfully.
        Completed,
        /// The encryption of data has failed.
        /// The state is set to FAILED when the encryption fails due to reasons like
        /// permission issues, invalid key etc.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EncryptionState::value] or
        /// [EncryptionState::name].
        UnknownValue(encryption_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod encryption_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EncryptionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Encrypting => std::option::Option::Some(1),
                Self::Completed => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENCRYPTION_STATE_UNSPECIFIED"),
                Self::Encrypting => std::option::Option::Some("ENCRYPTING"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EncryptionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EncryptionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EncryptionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Encrypting,
                2 => Self::Completed,
                3 => Self::Failed,
                _ => Self::UnknownValue(encryption_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EncryptionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENCRYPTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENCRYPTING" => Self::Encrypting,
                "COMPLETED" => Self::Completed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(encryption_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EncryptionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Encrypting => serializer.serialize_i32(1),
                Self::Completed => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EncryptionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionState>::new(
                ".google.cloud.dataplex.v1.EncryptionConfig.EncryptionState",
            ))
        }
    }
}

/// Create EncryptionConfig Request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEncryptionConfigRequest {
    /// Required. The location at which the EncryptionConfig is to be created.
    pub parent: std::string::String,

    /// Required. The ID of the
    /// [EncryptionConfig][google.cloud.dataplex.v1.EncryptionConfig] to create.
    /// Currently, only a value of "default" is supported.
    ///
    /// [google.cloud.dataplex.v1.EncryptionConfig]: crate::model::EncryptionConfig
    pub encryption_config_id: std::string::String,

    /// Required. The EncryptionConfig to create.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEncryptionConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [encryption_config_id][crate::model::CreateEncryptionConfigRequest::encryption_config_id].
    pub fn set_encryption_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config_id = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::CreateEncryptionConfigRequest::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::CreateEncryptionConfigRequest::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEncryptionConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEncryptionConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __encryption_config_id,
            __encryption_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEncryptionConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "encryptionConfigId" => Ok(__FieldTag::__encryption_config_id),
                            "encryption_config_id" => Ok(__FieldTag::__encryption_config_id),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEncryptionConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEncryptionConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_config_id => {
                            if !fields.insert(__FieldTag::__encryption_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config_id",
                                ));
                            }
                            result.encryption_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEncryptionConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.encryption_config_id.is_empty() {
            state.serialize_entry("encryptionConfigId", &self.encryption_config_id)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get EncryptionConfig Request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEncryptionConfigRequest {
    /// Required. The name of the EncryptionConfig to fetch.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEncryptionConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEncryptionConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEncryptionConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEncryptionConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEncryptionConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEncryptionConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEncryptionConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update EncryptionConfig Request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEncryptionConfigRequest {
    /// Required. The EncryptionConfig to update.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Optional. Mask of fields to update.
    /// The service treats an omitted field mask as an implied field mask
    /// equivalent to all fields that are populated (have a non-empty value).
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_config][crate::model::UpdateEncryptionConfigRequest::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::UpdateEncryptionConfigRequest::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEncryptionConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEncryptionConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEncryptionConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEncryptionConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEncryptionConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEncryptionConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEncryptionConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEncryptionConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete EncryptionConfig Request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEncryptionConfigRequest {
    /// Required. The name of the EncryptionConfig to delete.
    pub name: std::string::String,

    /// Optional. Etag of the EncryptionConfig. This is a strong etag.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEncryptionConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEncryptionConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEncryptionConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEncryptionConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEncryptionConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEncryptionConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEncryptionConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEncryptionConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List EncryptionConfigs Request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEncryptionConfigsRequest {
    /// Required. The location for which the EncryptionConfig is to be listed.
    pub parent: std::string::String,

    /// Optional. Maximum number of EncryptionConfigs to return. The service may
    /// return fewer than this value. If unspecified, at most 10 EncryptionConfigs
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEncryptionConfigs` call.
    /// Provide this to retrieve the subsequent page. When paginating, the
    /// parameters - filter and order_by provided to `ListEncryptionConfigs` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter the EncryptionConfigs to be returned.
    /// Using bare literals: (These values will be matched anywhere it may appear
    /// in the object's field values)
    ///
    /// * filter=some_value
    ///   Using fields: (These values will be matched only in the specified field)
    /// * filter=some_field=some_value
    ///   Supported fields:
    /// * name, key, create_time, update_time, encryption_state
    ///   Example:
    /// * filter=name=organizations/123/locations/us-central1/encryptionConfigs/test-config
    ///   conjunctions: (AND, OR, NOT)
    /// * filter=name=organizations/123/locations/us-central1/encryptionConfigs/test-config
    ///   AND mode=CMEK
    ///   logical operators: (>, <, >=, <=, !=, =, :),
    /// * filter=create_time>2024-05-01T00:00:00.000Z
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEncryptionConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEncryptionConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEncryptionConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEncryptionConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEncryptionConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEncryptionConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEncryptionConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEncryptionConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEncryptionConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEncryptionConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEncryptionConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEncryptionConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEncryptionConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List EncryptionConfigs Response
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEncryptionConfigsResponse {
    /// The list of EncryptionConfigs under the given parent location.
    pub encryption_configs: std::vec::Vec<crate::model::EncryptionConfig>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEncryptionConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_configs][crate::model::ListEncryptionConfigsResponse::encryption_configs].
    pub fn set_encryption_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EncryptionConfig>,
    {
        use std::iter::Iterator;
        self.encryption_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEncryptionConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListEncryptionConfigsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEncryptionConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEncryptionConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEncryptionConfigsResponse {
    type PageItem = crate::model::EncryptionConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.encryption_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEncryptionConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_configs,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEncryptionConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionConfigs" => Ok(__FieldTag::__encryption_configs),
                            "encryption_configs" => Ok(__FieldTag::__encryption_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEncryptionConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEncryptionConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_configs => {
                            if !fields.insert(__FieldTag::__encryption_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_configs",
                                ));
                            }
                            result.encryption_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EncryptionConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEncryptionConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.encryption_configs.is_empty() {
            state.serialize_entry("encryptionConfigs", &self.encryption_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create content request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateContentRequest {
    /// Required. The resource name of the parent lake:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}
    pub parent: std::string::String,

    /// Required. Content resource.
    pub content: std::option::Option<crate::model::Content>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [content][crate::model::CreateContentRequest::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Content>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::CreateContentRequest::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Content>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateContentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __content,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "content" => Ok(__FieldTag::__content),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content =
                                map.next_value::<std::option::Option<crate::model::Content>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update content request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateContentRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    pub content: std::option::Option<crate::model::Content>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateContentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateContentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [content][crate::model::UpdateContentRequest::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Content>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::UpdateContentRequest::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Content>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateContentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __content,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "content" => Ok(__FieldTag::__content),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content =
                                map.next_value::<std::option::Option<crate::model::Content>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete content request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteContentRequest {
    /// Required. The resource name of the content:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List content request. Returns the BASIC Content view.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContentRequest {
    /// Required. The resource name of the parent lake:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}
    pub parent: std::string::String,

    /// Optional. Maximum number of content to return. The service may return fewer
    /// than this value. If unspecified, at most 10 content will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListContent` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListContent` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The following formats are supported:
    ///
    /// labels.key1 = "value1"
    /// labels:key1
    /// type = "NOTEBOOK"
    /// type = "SQL_SCRIPT"
    ///
    /// These restrictions can be coinjoined with AND, OR and NOT conjunctions.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListContentRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListContentRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListContentRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List content response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContentResponse {
    /// Content under the given parent lake.
    pub content: std::vec::Vec<crate::model::Content>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::ListContentResponse::content].
    pub fn set_content<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.content = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListContentResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListContentResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListContentResponse {
    type PageItem = crate::model::Content;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.content
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Content>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get content request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetContentRequest {
    /// Required. The resource name of the content:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    pub name: std::string::String,

    /// Optional. Specify content view to make a partial request.
    pub view: crate::model::get_content_request::ContentView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetContentRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_content_request::ContentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<
                                    crate::model::get_content_request::ContentView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GetContentRequest].
pub mod get_content_request {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies whether the request should return the full or the partial
    /// representation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContentView {
        /// Content view not specified. Defaults to BASIC.
        /// The API will default to the BASIC view.
        Unspecified,
        /// Will not return the `data_text` field.
        Basic,
        /// Returns the complete proto.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContentView::value] or
        /// [ContentView::name].
        UnknownValue(content_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod content_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContentView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTENT_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContentView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContentView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContentView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::Full,
                _ => Self::UnknownValue(content_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContentView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTENT_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(content_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContentView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContentView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentView>::new(
                ".google.cloud.dataplex.v1.GetContentRequest.ContentView",
            ))
        }
    }
}

/// Spec for a data discovery scan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataDiscoverySpec {
    /// Optional. Configuration for metadata publishing.
    pub bigquery_publishing_config:
        std::option::Option<crate::model::data_discovery_spec::BigQueryPublishingConfig>,

    /// The configurations of the data discovery scan resource.
    pub resource_config: std::option::Option<crate::model::data_discovery_spec::ResourceConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataDiscoverySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_publishing_config][crate::model::DataDiscoverySpec::bigquery_publishing_config].
    pub fn set_bigquery_publishing_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_discovery_spec::BigQueryPublishingConfig>,
    {
        self.bigquery_publishing_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_publishing_config][crate::model::DataDiscoverySpec::bigquery_publishing_config].
    pub fn set_or_clear_bigquery_publishing_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_discovery_spec::BigQueryPublishingConfig>,
    {
        self.bigquery_publishing_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_config][crate::model::DataDiscoverySpec::resource_config].
    ///
    /// Note that all the setters affecting `resource_config` are mutually
    /// exclusive.
    pub fn set_resource_config<
        T: std::convert::Into<std::option::Option<crate::model::data_discovery_spec::ResourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_config = v.into();
        self
    }

    /// The value of [resource_config][crate::model::DataDiscoverySpec::resource_config]
    /// if it holds a `StorageConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_discovery_spec::StorageConfig>>
    {
        #[allow(unreachable_patterns)]
        self.resource_config.as_ref().and_then(|v| match v {
            crate::model::data_discovery_spec::ResourceConfig::StorageConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_config][crate::model::DataDiscoverySpec::resource_config]
    /// to hold a `StorageConfig`.
    ///
    /// Note that all the setters affecting `resource_config` are
    /// mutually exclusive.
    pub fn set_storage_config<
        T: std::convert::Into<std::boxed::Box<crate::model::data_discovery_spec::StorageConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_config = std::option::Option::Some(
            crate::model::data_discovery_spec::ResourceConfig::StorageConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataDiscoverySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataDiscoverySpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_publishing_config,
            __storage_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataDiscoverySpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryPublishingConfig" => {
                                Ok(__FieldTag::__bigquery_publishing_config)
                            }
                            "bigquery_publishing_config" => {
                                Ok(__FieldTag::__bigquery_publishing_config)
                            }
                            "storageConfig" => Ok(__FieldTag::__storage_config),
                            "storage_config" => Ok(__FieldTag::__storage_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataDiscoverySpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataDiscoverySpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_publishing_config => {
                            if !fields.insert(__FieldTag::__bigquery_publishing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_publishing_config",
                                ));
                            }
                            result.bigquery_publishing_config = map
                                .next_value::<std::option::Option<
                                    crate::model::data_discovery_spec::BigQueryPublishingConfig,
                                >>()?;
                        }
                        __FieldTag::__storage_config => {
                            if !fields.insert(__FieldTag::__storage_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_config",
                                ));
                            }
                            if result.resource_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_config`, a oneof with full ID .google.cloud.dataplex.v1.DataDiscoverySpec.storage_config, latest field was storageConfig",
                                ));
                            }
                            result.resource_config = std::option::Option::Some(
                                crate::model::data_discovery_spec::ResourceConfig::StorageConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_discovery_spec::StorageConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataDiscoverySpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bigquery_publishing_config.is_some() {
            state.serialize_entry("bigqueryPublishingConfig", &self.bigquery_publishing_config)?;
        }
        if let Some(value) = self.storage_config() {
            state.serialize_entry("storageConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataDiscoverySpec].
pub mod data_discovery_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Describes BigQuery publishing configurations.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryPublishingConfig {
        /// Optional. Determines whether to  publish discovered tables as BigLake
        /// external tables or non-BigLake external tables.
        pub table_type: crate::model::data_discovery_spec::big_query_publishing_config::TableType,

        /// Optional. The BigQuery connection used to create BigLake tables.
        /// Must be in the form
        /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
        pub connection: std::string::String,

        /// Optional. The location of the BigQuery dataset to publish BigLake
        /// external or non-BigLake external tables to.
        ///
        /// 1. If the Cloud Storage bucket is located in a multi-region bucket, then
        ///    BigQuery dataset can be in the same multi-region bucket or any single
        ///    region that is included in the same multi-region bucket. The datascan can
        ///    be created in any single region that is included in the same multi-region
        ///    bucket
        /// 1. If the Cloud Storage bucket is located in a dual-region bucket, then
        ///    BigQuery dataset can be located in regions that are included in the
        ///    dual-region bucket, or in a multi-region that includes the dual-region.
        ///    The datascan can be created in any single region that is included in the
        ///    same dual-region bucket.
        /// 1. If the Cloud Storage bucket is located in a single region, then
        ///    BigQuery dataset can be in the same single region or any multi-region
        ///    bucket that includes the same single region. The datascan will be created
        ///    in the same single region as the bucket.
        /// 1. If the BigQuery dataset is in single region, it must be in the same
        ///    single region as the datascan.
        ///
        /// For supported values, refer to
        /// <https://cloud.google.com/bigquery/docs/locations#supported_locations>.
        pub location: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryPublishingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table_type][crate::model::data_discovery_spec::BigQueryPublishingConfig::table_type].
        pub fn set_table_type<
            T: std::convert::Into<
                    crate::model::data_discovery_spec::big_query_publishing_config::TableType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.table_type = v.into();
            self
        }

        /// Sets the value of [connection][crate::model::data_discovery_spec::BigQueryPublishingConfig::connection].
        pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.connection = v.into();
            self
        }

        /// Sets the value of [location][crate::model::data_discovery_spec::BigQueryPublishingConfig::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryPublishingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.BigQueryPublishingConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryPublishingConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __table_type,
                __connection,
                __location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryPublishingConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tableType" => Ok(__FieldTag::__table_type),
                                "table_type" => Ok(__FieldTag::__table_type),
                                "connection" => Ok(__FieldTag::__connection),
                                "location" => Ok(__FieldTag::__location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryPublishingConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryPublishingConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__table_type => {
                                if !fields.insert(__FieldTag::__table_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_type",
                                    ));
                                }
                                result.table_type = map.next_value::<std::option::Option<crate::model::data_discovery_spec::big_query_publishing_config::TableType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__connection => {
                                if !fields.insert(__FieldTag::__connection) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for connection",
                                    ));
                                }
                                result.connection = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryPublishingConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.table_type) {
                state.serialize_entry("tableType", &self.table_type)?;
            }
            if !self.connection.is_empty() {
                state.serialize_entry("connection", &self.connection)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [BigQueryPublishingConfig].
    pub mod big_query_publishing_config {
        #[allow(unused_imports)]
        use super::*;

        /// Determines how discovered tables are published.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TableType {
            /// Table type unspecified.
            Unspecified,
            /// Default. Discovered tables are published as BigQuery external tables
            /// whose data is accessed using the credentials of the user querying the
            /// table.
            External,
            /// Discovered tables are published as BigLake external tables whose data
            /// is accessed using the credentials of the associated BigQuery
            /// connection.
            Biglake,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TableType::value] or
            /// [TableType::name].
            UnknownValue(table_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod table_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TableType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::External => std::option::Option::Some(1),
                    Self::Biglake => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TABLE_TYPE_UNSPECIFIED"),
                    Self::External => std::option::Option::Some("EXTERNAL"),
                    Self::Biglake => std::option::Option::Some("BIGLAKE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TableType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TableType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TableType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::External,
                    2 => Self::Biglake,
                    _ => Self::UnknownValue(table_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TableType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "EXTERNAL" => Self::External,
                    "BIGLAKE" => Self::Biglake,
                    _ => Self::UnknownValue(table_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TableType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::External => serializer.serialize_i32(1),
                    Self::Biglake => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TableType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableType>::new(
                    ".google.cloud.dataplex.v1.DataDiscoverySpec.BigQueryPublishingConfig.TableType"))
            }
        }
    }

    /// Configurations related to Cloud Storage as the data source.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StorageConfig {
        /// Optional. Defines the data to include during discovery when only a subset
        /// of the data should be considered. Provide a list of patterns that
        /// identify the data to include. For Cloud Storage bucket assets, these
        /// patterns are interpreted as glob patterns used to match object names. For
        /// BigQuery dataset assets, these patterns are interpreted as patterns to
        /// match table names.
        pub include_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Defines the data to exclude during discovery. Provide a list of
        /// patterns that identify the data to exclude. For Cloud Storage bucket
        /// assets, these patterns are interpreted as glob patterns used to match
        /// object names. For BigQuery dataset assets, these patterns are interpreted
        /// as patterns to match table names.
        pub exclude_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Configuration for CSV data.
        pub csv_options:
            std::option::Option<crate::model::data_discovery_spec::storage_config::CsvOptions>,

        /// Optional. Configuration for JSON data.
        pub json_options:
            std::option::Option<crate::model::data_discovery_spec::storage_config::JsonOptions>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StorageConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [include_patterns][crate::model::data_discovery_spec::StorageConfig::include_patterns].
        pub fn set_include_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclude_patterns][crate::model::data_discovery_spec::StorageConfig::exclude_patterns].
        pub fn set_exclude_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.exclude_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [csv_options][crate::model::data_discovery_spec::StorageConfig::csv_options].
        pub fn set_csv_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::data_discovery_spec::storage_config::CsvOptions>,
        {
            self.csv_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [csv_options][crate::model::data_discovery_spec::StorageConfig::csv_options].
        pub fn set_or_clear_csv_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::data_discovery_spec::storage_config::CsvOptions>,
        {
            self.csv_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [json_options][crate::model::data_discovery_spec::StorageConfig::json_options].
        pub fn set_json_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::data_discovery_spec::storage_config::JsonOptions>,
        {
            self.json_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [json_options][crate::model::data_discovery_spec::StorageConfig::json_options].
        pub fn set_or_clear_json_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::data_discovery_spec::storage_config::JsonOptions>,
        {
            self.json_options = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for StorageConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.StorageConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StorageConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __include_patterns,
                __exclude_patterns,
                __csv_options,
                __json_options,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StorageConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "includePatterns" => Ok(__FieldTag::__include_patterns),
                                "include_patterns" => Ok(__FieldTag::__include_patterns),
                                "excludePatterns" => Ok(__FieldTag::__exclude_patterns),
                                "exclude_patterns" => Ok(__FieldTag::__exclude_patterns),
                                "csvOptions" => Ok(__FieldTag::__csv_options),
                                "csv_options" => Ok(__FieldTag::__csv_options),
                                "jsonOptions" => Ok(__FieldTag::__json_options),
                                "json_options" => Ok(__FieldTag::__json_options),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StorageConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StorageConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__include_patterns => {
                                if !fields.insert(__FieldTag::__include_patterns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_patterns",
                                    ));
                                }
                                result.include_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__exclude_patterns => {
                                if !fields.insert(__FieldTag::__exclude_patterns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exclude_patterns",
                                    ));
                                }
                                result.exclude_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__csv_options => {
                                if !fields.insert(__FieldTag::__csv_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for csv_options",
                                    ));
                                }
                                result.csv_options = map.next_value::<std::option::Option<
                                    crate::model::data_discovery_spec::storage_config::CsvOptions,
                                >>()?;
                            }
                            __FieldTag::__json_options => {
                                if !fields.insert(__FieldTag::__json_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for json_options",
                                    ));
                                }
                                result.json_options = map.next_value::<std::option::Option<
                                    crate::model::data_discovery_spec::storage_config::JsonOptions,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StorageConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.include_patterns.is_empty() {
                state.serialize_entry("includePatterns", &self.include_patterns)?;
            }
            if !self.exclude_patterns.is_empty() {
                state.serialize_entry("excludePatterns", &self.exclude_patterns)?;
            }
            if self.csv_options.is_some() {
                state.serialize_entry("csvOptions", &self.csv_options)?;
            }
            if self.json_options.is_some() {
                state.serialize_entry("jsonOptions", &self.json_options)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [StorageConfig].
    pub mod storage_config {
        #[allow(unused_imports)]
        use super::*;

        /// Describes CSV and similar semi-structured data formats.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            pub header_rows: i32,

            /// Optional. The delimiter that is used to separate values. The default is
            /// `,` (comma).
            pub delimiter: std::string::String,

            /// Optional. The character encoding of the data. The default is UTF-8.
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data types for CSV data.
            /// If true, all columns are registered as strings.
            pub type_inference_disabled: bool,

            /// Optional. The character used to quote column values. Accepts `"`
            /// (double quotation mark) or `'` (single quotation mark). If unspecified,
            /// defaults to `"` (double quotation mark).
            pub quote: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CsvOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [header_rows][crate::model::data_discovery_spec::storage_config::CsvOptions::header_rows].
            pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.header_rows = v.into();
                self
            }

            /// Sets the value of [delimiter][crate::model::data_discovery_spec::storage_config::CsvOptions::delimiter].
            pub fn set_delimiter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.delimiter = v.into();
                self
            }

            /// Sets the value of [encoding][crate::model::data_discovery_spec::storage_config::CsvOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [type_inference_disabled][crate::model::data_discovery_spec::storage_config::CsvOptions::type_inference_disabled].
            pub fn set_type_inference_disabled<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.type_inference_disabled = v.into();
                self
            }

            /// Sets the value of [quote][crate::model::data_discovery_spec::storage_config::CsvOptions::quote].
            pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.quote = v.into();
                self
            }
        }

        impl wkt::message::Message for CsvOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.StorageConfig.CsvOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CsvOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __header_rows,
                    __delimiter,
                    __encoding,
                    __type_inference_disabled,
                    __quote,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CsvOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "headerRows" => Ok(__FieldTag::__header_rows),
                                    "header_rows" => Ok(__FieldTag::__header_rows),
                                    "delimiter" => Ok(__FieldTag::__delimiter),
                                    "encoding" => Ok(__FieldTag::__encoding),
                                    "typeInferenceDisabled" => {
                                        Ok(__FieldTag::__type_inference_disabled)
                                    }
                                    "type_inference_disabled" => {
                                        Ok(__FieldTag::__type_inference_disabled)
                                    }
                                    "quote" => Ok(__FieldTag::__quote),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CsvOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CsvOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__header_rows => {
                                    if !fields.insert(__FieldTag::__header_rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for header_rows",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.header_rows =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__delimiter => {
                                    if !fields.insert(__FieldTag::__delimiter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for delimiter",
                                            ),
                                        );
                                    }
                                    result.delimiter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__encoding => {
                                    if !fields.insert(__FieldTag::__encoding) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for encoding",
                                            ),
                                        );
                                    }
                                    result.encoding = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__type_inference_disabled => {
                                    if !fields.insert(__FieldTag::__type_inference_disabled) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for type_inference_disabled",
                                            ),
                                        );
                                    }
                                    result.type_inference_disabled = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__quote => {
                                    if !fields.insert(__FieldTag::__quote) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for quote"),
                                        );
                                    }
                                    result.quote = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CsvOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.header_rows) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("headerRows", &__With(&self.header_rows))?;
                }
                if !self.delimiter.is_empty() {
                    state.serialize_entry("delimiter", &self.delimiter)?;
                }
                if !self.encoding.is_empty() {
                    state.serialize_entry("encoding", &self.encoding)?;
                }
                if !wkt::internal::is_default(&self.type_inference_disabled) {
                    state
                        .serialize_entry("typeInferenceDisabled", &self.type_inference_disabled)?;
                }
                if !self.quote.is_empty() {
                    state.serialize_entry("quote", &self.quote)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Describes JSON data format.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data types for JSON data.
            /// If true, all columns are registered as their primitive types
            /// (strings, number, or boolean).
            pub type_inference_disabled: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::data_discovery_spec::storage_config::JsonOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [type_inference_disabled][crate::model::data_discovery_spec::storage_config::JsonOptions::type_inference_disabled].
            pub fn set_type_inference_disabled<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.type_inference_disabled = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.StorageConfig.JsonOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JsonOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __encoding,
                    __type_inference_disabled,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JsonOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "encoding" => Ok(__FieldTag::__encoding),
                                    "typeInferenceDisabled" => {
                                        Ok(__FieldTag::__type_inference_disabled)
                                    }
                                    "type_inference_disabled" => {
                                        Ok(__FieldTag::__type_inference_disabled)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JsonOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JsonOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__encoding => {
                                    if !fields.insert(__FieldTag::__encoding) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for encoding",
                                            ),
                                        );
                                    }
                                    result.encoding = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__type_inference_disabled => {
                                    if !fields.insert(__FieldTag::__type_inference_disabled) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for type_inference_disabled",
                                            ),
                                        );
                                    }
                                    result.type_inference_disabled = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JsonOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.encoding.is_empty() {
                    state.serialize_entry("encoding", &self.encoding)?;
                }
                if !wkt::internal::is_default(&self.type_inference_disabled) {
                    state
                        .serialize_entry("typeInferenceDisabled", &self.type_inference_disabled)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// The configurations of the data discovery scan resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceConfig {
        /// Cloud Storage related configurations.
        StorageConfig(std::boxed::Box<crate::model::data_discovery_spec::StorageConfig>),
    }
}

/// The output of a data discovery scan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataDiscoveryResult {
    /// Output only. Configuration for metadata publishing.
    pub bigquery_publishing:
        std::option::Option<crate::model::data_discovery_result::BigQueryPublishing>,

    /// Output only. Describes result statistics of a data scan discovery job.
    pub scan_statistics: std::option::Option<crate::model::data_discovery_result::ScanStatistics>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataDiscoveryResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_publishing][crate::model::DataDiscoveryResult::bigquery_publishing].
    pub fn set_bigquery_publishing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_discovery_result::BigQueryPublishing>,
    {
        self.bigquery_publishing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_publishing][crate::model::DataDiscoveryResult::bigquery_publishing].
    pub fn set_or_clear_bigquery_publishing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_discovery_result::BigQueryPublishing>,
    {
        self.bigquery_publishing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scan_statistics][crate::model::DataDiscoveryResult::scan_statistics].
    pub fn set_scan_statistics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_discovery_result::ScanStatistics>,
    {
        self.scan_statistics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scan_statistics][crate::model::DataDiscoveryResult::scan_statistics].
    pub fn set_or_clear_scan_statistics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_discovery_result::ScanStatistics>,
    {
        self.scan_statistics = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataDiscoveryResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoveryResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataDiscoveryResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_publishing,
            __scan_statistics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataDiscoveryResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryPublishing" => Ok(__FieldTag::__bigquery_publishing),
                            "bigquery_publishing" => Ok(__FieldTag::__bigquery_publishing),
                            "scanStatistics" => Ok(__FieldTag::__scan_statistics),
                            "scan_statistics" => Ok(__FieldTag::__scan_statistics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataDiscoveryResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataDiscoveryResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_publishing => {
                            if !fields.insert(__FieldTag::__bigquery_publishing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_publishing",
                                ));
                            }
                            result.bigquery_publishing = map.next_value::<std::option::Option<
                                crate::model::data_discovery_result::BigQueryPublishing,
                            >>()?;
                        }
                        __FieldTag::__scan_statistics => {
                            if !fields.insert(__FieldTag::__scan_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_statistics",
                                ));
                            }
                            result.scan_statistics = map.next_value::<std::option::Option<
                                crate::model::data_discovery_result::ScanStatistics,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataDiscoveryResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bigquery_publishing.is_some() {
            state.serialize_entry("bigqueryPublishing", &self.bigquery_publishing)?;
        }
        if self.scan_statistics.is_some() {
            state.serialize_entry("scanStatistics", &self.scan_statistics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataDiscoveryResult].
pub mod data_discovery_result {
    #[allow(unused_imports)]
    use super::*;

    /// Describes BigQuery publishing configurations.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryPublishing {
        /// Output only. The BigQuery dataset the discovered tables are published to.
        pub dataset: std::string::String,

        /// Output only. The location of the BigQuery publishing dataset.
        pub location: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryPublishing {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::data_discovery_result::BigQueryPublishing::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [location][crate::model::data_discovery_result::BigQueryPublishing::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryPublishing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoveryResult.BigQueryPublishing"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryPublishing {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset,
                __location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryPublishing")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dataset" => Ok(__FieldTag::__dataset),
                                "location" => Ok(__FieldTag::__location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryPublishing;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryPublishing")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset => {
                                if !fields.insert(__FieldTag::__dataset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset",
                                    ));
                                }
                                result.dataset = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryPublishing {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dataset.is_empty() {
                state.serialize_entry("dataset", &self.dataset)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Describes result statistics of a data scan discovery job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ScanStatistics {
        /// The number of files scanned.
        pub scanned_file_count: i32,

        /// The data processed in bytes.
        pub data_processed_bytes: i64,

        /// The number of files excluded.
        pub files_excluded: i32,

        /// The number of tables created.
        pub tables_created: i32,

        /// The number of tables deleted.
        pub tables_deleted: i32,

        /// The number of tables updated.
        pub tables_updated: i32,

        /// The number of filesets created.
        pub filesets_created: i32,

        /// The number of filesets deleted.
        pub filesets_deleted: i32,

        /// The number of filesets updated.
        pub filesets_updated: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ScanStatistics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scanned_file_count][crate::model::data_discovery_result::ScanStatistics::scanned_file_count].
        pub fn set_scanned_file_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.scanned_file_count = v.into();
            self
        }

        /// Sets the value of [data_processed_bytes][crate::model::data_discovery_result::ScanStatistics::data_processed_bytes].
        pub fn set_data_processed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.data_processed_bytes = v.into();
            self
        }

        /// Sets the value of [files_excluded][crate::model::data_discovery_result::ScanStatistics::files_excluded].
        pub fn set_files_excluded<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.files_excluded = v.into();
            self
        }

        /// Sets the value of [tables_created][crate::model::data_discovery_result::ScanStatistics::tables_created].
        pub fn set_tables_created<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.tables_created = v.into();
            self
        }

        /// Sets the value of [tables_deleted][crate::model::data_discovery_result::ScanStatistics::tables_deleted].
        pub fn set_tables_deleted<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.tables_deleted = v.into();
            self
        }

        /// Sets the value of [tables_updated][crate::model::data_discovery_result::ScanStatistics::tables_updated].
        pub fn set_tables_updated<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.tables_updated = v.into();
            self
        }

        /// Sets the value of [filesets_created][crate::model::data_discovery_result::ScanStatistics::filesets_created].
        pub fn set_filesets_created<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.filesets_created = v.into();
            self
        }

        /// Sets the value of [filesets_deleted][crate::model::data_discovery_result::ScanStatistics::filesets_deleted].
        pub fn set_filesets_deleted<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.filesets_deleted = v.into();
            self
        }

        /// Sets the value of [filesets_updated][crate::model::data_discovery_result::ScanStatistics::filesets_updated].
        pub fn set_filesets_updated<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.filesets_updated = v.into();
            self
        }
    }

    impl wkt::message::Message for ScanStatistics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoveryResult.ScanStatistics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ScanStatistics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __scanned_file_count,
                __data_processed_bytes,
                __files_excluded,
                __tables_created,
                __tables_deleted,
                __tables_updated,
                __filesets_created,
                __filesets_deleted,
                __filesets_updated,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ScanStatistics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "scannedFileCount" => Ok(__FieldTag::__scanned_file_count),
                                "scanned_file_count" => Ok(__FieldTag::__scanned_file_count),
                                "dataProcessedBytes" => Ok(__FieldTag::__data_processed_bytes),
                                "data_processed_bytes" => Ok(__FieldTag::__data_processed_bytes),
                                "filesExcluded" => Ok(__FieldTag::__files_excluded),
                                "files_excluded" => Ok(__FieldTag::__files_excluded),
                                "tablesCreated" => Ok(__FieldTag::__tables_created),
                                "tables_created" => Ok(__FieldTag::__tables_created),
                                "tablesDeleted" => Ok(__FieldTag::__tables_deleted),
                                "tables_deleted" => Ok(__FieldTag::__tables_deleted),
                                "tablesUpdated" => Ok(__FieldTag::__tables_updated),
                                "tables_updated" => Ok(__FieldTag::__tables_updated),
                                "filesetsCreated" => Ok(__FieldTag::__filesets_created),
                                "filesets_created" => Ok(__FieldTag::__filesets_created),
                                "filesetsDeleted" => Ok(__FieldTag::__filesets_deleted),
                                "filesets_deleted" => Ok(__FieldTag::__filesets_deleted),
                                "filesetsUpdated" => Ok(__FieldTag::__filesets_updated),
                                "filesets_updated" => Ok(__FieldTag::__filesets_updated),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ScanStatistics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ScanStatistics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__scanned_file_count => {
                                if !fields.insert(__FieldTag::__scanned_file_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scanned_file_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.scanned_file_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__data_processed_bytes => {
                                if !fields.insert(__FieldTag::__data_processed_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_processed_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.data_processed_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__files_excluded => {
                                if !fields.insert(__FieldTag::__files_excluded) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for files_excluded",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.files_excluded =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__tables_created => {
                                if !fields.insert(__FieldTag::__tables_created) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tables_created",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.tables_created =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__tables_deleted => {
                                if !fields.insert(__FieldTag::__tables_deleted) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tables_deleted",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.tables_deleted =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__tables_updated => {
                                if !fields.insert(__FieldTag::__tables_updated) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tables_updated",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.tables_updated =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__filesets_created => {
                                if !fields.insert(__FieldTag::__filesets_created) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filesets_created",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.filesets_created =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__filesets_deleted => {
                                if !fields.insert(__FieldTag::__filesets_deleted) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filesets_deleted",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.filesets_deleted =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__filesets_updated => {
                                if !fields.insert(__FieldTag::__filesets_updated) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filesets_updated",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.filesets_updated =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ScanStatistics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.scanned_file_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("scannedFileCount", &__With(&self.scanned_file_count))?;
            }
            if !wkt::internal::is_default(&self.data_processed_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("dataProcessedBytes", &__With(&self.data_processed_bytes))?;
            }
            if !wkt::internal::is_default(&self.files_excluded) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("filesExcluded", &__With(&self.files_excluded))?;
            }
            if !wkt::internal::is_default(&self.tables_created) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("tablesCreated", &__With(&self.tables_created))?;
            }
            if !wkt::internal::is_default(&self.tables_deleted) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("tablesDeleted", &__With(&self.tables_deleted))?;
            }
            if !wkt::internal::is_default(&self.tables_updated) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("tablesUpdated", &__With(&self.tables_updated))?;
            }
            if !wkt::internal::is_default(&self.filesets_created) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("filesetsCreated", &__With(&self.filesets_created))?;
            }
            if !wkt::internal::is_default(&self.filesets_deleted) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("filesetsDeleted", &__With(&self.filesets_deleted))?;
            }
            if !wkt::internal::is_default(&self.filesets_updated) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("filesetsUpdated", &__With(&self.filesets_updated))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// DataProfileScan related setting.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileSpec {
    /// Optional. The percentage of the records to be selected from the dataset for
    /// DataScan.
    ///
    /// * Value can range between 0.0 and 100.0 with up to 3 significant decimal
    ///   digits.
    /// * Sampling is not applied if `sampling_percent` is not specified, 0 or
    ///
    pub sampling_percent: f32,

    /// Optional. A filter applied to all rows in a single DataScan job.
    /// The filter needs to be a valid SQL expression for a [WHERE clause in
    /// GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#where_clause).
    ///
    /// Example: col1 >= 0 AND col2 < 10
    pub row_filter: std::string::String,

    /// Optional. Actions to take upon job completion..
    pub post_scan_actions: std::option::Option<crate::model::data_profile_spec::PostScanActions>,

    /// Optional. The fields to include in data profile.
    ///
    /// If not specified, all fields at the time of profile scan job execution are
    /// included, except for ones listed in `exclude_fields`.
    pub include_fields: std::option::Option<crate::model::data_profile_spec::SelectedFields>,

    /// Optional. The fields to exclude from data profile.
    ///
    /// If specified, the fields will be excluded from data profile, regardless of
    /// `include_fields` value.
    pub exclude_fields: std::option::Option<crate::model::data_profile_spec::SelectedFields>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sampling_percent][crate::model::DataProfileSpec::sampling_percent].
    pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.sampling_percent = v.into();
        self
    }

    /// Sets the value of [row_filter][crate::model::DataProfileSpec::row_filter].
    pub fn set_row_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.row_filter = v.into();
        self
    }

    /// Sets the value of [post_scan_actions][crate::model::DataProfileSpec::post_scan_actions].
    pub fn set_post_scan_actions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_spec::PostScanActions>,
    {
        self.post_scan_actions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [post_scan_actions][crate::model::DataProfileSpec::post_scan_actions].
    pub fn set_or_clear_post_scan_actions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_spec::PostScanActions>,
    {
        self.post_scan_actions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [include_fields][crate::model::DataProfileSpec::include_fields].
    pub fn set_include_fields<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_spec::SelectedFields>,
    {
        self.include_fields = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_fields][crate::model::DataProfileSpec::include_fields].
    pub fn set_or_clear_include_fields<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_spec::SelectedFields>,
    {
        self.include_fields = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_fields][crate::model::DataProfileSpec::exclude_fields].
    pub fn set_exclude_fields<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_spec::SelectedFields>,
    {
        self.exclude_fields = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_fields][crate::model::DataProfileSpec::exclude_fields].
    pub fn set_or_clear_exclude_fields<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_spec::SelectedFields>,
    {
        self.exclude_fields = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataProfileSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sampling_percent,
            __row_filter,
            __post_scan_actions,
            __include_fields,
            __exclude_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "samplingPercent" => Ok(__FieldTag::__sampling_percent),
                            "sampling_percent" => Ok(__FieldTag::__sampling_percent),
                            "rowFilter" => Ok(__FieldTag::__row_filter),
                            "row_filter" => Ok(__FieldTag::__row_filter),
                            "postScanActions" => Ok(__FieldTag::__post_scan_actions),
                            "post_scan_actions" => Ok(__FieldTag::__post_scan_actions),
                            "includeFields" => Ok(__FieldTag::__include_fields),
                            "include_fields" => Ok(__FieldTag::__include_fields),
                            "excludeFields" => Ok(__FieldTag::__exclude_fields),
                            "exclude_fields" => Ok(__FieldTag::__exclude_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sampling_percent => {
                            if !fields.insert(__FieldTag::__sampling_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sampling_percent",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sampling_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__row_filter => {
                            if !fields.insert(__FieldTag::__row_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_filter",
                                ));
                            }
                            result.row_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__post_scan_actions => {
                            if !fields.insert(__FieldTag::__post_scan_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_scan_actions",
                                ));
                            }
                            result.post_scan_actions = map.next_value::<std::option::Option<
                                crate::model::data_profile_spec::PostScanActions,
                            >>()?;
                        }
                        __FieldTag::__include_fields => {
                            if !fields.insert(__FieldTag::__include_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_fields",
                                ));
                            }
                            result.include_fields = map.next_value::<std::option::Option<
                                crate::model::data_profile_spec::SelectedFields,
                            >>()?;
                        }
                        __FieldTag::__exclude_fields => {
                            if !fields.insert(__FieldTag::__exclude_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_fields",
                                ));
                            }
                            result.exclude_fields = map.next_value::<std::option::Option<
                                crate::model::data_profile_spec::SelectedFields,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.sampling_percent) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("samplingPercent", &__With(&self.sampling_percent))?;
        }
        if !self.row_filter.is_empty() {
            state.serialize_entry("rowFilter", &self.row_filter)?;
        }
        if self.post_scan_actions.is_some() {
            state.serialize_entry("postScanActions", &self.post_scan_actions)?;
        }
        if self.include_fields.is_some() {
            state.serialize_entry("includeFields", &self.include_fields)?;
        }
        if self.exclude_fields.is_some() {
            state.serialize_entry("excludeFields", &self.exclude_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataProfileSpec].
pub mod data_profile_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of post scan actions of DataProfileScan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PostScanActions {
        /// Optional. If set, results will be exported to the provided BigQuery
        /// table.
        pub bigquery_export:
            std::option::Option<crate::model::data_profile_spec::post_scan_actions::BigQueryExport>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export][crate::model::data_profile_spec::PostScanActions::bigquery_export].
        pub fn set_bigquery_export<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_profile_spec::post_scan_actions::BigQueryExport,
                >,
        {
            self.bigquery_export = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bigquery_export][crate::model::data_profile_spec::PostScanActions::bigquery_export].
        pub fn set_or_clear_bigquery_export<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_profile_spec::post_scan_actions::BigQueryExport,
                >,
        {
            self.bigquery_export = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PostScanActions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec.PostScanActions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PostScanActions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bigquery_export,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PostScanActions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bigqueryExport" => Ok(__FieldTag::__bigquery_export),
                                "bigquery_export" => Ok(__FieldTag::__bigquery_export),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PostScanActions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PostScanActions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bigquery_export => {
                                if !fields.insert(__FieldTag::__bigquery_export) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bigquery_export",
                                    ));
                                }
                                result.bigquery_export = map.next_value::<std::option::Option<crate::model::data_profile_spec::post_scan_actions::BigQueryExport>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PostScanActions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.bigquery_export.is_some() {
                state.serialize_entry("bigqueryExport", &self.bigquery_export)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PostScanActions].
    pub mod post_scan_actions {
        #[allow(unused_imports)]
        use super::*;

        /// The configuration of BigQuery export post scan action.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BigQueryExport {
            /// Optional. The BigQuery table to export DataProfileScan results to.
            /// Format:
            /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            /// or
            /// projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            pub results_table: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExport {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [results_table][crate::model::data_profile_spec::post_scan_actions::BigQueryExport::results_table].
            pub fn set_results_table<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.results_table = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExport {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec.PostScanActions.BigQueryExport"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BigQueryExport {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __results_table,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BigQueryExport")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "resultsTable" => Ok(__FieldTag::__results_table),
                                    "results_table" => Ok(__FieldTag::__results_table),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BigQueryExport;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BigQueryExport")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__results_table => {
                                    if !fields.insert(__FieldTag::__results_table) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for results_table",
                                            ),
                                        );
                                    }
                                    result.results_table = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BigQueryExport {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.results_table.is_empty() {
                    state.serialize_entry("resultsTable", &self.results_table)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// The specification for fields to include or exclude in data profile scan.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SelectedFields {
        /// Optional. Expected input is a list of fully qualified names of fields as
        /// in the schema.
        ///
        /// Only top-level field names for nested fields are supported.
        /// For instance, if 'x' is of nested field type, listing 'x' is supported
        /// but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of
        /// 'x'.
        pub field_names: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SelectedFields {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_names][crate::model::data_profile_spec::SelectedFields::field_names].
        pub fn set_field_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.field_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SelectedFields {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec.SelectedFields"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SelectedFields {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field_names,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SelectedFields")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fieldNames" => Ok(__FieldTag::__field_names),
                                "field_names" => Ok(__FieldTag::__field_names),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SelectedFields;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SelectedFields")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field_names => {
                                if !fields.insert(__FieldTag::__field_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field_names",
                                    ));
                                }
                                result.field_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SelectedFields {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.field_names.is_empty() {
                state.serialize_entry("fieldNames", &self.field_names)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// DataProfileResult defines the output of DataProfileScan. Each field of the
/// table will have field type specific profile result.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileResult {
    /// The count of rows scanned.
    pub row_count: i64,

    /// The profile information per field.
    pub profile: std::option::Option<crate::model::data_profile_result::Profile>,

    /// The data scanned for this result.
    pub scanned_data: std::option::Option<crate::model::ScannedData>,

    /// Output only. The result of post scan actions.
    pub post_scan_actions_result:
        std::option::Option<crate::model::data_profile_result::PostScanActionsResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_count][crate::model::DataProfileResult::row_count].
    pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [profile][crate::model::DataProfileResult::profile].
    pub fn set_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_result::Profile>,
    {
        self.profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile][crate::model::DataProfileResult::profile].
    pub fn set_or_clear_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_result::Profile>,
    {
        self.profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scanned_data][crate::model::DataProfileResult::scanned_data].
    pub fn set_scanned_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScannedData>,
    {
        self.scanned_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scanned_data][crate::model::DataProfileResult::scanned_data].
    pub fn set_or_clear_scanned_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScannedData>,
    {
        self.scanned_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [post_scan_actions_result][crate::model::DataProfileResult::post_scan_actions_result].
    pub fn set_post_scan_actions_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_result::PostScanActionsResult>,
    {
        self.post_scan_actions_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [post_scan_actions_result][crate::model::DataProfileResult::post_scan_actions_result].
    pub fn set_or_clear_post_scan_actions_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_result::PostScanActionsResult>,
    {
        self.post_scan_actions_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataProfileResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __row_count,
            __profile,
            __scanned_data,
            __post_scan_actions_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rowCount" => Ok(__FieldTag::__row_count),
                            "row_count" => Ok(__FieldTag::__row_count),
                            "profile" => Ok(__FieldTag::__profile),
                            "scannedData" => Ok(__FieldTag::__scanned_data),
                            "scanned_data" => Ok(__FieldTag::__scanned_data),
                            "postScanActionsResult" => Ok(__FieldTag::__post_scan_actions_result),
                            "post_scan_actions_result" => {
                                Ok(__FieldTag::__post_scan_actions_result)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__row_count => {
                            if !fields.insert(__FieldTag::__row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__profile => {
                            if !fields.insert(__FieldTag::__profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile",
                                ));
                            }
                            result.profile = map.next_value::<std::option::Option<crate::model::data_profile_result::Profile>>()?
                                ;
                        }
                        __FieldTag::__scanned_data => {
                            if !fields.insert(__FieldTag::__scanned_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scanned_data",
                                ));
                            }
                            result.scanned_data =
                                map.next_value::<std::option::Option<crate::model::ScannedData>>()?;
                        }
                        __FieldTag::__post_scan_actions_result => {
                            if !fields.insert(__FieldTag::__post_scan_actions_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_scan_actions_result",
                                ));
                            }
                            result.post_scan_actions_result = map
                                .next_value::<std::option::Option<
                                    crate::model::data_profile_result::PostScanActionsResult,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowCount", &__With(&self.row_count))?;
        }
        if self.profile.is_some() {
            state.serialize_entry("profile", &self.profile)?;
        }
        if self.scanned_data.is_some() {
            state.serialize_entry("scannedData", &self.scanned_data)?;
        }
        if self.post_scan_actions_result.is_some() {
            state.serialize_entry("postScanActionsResult", &self.post_scan_actions_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataProfileResult].
pub mod data_profile_result {
    #[allow(unused_imports)]
    use super::*;

    /// Contains name, type, mode and field type specific profile information.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Profile {
        /// List of fields with structural and profile information for each field.
        pub fields: std::vec::Vec<crate::model::data_profile_result::profile::Field>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Profile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [fields][crate::model::data_profile_result::Profile::fields].
        pub fn set_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_result::profile::Field>,
        {
            use std::iter::Iterator;
            self.fields = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Profile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Profile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __fields,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Profile")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fields" => Ok(__FieldTag::__fields),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Profile;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Profile")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__fields => {
                                if !fields.insert(__FieldTag::__fields) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fields",
                                    ));
                                }
                                result.fields = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::data_profile_result::profile::Field,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Profile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.fields.is_empty() {
                state.serialize_entry("fields", &self.fields)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Profile].
    pub mod profile {
        #[allow(unused_imports)]
        use super::*;

        /// A field within a table.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Field {
            /// The name of the field.
            pub name: std::string::String,

            /// The data type retrieved from the schema of the data source. For
            /// instance, for a BigQuery native table, it is the [BigQuery Table
            /// Schema](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#tablefieldschema).
            /// For a Dataplex Entity, it is the [Entity
            /// Schema](https://cloud.google.com/dataplex/docs/reference/rpc/google.cloud.dataplex.v1#type_3).
            pub r#type: std::string::String,

            /// The mode of the field. Possible values include:
            ///
            /// * REQUIRED, if it is a required field.
            /// * NULLABLE, if it is an optional field.
            /// * REPEATED, if it is a repeated field.
            pub mode: std::string::String,

            /// Profile information for the corresponding field.
            pub profile:
                std::option::Option<crate::model::data_profile_result::profile::field::ProfileInfo>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Field {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::data_profile_result::profile::Field::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::data_profile_result::profile::Field::type].
            pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [mode][crate::model::data_profile_result::profile::Field::mode].
            pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.mode = v.into();
                self
            }

            /// Sets the value of [profile][crate::model::data_profile_result::profile::Field::profile].
            pub fn set_profile<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_profile_result::profile::field::ProfileInfo,
                    >,
            {
                self.profile = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [profile][crate::model::data_profile_result::profile::Field::profile].
            pub fn set_or_clear_profile<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_profile_result::profile::field::ProfileInfo,
                    >,
            {
                self.profile = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Field {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __name,
                    __type,
                    __mode,
                    __profile,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Field")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "name" => Ok(__FieldTag::__name),
                                    "type" => Ok(__FieldTag::__type),
                                    "mode" => Ok(__FieldTag::__mode),
                                    "profile" => Ok(__FieldTag::__profile),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Field")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__mode => {
                                    if !fields.insert(__FieldTag::__mode) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for mode"),
                                        );
                                    }
                                    result.mode = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__profile => {
                                    if !fields.insert(__FieldTag::__profile) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for profile",
                                            ),
                                        );
                                    }
                                    result.profile = map.next_value::<std::option::Option<crate::model::data_profile_result::profile::field::ProfileInfo>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Field {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self.r#type.is_empty() {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !self.mode.is_empty() {
                    state.serialize_entry("mode", &self.mode)?;
                }
                if self.profile.is_some() {
                    state.serialize_entry("profile", &self.profile)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Field].
        pub mod field {
            #[allow(unused_imports)]
            use super::*;

            /// The profile information for each field type.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ProfileInfo {
                /// Ratio of rows with null value against total scanned rows.
                pub null_ratio: f64,

                /// Ratio of rows with distinct values against total scanned rows.
                /// Not available for complex non-groupable field type, including RECORD,
                /// ARRAY, GEOGRAPHY, and JSON, as well as fields with REPEATABLE mode.
                pub distinct_ratio: f64,

                /// The list of top N non-null values, frequency and ratio with which
                /// they occur in the scanned data. N is 10 or equal to the number of
                /// distinct values in the field, whichever is smaller. Not available for
                /// complex non-groupable field type, including RECORD, ARRAY, GEOGRAPHY,
                /// and JSON, as well as fields with REPEATABLE mode.
                pub top_n_values: std::vec::Vec<
                    crate::model::data_profile_result::profile::field::profile_info::TopNValue,
                >,

                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                pub field_info: std::option::Option<
                    crate::model::data_profile_result::profile::field::profile_info::FieldInfo,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ProfileInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [null_ratio][crate::model::data_profile_result::profile::field::ProfileInfo::null_ratio].
                pub fn set_null_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                    self.null_ratio = v.into();
                    self
                }

                /// Sets the value of [distinct_ratio][crate::model::data_profile_result::profile::field::ProfileInfo::distinct_ratio].
                pub fn set_distinct_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                    self.distinct_ratio = v.into();
                    self
                }

                /// Sets the value of [top_n_values][crate::model::data_profile_result::profile::field::ProfileInfo::top_n_values].
                pub fn set_top_n_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::data_profile_result::profile::field::profile_info::TopNValue>
                {
                    use std::iter::Iterator;
                    self.top_n_values = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info].
                ///
                /// Note that all the setters affecting `field_info` are mutually
                /// exclusive.
                pub fn set_field_info<T: std::convert::Into<std::option::Option<crate::model::data_profile_result::profile::field::profile_info::FieldInfo>>>(mut self, v: T) -> Self
                {
                    self.field_info = v.into();
                    self
                }

                /// The value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// if it holds a `StringProfile`, `None` if the field is not set or
                /// holds a different branch.
                pub fn string_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo>>{
                    #[allow(unreachable_patterns)]
                    self.field_info.as_ref().and_then(|v| match v {
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::StringProfile(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// to hold a `StringProfile`.
                ///
                /// Note that all the setters affecting `field_info` are
                /// mutually exclusive.
                pub fn set_string_profile<T: std::convert::Into<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo>>>(mut self, v: T) -> Self{
                    self.field_info = std::option::Option::Some(
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::StringProfile(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// if it holds a `IntegerProfile`, `None` if the field is not set or
                /// holds a different branch.
                pub fn integer_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo>>{
                    #[allow(unreachable_patterns)]
                    self.field_info.as_ref().and_then(|v| match v {
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::IntegerProfile(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// to hold a `IntegerProfile`.
                ///
                /// Note that all the setters affecting `field_info` are
                /// mutually exclusive.
                pub fn set_integer_profile<T: std::convert::Into<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo>>>(mut self, v: T) -> Self{
                    self.field_info = std::option::Option::Some(
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::IntegerProfile(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// if it holds a `DoubleProfile`, `None` if the field is not set or
                /// holds a different branch.
                pub fn double_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo>>{
                    #[allow(unreachable_patterns)]
                    self.field_info.as_ref().and_then(|v| match v {
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::DoubleProfile(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// to hold a `DoubleProfile`.
                ///
                /// Note that all the setters affecting `field_info` are
                /// mutually exclusive.
                pub fn set_double_profile<T: std::convert::Into<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo>>>(mut self, v: T) -> Self{
                    self.field_info = std::option::Option::Some(
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::DoubleProfile(
                            v.into()
                        )
                    );
                    self
                }
            }

            impl wkt::message::Message for ProfileInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ProfileInfo {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __null_ratio,
                        __distinct_ratio,
                        __top_n_values,
                        __string_profile,
                        __integer_profile,
                        __double_profile,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ProfileInfo")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "nullRatio" => Ok(__FieldTag::__null_ratio),
                                        "null_ratio" => Ok(__FieldTag::__null_ratio),
                                        "distinctRatio" => Ok(__FieldTag::__distinct_ratio),
                                        "distinct_ratio" => Ok(__FieldTag::__distinct_ratio),
                                        "topNValues" => Ok(__FieldTag::__top_n_values),
                                        "top_n_values" => Ok(__FieldTag::__top_n_values),
                                        "stringProfile" => Ok(__FieldTag::__string_profile),
                                        "string_profile" => Ok(__FieldTag::__string_profile),
                                        "integerProfile" => Ok(__FieldTag::__integer_profile),
                                        "integer_profile" => Ok(__FieldTag::__integer_profile),
                                        "doubleProfile" => Ok(__FieldTag::__double_profile),
                                        "double_profile" => Ok(__FieldTag::__double_profile),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ProfileInfo;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ProfileInfo")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__null_ratio => {
                                        if !fields.insert(__FieldTag::__null_ratio) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for null_ratio",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.null_ratio =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__distinct_ratio => {
                                        if !fields.insert(__FieldTag::__distinct_ratio) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for distinct_ratio",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.distinct_ratio =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__top_n_values => {
                                        if !fields.insert(__FieldTag::__top_n_values) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for top_n_values",
                                                ),
                                            );
                                        }
                                        result.top_n_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::data_profile_result::profile::field::profile_info::TopNValue>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__string_profile => {
                                        if !fields.insert(__FieldTag::__string_profile) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for string_profile",
                                                ),
                                            );
                                        }
                                        if result.field_info.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `field_info`, a oneof with full ID .google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.string_profile, latest field was stringProfile",
                                                ),
                                            );
                                        }
                                        result.field_info = std::option::Option::Some(
                                            crate::model::data_profile_result::profile::field::profile_info::FieldInfo::StringProfile(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__integer_profile => {
                                        if !fields.insert(__FieldTag::__integer_profile) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for integer_profile",
                                                ),
                                            );
                                        }
                                        if result.field_info.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `field_info`, a oneof with full ID .google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.integer_profile, latest field was integerProfile",
                                                ),
                                            );
                                        }
                                        result.field_info = std::option::Option::Some(
                                            crate::model::data_profile_result::profile::field::profile_info::FieldInfo::IntegerProfile(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__double_profile => {
                                        if !fields.insert(__FieldTag::__double_profile) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for double_profile",
                                                ),
                                            );
                                        }
                                        if result.field_info.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `field_info`, a oneof with full ID .google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.double_profile, latest field was doubleProfile",
                                                ),
                                            );
                                        }
                                        result.field_info = std::option::Option::Some(
                                            crate::model::data_profile_result::profile::field::profile_info::FieldInfo::DoubleProfile(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ProfileInfo {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.null_ratio) {
                        struct __With<'a>(&'a f64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("nullRatio", &__With(&self.null_ratio))?;
                    }
                    if !wkt::internal::is_default(&self.distinct_ratio) {
                        struct __With<'a>(&'a f64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("distinctRatio", &__With(&self.distinct_ratio))?;
                    }
                    if !self.top_n_values.is_empty() {
                        state.serialize_entry("topNValues", &self.top_n_values)?;
                    }
                    if let Some(value) = self.string_profile() {
                        state.serialize_entry("stringProfile", value)?;
                    }
                    if let Some(value) = self.integer_profile() {
                        state.serialize_entry("integerProfile", value)?;
                    }
                    if let Some(value) = self.double_profile() {
                        state.serialize_entry("doubleProfile", value)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [ProfileInfo].
            pub mod profile_info {
                #[allow(unused_imports)]
                use super::*;

                /// The profile information for a string type field.
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct StringFieldInfo {
                    /// Minimum length of non-null values in the scanned data.
                    pub min_length: i64,

                    /// Maximum length of non-null values in the scanned data.
                    pub max_length: i64,

                    /// Average length of non-null values in the scanned data.
                    pub average_length: f64,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl StringFieldInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [min_length][crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo::min_length].
                    pub fn set_min_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.min_length = v.into();
                        self
                    }

                    /// Sets the value of [max_length][crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo::max_length].
                    pub fn set_max_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.max_length = v.into();
                        self
                    }

                    /// Sets the value of [average_length][crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo::average_length].
                    pub fn set_average_length<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.average_length = v.into();
                        self
                    }
                }

                impl wkt::message::Message for StringFieldInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.StringFieldInfo"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for StringFieldInfo {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __min_length,
                            __max_length,
                            __average_length,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for StringFieldInfo")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "minLength" => Ok(__FieldTag::__min_length),
                                            "min_length" => Ok(__FieldTag::__min_length),
                                            "maxLength" => Ok(__FieldTag::__max_length),
                                            "max_length" => Ok(__FieldTag::__max_length),
                                            "averageLength" => Ok(__FieldTag::__average_length),
                                            "average_length" => Ok(__FieldTag::__average_length),
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = StringFieldInfo;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct StringFieldInfo")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__min_length => {
                                            if !fields.insert(__FieldTag::__min_length) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for min_length",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<i64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::I64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.min_length =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__max_length => {
                                            if !fields.insert(__FieldTag::__max_length) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for max_length",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<i64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::I64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.max_length =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__average_length => {
                                            if !fields.insert(__FieldTag::__average_length) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for average_length",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.average_length =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for StringFieldInfo {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !wkt::internal::is_default(&self.min_length) {
                            struct __With<'a>(&'a i64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::I64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("minLength", &__With(&self.min_length))?;
                        }
                        if !wkt::internal::is_default(&self.max_length) {
                            struct __With<'a>(&'a i64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::I64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("maxLength", &__With(&self.max_length))?;
                        }
                        if !wkt::internal::is_default(&self.average_length) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state
                                .serialize_entry("averageLength", &__With(&self.average_length))?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// The profile information for an integer type field.
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct IntegerFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    pub average: f64,

                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    pub standard_deviation: f64,

                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    pub min: i64,

                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of approximate
                    /// quartile values for the scanned data, occurring in order Q1,
                    /// median, Q3.
                    pub quartiles: std::vec::Vec<i64>,

                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    pub max: i64,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl IntegerFieldInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [average][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::average].
                    pub fn set_average<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.average = v.into();
                        self
                    }

                    /// Sets the value of [standard_deviation][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::standard_deviation].
                    pub fn set_standard_deviation<T: std::convert::Into<f64>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.standard_deviation = v.into();
                        self
                    }

                    /// Sets the value of [min][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::min].
                    pub fn set_min<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.min = v.into();
                        self
                    }

                    /// Sets the value of [quartiles][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::quartiles].
                    pub fn set_quartiles<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<i64>,
                    {
                        use std::iter::Iterator;
                        self.quartiles = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [max][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::max].
                    pub fn set_max<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.max = v.into();
                        self
                    }
                }

                impl wkt::message::Message for IntegerFieldInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.IntegerFieldInfo"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for IntegerFieldInfo {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __average,
                            __standard_deviation,
                            __min,
                            __quartiles,
                            __max,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for IntegerFieldInfo")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "average" => Ok(__FieldTag::__average),
                                            "standardDeviation" => {
                                                Ok(__FieldTag::__standard_deviation)
                                            }
                                            "standard_deviation" => {
                                                Ok(__FieldTag::__standard_deviation)
                                            }
                                            "min" => Ok(__FieldTag::__min),
                                            "quartiles" => Ok(__FieldTag::__quartiles),
                                            "max" => Ok(__FieldTag::__max),
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = IntegerFieldInfo;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct IntegerFieldInfo")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__average => {
                                            if !fields.insert(__FieldTag::__average) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for average",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.average =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__standard_deviation => {
                                            if !fields.insert(__FieldTag::__standard_deviation) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for standard_deviation",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.standard_deviation =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__min => {
                                            if !fields.insert(__FieldTag::__min) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for min",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<i64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::I64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.min =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__quartiles => {
                                            if !fields.insert(__FieldTag::__quartiles) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for quartiles",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<
                                                            std::vec::Vec<wkt::internal::I64>,
                                                        >,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.quartiles =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__max => {
                                            if !fields.insert(__FieldTag::__max) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for max",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<i64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::I64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.max =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for IntegerFieldInfo {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !wkt::internal::is_default(&self.average) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("average", &__With(&self.average))?;
                        }
                        if !wkt::internal::is_default(&self.standard_deviation) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry(
                                "standardDeviation",
                                &__With(&self.standard_deviation),
                            )?;
                        }
                        if !wkt::internal::is_default(&self.min) {
                            struct __With<'a>(&'a i64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::I64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("min", &__With(&self.min))?;
                        }
                        if !self.quartiles.is_empty() {
                            struct __With<'a>(&'a std::vec::Vec<i64>);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("quartiles", &__With(&self.quartiles))?;
                        }
                        if !wkt::internal::is_default(&self.max) {
                            struct __With<'a>(&'a i64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::I64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("max", &__With(&self.max))?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// The profile information for a double type field.
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct DoubleFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    pub average: f64,

                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    pub standard_deviation: f64,

                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    pub min: f64,

                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of quartile
                    /// values for the scanned data, occurring in order Q1, median, Q3.
                    pub quartiles: std::vec::Vec<f64>,

                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    pub max: f64,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl DoubleFieldInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [average][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::average].
                    pub fn set_average<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.average = v.into();
                        self
                    }

                    /// Sets the value of [standard_deviation][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::standard_deviation].
                    pub fn set_standard_deviation<T: std::convert::Into<f64>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.standard_deviation = v.into();
                        self
                    }

                    /// Sets the value of [min][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::min].
                    pub fn set_min<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.min = v.into();
                        self
                    }

                    /// Sets the value of [quartiles][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::quartiles].
                    pub fn set_quartiles<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<f64>,
                    {
                        use std::iter::Iterator;
                        self.quartiles = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [max][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::max].
                    pub fn set_max<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.max = v.into();
                        self
                    }
                }

                impl wkt::message::Message for DoubleFieldInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.DoubleFieldInfo"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for DoubleFieldInfo {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __average,
                            __standard_deviation,
                            __min,
                            __quartiles,
                            __max,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for DoubleFieldInfo")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "average" => Ok(__FieldTag::__average),
                                            "standardDeviation" => {
                                                Ok(__FieldTag::__standard_deviation)
                                            }
                                            "standard_deviation" => {
                                                Ok(__FieldTag::__standard_deviation)
                                            }
                                            "min" => Ok(__FieldTag::__min),
                                            "quartiles" => Ok(__FieldTag::__quartiles),
                                            "max" => Ok(__FieldTag::__max),
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = DoubleFieldInfo;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct DoubleFieldInfo")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__average => {
                                            if !fields.insert(__FieldTag::__average) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for average",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.average =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__standard_deviation => {
                                            if !fields.insert(__FieldTag::__standard_deviation) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for standard_deviation",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.standard_deviation =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__min => {
                                            if !fields.insert(__FieldTag::__min) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for min",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.min =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__quartiles => {
                                            if !fields.insert(__FieldTag::__quartiles) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for quartiles",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<
                                                            std::vec::Vec<wkt::internal::F64>,
                                                        >,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.quartiles =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__max => {
                                            if !fields.insert(__FieldTag::__max) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for max",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.max =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for DoubleFieldInfo {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !wkt::internal::is_default(&self.average) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("average", &__With(&self.average))?;
                        }
                        if !wkt::internal::is_default(&self.standard_deviation) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry(
                                "standardDeviation",
                                &__With(&self.standard_deviation),
                            )?;
                        }
                        if !wkt::internal::is_default(&self.min) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("min", &__With(&self.min))?;
                        }
                        if !self.quartiles.is_empty() {
                            struct __With<'a>(&'a std::vec::Vec<f64>);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("quartiles", &__With(&self.quartiles))?;
                        }
                        if !wkt::internal::is_default(&self.max) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("max", &__With(&self.max))?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// Top N non-null values in the scanned data.
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct TopNValue {
                    /// String value of a top N non-null value.
                    pub value: std::string::String,

                    /// Count of the corresponding value in the scanned data.
                    pub count: i64,

                    /// Ratio of the corresponding value in the field against the total
                    /// number of rows in the scanned data.
                    pub ratio: f64,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl TopNValue {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [value][crate::model::data_profile_result::profile::field::profile_info::TopNValue::value].
                    pub fn set_value<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.value = v.into();
                        self
                    }

                    /// Sets the value of [count][crate::model::data_profile_result::profile::field::profile_info::TopNValue::count].
                    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.count = v.into();
                        self
                    }

                    /// Sets the value of [ratio][crate::model::data_profile_result::profile::field::profile_info::TopNValue::ratio].
                    pub fn set_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.ratio = v.into();
                        self
                    }
                }

                impl wkt::message::Message for TopNValue {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.TopNValue"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for TopNValue {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __value,
                            __count,
                            __ratio,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for TopNValue")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "value" => Ok(__FieldTag::__value),
                                            "count" => Ok(__FieldTag::__count),
                                            "ratio" => Ok(__FieldTag::__ratio),
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = TopNValue;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct TopNValue")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__value => {
                                            if !fields.insert(__FieldTag::__value) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for value",
                                                    ),
                                                );
                                            }
                                            result.value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::__count => {
                                            if !fields.insert(__FieldTag::__count) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for count",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<i64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::I64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.count =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__ratio => {
                                            if !fields.insert(__FieldTag::__ratio) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for ratio",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.ratio =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for TopNValue {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !self.value.is_empty() {
                            state.serialize_entry("value", &self.value)?;
                        }
                        if !wkt::internal::is_default(&self.count) {
                            struct __With<'a>(&'a i64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::I64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("count", &__With(&self.count))?;
                        }
                        if !wkt::internal::is_default(&self.ratio) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("ratio", &__With(&self.ratio))?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum FieldInfo {
                    /// String type field information.
                    StringProfile(std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo>),
                    /// Integer type field information.
                    IntegerProfile(std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo>),
                    /// Double type field information.
                    DoubleProfile(std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo>),
                }
            }
        }
    }

    /// The result of post scan actions of DataProfileScan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PostScanActionsResult {
        /// Output only. The result of BigQuery export post scan action.
        pub bigquery_export_result: std::option::Option<
            crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActionsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export_result][crate::model::data_profile_result::PostScanActionsResult::bigquery_export_result].
        pub fn set_bigquery_export_result<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult>
        {
            self.bigquery_export_result = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bigquery_export_result][crate::model::data_profile_result::PostScanActionsResult::bigquery_export_result].
        pub fn set_or_clear_bigquery_export_result<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult>
        {
            self.bigquery_export_result = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PostScanActionsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.PostScanActionsResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PostScanActionsResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bigquery_export_result,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PostScanActionsResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bigqueryExportResult" => Ok(__FieldTag::__bigquery_export_result),
                                "bigquery_export_result" => {
                                    Ok(__FieldTag::__bigquery_export_result)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PostScanActionsResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PostScanActionsResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bigquery_export_result => {
                                if !fields.insert(__FieldTag::__bigquery_export_result) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bigquery_export_result",
                                    ));
                                }
                                result.bigquery_export_result = map.next_value::<std::option::Option<crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PostScanActionsResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.bigquery_export_result.is_some() {
                state.serialize_entry("bigqueryExportResult", &self.bigquery_export_result)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PostScanActionsResult].
    pub mod post_scan_actions_result {
        #[allow(unused_imports)]
        use super::*;

        /// The result of BigQuery export post scan action.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BigQueryExportResult {

            /// Output only. Execution state for the BigQuery exporting.
            pub state: crate::model::data_profile_result::post_scan_actions_result::big_query_export_result::State,

            /// Output only. Additional information about the BigQuery exporting.
            pub message: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExportResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult::state].
            pub fn set_state<T: std::convert::Into<crate::model::data_profile_result::post_scan_actions_result::big_query_export_result::State>>(mut self, v: T) -> Self{
                self.state = v.into();
                self
            }

            /// Sets the value of [message][crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult::message].
            pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.message = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExportResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.PostScanActionsResult.BigQueryExportResult"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BigQueryExportResult {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __state,
                    __message,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BigQueryExportResult")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "state" => Ok(__FieldTag::__state),
                                    "message" => Ok(__FieldTag::__message),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BigQueryExportResult;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BigQueryExportResult")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__state => {
                                    if !fields.insert(__FieldTag::__state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for state"),
                                        );
                                    }
                                    result.state = map.next_value::<std::option::Option<crate::model::data_profile_result::post_scan_actions_result::big_query_export_result::State>>()?.unwrap_or_default();
                                }
                                __FieldTag::__message => {
                                    if !fields.insert(__FieldTag::__message) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for message",
                                            ),
                                        );
                                    }
                                    result.message = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BigQueryExportResult {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.state) {
                    state.serialize_entry("state", &self.state)?;
                }
                if !self.message.is_empty() {
                    state.serialize_entry("message", &self.message)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BigQueryExportResult].
        pub mod big_query_export_result {
            #[allow(unused_imports)]
            use super::*;

            /// Execution state for the exporting.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified,
                /// The exporting completed successfully.
                Succeeded,
                /// The exporting is no longer running due to an error.
                Failed,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [State::value] or
                /// [State::name].
                UnknownValue(state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl State {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Succeeded => std::option::Option::Some(1),
                        Self::Failed => std::option::Option::Some(2),
                        Self::Skipped => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                        Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                        Self::Failed => std::option::Option::Some("FAILED"),
                        Self::Skipped => std::option::Option::Some("SKIPPED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for State {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for State {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for State {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Succeeded,
                        2 => Self::Failed,
                        3 => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for State {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATE_UNSPECIFIED" => Self::Unspecified,
                        "SUCCEEDED" => Self::Succeeded,
                        "FAILED" => Self::Failed,
                        "SKIPPED" => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for State {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Succeeded => serializer.serialize_i32(1),
                        Self::Failed => serializer.serialize_i32(2),
                        Self::Skipped => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for State {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                        ".google.cloud.dataplex.v1.DataProfileResult.PostScanActionsResult.BigQueryExportResult.State"))
                }
            }
        }
    }
}

/// DataQualityScan related setting.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualitySpec {
    /// Required. The list of rules to evaluate against a data source. At least one
    /// rule is required.
    pub rules: std::vec::Vec<crate::model::DataQualityRule>,

    /// Optional. The percentage of the records to be selected from the dataset for
    /// DataScan.
    ///
    /// * Value can range between 0.0 and 100.0 with up to 3 significant decimal
    ///   digits.
    /// * Sampling is not applied if `sampling_percent` is not specified, 0 or
    ///
    pub sampling_percent: f32,

    /// Optional. A filter applied to all rows in a single DataScan job.
    /// The filter needs to be a valid SQL expression for a [WHERE clause in
    /// GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#where_clause).
    ///
    /// Example: col1 >= 0 AND col2 < 10
    pub row_filter: std::string::String,

    /// Optional. Actions to take upon job completion.
    pub post_scan_actions: std::option::Option<crate::model::data_quality_spec::PostScanActions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rules][crate::model::DataQualitySpec::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sampling_percent][crate::model::DataQualitySpec::sampling_percent].
    pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.sampling_percent = v.into();
        self
    }

    /// Sets the value of [row_filter][crate::model::DataQualitySpec::row_filter].
    pub fn set_row_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.row_filter = v.into();
        self
    }

    /// Sets the value of [post_scan_actions][crate::model::DataQualitySpec::post_scan_actions].
    pub fn set_post_scan_actions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_quality_spec::PostScanActions>,
    {
        self.post_scan_actions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [post_scan_actions][crate::model::DataQualitySpec::post_scan_actions].
    pub fn set_or_clear_post_scan_actions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_quality_spec::PostScanActions>,
    {
        self.post_scan_actions = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualitySpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rules,
            __sampling_percent,
            __row_filter,
            __post_scan_actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualitySpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rules" => Ok(__FieldTag::__rules),
                            "samplingPercent" => Ok(__FieldTag::__sampling_percent),
                            "sampling_percent" => Ok(__FieldTag::__sampling_percent),
                            "rowFilter" => Ok(__FieldTag::__row_filter),
                            "row_filter" => Ok(__FieldTag::__row_filter),
                            "postScanActions" => Ok(__FieldTag::__post_scan_actions),
                            "post_scan_actions" => Ok(__FieldTag::__post_scan_actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualitySpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualitySpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataQualityRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sampling_percent => {
                            if !fields.insert(__FieldTag::__sampling_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sampling_percent",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sampling_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__row_filter => {
                            if !fields.insert(__FieldTag::__row_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_filter",
                                ));
                            }
                            result.row_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__post_scan_actions => {
                            if !fields.insert(__FieldTag::__post_scan_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_scan_actions",
                                ));
                            }
                            result.post_scan_actions = map.next_value::<std::option::Option<
                                crate::model::data_quality_spec::PostScanActions,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualitySpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !wkt::internal::is_default(&self.sampling_percent) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("samplingPercent", &__With(&self.sampling_percent))?;
        }
        if !self.row_filter.is_empty() {
            state.serialize_entry("rowFilter", &self.row_filter)?;
        }
        if self.post_scan_actions.is_some() {
            state.serialize_entry("postScanActions", &self.post_scan_actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataQualitySpec].
pub mod data_quality_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of post scan actions of DataQualityScan.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PostScanActions {
        /// Optional. If set, results will be exported to the provided BigQuery
        /// table.
        pub bigquery_export:
            std::option::Option<crate::model::data_quality_spec::post_scan_actions::BigQueryExport>,

        /// Optional. If set, results will be sent to the provided notification
        /// receipts upon triggers.
        pub notification_report: std::option::Option<
            crate::model::data_quality_spec::post_scan_actions::NotificationReport,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export][crate::model::data_quality_spec::PostScanActions::bigquery_export].
        pub fn set_bigquery_export<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_quality_spec::post_scan_actions::BigQueryExport,
                >,
        {
            self.bigquery_export = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bigquery_export][crate::model::data_quality_spec::PostScanActions::bigquery_export].
        pub fn set_or_clear_bigquery_export<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_quality_spec::post_scan_actions::BigQueryExport,
                >,
        {
            self.bigquery_export = v.map(|x| x.into());
            self
        }

        /// Sets the value of [notification_report][crate::model::data_quality_spec::PostScanActions::notification_report].
        pub fn set_notification_report<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_quality_spec::post_scan_actions::NotificationReport,
                >,
        {
            self.notification_report = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [notification_report][crate::model::data_quality_spec::PostScanActions::notification_report].
        pub fn set_or_clear_notification_report<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_quality_spec::post_scan_actions::NotificationReport,
                >,
        {
            self.notification_report = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PostScanActions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PostScanActions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bigquery_export,
                __notification_report,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PostScanActions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bigqueryExport" => Ok(__FieldTag::__bigquery_export),
                                "bigquery_export" => Ok(__FieldTag::__bigquery_export),
                                "notificationReport" => Ok(__FieldTag::__notification_report),
                                "notification_report" => Ok(__FieldTag::__notification_report),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PostScanActions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PostScanActions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bigquery_export => {
                                if !fields.insert(__FieldTag::__bigquery_export) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bigquery_export",
                                    ));
                                }
                                result.bigquery_export = map.next_value::<std::option::Option<crate::model::data_quality_spec::post_scan_actions::BigQueryExport>>()?
                                    ;
                            }
                            __FieldTag::__notification_report => {
                                if !fields.insert(__FieldTag::__notification_report) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for notification_report",
                                    ));
                                }
                                result.notification_report = map.next_value::<std::option::Option<crate::model::data_quality_spec::post_scan_actions::NotificationReport>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PostScanActions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.bigquery_export.is_some() {
                state.serialize_entry("bigqueryExport", &self.bigquery_export)?;
            }
            if self.notification_report.is_some() {
                state.serialize_entry("notificationReport", &self.notification_report)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PostScanActions].
    pub mod post_scan_actions {
        #[allow(unused_imports)]
        use super::*;

        /// The configuration of BigQuery export post scan action.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BigQueryExport {
            /// Optional. The BigQuery table to export DataQualityScan results to.
            /// Format:
            /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            /// or
            /// projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            pub results_table: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExport {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [results_table][crate::model::data_quality_spec::post_scan_actions::BigQueryExport::results_table].
            pub fn set_results_table<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.results_table = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExport {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.BigQueryExport"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BigQueryExport {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __results_table,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BigQueryExport")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "resultsTable" => Ok(__FieldTag::__results_table),
                                    "results_table" => Ok(__FieldTag::__results_table),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BigQueryExport;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BigQueryExport")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__results_table => {
                                    if !fields.insert(__FieldTag::__results_table) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for results_table",
                                            ),
                                        );
                                    }
                                    result.results_table = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BigQueryExport {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.results_table.is_empty() {
                    state.serialize_entry("resultsTable", &self.results_table)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The individuals or groups who are designated to receive notifications
        /// upon triggers.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Recipients {
            /// Optional. The email recipients who will receive the DataQualityScan
            /// results report.
            pub emails: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Recipients {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [emails][crate::model::data_quality_spec::post_scan_actions::Recipients::emails].
            pub fn set_emails<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.emails = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Recipients {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.Recipients"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Recipients {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __emails,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Recipients")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "emails" => Ok(__FieldTag::__emails),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Recipients;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Recipients")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__emails => {
                                    if !fields.insert(__FieldTag::__emails) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for emails"),
                                        );
                                    }
                                    result.emails = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Recipients {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.emails.is_empty() {
                    state.serialize_entry("emails", &self.emails)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// This trigger is triggered when the DQ score in the job result is less
        /// than a specified input score.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ScoreThresholdTrigger {
            /// Optional. The score range is in [0,100].
            pub score_threshold: f32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ScoreThresholdTrigger {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [score_threshold][crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger::score_threshold].
            pub fn set_score_threshold<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.score_threshold = v.into();
                self
            }
        }

        impl wkt::message::Message for ScoreThresholdTrigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.ScoreThresholdTrigger"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ScoreThresholdTrigger {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __score_threshold,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ScoreThresholdTrigger")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "scoreThreshold" => Ok(__FieldTag::__score_threshold),
                                    "score_threshold" => Ok(__FieldTag::__score_threshold),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ScoreThresholdTrigger;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ScoreThresholdTrigger")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__score_threshold => {
                                    if !fields.insert(__FieldTag::__score_threshold) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for score_threshold",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.score_threshold =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ScoreThresholdTrigger {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.score_threshold) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("scoreThreshold", &__With(&self.score_threshold))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// This trigger is triggered when the scan job itself fails, regardless of
        /// the result.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JobFailureTrigger {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JobFailureTrigger {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for JobFailureTrigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.JobFailureTrigger"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JobFailureTrigger {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JobFailureTrigger")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JobFailureTrigger;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JobFailureTrigger")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JobFailureTrigger {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// This trigger is triggered whenever a scan job run ends, regardless
        /// of the result.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JobEndTrigger {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JobEndTrigger {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for JobEndTrigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.JobEndTrigger"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JobEndTrigger {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JobEndTrigger")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JobEndTrigger;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JobEndTrigger")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JobEndTrigger {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The configuration of notification report post scan action.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NotificationReport {
            /// Required. The recipients who will receive the notification report.
            pub recipients:
                std::option::Option<crate::model::data_quality_spec::post_scan_actions::Recipients>,

            /// Optional. If set, report will be sent when score threshold is met.
            pub score_threshold_trigger: std::option::Option<
                crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger,
            >,

            /// Optional. If set, report will be sent when a scan job fails.
            pub job_failure_trigger: std::option::Option<
                crate::model::data_quality_spec::post_scan_actions::JobFailureTrigger,
            >,

            /// Optional. If set, report will be sent when a scan job ends.
            pub job_end_trigger: std::option::Option<
                crate::model::data_quality_spec::post_scan_actions::JobEndTrigger,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NotificationReport {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [recipients][crate::model::data_quality_spec::post_scan_actions::NotificationReport::recipients].
            pub fn set_recipients<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::Recipients,
                    >,
            {
                self.recipients = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [recipients][crate::model::data_quality_spec::post_scan_actions::NotificationReport::recipients].
            pub fn set_or_clear_recipients<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::Recipients,
                    >,
            {
                self.recipients = v.map(|x| x.into());
                self
            }

            /// Sets the value of [score_threshold_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::score_threshold_trigger].
            pub fn set_score_threshold_trigger<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger,
                    >,
            {
                self.score_threshold_trigger = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [score_threshold_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::score_threshold_trigger].
            pub fn set_or_clear_score_threshold_trigger<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger,
                    >,
            {
                self.score_threshold_trigger = v.map(|x| x.into());
                self
            }

            /// Sets the value of [job_failure_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::job_failure_trigger].
            pub fn set_job_failure_trigger<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::JobFailureTrigger,
                    >,
            {
                self.job_failure_trigger = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [job_failure_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::job_failure_trigger].
            pub fn set_or_clear_job_failure_trigger<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::JobFailureTrigger,
                    >,
            {
                self.job_failure_trigger = v.map(|x| x.into());
                self
            }

            /// Sets the value of [job_end_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::job_end_trigger].
            pub fn set_job_end_trigger<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::JobEndTrigger,
                    >,
            {
                self.job_end_trigger = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [job_end_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::job_end_trigger].
            pub fn set_or_clear_job_end_trigger<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::data_quality_spec::post_scan_actions::JobEndTrigger,
                    >,
            {
                self.job_end_trigger = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for NotificationReport {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.NotificationReport"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for NotificationReport {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __recipients,
                    __score_threshold_trigger,
                    __job_failure_trigger,
                    __job_end_trigger,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for NotificationReport")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "recipients" => Ok(__FieldTag::__recipients),
                                    "scoreThresholdTrigger" => {
                                        Ok(__FieldTag::__score_threshold_trigger)
                                    }
                                    "score_threshold_trigger" => {
                                        Ok(__FieldTag::__score_threshold_trigger)
                                    }
                                    "jobFailureTrigger" => Ok(__FieldTag::__job_failure_trigger),
                                    "job_failure_trigger" => Ok(__FieldTag::__job_failure_trigger),
                                    "jobEndTrigger" => Ok(__FieldTag::__job_end_trigger),
                                    "job_end_trigger" => Ok(__FieldTag::__job_end_trigger),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = NotificationReport;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct NotificationReport")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__recipients => {
                                    if !fields.insert(__FieldTag::__recipients) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for recipients",
                                            ),
                                        );
                                    }
                                    result.recipients = map.next_value::<std::option::Option<crate::model::data_quality_spec::post_scan_actions::Recipients>>()?
                                        ;
                                }
                                __FieldTag::__score_threshold_trigger => {
                                    if !fields.insert(__FieldTag::__score_threshold_trigger) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for score_threshold_trigger",
                                            ),
                                        );
                                    }
                                    result.score_threshold_trigger = map.next_value::<std::option::Option<crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger>>()?
                                        ;
                                }
                                __FieldTag::__job_failure_trigger => {
                                    if !fields.insert(__FieldTag::__job_failure_trigger) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for job_failure_trigger",
                                            ),
                                        );
                                    }
                                    result.job_failure_trigger = map.next_value::<std::option::Option<crate::model::data_quality_spec::post_scan_actions::JobFailureTrigger>>()?
                                        ;
                                }
                                __FieldTag::__job_end_trigger => {
                                    if !fields.insert(__FieldTag::__job_end_trigger) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for job_end_trigger",
                                            ),
                                        );
                                    }
                                    result.job_end_trigger = map.next_value::<std::option::Option<crate::model::data_quality_spec::post_scan_actions::JobEndTrigger>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for NotificationReport {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.recipients.is_some() {
                    state.serialize_entry("recipients", &self.recipients)?;
                }
                if self.score_threshold_trigger.is_some() {
                    state
                        .serialize_entry("scoreThresholdTrigger", &self.score_threshold_trigger)?;
                }
                if self.job_failure_trigger.is_some() {
                    state.serialize_entry("jobFailureTrigger", &self.job_failure_trigger)?;
                }
                if self.job_end_trigger.is_some() {
                    state.serialize_entry("jobEndTrigger", &self.job_end_trigger)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// The output of a DataQualityScan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualityResult {
    /// Output only. Overall data quality result -- `true` if all rules passed.
    pub passed: bool,

    /// Output only. The overall data quality score.
    ///
    /// The score ranges between [0, 100] (up to two decimal points).
    pub score: std::option::Option<f32>,

    /// Output only. A list of results at the dimension level.
    ///
    /// A dimension will have a corresponding `DataQualityDimensionResult` if and
    /// only if there is at least one rule with the 'dimension' field set to it.
    pub dimensions: std::vec::Vec<crate::model::DataQualityDimensionResult>,

    /// Output only. A list of results at the column level.
    ///
    /// A column will have a corresponding `DataQualityColumnResult` if and only if
    /// there is at least one rule with the 'column' field set to it.
    pub columns: std::vec::Vec<crate::model::DataQualityColumnResult>,

    /// Output only. A list of all the rules in a job, and their results.
    pub rules: std::vec::Vec<crate::model::DataQualityRuleResult>,

    /// Output only. The count of rows processed.
    pub row_count: i64,

    /// Output only. The data scanned for this result.
    pub scanned_data: std::option::Option<crate::model::ScannedData>,

    /// Output only. The result of post scan actions.
    pub post_scan_actions_result:
        std::option::Option<crate::model::data_quality_result::PostScanActionsResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [passed][crate::model::DataQualityResult::passed].
    pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.passed = v.into();
        self
    }

    /// Sets the value of [score][crate::model::DataQualityResult::score].
    pub fn set_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [score][crate::model::DataQualityResult::score].
    pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dimensions][crate::model::DataQualityResult::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityDimensionResult>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [columns][crate::model::DataQualityResult::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityColumnResult>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::DataQualityResult::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityRuleResult>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [row_count][crate::model::DataQualityResult::row_count].
    pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [scanned_data][crate::model::DataQualityResult::scanned_data].
    pub fn set_scanned_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScannedData>,
    {
        self.scanned_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scanned_data][crate::model::DataQualityResult::scanned_data].
    pub fn set_or_clear_scanned_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScannedData>,
    {
        self.scanned_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [post_scan_actions_result][crate::model::DataQualityResult::post_scan_actions_result].
    pub fn set_post_scan_actions_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_quality_result::PostScanActionsResult>,
    {
        self.post_scan_actions_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [post_scan_actions_result][crate::model::DataQualityResult::post_scan_actions_result].
    pub fn set_or_clear_post_scan_actions_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_quality_result::PostScanActionsResult>,
    {
        self.post_scan_actions_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualityResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __passed,
            __score,
            __dimensions,
            __columns,
            __rules,
            __row_count,
            __scanned_data,
            __post_scan_actions_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualityResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "passed" => Ok(__FieldTag::__passed),
                            "score" => Ok(__FieldTag::__score),
                            "dimensions" => Ok(__FieldTag::__dimensions),
                            "columns" => Ok(__FieldTag::__columns),
                            "rules" => Ok(__FieldTag::__rules),
                            "rowCount" => Ok(__FieldTag::__row_count),
                            "row_count" => Ok(__FieldTag::__row_count),
                            "scannedData" => Ok(__FieldTag::__scanned_data),
                            "scanned_data" => Ok(__FieldTag::__scanned_data),
                            "postScanActionsResult" => Ok(__FieldTag::__post_scan_actions_result),
                            "post_scan_actions_result" => {
                                Ok(__FieldTag::__post_scan_actions_result)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualityResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualityResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__passed => {
                            if !fields.insert(__FieldTag::__passed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passed",
                                ));
                            }
                            result.passed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__dimensions => {
                            if !fields.insert(__FieldTag::__dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions",
                                ));
                            }
                            result.dimensions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataQualityDimensionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataQualityColumnResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataQualityRuleResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_count => {
                            if !fields.insert(__FieldTag::__row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scanned_data => {
                            if !fields.insert(__FieldTag::__scanned_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scanned_data",
                                ));
                            }
                            result.scanned_data =
                                map.next_value::<std::option::Option<crate::model::ScannedData>>()?;
                        }
                        __FieldTag::__post_scan_actions_result => {
                            if !fields.insert(__FieldTag::__post_scan_actions_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_scan_actions_result",
                                ));
                            }
                            result.post_scan_actions_result = map
                                .next_value::<std::option::Option<
                                    crate::model::data_quality_result::PostScanActionsResult,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualityResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.passed) {
            state.serialize_entry("passed", &self.passed)?;
        }
        if self.score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !wkt::internal::is_default(&self.row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowCount", &__With(&self.row_count))?;
        }
        if self.scanned_data.is_some() {
            state.serialize_entry("scannedData", &self.scanned_data)?;
        }
        if self.post_scan_actions_result.is_some() {
            state.serialize_entry("postScanActionsResult", &self.post_scan_actions_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataQualityResult].
pub mod data_quality_result {
    #[allow(unused_imports)]
    use super::*;

    /// The result of post scan actions of DataQualityScan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PostScanActionsResult {
        /// Output only. The result of BigQuery export post scan action.
        pub bigquery_export_result: std::option::Option<
            crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActionsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export_result][crate::model::data_quality_result::PostScanActionsResult::bigquery_export_result].
        pub fn set_bigquery_export_result<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult>
        {
            self.bigquery_export_result = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bigquery_export_result][crate::model::data_quality_result::PostScanActionsResult::bigquery_export_result].
        pub fn set_or_clear_bigquery_export_result<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult>
        {
            self.bigquery_export_result = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PostScanActionsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityResult.PostScanActionsResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PostScanActionsResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bigquery_export_result,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PostScanActionsResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bigqueryExportResult" => Ok(__FieldTag::__bigquery_export_result),
                                "bigquery_export_result" => {
                                    Ok(__FieldTag::__bigquery_export_result)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PostScanActionsResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PostScanActionsResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bigquery_export_result => {
                                if !fields.insert(__FieldTag::__bigquery_export_result) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bigquery_export_result",
                                    ));
                                }
                                result.bigquery_export_result = map.next_value::<std::option::Option<crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PostScanActionsResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.bigquery_export_result.is_some() {
                state.serialize_entry("bigqueryExportResult", &self.bigquery_export_result)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PostScanActionsResult].
    pub mod post_scan_actions_result {
        #[allow(unused_imports)]
        use super::*;

        /// The result of BigQuery export post scan action.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BigQueryExportResult {

            /// Output only. Execution state for the BigQuery exporting.
            pub state: crate::model::data_quality_result::post_scan_actions_result::big_query_export_result::State,

            /// Output only. Additional information about the BigQuery exporting.
            pub message: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExportResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult::state].
            pub fn set_state<T: std::convert::Into<crate::model::data_quality_result::post_scan_actions_result::big_query_export_result::State>>(mut self, v: T) -> Self{
                self.state = v.into();
                self
            }

            /// Sets the value of [message][crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult::message].
            pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.message = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExportResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualityResult.PostScanActionsResult.BigQueryExportResult"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BigQueryExportResult {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __state,
                    __message,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BigQueryExportResult")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "state" => Ok(__FieldTag::__state),
                                    "message" => Ok(__FieldTag::__message),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BigQueryExportResult;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BigQueryExportResult")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__state => {
                                    if !fields.insert(__FieldTag::__state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for state"),
                                        );
                                    }
                                    result.state = map.next_value::<std::option::Option<crate::model::data_quality_result::post_scan_actions_result::big_query_export_result::State>>()?.unwrap_or_default();
                                }
                                __FieldTag::__message => {
                                    if !fields.insert(__FieldTag::__message) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for message",
                                            ),
                                        );
                                    }
                                    result.message = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BigQueryExportResult {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.state) {
                    state.serialize_entry("state", &self.state)?;
                }
                if !self.message.is_empty() {
                    state.serialize_entry("message", &self.message)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BigQueryExportResult].
        pub mod big_query_export_result {
            #[allow(unused_imports)]
            use super::*;

            /// Execution state for the exporting.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified,
                /// The exporting completed successfully.
                Succeeded,
                /// The exporting is no longer running due to an error.
                Failed,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [State::value] or
                /// [State::name].
                UnknownValue(state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl State {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Succeeded => std::option::Option::Some(1),
                        Self::Failed => std::option::Option::Some(2),
                        Self::Skipped => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                        Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                        Self::Failed => std::option::Option::Some("FAILED"),
                        Self::Skipped => std::option::Option::Some("SKIPPED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for State {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for State {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for State {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Succeeded,
                        2 => Self::Failed,
                        3 => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for State {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATE_UNSPECIFIED" => Self::Unspecified,
                        "SUCCEEDED" => Self::Succeeded,
                        "FAILED" => Self::Failed,
                        "SKIPPED" => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for State {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Succeeded => serializer.serialize_i32(1),
                        Self::Failed => serializer.serialize_i32(2),
                        Self::Skipped => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for State {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                        ".google.cloud.dataplex.v1.DataQualityResult.PostScanActionsResult.BigQueryExportResult.State"))
                }
            }
        }
    }
}

/// DataQualityRuleResult provides a more detailed, per-rule view of the results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualityRuleResult {
    /// Output only. The rule specified in the DataQualitySpec, as is.
    pub rule: std::option::Option<crate::model::DataQualityRule>,

    /// Output only. Whether the rule passed or failed.
    pub passed: bool,

    /// Output only. The number of rows a rule was evaluated against.
    ///
    /// This field is only valid for row-level type rules.
    ///
    /// Evaluated count can be configured to either
    ///
    /// * include all rows (default) - with `null` rows automatically failing rule
    ///   evaluation, or
    /// * exclude `null` rows from the `evaluated_count`, by setting
    ///   `ignore_nulls = true`.
    ///
    /// This field is not set for rule SqlAssertion.
    pub evaluated_count: i64,

    /// Output only. The number of rows which passed a rule evaluation.
    ///
    /// This field is only valid for row-level type rules.
    ///
    /// This field is not set for rule SqlAssertion.
    pub passed_count: i64,

    /// Output only. The number of rows with null values in the specified column.
    pub null_count: i64,

    /// Output only. The ratio of **passed_count / evaluated_count**.
    ///
    /// This field is only valid for row-level type rules.
    pub pass_ratio: f64,

    /// Output only. The query to find rows that did not pass this rule.
    ///
    /// This field is only valid for row-level type rules.
    pub failing_rows_query: std::string::String,

    /// Output only. The number of rows returned by the SQL statement in a SQL
    /// assertion rule.
    ///
    /// This field is only valid for SQL assertion rules.
    pub assertion_row_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityRuleResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::DataQualityRuleResult::rule].
    pub fn set_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataQualityRule>,
    {
        self.rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule][crate::model::DataQualityRuleResult::rule].
    pub fn set_or_clear_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataQualityRule>,
    {
        self.rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [passed][crate::model::DataQualityRuleResult::passed].
    pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.passed = v.into();
        self
    }

    /// Sets the value of [evaluated_count][crate::model::DataQualityRuleResult::evaluated_count].
    pub fn set_evaluated_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.evaluated_count = v.into();
        self
    }

    /// Sets the value of [passed_count][crate::model::DataQualityRuleResult::passed_count].
    pub fn set_passed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.passed_count = v.into();
        self
    }

    /// Sets the value of [null_count][crate::model::DataQualityRuleResult::null_count].
    pub fn set_null_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.null_count = v.into();
        self
    }

    /// Sets the value of [pass_ratio][crate::model::DataQualityRuleResult::pass_ratio].
    pub fn set_pass_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.pass_ratio = v.into();
        self
    }

    /// Sets the value of [failing_rows_query][crate::model::DataQualityRuleResult::failing_rows_query].
    pub fn set_failing_rows_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.failing_rows_query = v.into();
        self
    }

    /// Sets the value of [assertion_row_count][crate::model::DataQualityRuleResult::assertion_row_count].
    pub fn set_assertion_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.assertion_row_count = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityRuleResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRuleResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualityRuleResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rule,
            __passed,
            __evaluated_count,
            __passed_count,
            __null_count,
            __pass_ratio,
            __failing_rows_query,
            __assertion_row_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualityRuleResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rule" => Ok(__FieldTag::__rule),
                            "passed" => Ok(__FieldTag::__passed),
                            "evaluatedCount" => Ok(__FieldTag::__evaluated_count),
                            "evaluated_count" => Ok(__FieldTag::__evaluated_count),
                            "passedCount" => Ok(__FieldTag::__passed_count),
                            "passed_count" => Ok(__FieldTag::__passed_count),
                            "nullCount" => Ok(__FieldTag::__null_count),
                            "null_count" => Ok(__FieldTag::__null_count),
                            "passRatio" => Ok(__FieldTag::__pass_ratio),
                            "pass_ratio" => Ok(__FieldTag::__pass_ratio),
                            "failingRowsQuery" => Ok(__FieldTag::__failing_rows_query),
                            "failing_rows_query" => Ok(__FieldTag::__failing_rows_query),
                            "assertionRowCount" => Ok(__FieldTag::__assertion_row_count),
                            "assertion_row_count" => Ok(__FieldTag::__assertion_row_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualityRuleResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualityRuleResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rule => {
                            if !fields.insert(__FieldTag::__rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule",
                                ));
                            }
                            result.rule = map
                                .next_value::<std::option::Option<crate::model::DataQualityRule>>(
                                )?;
                        }
                        __FieldTag::__passed => {
                            if !fields.insert(__FieldTag::__passed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passed",
                                ));
                            }
                            result.passed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluated_count => {
                            if !fields.insert(__FieldTag::__evaluated_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluated_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.evaluated_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__passed_count => {
                            if !fields.insert(__FieldTag::__passed_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passed_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.passed_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__null_count => {
                            if !fields.insert(__FieldTag::__null_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.null_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pass_ratio => {
                            if !fields.insert(__FieldTag::__pass_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pass_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pass_ratio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failing_rows_query => {
                            if !fields.insert(__FieldTag::__failing_rows_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failing_rows_query",
                                ));
                            }
                            result.failing_rows_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assertion_row_count => {
                            if !fields.insert(__FieldTag::__assertion_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assertion_row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.assertion_row_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualityRuleResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rule.is_some() {
            state.serialize_entry("rule", &self.rule)?;
        }
        if !wkt::internal::is_default(&self.passed) {
            state.serialize_entry("passed", &self.passed)?;
        }
        if !wkt::internal::is_default(&self.evaluated_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("evaluatedCount", &__With(&self.evaluated_count))?;
        }
        if !wkt::internal::is_default(&self.passed_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("passedCount", &__With(&self.passed_count))?;
        }
        if !wkt::internal::is_default(&self.null_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nullCount", &__With(&self.null_count))?;
        }
        if !wkt::internal::is_default(&self.pass_ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("passRatio", &__With(&self.pass_ratio))?;
        }
        if !self.failing_rows_query.is_empty() {
            state.serialize_entry("failingRowsQuery", &self.failing_rows_query)?;
        }
        if !wkt::internal::is_default(&self.assertion_row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("assertionRowCount", &__With(&self.assertion_row_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DataQualityDimensionResult provides a more detailed, per-dimension view of
/// the results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualityDimensionResult {
    /// Output only. The dimension config specified in the DataQualitySpec, as is.
    pub dimension: std::option::Option<crate::model::DataQualityDimension>,

    /// Output only. Whether the dimension passed or failed.
    pub passed: bool,

    /// Output only. The dimension-level data quality score for this data scan job
    /// if and only if the 'dimension' field is set.
    ///
    /// The score ranges between [0, 100] (up to two decimal
    /// points).
    pub score: std::option::Option<f32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityDimensionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimension][crate::model::DataQualityDimensionResult::dimension].
    pub fn set_dimension<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataQualityDimension>,
    {
        self.dimension = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dimension][crate::model::DataQualityDimensionResult::dimension].
    pub fn set_or_clear_dimension<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataQualityDimension>,
    {
        self.dimension = v.map(|x| x.into());
        self
    }

    /// Sets the value of [passed][crate::model::DataQualityDimensionResult::passed].
    pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.passed = v.into();
        self
    }

    /// Sets the value of [score][crate::model::DataQualityDimensionResult::score].
    pub fn set_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [score][crate::model::DataQualityDimensionResult::score].
    pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.score = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataQualityDimensionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityDimensionResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualityDimensionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dimension,
            __passed,
            __score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualityDimensionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dimension" => Ok(__FieldTag::__dimension),
                            "passed" => Ok(__FieldTag::__passed),
                            "score" => Ok(__FieldTag::__score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualityDimensionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualityDimensionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dimension => {
                            if !fields.insert(__FieldTag::__dimension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimension",
                                ));
                            }
                            result.dimension = map.next_value::<std::option::Option<crate::model::DataQualityDimension>>()?
                                ;
                        }
                        __FieldTag::__passed => {
                            if !fields.insert(__FieldTag::__passed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passed",
                                ));
                            }
                            result.passed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualityDimensionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dimension.is_some() {
            state.serialize_entry("dimension", &self.dimension)?;
        }
        if !wkt::internal::is_default(&self.passed) {
            state.serialize_entry("passed", &self.passed)?;
        }
        if self.score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A dimension captures data quality intent about a defined subset of the rules
/// specified.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualityDimension {
    /// Optional. The dimension name a rule belongs to. Custom dimension name is
    /// supported with all uppercase letters and maximum length of 30 characters.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataQualityDimension::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityDimension"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualityDimension {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualityDimension")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualityDimension;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualityDimension")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualityDimension {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A rule captures data quality intent about a data source.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualityRule {
    /// Optional. The unnested column which this rule is evaluated against.
    pub column: std::string::String,

    /// Optional. Rows with `null` values will automatically fail a rule, unless
    /// `ignore_null` is `true`. In that case, such `null` rows are trivially
    /// considered passing.
    ///
    /// This field is only valid for the following type of rules:
    ///
    /// * RangeExpectation
    /// * RegexExpectation
    /// * SetExpectation
    /// * UniquenessExpectation
    pub ignore_null: bool,

    /// Required. The dimension a rule belongs to. Results are also aggregated at
    /// the dimension level. Supported dimensions are **["COMPLETENESS",
    /// "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "FRESHNESS",
    /// "VOLUME"]**
    pub dimension: std::string::String,

    /// Optional. The minimum ratio of **passing_rows / total_rows** required to
    /// pass this rule, with a range of [0.0, 1.0].
    ///
    /// 0 indicates default value (i.e. 1.0).
    ///
    /// This field is only valid for row-level type rules.
    pub threshold: f64,

    /// Optional. A mutable name for the rule.
    ///
    /// * The name must contain only letters (a-z, A-Z), numbers (0-9), or
    ///   hyphens (-).
    /// * The maximum length is 63 characters.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    pub name: std::string::String,

    /// Optional. Description of the rule.
    ///
    /// * The maximum length is 1,024 characters.
    pub description: std::string::String,

    /// Optional. Whether the Rule is active or suspended.
    /// Default is false.
    pub suspended: bool,

    /// The rule-specific configuration.
    pub rule_type: std::option::Option<crate::model::data_quality_rule::RuleType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::DataQualityRule::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [ignore_null][crate::model::DataQualityRule::ignore_null].
    pub fn set_ignore_null<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_null = v.into();
        self
    }

    /// Sets the value of [dimension][crate::model::DataQualityRule::dimension].
    pub fn set_dimension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dimension = v.into();
        self
    }

    /// Sets the value of [threshold][crate::model::DataQualityRule::threshold].
    pub fn set_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.threshold = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DataQualityRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataQualityRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::DataQualityRule::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type].
    ///
    /// Note that all the setters affecting `rule_type` are mutually
    /// exclusive.
    pub fn set_rule_type<
        T: std::convert::Into<std::option::Option<crate::model::data_quality_rule::RuleType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = v.into();
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `RangeExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn range_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::RangeExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::RangeExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `RangeExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_range_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::RangeExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::RangeExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `NonNullExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn non_null_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::NonNullExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::NonNullExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `NonNullExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_non_null_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::NonNullExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::NonNullExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `SetExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn set_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::SetExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::SetExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `SetExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_set_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::SetExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::SetExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `RegexExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::RegexExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::RegexExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `RegexExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_regex_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::RegexExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::RegexExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `UniquenessExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uniqueness_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::UniquenessExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::UniquenessExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `UniquenessExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_uniqueness_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::UniquenessExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::UniquenessExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `StatisticRangeExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn statistic_range_expectation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_quality_rule::StatisticRangeExpectation>,
    > {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::StatisticRangeExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `StatisticRangeExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_statistic_range_expectation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_quality_rule::StatisticRangeExpectation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::StatisticRangeExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `RowConditionExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn row_condition_expectation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_quality_rule::RowConditionExpectation>,
    > {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::RowConditionExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `RowConditionExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_row_condition_expectation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_quality_rule::RowConditionExpectation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::RowConditionExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `TableConditionExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_condition_expectation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_quality_rule::TableConditionExpectation>,
    > {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::TableConditionExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `TableConditionExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_table_condition_expectation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_quality_rule::TableConditionExpectation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::TableConditionExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `SqlAssertion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_assertion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::SqlAssertion>> {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::SqlAssertion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `SqlAssertion`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_sql_assertion<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::SqlAssertion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::SqlAssertion(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataQualityRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualityRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __range_expectation,
            __non_null_expectation,
            __set_expectation,
            __regex_expectation,
            __uniqueness_expectation,
            __statistic_range_expectation,
            __row_condition_expectation,
            __table_condition_expectation,
            __sql_assertion,
            __column,
            __ignore_null,
            __dimension,
            __threshold,
            __name,
            __description,
            __suspended,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualityRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rangeExpectation" => Ok(__FieldTag::__range_expectation),
                            "range_expectation" => Ok(__FieldTag::__range_expectation),
                            "nonNullExpectation" => Ok(__FieldTag::__non_null_expectation),
                            "non_null_expectation" => Ok(__FieldTag::__non_null_expectation),
                            "setExpectation" => Ok(__FieldTag::__set_expectation),
                            "set_expectation" => Ok(__FieldTag::__set_expectation),
                            "regexExpectation" => Ok(__FieldTag::__regex_expectation),
                            "regex_expectation" => Ok(__FieldTag::__regex_expectation),
                            "uniquenessExpectation" => Ok(__FieldTag::__uniqueness_expectation),
                            "uniqueness_expectation" => Ok(__FieldTag::__uniqueness_expectation),
                            "statisticRangeExpectation" => {
                                Ok(__FieldTag::__statistic_range_expectation)
                            }
                            "statistic_range_expectation" => {
                                Ok(__FieldTag::__statistic_range_expectation)
                            }
                            "rowConditionExpectation" => {
                                Ok(__FieldTag::__row_condition_expectation)
                            }
                            "row_condition_expectation" => {
                                Ok(__FieldTag::__row_condition_expectation)
                            }
                            "tableConditionExpectation" => {
                                Ok(__FieldTag::__table_condition_expectation)
                            }
                            "table_condition_expectation" => {
                                Ok(__FieldTag::__table_condition_expectation)
                            }
                            "sqlAssertion" => Ok(__FieldTag::__sql_assertion),
                            "sql_assertion" => Ok(__FieldTag::__sql_assertion),
                            "column" => Ok(__FieldTag::__column),
                            "ignoreNull" => Ok(__FieldTag::__ignore_null),
                            "ignore_null" => Ok(__FieldTag::__ignore_null),
                            "dimension" => Ok(__FieldTag::__dimension),
                            "threshold" => Ok(__FieldTag::__threshold),
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "suspended" => Ok(__FieldTag::__suspended),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualityRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualityRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__range_expectation => {
                            if !fields.insert(__FieldTag::__range_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.range_expectation, latest field was rangeExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::RangeExpectation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_quality_rule::RangeExpectation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__non_null_expectation => {
                            if !fields.insert(__FieldTag::__non_null_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_null_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.non_null_expectation, latest field was nonNullExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::NonNullExpectation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_quality_rule::NonNullExpectation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__set_expectation => {
                            if !fields.insert(__FieldTag::__set_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.set_expectation, latest field was setExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::SetExpectation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_quality_rule::SetExpectation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__regex_expectation => {
                            if !fields.insert(__FieldTag::__regex_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regex_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.regex_expectation, latest field was regexExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::RegexExpectation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_quality_rule::RegexExpectation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uniqueness_expectation => {
                            if !fields.insert(__FieldTag::__uniqueness_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uniqueness_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.uniqueness_expectation, latest field was uniquenessExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::UniquenessExpectation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_quality_rule::UniquenessExpectation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__statistic_range_expectation => {
                            if !fields.insert(__FieldTag::__statistic_range_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statistic_range_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.statistic_range_expectation, latest field was statisticRangeExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::StatisticRangeExpectation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_quality_rule::StatisticRangeExpectation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__row_condition_expectation => {
                            if !fields.insert(__FieldTag::__row_condition_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_condition_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.row_condition_expectation, latest field was rowConditionExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::RowConditionExpectation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_quality_rule::RowConditionExpectation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__table_condition_expectation => {
                            if !fields.insert(__FieldTag::__table_condition_expectation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_condition_expectation",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.table_condition_expectation, latest field was tableConditionExpectation",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::TableConditionExpectation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_quality_rule::TableConditionExpectation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sql_assertion => {
                            if !fields.insert(__FieldTag::__sql_assertion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_assertion",
                                ));
                            }
                            if result.rule_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type`, a oneof with full ID .google.cloud.dataplex.v1.DataQualityRule.sql_assertion, latest field was sqlAssertion",
                                ));
                            }
                            result.rule_type = std::option::Option::Some(
                                crate::model::data_quality_rule::RuleType::SqlAssertion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_quality_rule::SqlAssertion,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_null => {
                            if !fields.insert(__FieldTag::__ignore_null) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_null",
                                ));
                            }
                            result.ignore_null = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dimension => {
                            if !fields.insert(__FieldTag::__dimension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimension",
                                ));
                            }
                            result.dimension = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__threshold => {
                            if !fields.insert(__FieldTag::__threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threshold",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threshold = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suspended => {
                            if !fields.insert(__FieldTag::__suspended) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suspended",
                                ));
                            }
                            result.suspended = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualityRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.range_expectation() {
            state.serialize_entry("rangeExpectation", value)?;
        }
        if let Some(value) = self.non_null_expectation() {
            state.serialize_entry("nonNullExpectation", value)?;
        }
        if let Some(value) = self.set_expectation() {
            state.serialize_entry("setExpectation", value)?;
        }
        if let Some(value) = self.regex_expectation() {
            state.serialize_entry("regexExpectation", value)?;
        }
        if let Some(value) = self.uniqueness_expectation() {
            state.serialize_entry("uniquenessExpectation", value)?;
        }
        if let Some(value) = self.statistic_range_expectation() {
            state.serialize_entry("statisticRangeExpectation", value)?;
        }
        if let Some(value) = self.row_condition_expectation() {
            state.serialize_entry("rowConditionExpectation", value)?;
        }
        if let Some(value) = self.table_condition_expectation() {
            state.serialize_entry("tableConditionExpectation", value)?;
        }
        if let Some(value) = self.sql_assertion() {
            state.serialize_entry("sqlAssertion", value)?;
        }
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if !wkt::internal::is_default(&self.ignore_null) {
            state.serialize_entry("ignoreNull", &self.ignore_null)?;
        }
        if !self.dimension.is_empty() {
            state.serialize_entry("dimension", &self.dimension)?;
        }
        if !wkt::internal::is_default(&self.threshold) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("threshold", &__With(&self.threshold))?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.suspended) {
            state.serialize_entry("suspended", &self.suspended)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataQualityRule].
pub mod data_quality_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Evaluates whether each column value lies between a specified range.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RangeExpectation {
        /// Optional. The minimum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        pub min_value: std::string::String,

        /// Optional. The maximum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        pub max_value: std::string::String,

        /// Optional. Whether each value needs to be strictly greater than ('>') the
        /// minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        pub strict_min_enabled: bool,

        /// Optional. Whether each value needs to be strictly lesser than ('<') the
        /// maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        pub strict_max_enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RangeExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::data_quality_rule::RangeExpectation::min_value].
        pub fn set_min_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.min_value = v.into();
            self
        }

        /// Sets the value of [max_value][crate::model::data_quality_rule::RangeExpectation::max_value].
        pub fn set_max_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.max_value = v.into();
            self
        }

        /// Sets the value of [strict_min_enabled][crate::model::data_quality_rule::RangeExpectation::strict_min_enabled].
        pub fn set_strict_min_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_min_enabled = v.into();
            self
        }

        /// Sets the value of [strict_max_enabled][crate::model::data_quality_rule::RangeExpectation::strict_max_enabled].
        pub fn set_strict_max_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_max_enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for RangeExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.RangeExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RangeExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min_value,
                __max_value,
                __strict_min_enabled,
                __strict_max_enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RangeExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "minValue" => Ok(__FieldTag::__min_value),
                                "min_value" => Ok(__FieldTag::__min_value),
                                "maxValue" => Ok(__FieldTag::__max_value),
                                "max_value" => Ok(__FieldTag::__max_value),
                                "strictMinEnabled" => Ok(__FieldTag::__strict_min_enabled),
                                "strict_min_enabled" => Ok(__FieldTag::__strict_min_enabled),
                                "strictMaxEnabled" => Ok(__FieldTag::__strict_max_enabled),
                                "strict_max_enabled" => Ok(__FieldTag::__strict_max_enabled),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RangeExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RangeExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min_value => {
                                if !fields.insert(__FieldTag::__min_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_value",
                                    ));
                                }
                                result.min_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_value => {
                                if !fields.insert(__FieldTag::__max_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_value",
                                    ));
                                }
                                result.max_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__strict_min_enabled => {
                                if !fields.insert(__FieldTag::__strict_min_enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for strict_min_enabled",
                                    ));
                                }
                                result.strict_min_enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__strict_max_enabled => {
                                if !fields.insert(__FieldTag::__strict_max_enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for strict_max_enabled",
                                    ));
                                }
                                result.strict_max_enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RangeExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.min_value.is_empty() {
                state.serialize_entry("minValue", &self.min_value)?;
            }
            if !self.max_value.is_empty() {
                state.serialize_entry("maxValue", &self.max_value)?;
            }
            if !wkt::internal::is_default(&self.strict_min_enabled) {
                state.serialize_entry("strictMinEnabled", &self.strict_min_enabled)?;
            }
            if !wkt::internal::is_default(&self.strict_max_enabled) {
                state.serialize_entry("strictMaxEnabled", &self.strict_max_enabled)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluates whether each column value is null.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NonNullExpectation {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NonNullExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for NonNullExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.NonNullExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NonNullExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NonNullExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NonNullExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NonNullExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NonNullExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluates whether each column value is contained by a specified set.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetExpectation {
        /// Optional. Expected values for the column value.
        pub values: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SetExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::data_quality_rule::SetExpectation::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SetExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.SetExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SetExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SetExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SetExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SetExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SetExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluates whether each column value matches a specified regex.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RegexExpectation {
        /// Optional. A regular expression the column value is expected to match.
        pub regex: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RegexExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [regex][crate::model::data_quality_rule::RegexExpectation::regex].
        pub fn set_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.regex = v.into();
            self
        }
    }

    impl wkt::message::Message for RegexExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.RegexExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RegexExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __regex,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RegexExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "regex" => Ok(__FieldTag::__regex),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RegexExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RegexExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__regex => {
                                if !fields.insert(__FieldTag::__regex) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for regex",
                                    ));
                                }
                                result.regex = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RegexExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.regex.is_empty() {
                state.serialize_entry("regex", &self.regex)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluates whether the column has duplicates.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UniquenessExpectation {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UniquenessExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for UniquenessExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.UniquenessExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UniquenessExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UniquenessExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UniquenessExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UniquenessExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UniquenessExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluates whether the column aggregate statistic lies between a specified
    /// range.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StatisticRangeExpectation {
        /// Optional. The aggregate metric to evaluate.
        pub statistic:
            crate::model::data_quality_rule::statistic_range_expectation::ColumnStatistic,

        /// Optional. The minimum column statistic value allowed for a row to pass
        /// this validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        pub min_value: std::string::String,

        /// Optional. The maximum column statistic value allowed for a row to pass
        /// this validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        pub max_value: std::string::String,

        /// Optional. Whether column statistic needs to be strictly greater than
        /// ('>') the minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        pub strict_min_enabled: bool,

        /// Optional. Whether column statistic needs to be strictly lesser than ('<')
        /// the maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        pub strict_max_enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StatisticRangeExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [statistic][crate::model::data_quality_rule::StatisticRangeExpectation::statistic].
        pub fn set_statistic<
            T: std::convert::Into<
                    crate::model::data_quality_rule::statistic_range_expectation::ColumnStatistic,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.statistic = v.into();
            self
        }

        /// Sets the value of [min_value][crate::model::data_quality_rule::StatisticRangeExpectation::min_value].
        pub fn set_min_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.min_value = v.into();
            self
        }

        /// Sets the value of [max_value][crate::model::data_quality_rule::StatisticRangeExpectation::max_value].
        pub fn set_max_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.max_value = v.into();
            self
        }

        /// Sets the value of [strict_min_enabled][crate::model::data_quality_rule::StatisticRangeExpectation::strict_min_enabled].
        pub fn set_strict_min_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_min_enabled = v.into();
            self
        }

        /// Sets the value of [strict_max_enabled][crate::model::data_quality_rule::StatisticRangeExpectation::strict_max_enabled].
        pub fn set_strict_max_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_max_enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for StatisticRangeExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StatisticRangeExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __statistic,
                __min_value,
                __max_value,
                __strict_min_enabled,
                __strict_max_enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StatisticRangeExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "statistic" => Ok(__FieldTag::__statistic),
                                "minValue" => Ok(__FieldTag::__min_value),
                                "min_value" => Ok(__FieldTag::__min_value),
                                "maxValue" => Ok(__FieldTag::__max_value),
                                "max_value" => Ok(__FieldTag::__max_value),
                                "strictMinEnabled" => Ok(__FieldTag::__strict_min_enabled),
                                "strict_min_enabled" => Ok(__FieldTag::__strict_min_enabled),
                                "strictMaxEnabled" => Ok(__FieldTag::__strict_max_enabled),
                                "strict_max_enabled" => Ok(__FieldTag::__strict_max_enabled),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StatisticRangeExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StatisticRangeExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__statistic => {
                                if !fields.insert(__FieldTag::__statistic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for statistic",
                                    ));
                                }
                                result.statistic = map.next_value::<std::option::Option<crate::model::data_quality_rule::statistic_range_expectation::ColumnStatistic>>()?.unwrap_or_default();
                            }
                            __FieldTag::__min_value => {
                                if !fields.insert(__FieldTag::__min_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_value",
                                    ));
                                }
                                result.min_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_value => {
                                if !fields.insert(__FieldTag::__max_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_value",
                                    ));
                                }
                                result.max_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__strict_min_enabled => {
                                if !fields.insert(__FieldTag::__strict_min_enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for strict_min_enabled",
                                    ));
                                }
                                result.strict_min_enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__strict_max_enabled => {
                                if !fields.insert(__FieldTag::__strict_max_enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for strict_max_enabled",
                                    ));
                                }
                                result.strict_max_enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StatisticRangeExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.statistic) {
                state.serialize_entry("statistic", &self.statistic)?;
            }
            if !self.min_value.is_empty() {
                state.serialize_entry("minValue", &self.min_value)?;
            }
            if !self.max_value.is_empty() {
                state.serialize_entry("maxValue", &self.max_value)?;
            }
            if !wkt::internal::is_default(&self.strict_min_enabled) {
                state.serialize_entry("strictMinEnabled", &self.strict_min_enabled)?;
            }
            if !wkt::internal::is_default(&self.strict_max_enabled) {
                state.serialize_entry("strictMaxEnabled", &self.strict_max_enabled)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [StatisticRangeExpectation].
    pub mod statistic_range_expectation {
        #[allow(unused_imports)]
        use super::*;

        /// The list of aggregate metrics a rule can be evaluated against.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ColumnStatistic {
            /// Unspecified statistic type
            StatisticUndefined,
            /// Evaluate the column mean
            Mean,
            /// Evaluate the column min
            Min,
            /// Evaluate the column max
            Max,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ColumnStatistic::value] or
            /// [ColumnStatistic::name].
            UnknownValue(column_statistic::UnknownValue),
        }

        #[doc(hidden)]
        pub mod column_statistic {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ColumnStatistic {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::StatisticUndefined => std::option::Option::Some(0),
                    Self::Mean => std::option::Option::Some(1),
                    Self::Min => std::option::Option::Some(2),
                    Self::Max => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::StatisticUndefined => std::option::Option::Some("STATISTIC_UNDEFINED"),
                    Self::Mean => std::option::Option::Some("MEAN"),
                    Self::Min => std::option::Option::Some("MIN"),
                    Self::Max => std::option::Option::Some("MAX"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ColumnStatistic {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ColumnStatistic {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ColumnStatistic {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::StatisticUndefined,
                    1 => Self::Mean,
                    2 => Self::Min,
                    3 => Self::Max,
                    _ => Self::UnknownValue(column_statistic::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ColumnStatistic {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATISTIC_UNDEFINED" => Self::StatisticUndefined,
                    "MEAN" => Self::Mean,
                    "MIN" => Self::Min,
                    "MAX" => Self::Max,
                    _ => Self::UnknownValue(column_statistic::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ColumnStatistic {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::StatisticUndefined => serializer.serialize_i32(0),
                    Self::Mean => serializer.serialize_i32(1),
                    Self::Min => serializer.serialize_i32(2),
                    Self::Max => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ColumnStatistic {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColumnStatistic>::new(
                    ".google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation.ColumnStatistic"))
            }
        }
    }

    /// Evaluates whether each row passes the specified condition.
    ///
    /// The SQL expression needs to use [GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax)
    /// and should produce a boolean value per row as the result.
    ///
    /// Example: col1 >= 0 AND col2 < 10
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RowConditionExpectation {
        /// Optional. The SQL expression.
        pub sql_expression: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RowConditionExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_expression][crate::model::data_quality_rule::RowConditionExpectation::sql_expression].
        pub fn set_sql_expression<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sql_expression = v.into();
            self
        }
    }

    impl wkt::message::Message for RowConditionExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.RowConditionExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RowConditionExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sql_expression,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RowConditionExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sqlExpression" => Ok(__FieldTag::__sql_expression),
                                "sql_expression" => Ok(__FieldTag::__sql_expression),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RowConditionExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RowConditionExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sql_expression => {
                                if !fields.insert(__FieldTag::__sql_expression) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_expression",
                                    ));
                                }
                                result.sql_expression = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RowConditionExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sql_expression.is_empty() {
                state.serialize_entry("sqlExpression", &self.sql_expression)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluates whether the provided expression is true.
    ///
    /// The SQL expression needs to use [GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax)
    /// and should produce a scalar boolean result.
    ///
    /// Example: MIN(col1) >= 0
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TableConditionExpectation {
        /// Optional. The SQL expression.
        pub sql_expression: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TableConditionExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_expression][crate::model::data_quality_rule::TableConditionExpectation::sql_expression].
        pub fn set_sql_expression<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sql_expression = v.into();
            self
        }
    }

    impl wkt::message::Message for TableConditionExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.TableConditionExpectation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TableConditionExpectation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sql_expression,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TableConditionExpectation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sqlExpression" => Ok(__FieldTag::__sql_expression),
                                "sql_expression" => Ok(__FieldTag::__sql_expression),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TableConditionExpectation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TableConditionExpectation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sql_expression => {
                                if !fields.insert(__FieldTag::__sql_expression) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_expression",
                                    ));
                                }
                                result.sql_expression = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TableConditionExpectation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sql_expression.is_empty() {
                state.serialize_entry("sqlExpression", &self.sql_expression)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A SQL statement that is evaluated to return rows that match an invalid
    /// state. If any rows are are returned, this rule fails.
    ///
    /// The SQL statement must use [GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax),
    /// and must not contain any semicolons.
    ///
    /// You can use the data reference parameter `${data()}` to reference the
    /// source table with all of its precondition filters applied. Examples of
    /// precondition filters include row filters, incremental data filters, and
    /// sampling. For more information, see [Data reference
    /// parameter](https://cloud.google.com/dataplex/docs/auto-data-quality-overview#data-reference-parameter).
    ///
    /// Example: `SELECT * FROM ${data()} WHERE price < 0`
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlAssertion {
        /// Optional. The SQL statement.
        pub sql_statement: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlAssertion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_statement][crate::model::data_quality_rule::SqlAssertion::sql_statement].
        pub fn set_sql_statement<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sql_statement = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlAssertion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.SqlAssertion"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlAssertion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sql_statement,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlAssertion")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sqlStatement" => Ok(__FieldTag::__sql_statement),
                                "sql_statement" => Ok(__FieldTag::__sql_statement),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlAssertion;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlAssertion")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sql_statement => {
                                if !fields.insert(__FieldTag::__sql_statement) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_statement",
                                    ));
                                }
                                result.sql_statement = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlAssertion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sql_statement.is_empty() {
                state.serialize_entry("sqlStatement", &self.sql_statement)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The rule-specific configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RuleType {
        /// Row-level rule which evaluates whether each column value lies between a
        /// specified range.
        RangeExpectation(std::boxed::Box<crate::model::data_quality_rule::RangeExpectation>),
        /// Row-level rule which evaluates whether each column value is null.
        NonNullExpectation(std::boxed::Box<crate::model::data_quality_rule::NonNullExpectation>),
        /// Row-level rule which evaluates whether each column value is contained by
        /// a specified set.
        SetExpectation(std::boxed::Box<crate::model::data_quality_rule::SetExpectation>),
        /// Row-level rule which evaluates whether each column value matches a
        /// specified regex.
        RegexExpectation(std::boxed::Box<crate::model::data_quality_rule::RegexExpectation>),
        /// Row-level rule which evaluates whether each column value is unique.
        UniquenessExpectation(
            std::boxed::Box<crate::model::data_quality_rule::UniquenessExpectation>,
        ),
        /// Aggregate rule which evaluates whether the column aggregate
        /// statistic lies between a specified range.
        StatisticRangeExpectation(
            std::boxed::Box<crate::model::data_quality_rule::StatisticRangeExpectation>,
        ),
        /// Row-level rule which evaluates whether each row in a table passes the
        /// specified condition.
        RowConditionExpectation(
            std::boxed::Box<crate::model::data_quality_rule::RowConditionExpectation>,
        ),
        /// Aggregate rule which evaluates whether the provided expression is true
        /// for a table.
        TableConditionExpectation(
            std::boxed::Box<crate::model::data_quality_rule::TableConditionExpectation>,
        ),
        /// Aggregate rule which evaluates the number of rows returned for the
        /// provided statement. If any rows are returned, this rule fails.
        SqlAssertion(std::boxed::Box<crate::model::data_quality_rule::SqlAssertion>),
    }
}

/// DataQualityColumnResult provides a more detailed, per-column view of
/// the results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualityColumnResult {
    /// Output only. The column specified in the DataQualityRule.
    pub column: std::string::String,

    /// Output only. The column-level data quality score for this data scan job if
    /// and only if the 'column' field is set.
    ///
    /// The score ranges between between [0, 100] (up to two decimal
    /// points).
    pub score: std::option::Option<f32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityColumnResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::DataQualityColumnResult::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [score][crate::model::DataQualityColumnResult::score].
    pub fn set_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [score][crate::model::DataQualityColumnResult::score].
    pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.score = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataQualityColumnResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityColumnResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualityColumnResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column,
            __score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualityColumnResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "column" => Ok(__FieldTag::__column),
                            "score" => Ok(__FieldTag::__score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualityColumnResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualityColumnResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualityColumnResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if self.score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DataTaxonomy represents a set of hierarchical DataAttributes resources,
/// grouped with a common theme Eg: 'SensitiveDataTaxonomy' can have attributes
/// to manage PII data. It is defined at project level.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct DataTaxonomy {
    /// Output only. The relative resource name of the DataTaxonomy, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the dataTaxonomy. This
    /// ID will be different if the DataTaxonomy is deleted and re-created with the
    /// same name.
    pub uid: std::string::String,

    /// Output only. The time when the DataTaxonomy was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataTaxonomy was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the DataTaxonomy.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the DataTaxonomy.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The number of attributes in the DataTaxonomy.
    pub attribute_count: i32,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. The number of classes in the DataTaxonomy.
    pub class_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataTaxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataTaxonomy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataTaxonomy::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataTaxonomy::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataTaxonomy::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DataTaxonomy::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DataTaxonomy::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::DataTaxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataTaxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataTaxonomy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [attribute_count][crate::model::DataTaxonomy::attribute_count].
    pub fn set_attribute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.attribute_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DataTaxonomy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [class_count][crate::model::DataTaxonomy::class_count].
    pub fn set_class_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.class_count = v.into();
        self
    }
}

impl wkt::message::Message for DataTaxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataTaxonomy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataTaxonomy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __labels,
            __attribute_count,
            __etag,
            __class_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataTaxonomy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "attributeCount" => Ok(__FieldTag::__attribute_count),
                            "attribute_count" => Ok(__FieldTag::__attribute_count),
                            "etag" => Ok(__FieldTag::__etag),
                            "classCount" => Ok(__FieldTag::__class_count),
                            "class_count" => Ok(__FieldTag::__class_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataTaxonomy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataTaxonomy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute_count => {
                            if !fields.insert(__FieldTag::__attribute_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attribute_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__class_count => {
                            if !fields.insert(__FieldTag::__class_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for class_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.class_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataTaxonomy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.attribute_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("attributeCount", &__With(&self.attribute_count))?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.class_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("classCount", &__With(&self.class_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Denotes one dataAttribute in a dataTaxonomy, for example, PII.
/// DataAttribute resources can be defined in a hierarchy.
/// A single dataAttribute resource can contain specs of multiple types
///
/// ```norust
/// PII
///   - ResourceAccessSpec :
///                 - readers :foo@bar.com
///   - DataAccessSpec :
///                 - readers :bar@foo.com
/// ```
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct DataAttribute {
    /// Output only. The relative resource name of the dataAttribute, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the DataAttribute.
    /// This ID will be different if the DataAttribute is deleted and re-created
    /// with the same name.
    pub uid: std::string::String,

    /// Output only. The time when the DataAttribute was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataAttribute was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the DataAttribute.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the DataAttribute.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The ID of the parent DataAttribute resource, should belong to the
    /// same data taxonomy. Circular dependency in parent chain is not valid.
    /// Maximum depth of the hierarchy allowed is 4.
    /// [a -> b -> c -> d -> e, depth = 4]
    pub parent_id: std::string::String,

    /// Output only. The number of child attributes present for this attribute.
    pub attribute_count: i32,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. Specified when applied to a resource (eg: Cloud Storage bucket,
    /// BigQuery dataset, BigQuery table).
    pub resource_access_spec: std::option::Option<crate::model::ResourceAccessSpec>,

    /// Optional. Specified when applied to data stored on the resource (eg: rows,
    /// columns in BigQuery Tables).
    pub data_access_spec: std::option::Option<crate::model::DataAccessSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataAttribute::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataAttribute::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataAttribute::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataAttribute::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DataAttribute::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DataAttribute::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::DataAttribute::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataAttribute::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataAttribute::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [parent_id][crate::model::DataAttribute::parent_id].
    pub fn set_parent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_id = v.into();
        self
    }

    /// Sets the value of [attribute_count][crate::model::DataAttribute::attribute_count].
    pub fn set_attribute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.attribute_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DataAttribute::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [resource_access_spec][crate::model::DataAttribute::resource_access_spec].
    pub fn set_resource_access_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceAccessSpec>,
    {
        self.resource_access_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_access_spec][crate::model::DataAttribute::resource_access_spec].
    pub fn set_or_clear_resource_access_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceAccessSpec>,
    {
        self.resource_access_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_access_spec][crate::model::DataAttribute::data_access_spec].
    pub fn set_data_access_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataAccessSpec>,
    {
        self.data_access_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_access_spec][crate::model::DataAttribute::data_access_spec].
    pub fn set_or_clear_data_access_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataAccessSpec>,
    {
        self.data_access_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataAttribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataAttribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __labels,
            __parent_id,
            __attribute_count,
            __etag,
            __resource_access_spec,
            __data_access_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataAttribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "parentId" => Ok(__FieldTag::__parent_id),
                            "parent_id" => Ok(__FieldTag::__parent_id),
                            "attributeCount" => Ok(__FieldTag::__attribute_count),
                            "attribute_count" => Ok(__FieldTag::__attribute_count),
                            "etag" => Ok(__FieldTag::__etag),
                            "resourceAccessSpec" => Ok(__FieldTag::__resource_access_spec),
                            "resource_access_spec" => Ok(__FieldTag::__resource_access_spec),
                            "dataAccessSpec" => Ok(__FieldTag::__data_access_spec),
                            "data_access_spec" => Ok(__FieldTag::__data_access_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataAttribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataAttribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_id => {
                            if !fields.insert(__FieldTag::__parent_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_id",
                                ));
                            }
                            result.parent_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute_count => {
                            if !fields.insert(__FieldTag::__attribute_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attribute_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_access_spec => {
                            if !fields.insert(__FieldTag::__resource_access_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_access_spec",
                                ));
                            }
                            result.resource_access_spec = map.next_value::<std::option::Option<crate::model::ResourceAccessSpec>>()?
                                ;
                        }
                        __FieldTag::__data_access_spec => {
                            if !fields.insert(__FieldTag::__data_access_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_access_spec",
                                ));
                            }
                            result.data_access_spec = map
                                .next_value::<std::option::Option<crate::model::DataAccessSpec>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.parent_id.is_empty() {
            state.serialize_entry("parentId", &self.parent_id)?;
        }
        if !wkt::internal::is_default(&self.attribute_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("attributeCount", &__With(&self.attribute_count))?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.resource_access_spec.is_some() {
            state.serialize_entry("resourceAccessSpec", &self.resource_access_spec)?;
        }
        if self.data_access_spec.is_some() {
            state.serialize_entry("dataAccessSpec", &self.data_access_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DataAttributeBinding represents binding of attributes to resources. Eg: Bind
/// 'CustomerInfo' entity with 'PII' attribute.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct DataAttributeBinding {
    /// Output only. The relative resource name of the Data Attribute Binding, of
    /// the form:
    /// projects/{project_number}/locations/{location}/dataAttributeBindings/{data_attribute_binding_id}
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the
    /// DataAttributeBinding. This ID will be different if the DataAttributeBinding
    /// is deleted and re-created with the same name.
    pub uid: std::string::String,

    /// Output only. The time when the DataAttributeBinding was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataAttributeBinding was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the DataAttributeBinding.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the DataAttributeBinding.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    /// Etags must be used when calling the DeleteDataAttributeBinding and the
    /// UpdateDataAttributeBinding method.
    pub etag: std::string::String,

    /// Optional. List of attributes to be associated with the resource, provided
    /// in the form:
    /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    pub attributes: std::vec::Vec<std::string::String>,

    /// Optional. The list of paths for items within the associated resource (eg.
    /// columns and partitions within a table) along with attribute bindings.
    pub paths: std::vec::Vec<crate::model::data_attribute_binding::Path>,

    /// The reference to the resource that is associated to attributes, or
    /// the query to match resources and associate attributes.
    pub resource_reference:
        std::option::Option<crate::model::data_attribute_binding::ResourceReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataAttributeBinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataAttributeBinding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataAttributeBinding::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataAttributeBinding::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataAttributeBinding::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DataAttributeBinding::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DataAttributeBinding::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::DataAttributeBinding::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataAttributeBinding::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataAttributeBinding::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::DataAttributeBinding::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::DataAttributeBinding::attributes].
    pub fn set_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paths][crate::model::DataAttributeBinding::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::data_attribute_binding::Path>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_reference][crate::model::DataAttributeBinding::resource_reference].
    ///
    /// Note that all the setters affecting `resource_reference` are mutually
    /// exclusive.
    pub fn set_resource_reference<
        T: std::convert::Into<
                std::option::Option<crate::model::data_attribute_binding::ResourceReference>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_reference = v.into();
        self
    }

    /// The value of [resource_reference][crate::model::DataAttributeBinding::resource_reference]
    /// if it holds a `Resource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.resource_reference.as_ref().and_then(|v| match v {
            crate::model::data_attribute_binding::ResourceReference::Resource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_reference][crate::model::DataAttributeBinding::resource_reference]
    /// to hold a `Resource`.
    ///
    /// Note that all the setters affecting `resource_reference` are
    /// mutually exclusive.
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_reference = std::option::Option::Some(
            crate::model::data_attribute_binding::ResourceReference::Resource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataAttributeBinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataAttributeBinding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataAttributeBinding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __labels,
            __etag,
            __resource,
            __attributes,
            __paths,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataAttributeBinding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "resource" => Ok(__FieldTag::__resource),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "paths" => Ok(__FieldTag::__paths),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataAttributeBinding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataAttributeBinding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            if result.resource_reference.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_reference`, a oneof with full ID .google.cloud.dataplex.v1.DataAttributeBinding.resource, latest field was resource",
                                ));
                            }
                            result.resource_reference = std::option::Option::Some(
                                crate::model::data_attribute_binding::ResourceReference::Resource(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::data_attribute_binding::Path>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataAttributeBinding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if let Some(value) = self.resource() {
            state.serialize_entry("resource", value)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.paths.is_empty() {
            state.serialize_entry("paths", &self.paths)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataAttributeBinding].
pub mod data_attribute_binding {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a subresource of the given resource, and associated bindings
    /// with it. Currently supported subresources are column and partition schema
    /// fields within a table.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Path {
        /// Required. The name identifier of the path.
        /// Nested columns should be of the form: 'address.city'.
        pub name: std::string::String,

        /// Optional. List of attributes to be associated with the path of the
        /// resource, provided in the form:
        /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
        pub attributes: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Path {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::data_attribute_binding::Path::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [attributes][crate::model::data_attribute_binding::Path::attributes].
        pub fn set_attributes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.attributes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Path {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataAttributeBinding.Path"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Path {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __attributes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Path")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "attributes" => Ok(__FieldTag::__attributes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Path;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Path")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__attributes => {
                                if !fields.insert(__FieldTag::__attributes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attributes",
                                    ));
                                }
                                result.attributes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Path {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.attributes.is_empty() {
                state.serialize_entry("attributes", &self.attributes)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The reference to the resource that is associated to attributes, or
    /// the query to match resources and associate attributes.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceReference {
        /// Optional. Immutable. The resource name of the resource that is associated
        /// to attributes. Presently, only entity resource is supported in the form:
        /// projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/entities/{entity_id}
        /// Must belong in the same project and region as the attribute binding, and
        /// there can only exist one active binding for a resource.
        Resource(std::string::String),
    }
}

/// Create DataTaxonomy request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct CreateDataTaxonomyRequest {
    pub parent: std::string::String,

    /// Required. DataTaxonomy identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the Project.
    pub data_taxonomy_id: std::string::String,

    /// Required. DataTaxonomy resource.
    pub data_taxonomy: std::option::Option<crate::model::DataTaxonomy>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataTaxonomyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_taxonomy_id][crate::model::CreateDataTaxonomyRequest::data_taxonomy_id].
    pub fn set_data_taxonomy_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_taxonomy_id = v.into();
        self
    }

    /// Sets the value of [data_taxonomy][crate::model::CreateDataTaxonomyRequest::data_taxonomy].
    pub fn set_data_taxonomy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataTaxonomy>,
    {
        self.data_taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_taxonomy][crate::model::CreateDataTaxonomyRequest::data_taxonomy].
    pub fn set_or_clear_data_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataTaxonomy>,
    {
        self.data_taxonomy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataTaxonomyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDataTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __data_taxonomy_id,
            __data_taxonomy,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDataTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataTaxonomyId" => Ok(__FieldTag::__data_taxonomy_id),
                            "data_taxonomy_id" => Ok(__FieldTag::__data_taxonomy_id),
                            "dataTaxonomy" => Ok(__FieldTag::__data_taxonomy),
                            "data_taxonomy" => Ok(__FieldTag::__data_taxonomy),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDataTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDataTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_taxonomy_id => {
                            if !fields.insert(__FieldTag::__data_taxonomy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_taxonomy_id",
                                ));
                            }
                            result.data_taxonomy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_taxonomy => {
                            if !fields.insert(__FieldTag::__data_taxonomy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_taxonomy",
                                ));
                            }
                            result.data_taxonomy = map
                                .next_value::<std::option::Option<crate::model::DataTaxonomy>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDataTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.data_taxonomy_id.is_empty() {
            state.serialize_entry("dataTaxonomyId", &self.data_taxonomy_id)?;
        }
        if self.data_taxonomy.is_some() {
            state.serialize_entry("dataTaxonomy", &self.data_taxonomy)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update DataTaxonomy request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct UpdateDataTaxonomyRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in `update_mask` are updated.
    pub data_taxonomy: std::option::Option<crate::model::DataTaxonomy>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataTaxonomyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDataTaxonomyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_taxonomy][crate::model::UpdateDataTaxonomyRequest::data_taxonomy].
    pub fn set_data_taxonomy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataTaxonomy>,
    {
        self.data_taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_taxonomy][crate::model::UpdateDataTaxonomyRequest::data_taxonomy].
    pub fn set_or_clear_data_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataTaxonomy>,
    {
        self.data_taxonomy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataTaxonomyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDataTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __data_taxonomy,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDataTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "dataTaxonomy" => Ok(__FieldTag::__data_taxonomy),
                            "data_taxonomy" => Ok(__FieldTag::__data_taxonomy),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDataTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDataTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__data_taxonomy => {
                            if !fields.insert(__FieldTag::__data_taxonomy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_taxonomy",
                                ));
                            }
                            result.data_taxonomy = map
                                .next_value::<std::option::Option<crate::model::DataTaxonomy>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDataTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.data_taxonomy.is_some() {
            state.serialize_entry("dataTaxonomy", &self.data_taxonomy)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get DataTaxonomy request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct GetDataTaxonomyRequest {
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDataTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDataTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDataTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDataTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDataTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List DataTaxonomies request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataTaxonomiesRequest {
    /// Required. The resource name of the DataTaxonomy location, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Optional. Maximum number of DataTaxonomies to return. The service may
    /// return fewer than this value. If unspecified, at most 10 DataTaxonomies
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous ` ListDataTaxonomies` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to ` ListDataTaxonomies` must match the call that
    /// provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataTaxonomiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataTaxonomiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataTaxonomiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataTaxonomiesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataTaxonomiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataTaxonomiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataTaxonomiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataTaxonomiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataTaxonomiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataTaxonomiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List DataTaxonomies response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataTaxonomiesResponse {
    /// DataTaxonomies under the given parent location.
    pub data_taxonomies: std::vec::Vec<crate::model::DataTaxonomy>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_taxonomies][crate::model::ListDataTaxonomiesResponse::data_taxonomies].
    pub fn set_data_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataTaxonomy>,
    {
        use std::iter::Iterator;
        self.data_taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataTaxonomiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListDataTaxonomiesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataTaxonomiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataTaxonomiesResponse {
    type PageItem = crate::model::DataTaxonomy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_taxonomies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataTaxonomiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_taxonomies,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataTaxonomiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataTaxonomies" => Ok(__FieldTag::__data_taxonomies),
                            "data_taxonomies" => Ok(__FieldTag::__data_taxonomies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataTaxonomiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataTaxonomiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_taxonomies => {
                            if !fields.insert(__FieldTag::__data_taxonomies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_taxonomies",
                                ));
                            }
                            result.data_taxonomies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataTaxonomy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataTaxonomiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_taxonomies.is_empty() {
            state.serialize_entry("dataTaxonomies", &self.data_taxonomies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete DataTaxonomy request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct DeleteDataTaxonomyRequest {
    /// Required. The resource name of the DataTaxonomy:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value,the DeleteDataTaxonomy method returns an ABORTED error.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDataTaxonomyRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDataTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDataTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDataTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDataTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDataTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create DataAttribute request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDataAttributeRequest {
    /// Required. The resource name of the parent data taxonomy
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    pub parent: std::string::String,

    /// Required. DataAttribute identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the DataTaxonomy.
    pub data_attribute_id: std::string::String,

    /// Required. DataAttribute resource.
    pub data_attribute: std::option::Option<crate::model::DataAttribute>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataAttributeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_attribute_id][crate::model::CreateDataAttributeRequest::data_attribute_id].
    pub fn set_data_attribute_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute_id = v.into();
        self
    }

    /// Sets the value of [data_attribute][crate::model::CreateDataAttributeRequest::data_attribute].
    pub fn set_data_attribute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataAttribute>,
    {
        self.data_attribute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_attribute][crate::model::CreateDataAttributeRequest::data_attribute].
    pub fn set_or_clear_data_attribute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataAttribute>,
    {
        self.data_attribute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataAttributeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDataAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __data_attribute_id,
            __data_attribute,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDataAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataAttributeId" => Ok(__FieldTag::__data_attribute_id),
                            "data_attribute_id" => Ok(__FieldTag::__data_attribute_id),
                            "dataAttribute" => Ok(__FieldTag::__data_attribute),
                            "data_attribute" => Ok(__FieldTag::__data_attribute),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDataAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDataAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_attribute_id => {
                            if !fields.insert(__FieldTag::__data_attribute_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attribute_id",
                                ));
                            }
                            result.data_attribute_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_attribute => {
                            if !fields.insert(__FieldTag::__data_attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attribute",
                                ));
                            }
                            result.data_attribute = map
                                .next_value::<std::option::Option<crate::model::DataAttribute>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDataAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.data_attribute_id.is_empty() {
            state.serialize_entry("dataAttributeId", &self.data_attribute_id)?;
        }
        if self.data_attribute.is_some() {
            state.serialize_entry("dataAttribute", &self.data_attribute)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update DataAttribute request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDataAttributeRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in `update_mask` are updated.
    pub data_attribute: std::option::Option<crate::model::DataAttribute>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataAttributeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDataAttributeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_attribute][crate::model::UpdateDataAttributeRequest::data_attribute].
    pub fn set_data_attribute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataAttribute>,
    {
        self.data_attribute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_attribute][crate::model::UpdateDataAttributeRequest::data_attribute].
    pub fn set_or_clear_data_attribute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataAttribute>,
    {
        self.data_attribute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataAttributeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDataAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __data_attribute,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDataAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "dataAttribute" => Ok(__FieldTag::__data_attribute),
                            "data_attribute" => Ok(__FieldTag::__data_attribute),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDataAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDataAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__data_attribute => {
                            if !fields.insert(__FieldTag::__data_attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attribute",
                                ));
                            }
                            result.data_attribute = map
                                .next_value::<std::option::Option<crate::model::DataAttribute>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDataAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.data_attribute.is_some() {
            state.serialize_entry("dataAttribute", &self.data_attribute)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get DataAttribute request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDataAttributeRequest {
    /// Required. The resource name of the dataAttribute:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataAttributeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDataAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDataAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDataAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDataAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDataAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List DataAttributes request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataAttributesRequest {
    /// Required. The resource name of the DataTaxonomy:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    pub parent: std::string::String,

    /// Optional. Maximum number of DataAttributes to return. The service may
    /// return fewer than this value. If unspecified, at most 10 dataAttributes
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataAttributes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListDataAttributes` must match the call that
    /// provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataAttributesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataAttributesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataAttributesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataAttributesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataAttributesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataAttributesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataAttributesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataAttributesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataAttributesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataAttributesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataAttributesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List DataAttributes response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataAttributesResponse {
    /// DataAttributes under the given parent DataTaxonomy.
    pub data_attributes: std::vec::Vec<crate::model::DataAttribute>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_attributes][crate::model::ListDataAttributesResponse::data_attributes].
    pub fn set_data_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataAttribute>,
    {
        use std::iter::Iterator;
        self.data_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataAttributesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListDataAttributesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataAttributesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataAttributesResponse {
    type PageItem = crate::model::DataAttribute;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_attributes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataAttributesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_attributes,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataAttributesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataAttributes" => Ok(__FieldTag::__data_attributes),
                            "data_attributes" => Ok(__FieldTag::__data_attributes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataAttributesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataAttributesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_attributes => {
                            if !fields.insert(__FieldTag::__data_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attributes",
                                ));
                            }
                            result.data_attributes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataAttribute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataAttributesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_attributes.is_empty() {
            state.serialize_entry("dataAttributes", &self.data_attributes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete DataAttribute request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDataAttributeRequest {
    /// Required. The resource name of the DataAttribute:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteDataAttribute method returns an ABORTED error response.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataAttributeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDataAttributeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDataAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDataAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDataAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDataAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDataAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create DataAttributeBinding request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDataAttributeBindingRequest {
    /// Required. The resource name of the parent data taxonomy
    /// projects/{project_number}/locations/{location_id}
    pub parent: std::string::String,

    /// Required. DataAttributeBinding identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the Location.
    pub data_attribute_binding_id: std::string::String,

    /// Required. DataAttributeBinding resource.
    pub data_attribute_binding: std::option::Option<crate::model::DataAttributeBinding>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataAttributeBindingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_attribute_binding_id][crate::model::CreateDataAttributeBindingRequest::data_attribute_binding_id].
    pub fn set_data_attribute_binding_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute_binding_id = v.into();
        self
    }

    /// Sets the value of [data_attribute_binding][crate::model::CreateDataAttributeBindingRequest::data_attribute_binding].
    pub fn set_data_attribute_binding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataAttributeBinding>,
    {
        self.data_attribute_binding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_attribute_binding][crate::model::CreateDataAttributeBindingRequest::data_attribute_binding].
    pub fn set_or_clear_data_attribute_binding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataAttributeBinding>,
    {
        self.data_attribute_binding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataAttributeBindingRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataAttributeBindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDataAttributeBindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __data_attribute_binding_id,
            __data_attribute_binding,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDataAttributeBindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataAttributeBindingId" => Ok(__FieldTag::__data_attribute_binding_id),
                            "data_attribute_binding_id" => {
                                Ok(__FieldTag::__data_attribute_binding_id)
                            }
                            "dataAttributeBinding" => Ok(__FieldTag::__data_attribute_binding),
                            "data_attribute_binding" => Ok(__FieldTag::__data_attribute_binding),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDataAttributeBindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDataAttributeBindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_attribute_binding_id => {
                            if !fields.insert(__FieldTag::__data_attribute_binding_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attribute_binding_id",
                                ));
                            }
                            result.data_attribute_binding_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_attribute_binding => {
                            if !fields.insert(__FieldTag::__data_attribute_binding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attribute_binding",
                                ));
                            }
                            result.data_attribute_binding = map.next_value::<std::option::Option<crate::model::DataAttributeBinding>>()?
                                ;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDataAttributeBindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.data_attribute_binding_id.is_empty() {
            state.serialize_entry("dataAttributeBindingId", &self.data_attribute_binding_id)?;
        }
        if self.data_attribute_binding.is_some() {
            state.serialize_entry("dataAttributeBinding", &self.data_attribute_binding)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update DataAttributeBinding request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDataAttributeBindingRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in `update_mask` are updated.
    pub data_attribute_binding: std::option::Option<crate::model::DataAttributeBinding>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataAttributeBindingRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDataAttributeBindingRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_attribute_binding][crate::model::UpdateDataAttributeBindingRequest::data_attribute_binding].
    pub fn set_data_attribute_binding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataAttributeBinding>,
    {
        self.data_attribute_binding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_attribute_binding][crate::model::UpdateDataAttributeBindingRequest::data_attribute_binding].
    pub fn set_or_clear_data_attribute_binding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataAttributeBinding>,
    {
        self.data_attribute_binding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataAttributeBindingRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataAttributeBindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDataAttributeBindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __data_attribute_binding,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDataAttributeBindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "dataAttributeBinding" => Ok(__FieldTag::__data_attribute_binding),
                            "data_attribute_binding" => Ok(__FieldTag::__data_attribute_binding),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDataAttributeBindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDataAttributeBindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__data_attribute_binding => {
                            if !fields.insert(__FieldTag::__data_attribute_binding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attribute_binding",
                                ));
                            }
                            result.data_attribute_binding = map.next_value::<std::option::Option<crate::model::DataAttributeBinding>>()?
                                ;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDataAttributeBindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.data_attribute_binding.is_some() {
            state.serialize_entry("dataAttributeBinding", &self.data_attribute_binding)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get DataAttributeBinding request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDataAttributeBindingRequest {
    /// Required. The resource name of the DataAttributeBinding:
    /// projects/{project_number}/locations/{location_id}/dataAttributeBindings/{data_attribute_binding_id}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataAttributeBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataAttributeBindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDataAttributeBindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDataAttributeBindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDataAttributeBindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDataAttributeBindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDataAttributeBindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List DataAttributeBindings request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataAttributeBindingsRequest {
    /// Required. The resource name of the Location:
    /// projects/{project_number}/locations/{location_id}
    pub parent: std::string::String,

    /// Optional. Maximum number of DataAttributeBindings to return. The service
    /// may return fewer than this value. If unspecified, at most 10
    /// DataAttributeBindings will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataAttributeBindings`
    /// call. Provide this to retrieve the subsequent page. When paginating, all
    /// other parameters provided to `ListDataAttributeBindings` must match the
    /// call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    /// Filter using resource: filter=resource:"resource-name"
    /// Filter using attribute: filter=attributes:"attribute-name"
    /// Filter using attribute in paths list:
    /// filter=paths.attributes:"attribute-name"
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributeBindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataAttributeBindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataAttributeBindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataAttributeBindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataAttributeBindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataAttributeBindingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataAttributeBindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributeBindingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataAttributeBindingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataAttributeBindingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataAttributeBindingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataAttributeBindingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataAttributeBindingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List DataAttributeBindings response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataAttributeBindingsResponse {
    /// DataAttributeBindings under the given parent Location.
    pub data_attribute_bindings: std::vec::Vec<crate::model::DataAttributeBinding>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributeBindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_attribute_bindings][crate::model::ListDataAttributeBindingsResponse::data_attribute_bindings].
    pub fn set_data_attribute_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataAttributeBinding>,
    {
        use std::iter::Iterator;
        self.data_attribute_bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataAttributeBindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListDataAttributeBindingsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataAttributeBindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributeBindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataAttributeBindingsResponse {
    type PageItem = crate::model::DataAttributeBinding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_attribute_bindings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataAttributeBindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_attribute_bindings,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataAttributeBindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataAttributeBindings" => Ok(__FieldTag::__data_attribute_bindings),
                            "data_attribute_bindings" => Ok(__FieldTag::__data_attribute_bindings),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataAttributeBindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataAttributeBindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_attribute_bindings => {
                            if !fields.insert(__FieldTag::__data_attribute_bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_attribute_bindings",
                                ));
                            }
                            result.data_attribute_bindings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataAttributeBinding>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataAttributeBindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_attribute_bindings.is_empty() {
            state.serialize_entry("dataAttributeBindings", &self.data_attribute_bindings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete DataAttributeBinding request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDataAttributeBindingRequest {
    /// Required. The resource name of the DataAttributeBinding:
    /// projects/{project_number}/locations/{location_id}/dataAttributeBindings/{data_attribute_binding_id}
    pub name: std::string::String,

    /// Required. If the client provided etag value does not match the current etag
    /// value, the DeleteDataAttributeBindingRequest method returns an ABORTED
    /// error response. Etags must be used when calling the
    /// DeleteDataAttributeBinding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataAttributeBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDataAttributeBindingRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataAttributeBindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDataAttributeBindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDataAttributeBindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDataAttributeBindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDataAttributeBindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDataAttributeBindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create dataScan request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDataScanRequest {
    /// Required. The resource name of the parent location:
    /// `projects/{project}/locations/{location_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Required. DataScan resource.
    pub data_scan: std::option::Option<crate::model::DataScan>,

    /// Required. DataScan identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the customer project / location.
    pub data_scan_id: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is `false`.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataScanRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_scan][crate::model::CreateDataScanRequest::data_scan].
    pub fn set_data_scan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataScan>,
    {
        self.data_scan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_scan][crate::model::CreateDataScanRequest::data_scan].
    pub fn set_or_clear_data_scan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataScan>,
    {
        self.data_scan = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_scan_id][crate::model::CreateDataScanRequest::data_scan_id].
    pub fn set_data_scan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_scan_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataScanRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataScanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDataScanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __data_scan,
            __data_scan_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDataScanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataScan" => Ok(__FieldTag::__data_scan),
                            "data_scan" => Ok(__FieldTag::__data_scan),
                            "dataScanId" => Ok(__FieldTag::__data_scan_id),
                            "data_scan_id" => Ok(__FieldTag::__data_scan_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDataScanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDataScanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_scan => {
                            if !fields.insert(__FieldTag::__data_scan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_scan",
                                ));
                            }
                            result.data_scan =
                                map.next_value::<std::option::Option<crate::model::DataScan>>()?;
                        }
                        __FieldTag::__data_scan_id => {
                            if !fields.insert(__FieldTag::__data_scan_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_scan_id",
                                ));
                            }
                            result.data_scan_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDataScanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.data_scan.is_some() {
            state.serialize_entry("dataScan", &self.data_scan)?;
        }
        if !self.data_scan_id.is_empty() {
            state.serialize_entry("dataScanId", &self.data_scan_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update dataScan request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDataScanRequest {
    /// Required. DataScan resource to be updated.
    ///
    /// Only fields specified in `update_mask` are updated.
    pub data_scan: std::option::Option<crate::model::DataScan>,

    /// Optional. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is `false`.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_scan][crate::model::UpdateDataScanRequest::data_scan].
    pub fn set_data_scan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataScan>,
    {
        self.data_scan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_scan][crate::model::UpdateDataScanRequest::data_scan].
    pub fn set_or_clear_data_scan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataScan>,
    {
        self.data_scan = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataScanRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDataScanRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataScanRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataScanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDataScanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_scan,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDataScanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataScan" => Ok(__FieldTag::__data_scan),
                            "data_scan" => Ok(__FieldTag::__data_scan),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDataScanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDataScanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_scan => {
                            if !fields.insert(__FieldTag::__data_scan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_scan",
                                ));
                            }
                            result.data_scan =
                                map.next_value::<std::option::Option<crate::model::DataScan>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDataScanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.data_scan.is_some() {
            state.serialize_entry("dataScan", &self.data_scan)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete dataScan request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDataScanRequest {
    /// Required. The resource name of the dataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Optional. If set to true, any child resources of this data scan will also
    /// be deleted. (Otherwise, the request will only work if the data scan has no
    /// child resources.)
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataScanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteDataScanRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataScanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDataScanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDataScanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDataScanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDataScanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDataScanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get dataScan request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDataScanRequest {
    /// Required. The resource name of the dataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Optional. Select the DataScan view to return. Defaults to `BASIC`.
    pub view: crate::model::get_data_scan_request::DataScanView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataScanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetDataScanRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_data_scan_request::DataScanView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataScanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDataScanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDataScanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDataScanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDataScanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::get_data_scan_request::DataScanView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDataScanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GetDataScanRequest].
pub mod get_data_scan_request {
    #[allow(unused_imports)]
    use super::*;

    /// DataScan view options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataScanView {
        /// The API will default to the `BASIC` view.
        Unspecified,
        /// Basic view that does not include *spec* and *result*.
        Basic,
        /// Include everything.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataScanView::value] or
        /// [DataScanView::name].
        UnknownValue(data_scan_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_scan_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataScanView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SCAN_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataScanView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataScanView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataScanView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                10 => Self::Full,
                _ => Self::UnknownValue(data_scan_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataScanView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SCAN_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(data_scan_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataScanView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataScanView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataScanView>::new(
                ".google.cloud.dataplex.v1.GetDataScanRequest.DataScanView",
            ))
        }
    }
}

/// List dataScans request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataScansRequest {
    /// Required. The resource name of the parent location:
    /// `projects/{project}/locations/{location_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Optional. Maximum number of dataScans to return. The service may return
    /// fewer than this value. If unspecified, at most 500 scans will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataScans` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListDataScans` must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields (`name` or `create_time`) for the result.
    /// If not specified, the ordering is undefined.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataScansRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataScansRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataScansRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataScansRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataScansRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataScansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScansRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataScansRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataScansRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataScansRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataScansRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataScansRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List dataScans response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataScansResponse {
    /// DataScans (`BASIC` view only) under the given parent location.
    pub data_scans: std::vec::Vec<crate::model::DataScan>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScansResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_scans][crate::model::ListDataScansResponse::data_scans].
    pub fn set_data_scans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataScan>,
    {
        use std::iter::Iterator;
        self.data_scans = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataScansResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDataScansResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataScansResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScansResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataScansResponse {
    type PageItem = crate::model::DataScan;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_scans
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataScansResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_scans,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataScansResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataScans" => Ok(__FieldTag::__data_scans),
                            "data_scans" => Ok(__FieldTag::__data_scans),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataScansResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataScansResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_scans => {
                            if !fields.insert(__FieldTag::__data_scans) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_scans",
                                ));
                            }
                            result.data_scans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataScan>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataScansResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_scans.is_empty() {
            state.serialize_entry("dataScans", &self.data_scans)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Run DataScan Request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunDataScanRequest {
    /// Required. The resource name of the DataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`.
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    ///
    /// Only **OnDemand** data scans are allowed.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunDataScanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RunDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunDataScanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunDataScanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunDataScanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunDataScanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunDataScanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunDataScanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Run DataScan Response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunDataScanResponse {
    /// DataScanJob created by RunDataScan request.
    pub job: std::option::Option<crate::model::DataScanJob>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunDataScanResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::RunDataScanResponse::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataScanJob>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::RunDataScanResponse::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataScanJob>,
    {
        self.job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RunDataScanResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunDataScanResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunDataScanResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunDataScanResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "job" => Ok(__FieldTag::__job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunDataScanResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunDataScanResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::DataScanJob>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunDataScanResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get DataScanJob request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDataScanJobRequest {
    /// Required. The resource name of the DataScanJob:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}/jobs/{data_scan_job_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Optional. Select the DataScanJob view to return. Defaults to `BASIC`.
    pub view: crate::model::get_data_scan_job_request::DataScanJobView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataScanJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataScanJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetDataScanJobRequest::view].
    pub fn set_view<
        T: std::convert::Into<crate::model::get_data_scan_job_request::DataScanJobView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetDataScanJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataScanJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDataScanJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDataScanJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDataScanJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDataScanJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::get_data_scan_job_request::DataScanJobView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDataScanJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GetDataScanJobRequest].
pub mod get_data_scan_job_request {
    #[allow(unused_imports)]
    use super::*;

    /// DataScanJob view options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataScanJobView {
        /// The API will default to the `BASIC` view.
        Unspecified,
        /// Basic view that does not include *spec* and *result*.
        Basic,
        /// Include everything.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataScanJobView::value] or
        /// [DataScanJobView::name].
        UnknownValue(data_scan_job_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_scan_job_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataScanJobView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SCAN_JOB_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataScanJobView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataScanJobView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataScanJobView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                10 => Self::Full,
                _ => Self::UnknownValue(data_scan_job_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataScanJobView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SCAN_JOB_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(data_scan_job_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataScanJobView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataScanJobView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataScanJobView>::new(
                ".google.cloud.dataplex.v1.GetDataScanJobRequest.DataScanJobView",
            ))
        }
    }
}

/// List DataScanJobs request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataScanJobsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Optional. Maximum number of DataScanJobs to return. The service may return
    /// fewer than this value. If unspecified, at most 10 DataScanJobs will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataScanJobs` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListDataScanJobs` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the ListDataScanJobs
    /// request.
    ///
    /// If unspecified, all datascan jobs will be returned. Multiple filters can be
    /// applied (with `AND`, `OR` logical operators). Filters are case-sensitive.
    ///
    /// Allowed fields are:
    ///
    /// - `start_time`
    /// - `end_time`
    ///
    /// `start_time` and `end_time` expect RFC-3339 formatted strings (e.g.
    /// 2018-10-08T18:30:00-07:00).
    ///
    /// For instance, 'start_time > 2018-10-08T00:00:00.123456789Z AND end_time <
    /// 2018-10-09T00:00:00.123456789Z' limits results to DataScanJobs between
    /// specified start and end times.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScanJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataScanJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataScanJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataScanJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataScanJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDataScanJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScanJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataScanJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataScanJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataScanJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataScanJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataScanJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List DataScanJobs response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataScanJobsResponse {
    /// DataScanJobs (`BASIC` view only) under a given dataScan.
    pub data_scan_jobs: std::vec::Vec<crate::model::DataScanJob>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScanJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_scan_jobs][crate::model::ListDataScanJobsResponse::data_scan_jobs].
    pub fn set_data_scan_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataScanJob>,
    {
        use std::iter::Iterator;
        self.data_scan_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataScanJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataScanJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScanJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataScanJobsResponse {
    type PageItem = crate::model::DataScanJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_scan_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataScanJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_scan_jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataScanJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataScanJobs" => Ok(__FieldTag::__data_scan_jobs),
                            "data_scan_jobs" => Ok(__FieldTag::__data_scan_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataScanJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataScanJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_scan_jobs => {
                            if !fields.insert(__FieldTag::__data_scan_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_scan_jobs",
                                ));
                            }
                            result.data_scan_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataScanJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataScanJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_scan_jobs.is_empty() {
            state.serialize_entry("dataScanJobs", &self.data_scan_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request details for generating data quality rule recommendations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateDataQualityRulesRequest {
    /// Required. The name must be one of the following:
    ///
    /// * The name of a data scan with at least one successful, completed data
    ///   profiling job
    /// * The name of a successful, completed data profiling job (a data scan job
    ///   where the job type is data profiling)
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateDataQualityRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateDataQualityRulesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GenerateDataQualityRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GenerateDataQualityRulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateDataQualityRulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateDataQualityRulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateDataQualityRulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateDataQualityRulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateDataQualityRulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response details for data quality rule recommendations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateDataQualityRulesResponse {
    /// The data quality rules that Dataplex generates based on the results
    /// of a data profiling scan.
    pub rule: std::vec::Vec<crate::model::DataQualityRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateDataQualityRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::GenerateDataQualityRulesResponse::rule].
    pub fn set_rule<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityRule>,
    {
        use std::iter::Iterator;
        self.rule = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerateDataQualityRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GenerateDataQualityRulesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateDataQualityRulesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateDataQualityRulesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rule" => Ok(__FieldTag::__rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateDataQualityRulesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateDataQualityRulesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rule => {
                            if !fields.insert(__FieldTag::__rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule",
                                ));
                            }
                            result.rule =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataQualityRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateDataQualityRulesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rule.is_empty() {
            state.serialize_entry("rule", &self.rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a user-visible job which provides the insights for the related
/// data source.
///
/// For example:
///
/// * Data quality: generates queries based on the rules and runs against the
///   data to get data quality check results. For more information, see [Auto
///   data quality
///   overview](https://cloud.google.com/dataplex/docs/auto-data-quality-overview).
/// * Data profile: analyzes the data in tables and generates insights about
///   the structure, content and relationships (such as null percent,
///   cardinality, min/max/mean, etc). For more information, see [About data
///   profiling](https://cloud.google.com/dataplex/docs/data-profiling-overview).
/// * Data discovery: scans data in Cloud Storage buckets to extract and then
///   catalog metadata. For more information, see [Discover and catalog Cloud
///   Storage data](https://cloud.google.com/bigquery/docs/automatic-discovery).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataScan {
    /// Output only. Identifier. The relative resource name of the scan, of the
    /// form: `projects/{project}/locations/{location_id}/dataScans/{datascan_id}`,
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the scan. This ID will
    /// be different if the scan is deleted and re-created with the same name.
    pub uid: std::string::String,

    /// Optional. Description of the scan.
    ///
    /// * Must be between 1-1024 characters.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    ///
    /// * Must be between 1-256 characters.
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the scan.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Current state of the DataScan.
    pub state: crate::model::State,

    /// Output only. The time when the scan was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the scan was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The data source for DataScan.
    pub data: std::option::Option<crate::model::DataSource>,

    /// Optional. DataScan execution settings.
    ///
    /// If not specified, the fields in it will use their default values.
    pub execution_spec: std::option::Option<crate::model::data_scan::ExecutionSpec>,

    /// Output only. Status of the data scan execution.
    pub execution_status: std::option::Option<crate::model::data_scan::ExecutionStatus>,

    /// Output only. The type of DataScan.
    pub r#type: crate::model::DataScanType,

    /// Data scan related setting.
    /// The settings are required and immutable. After you configure the settings
    /// for one type of data scan, you can't change the data scan to a different
    /// type of data scan.
    pub spec: std::option::Option<crate::model::data_scan::Spec>,

    /// The result of the data scan.
    pub result: std::option::Option<crate::model::data_scan::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataScan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataScan::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataScan::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataScan::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataScan::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataScan::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::DataScan::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataScan::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataScan::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DataScan::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DataScan::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data][crate::model::DataScan::data].
    pub fn set_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSource>,
    {
        self.data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data][crate::model::DataScan::data].
    pub fn set_or_clear_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSource>,
    {
        self.data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [execution_spec][crate::model::DataScan::execution_spec].
    pub fn set_execution_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_scan::ExecutionSpec>,
    {
        self.execution_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_spec][crate::model::DataScan::execution_spec].
    pub fn set_or_clear_execution_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_scan::ExecutionSpec>,
    {
        self.execution_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [execution_status][crate::model::DataScan::execution_status].
    pub fn set_execution_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_scan::ExecutionStatus>,
    {
        self.execution_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_status][crate::model::DataScan::execution_status].
    pub fn set_or_clear_execution_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_scan::ExecutionStatus>,
    {
        self.execution_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::DataScan::type].
    pub fn set_type<T: std::convert::Into<crate::model::DataScanType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::DataScan::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::data_scan::Spec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::DataScan::spec]
    /// if it holds a `DataQualitySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualitySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan::Spec::DataQualitySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScan::spec]
    /// to hold a `DataQualitySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_quality_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan::Spec::DataQualitySpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScan::spec]
    /// if it holds a `DataProfileSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan::Spec::DataProfileSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScan::spec]
    /// to hold a `DataProfileSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_profile_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan::Spec::DataProfileSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScan::spec]
    /// if it holds a `DataDiscoverySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoverySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan::Spec::DataDiscoverySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScan::spec]
    /// to hold a `DataDiscoverySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_discovery_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoverySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan::Spec::DataDiscoverySpec(v.into()));
        self
    }

    /// Sets the value of [result][crate::model::DataScan::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::data_scan::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::DataScan::result]
    /// if it holds a `DataQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualityResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan::Result::DataQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScan::result]
    /// to hold a `DataQualityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan::Result::DataQualityResult(v.into()));
        self
    }

    /// The value of [result][crate::model::DataScan::result]
    /// if it holds a `DataProfileResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan::Result::DataProfileResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScan::result]
    /// to hold a `DataProfileResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_profile_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan::Result::DataProfileResult(v.into()));
        self
    }

    /// The value of [result][crate::model::DataScan::result]
    /// if it holds a `DataDiscoveryResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoveryResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan::Result::DataDiscoveryResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScan::result]
    /// to hold a `DataDiscoveryResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_discovery_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoveryResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan::Result::DataDiscoveryResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataScan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataScan"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataScan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __description,
            __display_name,
            __labels,
            __state,
            __create_time,
            __update_time,
            __data,
            __execution_spec,
            __execution_status,
            __type,
            __data_quality_spec,
            __data_profile_spec,
            __data_discovery_spec,
            __data_quality_result,
            __data_profile_result,
            __data_discovery_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataScan")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "data" => Ok(__FieldTag::__data),
                            "executionSpec" => Ok(__FieldTag::__execution_spec),
                            "execution_spec" => Ok(__FieldTag::__execution_spec),
                            "executionStatus" => Ok(__FieldTag::__execution_status),
                            "execution_status" => Ok(__FieldTag::__execution_status),
                            "type" => Ok(__FieldTag::__type),
                            "dataQualitySpec" => Ok(__FieldTag::__data_quality_spec),
                            "data_quality_spec" => Ok(__FieldTag::__data_quality_spec),
                            "dataProfileSpec" => Ok(__FieldTag::__data_profile_spec),
                            "data_profile_spec" => Ok(__FieldTag::__data_profile_spec),
                            "dataDiscoverySpec" => Ok(__FieldTag::__data_discovery_spec),
                            "data_discovery_spec" => Ok(__FieldTag::__data_discovery_spec),
                            "dataQualityResult" => Ok(__FieldTag::__data_quality_result),
                            "data_quality_result" => Ok(__FieldTag::__data_quality_result),
                            "dataProfileResult" => Ok(__FieldTag::__data_profile_result),
                            "data_profile_result" => Ok(__FieldTag::__data_profile_result),
                            "dataDiscoveryResult" => Ok(__FieldTag::__data_discovery_result),
                            "data_discovery_result" => Ok(__FieldTag::__data_discovery_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataScan;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataScan")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            result.data =
                                map.next_value::<std::option::Option<crate::model::DataSource>>()?;
                        }
                        __FieldTag::__execution_spec => {
                            if !fields.insert(__FieldTag::__execution_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_spec",
                                ));
                            }
                            result.execution_spec = map.next_value::<std::option::Option<crate::model::data_scan::ExecutionSpec>>()?
                                ;
                        }
                        __FieldTag::__execution_status => {
                            if !fields.insert(__FieldTag::__execution_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_status",
                                ));
                            }
                            result.execution_status = map.next_value::<std::option::Option<crate::model::data_scan::ExecutionStatus>>()?
                                ;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::DataScanType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_quality_spec => {
                            if !fields.insert(__FieldTag::__data_quality_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_quality_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.DataScan.data_quality_spec, latest field was dataQualitySpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::data_scan::Spec::DataQualitySpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataQualitySpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_profile_spec => {
                            if !fields.insert(__FieldTag::__data_profile_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.DataScan.data_profile_spec, latest field was dataProfileSpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::data_scan::Spec::DataProfileSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataProfileSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_discovery_spec => {
                            if !fields.insert(__FieldTag::__data_discovery_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_discovery_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.DataScan.data_discovery_spec, latest field was dataDiscoverySpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::data_scan::Spec::DataDiscoverySpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataDiscoverySpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_quality_result => {
                            if !fields.insert(__FieldTag::__data_quality_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_quality_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScan.data_quality_result, latest field was dataQualityResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan::Result::DataQualityResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataQualityResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_profile_result => {
                            if !fields.insert(__FieldTag::__data_profile_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScan.data_profile_result, latest field was dataProfileResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan::Result::DataProfileResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataProfileResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_discovery_result => {
                            if !fields.insert(__FieldTag::__data_discovery_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_discovery_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScan.data_discovery_result, latest field was dataDiscoveryResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan::Result::DataDiscoveryResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataDiscoveryResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataScan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.data.is_some() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.execution_spec.is_some() {
            state.serialize_entry("executionSpec", &self.execution_spec)?;
        }
        if self.execution_status.is_some() {
            state.serialize_entry("executionStatus", &self.execution_status)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.data_quality_spec() {
            state.serialize_entry("dataQualitySpec", value)?;
        }
        if let Some(value) = self.data_profile_spec() {
            state.serialize_entry("dataProfileSpec", value)?;
        }
        if let Some(value) = self.data_discovery_spec() {
            state.serialize_entry("dataDiscoverySpec", value)?;
        }
        if let Some(value) = self.data_quality_result() {
            state.serialize_entry("dataQualityResult", value)?;
        }
        if let Some(value) = self.data_profile_result() {
            state.serialize_entry("dataProfileResult", value)?;
        }
        if let Some(value) = self.data_discovery_result() {
            state.serialize_entry("dataDiscoveryResult", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataScan].
pub mod data_scan {
    #[allow(unused_imports)]
    use super::*;

    /// DataScan execution settings.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExecutionSpec {
        /// Optional. Spec related to how often and when a scan should be triggered.
        ///
        /// If not specified, the default is `OnDemand`, which means the scan will
        /// not run until the user calls `RunDataScan` API.
        pub trigger: std::option::Option<crate::model::Trigger>,

        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        pub incremental: std::option::Option<crate::model::data_scan::execution_spec::Incremental>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trigger][crate::model::data_scan::ExecutionSpec::trigger].
        pub fn set_trigger<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Trigger>,
        {
            self.trigger = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [trigger][crate::model::data_scan::ExecutionSpec::trigger].
        pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Trigger>,
        {
            self.trigger = v.map(|x| x.into());
            self
        }

        /// Sets the value of [incremental][crate::model::data_scan::ExecutionSpec::incremental].
        ///
        /// Note that all the setters affecting `incremental` are mutually
        /// exclusive.
        pub fn set_incremental<
            T: std::convert::Into<
                    std::option::Option<crate::model::data_scan::execution_spec::Incremental>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.incremental = v.into();
            self
        }

        /// The value of [incremental][crate::model::data_scan::ExecutionSpec::incremental]
        /// if it holds a `Field`, `None` if the field is not set or
        /// holds a different branch.
        pub fn field(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.incremental.as_ref().and_then(|v| match v {
                crate::model::data_scan::execution_spec::Incremental::Field(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [incremental][crate::model::data_scan::ExecutionSpec::incremental]
        /// to hold a `Field`.
        ///
        /// Note that all the setters affecting `incremental` are
        /// mutually exclusive.
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.incremental = std::option::Option::Some(
                crate::model::data_scan::execution_spec::Incremental::Field(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ExecutionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScan.ExecutionSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExecutionSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __trigger,
                __field,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExecutionSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trigger" => Ok(__FieldTag::__trigger),
                                "field" => Ok(__FieldTag::__field),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExecutionSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExecutionSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__trigger => {
                                if !fields.insert(__FieldTag::__trigger) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for trigger",
                                    ));
                                }
                                result.trigger =
                                    map.next_value::<std::option::Option<crate::model::Trigger>>()?;
                            }
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                if result.incremental.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `incremental`, a oneof with full ID .google.cloud.dataplex.v1.DataScan.ExecutionSpec.field, latest field was field",
                                    ));
                                }
                                result.incremental = std::option::Option::Some(
                                    crate::model::data_scan::execution_spec::Incremental::Field(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExecutionSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.trigger.is_some() {
                state.serialize_entry("trigger", &self.trigger)?;
            }
            if let Some(value) = self.field() {
                state.serialize_entry("field", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ExecutionSpec].
    pub mod execution_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Incremental {
            /// Immutable. The unnested field (of type *Date* or *Timestamp*) that
            /// contains values which monotonically increase over time.
            ///
            /// If not specified, a data scan will run for all data in the table.
            Field(std::string::String),
        }
    }

    /// Status of the data scan execution.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExecutionStatus {
        /// Optional. The time when the latest DataScanJob started.
        pub latest_job_start_time: std::option::Option<wkt::Timestamp>,

        /// Optional. The time when the latest DataScanJob ended.
        pub latest_job_end_time: std::option::Option<wkt::Timestamp>,

        /// Optional. The time when the DataScanJob execution was created.
        pub latest_job_create_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [latest_job_start_time][crate::model::data_scan::ExecutionStatus::latest_job_start_time].
        pub fn set_latest_job_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.latest_job_start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [latest_job_start_time][crate::model::data_scan::ExecutionStatus::latest_job_start_time].
        pub fn set_or_clear_latest_job_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.latest_job_start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [latest_job_end_time][crate::model::data_scan::ExecutionStatus::latest_job_end_time].
        pub fn set_latest_job_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.latest_job_end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [latest_job_end_time][crate::model::data_scan::ExecutionStatus::latest_job_end_time].
        pub fn set_or_clear_latest_job_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.latest_job_end_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [latest_job_create_time][crate::model::data_scan::ExecutionStatus::latest_job_create_time].
        pub fn set_latest_job_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.latest_job_create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [latest_job_create_time][crate::model::data_scan::ExecutionStatus::latest_job_create_time].
        pub fn set_or_clear_latest_job_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.latest_job_create_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ExecutionStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScan.ExecutionStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExecutionStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __latest_job_start_time,
                __latest_job_end_time,
                __latest_job_create_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExecutionStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "latestJobStartTime" => Ok(__FieldTag::__latest_job_start_time),
                                "latest_job_start_time" => Ok(__FieldTag::__latest_job_start_time),
                                "latestJobEndTime" => Ok(__FieldTag::__latest_job_end_time),
                                "latest_job_end_time" => Ok(__FieldTag::__latest_job_end_time),
                                "latestJobCreateTime" => Ok(__FieldTag::__latest_job_create_time),
                                "latest_job_create_time" => {
                                    Ok(__FieldTag::__latest_job_create_time)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExecutionStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExecutionStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__latest_job_start_time => {
                                if !fields.insert(__FieldTag::__latest_job_start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for latest_job_start_time",
                                    ));
                                }
                                result.latest_job_start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__latest_job_end_time => {
                                if !fields.insert(__FieldTag::__latest_job_end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for latest_job_end_time",
                                    ));
                                }
                                result.latest_job_end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__latest_job_create_time => {
                                if !fields.insert(__FieldTag::__latest_job_create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for latest_job_create_time",
                                    ));
                                }
                                result.latest_job_create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExecutionStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.latest_job_start_time.is_some() {
                state.serialize_entry("latestJobStartTime", &self.latest_job_start_time)?;
            }
            if self.latest_job_end_time.is_some() {
                state.serialize_entry("latestJobEndTime", &self.latest_job_end_time)?;
            }
            if self.latest_job_create_time.is_some() {
                state.serialize_entry("latestJobCreateTime", &self.latest_job_create_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Data scan related setting.
    /// The settings are required and immutable. After you configure the settings
    /// for one type of data scan, you can't change the data scan to a different
    /// type of data scan.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Spec {
        /// Settings for a data quality scan.
        DataQualitySpec(std::boxed::Box<crate::model::DataQualitySpec>),
        /// Settings for a data profile scan.
        DataProfileSpec(std::boxed::Box<crate::model::DataProfileSpec>),
        /// Settings for a data discovery scan.
        DataDiscoverySpec(std::boxed::Box<crate::model::DataDiscoverySpec>),
    }

    /// The result of the data scan.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Output only. The result of a data quality scan.
        DataQualityResult(std::boxed::Box<crate::model::DataQualityResult>),
        /// Output only. The result of a data profile scan.
        DataProfileResult(std::boxed::Box<crate::model::DataProfileResult>),
        /// Output only. The result of a data discovery scan.
        DataDiscoveryResult(std::boxed::Box<crate::model::DataDiscoveryResult>),
    }
}

/// A DataScanJob represents an instance of DataScan execution.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataScanJob {
    /// Output only. Identifier. The relative resource name of the DataScanJob, of
    /// the form:
    /// `projects/{project}/locations/{location_id}/dataScans/{datascan_id}/jobs/{job_id}`,
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the DataScanJob.
    pub uid: std::string::String,

    /// Output only. The time when the DataScanJob was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataScanJob was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataScanJob ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Execution state for the DataScanJob.
    pub state: crate::model::data_scan_job::State,

    /// Output only. Additional information about the current state.
    pub message: std::string::String,

    /// Output only. The type of the parent DataScan.
    pub r#type: crate::model::DataScanType,

    /// Data scan related setting.
    pub spec: std::option::Option<crate::model::data_scan_job::Spec>,

    /// The result of the data scan.
    pub result: std::option::Option<crate::model::data_scan_job::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataScanJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataScanJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataScanJob::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataScanJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataScanJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::DataScanJob::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::DataScanJob::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::DataScanJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::DataScanJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::DataScanJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_scan_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::DataScanJob::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataScanJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::DataScanType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_job::Spec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::DataScanJob::spec]
    /// if it holds a `DataQualitySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualitySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Spec::DataQualitySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec]
    /// to hold a `DataQualitySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_quality_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan_job::Spec::DataQualitySpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScanJob::spec]
    /// if it holds a `DataProfileSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Spec::DataProfileSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec]
    /// to hold a `DataProfileSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_profile_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan_job::Spec::DataProfileSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScanJob::spec]
    /// if it holds a `DataDiscoverySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoverySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Spec::DataDiscoverySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec]
    /// to hold a `DataDiscoverySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_discovery_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoverySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::data_scan_job::Spec::DataDiscoverySpec(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::DataScanJob::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_job::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::DataScanJob::result]
    /// if it holds a `DataQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualityResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Result::DataQualityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanJob::result]
    /// to hold a `DataQualityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan_job::Result::DataQualityResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::DataScanJob::result]
    /// if it holds a `DataProfileResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Result::DataProfileResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanJob::result]
    /// to hold a `DataProfileResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_profile_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan_job::Result::DataProfileResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::DataScanJob::result]
    /// if it holds a `DataDiscoveryResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoveryResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Result::DataDiscoveryResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanJob::result]
    /// to hold a `DataDiscoveryResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_discovery_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoveryResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan_job::Result::DataDiscoveryResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataScanJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataScanJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataScanJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __start_time,
            __end_time,
            __state,
            __message,
            __type,
            __data_quality_spec,
            __data_profile_spec,
            __data_discovery_spec,
            __data_quality_result,
            __data_profile_result,
            __data_discovery_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataScanJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "state" => Ok(__FieldTag::__state),
                            "message" => Ok(__FieldTag::__message),
                            "type" => Ok(__FieldTag::__type),
                            "dataQualitySpec" => Ok(__FieldTag::__data_quality_spec),
                            "data_quality_spec" => Ok(__FieldTag::__data_quality_spec),
                            "dataProfileSpec" => Ok(__FieldTag::__data_profile_spec),
                            "data_profile_spec" => Ok(__FieldTag::__data_profile_spec),
                            "dataDiscoverySpec" => Ok(__FieldTag::__data_discovery_spec),
                            "data_discovery_spec" => Ok(__FieldTag::__data_discovery_spec),
                            "dataQualityResult" => Ok(__FieldTag::__data_quality_result),
                            "data_quality_result" => Ok(__FieldTag::__data_quality_result),
                            "dataProfileResult" => Ok(__FieldTag::__data_profile_result),
                            "data_profile_result" => Ok(__FieldTag::__data_profile_result),
                            "dataDiscoveryResult" => Ok(__FieldTag::__data_discovery_result),
                            "data_discovery_result" => Ok(__FieldTag::__data_discovery_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataScanJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataScanJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::data_scan_job::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::DataScanType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_quality_spec => {
                            if !fields.insert(__FieldTag::__data_quality_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_quality_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.DataScanJob.data_quality_spec, latest field was dataQualitySpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::data_scan_job::Spec::DataQualitySpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataQualitySpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_profile_spec => {
                            if !fields.insert(__FieldTag::__data_profile_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.DataScanJob.data_profile_spec, latest field was dataProfileSpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::data_scan_job::Spec::DataProfileSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataProfileSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_discovery_spec => {
                            if !fields.insert(__FieldTag::__data_discovery_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_discovery_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.dataplex.v1.DataScanJob.data_discovery_spec, latest field was dataDiscoverySpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::data_scan_job::Spec::DataDiscoverySpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataDiscoverySpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_quality_result => {
                            if !fields.insert(__FieldTag::__data_quality_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_quality_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScanJob.data_quality_result, latest field was dataQualityResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan_job::Result::DataQualityResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataQualityResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_profile_result => {
                            if !fields.insert(__FieldTag::__data_profile_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScanJob.data_profile_result, latest field was dataProfileResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan_job::Result::DataProfileResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataProfileResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_discovery_result => {
                            if !fields.insert(__FieldTag::__data_discovery_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_discovery_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScanJob.data_discovery_result, latest field was dataDiscoveryResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan_job::Result::DataDiscoveryResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataDiscoveryResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataScanJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.data_quality_spec() {
            state.serialize_entry("dataQualitySpec", value)?;
        }
        if let Some(value) = self.data_profile_spec() {
            state.serialize_entry("dataProfileSpec", value)?;
        }
        if let Some(value) = self.data_discovery_spec() {
            state.serialize_entry("dataDiscoverySpec", value)?;
        }
        if let Some(value) = self.data_quality_result() {
            state.serialize_entry("dataQualityResult", value)?;
        }
        if let Some(value) = self.data_profile_result() {
            state.serialize_entry("dataProfileResult", value)?;
        }
        if let Some(value) = self.data_discovery_result() {
            state.serialize_entry("dataDiscoveryResult", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataScanJob].
pub mod data_scan_job {
    #[allow(unused_imports)]
    use super::*;

    /// Execution state for the DataScanJob.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The DataScanJob state is unspecified.
        Unspecified,
        /// The DataScanJob is running.
        Running,
        /// The DataScanJob is canceling.
        Canceling,
        /// The DataScanJob cancellation was successful.
        Cancelled,
        /// The DataScanJob completed successfully.
        Succeeded,
        /// The DataScanJob is no longer running due to an error.
        Failed,
        /// The DataScanJob has been created but not started to run yet.
        Pending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Canceling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Pending => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Canceling => std::option::Option::Some("CANCELING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Canceling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                5 => Self::Failed,
                7 => Self::Pending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "CANCELING" => Self::Canceling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Canceling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Pending => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.DataScanJob.State",
            ))
        }
    }

    /// Data scan related setting.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Spec {
        /// Output only. Settings for a data quality scan.
        DataQualitySpec(std::boxed::Box<crate::model::DataQualitySpec>),
        /// Output only. Settings for a data profile scan.
        DataProfileSpec(std::boxed::Box<crate::model::DataProfileSpec>),
        /// Output only. Settings for a data discovery scan.
        DataDiscoverySpec(std::boxed::Box<crate::model::DataDiscoverySpec>),
    }

    /// The result of the data scan.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Output only. The result of a data quality scan.
        DataQualityResult(std::boxed::Box<crate::model::DataQualityResult>),
        /// Output only. The result of a data profile scan.
        DataProfileResult(std::boxed::Box<crate::model::DataProfileResult>),
        /// Output only. The result of a data discovery scan.
        DataDiscoveryResult(std::boxed::Box<crate::model::DataDiscoveryResult>),
    }
}

/// The payload associated with Discovery data processing.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryEvent {
    /// The log message.
    pub message: std::string::String,

    /// The id of the associated lake.
    pub lake_id: std::string::String,

    /// The id of the associated zone.
    pub zone_id: std::string::String,

    /// The id of the associated asset.
    pub asset_id: std::string::String,

    /// The data location associated with the event.
    pub data_location: std::string::String,

    /// The id of the associated datascan for standalone discovery.
    pub datascan_id: std::string::String,

    /// The type of the event being logged.
    pub r#type: crate::model::discovery_event::EventType,

    /// Additional details about the event.
    pub details: std::option::Option<crate::model::discovery_event::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DiscoveryEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [lake_id][crate::model::DiscoveryEvent::lake_id].
    pub fn set_lake_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lake_id = v.into();
        self
    }

    /// Sets the value of [zone_id][crate::model::DiscoveryEvent::zone_id].
    pub fn set_zone_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone_id = v.into();
        self
    }

    /// Sets the value of [asset_id][crate::model::DiscoveryEvent::asset_id].
    pub fn set_asset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_id = v.into();
        self
    }

    /// Sets the value of [data_location][crate::model::DiscoveryEvent::data_location].
    pub fn set_data_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_location = v.into();
        self
    }

    /// Sets the value of [datascan_id][crate::model::DiscoveryEvent::datascan_id].
    pub fn set_datascan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datascan_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DiscoveryEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::discovery_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::discovery_event::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::ConfigDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Config(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Config`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_config<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::ConfigDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Config(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Entity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::EntityDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Entity(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Entity`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_entity<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::EntityDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Entity(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Partition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn partition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::PartitionDetails>>
    {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Partition(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Partition`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_partition<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::PartitionDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Partition(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Action`, `None` if the field is not set or
    /// holds a different branch.
    pub fn action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::ActionDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Action(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Action`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_action<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::ActionDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Action(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::TableDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_table<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::TableDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Table(v.into()));
        self
    }
}

impl wkt::message::Message for DiscoveryEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __lake_id,
            __zone_id,
            __asset_id,
            __data_location,
            __datascan_id,
            __type,
            __config,
            __entity,
            __partition,
            __action,
            __table,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "lakeId" => Ok(__FieldTag::__lake_id),
                            "lake_id" => Ok(__FieldTag::__lake_id),
                            "zoneId" => Ok(__FieldTag::__zone_id),
                            "zone_id" => Ok(__FieldTag::__zone_id),
                            "assetId" => Ok(__FieldTag::__asset_id),
                            "asset_id" => Ok(__FieldTag::__asset_id),
                            "dataLocation" => Ok(__FieldTag::__data_location),
                            "data_location" => Ok(__FieldTag::__data_location),
                            "datascanId" => Ok(__FieldTag::__datascan_id),
                            "datascan_id" => Ok(__FieldTag::__datascan_id),
                            "type" => Ok(__FieldTag::__type),
                            "config" => Ok(__FieldTag::__config),
                            "entity" => Ok(__FieldTag::__entity),
                            "partition" => Ok(__FieldTag::__partition),
                            "action" => Ok(__FieldTag::__action),
                            "table" => Ok(__FieldTag::__table),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lake_id => {
                            if !fields.insert(__FieldTag::__lake_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lake_id",
                                ));
                            }
                            result.lake_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone_id => {
                            if !fields.insert(__FieldTag::__zone_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone_id",
                                ));
                            }
                            result.zone_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_id => {
                            if !fields.insert(__FieldTag::__asset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_id",
                                ));
                            }
                            result.asset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_location => {
                            if !fields.insert(__FieldTag::__data_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_location",
                                ));
                            }
                            result.data_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datascan_id => {
                            if !fields.insert(__FieldTag::__datascan_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datascan_id",
                                ));
                            }
                            result.datascan_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::discovery_event::EventType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.DiscoveryEvent.config, latest field was config",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::discovery_event::Details::Config(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::discovery_event::ConfigDetails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.DiscoveryEvent.entity, latest field was entity",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::discovery_event::Details::Entity(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::discovery_event::EntityDetails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__partition => {
                            if !fields.insert(__FieldTag::__partition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.DiscoveryEvent.partition, latest field was partition",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::discovery_event::Details::Partition(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::discovery_event::PartitionDetails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.DiscoveryEvent.action, latest field was action",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::discovery_event::Details::Action(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::discovery_event::ActionDetails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.DiscoveryEvent.table, latest field was table",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::discovery_event::Details::Table(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::discovery_event::TableDetails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.lake_id.is_empty() {
            state.serialize_entry("lakeId", &self.lake_id)?;
        }
        if !self.zone_id.is_empty() {
            state.serialize_entry("zoneId", &self.zone_id)?;
        }
        if !self.asset_id.is_empty() {
            state.serialize_entry("assetId", &self.asset_id)?;
        }
        if !self.data_location.is_empty() {
            state.serialize_entry("dataLocation", &self.data_location)?;
        }
        if !self.datascan_id.is_empty() {
            state.serialize_entry("datascanId", &self.datascan_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.config() {
            state.serialize_entry("config", value)?;
        }
        if let Some(value) = self.entity() {
            state.serialize_entry("entity", value)?;
        }
        if let Some(value) = self.partition() {
            state.serialize_entry("partition", value)?;
        }
        if let Some(value) = self.action() {
            state.serialize_entry("action", value)?;
        }
        if let Some(value) = self.table() {
            state.serialize_entry("table", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryEvent].
pub mod discovery_event {
    #[allow(unused_imports)]
    use super::*;

    /// Details about configuration events.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConfigDetails {
        /// A list of discovery configuration parameters in effect.
        /// The keys are the field paths within DiscoverySpec.
        /// Eg. includePatterns, excludePatterns, csvOptions.disableTypeInference,
        /// etc.
        pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConfigDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameters][crate::model::discovery_event::ConfigDetails::parameters].
        pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for ConfigDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.ConfigDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConfigDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __parameters,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConfigDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "parameters" => Ok(__FieldTag::__parameters),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConfigDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConfigDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__parameters => {
                                if !fields.insert(__FieldTag::__parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameters",
                                    ));
                                }
                                result.parameters = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConfigDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.parameters.is_empty() {
                state.serialize_entry("parameters", &self.parameters)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details about the entity.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EntityDetails {
        /// The name of the entity resource.
        /// The name is the fully-qualified resource name.
        pub entity: std::string::String,

        /// The type of the entity resource.
        pub r#type: crate::model::discovery_event::EntityType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EntityDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity][crate::model::discovery_event::EntityDetails::entity].
        pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::discovery_event::EntityDetails::type].
        pub fn set_type<T: std::convert::Into<crate::model::discovery_event::EntityType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for EntityDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.EntityDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EntityDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __entity,
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EntityDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "entity" => Ok(__FieldTag::__entity),
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EntityDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EntityDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__entity => {
                                if !fields.insert(__FieldTag::__entity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity",
                                    ));
                                }
                                result.entity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type =
                                    map.next_value::<std::option::Option<
                                        crate::model::discovery_event::EntityType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EntityDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.entity.is_empty() {
                state.serialize_entry("entity", &self.entity)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details about the published table.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TableDetails {
        /// The fully-qualified resource name of the table resource.
        pub table: std::string::String,

        /// The type of the table resource.
        pub r#type: crate::model::discovery_event::TableType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TableDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::discovery_event::TableDetails::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::discovery_event::TableDetails::type].
        pub fn set_type<T: std::convert::Into<crate::model::discovery_event::TableType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for TableDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.TableDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TableDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __table,
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TableDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "table" => Ok(__FieldTag::__table),
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TableDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TableDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type =
                                    map.next_value::<std::option::Option<
                                        crate::model::discovery_event::TableType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TableDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details about the partition.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PartitionDetails {
        /// The name to the partition resource.
        /// The name is the fully-qualified resource name.
        pub partition: std::string::String,

        /// The name to the containing entity resource.
        /// The name is the fully-qualified resource name.
        pub entity: std::string::String,

        /// The type of the containing entity resource.
        pub r#type: crate::model::discovery_event::EntityType,

        /// The locations of the data items (e.g., a Cloud Storage objects) sampled
        /// for metadata inference.
        pub sampled_data_locations: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PartitionDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [partition][crate::model::discovery_event::PartitionDetails::partition].
        pub fn set_partition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.partition = v.into();
            self
        }

        /// Sets the value of [entity][crate::model::discovery_event::PartitionDetails::entity].
        pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::discovery_event::PartitionDetails::type].
        pub fn set_type<T: std::convert::Into<crate::model::discovery_event::EntityType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [sampled_data_locations][crate::model::discovery_event::PartitionDetails::sampled_data_locations].
        pub fn set_sampled_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.sampled_data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PartitionDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.PartitionDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PartitionDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __partition,
                __entity,
                __type,
                __sampled_data_locations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PartitionDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "partition" => Ok(__FieldTag::__partition),
                                "entity" => Ok(__FieldTag::__entity),
                                "type" => Ok(__FieldTag::__type),
                                "sampledDataLocations" => Ok(__FieldTag::__sampled_data_locations),
                                "sampled_data_locations" => {
                                    Ok(__FieldTag::__sampled_data_locations)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PartitionDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PartitionDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__partition => {
                                if !fields.insert(__FieldTag::__partition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for partition",
                                    ));
                                }
                                result.partition = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__entity => {
                                if !fields.insert(__FieldTag::__entity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity",
                                    ));
                                }
                                result.entity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type =
                                    map.next_value::<std::option::Option<
                                        crate::model::discovery_event::EntityType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__sampled_data_locations => {
                                if !fields.insert(__FieldTag::__sampled_data_locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sampled_data_locations",
                                    ));
                                }
                                result.sampled_data_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PartitionDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.partition.is_empty() {
                state.serialize_entry("partition", &self.partition)?;
            }
            if !self.entity.is_empty() {
                state.serialize_entry("entity", &self.entity)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.sampled_data_locations.is_empty() {
                state.serialize_entry("sampledDataLocations", &self.sampled_data_locations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details about the action.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ActionDetails {
        /// The type of action.
        /// Eg. IncompatibleDataSchema, InvalidDataFormat
        pub r#type: std::string::String,

        /// The human readable issue associated with the action.
        pub issue: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ActionDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::discovery_event::ActionDetails::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [issue][crate::model::discovery_event::ActionDetails::issue].
        pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.issue = v.into();
            self
        }
    }

    impl wkt::message::Message for ActionDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.ActionDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ActionDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __issue,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ActionDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "issue" => Ok(__FieldTag::__issue),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ActionDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ActionDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__issue => {
                                if !fields.insert(__FieldTag::__issue) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for issue",
                                    ));
                                }
                                result.issue = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ActionDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.issue.is_empty() {
                state.serialize_entry("issue", &self.issue)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The type of the event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// An event representing discovery configuration in effect.
        Config,
        /// An event representing a metadata entity being created.
        EntityCreated,
        /// An event representing a metadata entity being updated.
        EntityUpdated,
        /// An event representing a metadata entity being deleted.
        EntityDeleted,
        /// An event representing a partition being created.
        PartitionCreated,
        /// An event representing a partition being updated.
        PartitionUpdated,
        /// An event representing a partition being deleted.
        PartitionDeleted,
        /// An event representing a table being published.
        TablePublished,
        /// An event representing a table being updated.
        TableUpdated,
        /// An event representing a table being skipped in publishing.
        TableIgnored,
        /// An event representing a table being deleted.
        TableDeleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Config => std::option::Option::Some(1),
                Self::EntityCreated => std::option::Option::Some(2),
                Self::EntityUpdated => std::option::Option::Some(3),
                Self::EntityDeleted => std::option::Option::Some(4),
                Self::PartitionCreated => std::option::Option::Some(5),
                Self::PartitionUpdated => std::option::Option::Some(6),
                Self::PartitionDeleted => std::option::Option::Some(7),
                Self::TablePublished => std::option::Option::Some(10),
                Self::TableUpdated => std::option::Option::Some(11),
                Self::TableIgnored => std::option::Option::Some(12),
                Self::TableDeleted => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::Config => std::option::Option::Some("CONFIG"),
                Self::EntityCreated => std::option::Option::Some("ENTITY_CREATED"),
                Self::EntityUpdated => std::option::Option::Some("ENTITY_UPDATED"),
                Self::EntityDeleted => std::option::Option::Some("ENTITY_DELETED"),
                Self::PartitionCreated => std::option::Option::Some("PARTITION_CREATED"),
                Self::PartitionUpdated => std::option::Option::Some("PARTITION_UPDATED"),
                Self::PartitionDeleted => std::option::Option::Some("PARTITION_DELETED"),
                Self::TablePublished => std::option::Option::Some("TABLE_PUBLISHED"),
                Self::TableUpdated => std::option::Option::Some("TABLE_UPDATED"),
                Self::TableIgnored => std::option::Option::Some("TABLE_IGNORED"),
                Self::TableDeleted => std::option::Option::Some("TABLE_DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Config,
                2 => Self::EntityCreated,
                3 => Self::EntityUpdated,
                4 => Self::EntityDeleted,
                5 => Self::PartitionCreated,
                6 => Self::PartitionUpdated,
                7 => Self::PartitionDeleted,
                10 => Self::TablePublished,
                11 => Self::TableUpdated,
                12 => Self::TableIgnored,
                13 => Self::TableDeleted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CONFIG" => Self::Config,
                "ENTITY_CREATED" => Self::EntityCreated,
                "ENTITY_UPDATED" => Self::EntityUpdated,
                "ENTITY_DELETED" => Self::EntityDeleted,
                "PARTITION_CREATED" => Self::PartitionCreated,
                "PARTITION_UPDATED" => Self::PartitionUpdated,
                "PARTITION_DELETED" => Self::PartitionDeleted,
                "TABLE_PUBLISHED" => Self::TablePublished,
                "TABLE_UPDATED" => Self::TableUpdated,
                "TABLE_IGNORED" => Self::TableIgnored,
                "TABLE_DELETED" => Self::TableDeleted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Config => serializer.serialize_i32(1),
                Self::EntityCreated => serializer.serialize_i32(2),
                Self::EntityUpdated => serializer.serialize_i32(3),
                Self::EntityDeleted => serializer.serialize_i32(4),
                Self::PartitionCreated => serializer.serialize_i32(5),
                Self::PartitionUpdated => serializer.serialize_i32(6),
                Self::PartitionDeleted => serializer.serialize_i32(7),
                Self::TablePublished => serializer.serialize_i32(10),
                Self::TableUpdated => serializer.serialize_i32(11),
                Self::TableIgnored => serializer.serialize_i32(12),
                Self::TableDeleted => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.DiscoveryEvent.EventType",
            ))
        }
    }

    /// The type of the entity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityType {
        /// An unspecified event type.
        Unspecified,
        /// Entities representing structured data.
        Table,
        /// Entities representing unstructured data.
        Fileset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityType::value] or
        /// [EntityType::name].
        UnknownValue(entity_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod entity_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EntityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Table => std::option::Option::Some(1),
                Self::Fileset => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_TYPE_UNSPECIFIED"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Fileset => std::option::Option::Some("FILESET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EntityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EntityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EntityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Table,
                2 => Self::Fileset,
                _ => Self::UnknownValue(entity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EntityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TABLE" => Self::Table,
                "FILESET" => Self::Fileset,
                _ => Self::UnknownValue(entity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EntityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Table => serializer.serialize_i32(1),
                Self::Fileset => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EntityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityType>::new(
                ".google.cloud.dataplex.v1.DiscoveryEvent.EntityType",
            ))
        }
    }

    /// The type of the published table.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TableType {
        /// An unspecified table type.
        Unspecified,
        /// External table type.
        ExternalTable,
        /// BigLake table type.
        BiglakeTable,
        /// Object table type for unstructured data.
        ObjectTable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TableType::value] or
        /// [TableType::name].
        UnknownValue(table_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod table_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TableType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ExternalTable => std::option::Option::Some(1),
                Self::BiglakeTable => std::option::Option::Some(2),
                Self::ObjectTable => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TABLE_TYPE_UNSPECIFIED"),
                Self::ExternalTable => std::option::Option::Some("EXTERNAL_TABLE"),
                Self::BiglakeTable => std::option::Option::Some("BIGLAKE_TABLE"),
                Self::ObjectTable => std::option::Option::Some("OBJECT_TABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TableType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TableType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TableType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ExternalTable,
                2 => Self::BiglakeTable,
                3 => Self::ObjectTable,
                _ => Self::UnknownValue(table_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TableType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EXTERNAL_TABLE" => Self::ExternalTable,
                "BIGLAKE_TABLE" => Self::BiglakeTable,
                "OBJECT_TABLE" => Self::ObjectTable,
                _ => Self::UnknownValue(table_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TableType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ExternalTable => serializer.serialize_i32(1),
                Self::BiglakeTable => serializer.serialize_i32(2),
                Self::ObjectTable => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TableType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableType>::new(
                ".google.cloud.dataplex.v1.DiscoveryEvent.TableType",
            ))
        }
    }

    /// Additional details about the event.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Details about discovery configuration in effect.
        Config(std::boxed::Box<crate::model::discovery_event::ConfigDetails>),
        /// Details about the entity associated with the event.
        Entity(std::boxed::Box<crate::model::discovery_event::EntityDetails>),
        /// Details about the partition associated with the event.
        Partition(std::boxed::Box<crate::model::discovery_event::PartitionDetails>),
        /// Details about the action associated with the event.
        Action(std::boxed::Box<crate::model::discovery_event::ActionDetails>),
        /// Details about the BigQuery table publishing associated with the event.
        Table(std::boxed::Box<crate::model::discovery_event::TableDetails>),
    }
}

/// The payload associated with Job logs that contains events describing jobs
/// that have run within a Lake.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JobEvent {
    /// The log message.
    pub message: std::string::String,

    /// The unique id identifying the job.
    pub job_id: std::string::String,

    /// The time when the job started running.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time when the job ended running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The job state on completion.
    pub state: crate::model::job_event::State,

    /// The number of retries.
    pub retries: i32,

    /// The type of the job.
    pub r#type: crate::model::job_event::Type,

    /// The service used to execute the job.
    pub service: crate::model::job_event::Service,

    /// The reference to the job within the service.
    pub service_job: std::string::String,

    /// Job execution trigger.
    pub execution_trigger: crate::model::job_event::ExecutionTrigger,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::JobEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::JobEvent::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::JobEvent::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::JobEvent::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::JobEvent::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::JobEvent::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::JobEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::job_event::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [retries][crate::model::JobEvent::retries].
    pub fn set_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retries = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::JobEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::job_event::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [service][crate::model::JobEvent::service].
    pub fn set_service<T: std::convert::Into<crate::model::job_event::Service>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [service_job][crate::model::JobEvent::service_job].
    pub fn set_service_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_job = v.into();
        self
    }

    /// Sets the value of [execution_trigger][crate::model::JobEvent::execution_trigger].
    pub fn set_execution_trigger<
        T: std::convert::Into<crate::model::job_event::ExecutionTrigger>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_trigger = v.into();
        self
    }
}

impl wkt::message::Message for JobEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.JobEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __job_id,
            __start_time,
            __end_time,
            __state,
            __retries,
            __type,
            __service,
            __service_job,
            __execution_trigger,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "state" => Ok(__FieldTag::__state),
                            "retries" => Ok(__FieldTag::__retries),
                            "type" => Ok(__FieldTag::__type),
                            "service" => Ok(__FieldTag::__service),
                            "serviceJob" => Ok(__FieldTag::__service_job),
                            "service_job" => Ok(__FieldTag::__service_job),
                            "executionTrigger" => Ok(__FieldTag::__execution_trigger),
                            "execution_trigger" => Ok(__FieldTag::__execution_trigger),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::job_event::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retries => {
                            if !fields.insert(__FieldTag::__retries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retries",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retries = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::job_event::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map.next_value::<std::option::Option<crate::model::job_event::Service>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_job => {
                            if !fields.insert(__FieldTag::__service_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_job",
                                ));
                            }
                            result.service_job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_trigger => {
                            if !fields.insert(__FieldTag::__execution_trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_trigger",
                                ));
                            }
                            result.execution_trigger = map.next_value::<std::option::Option<crate::model::job_event::ExecutionTrigger>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.retries) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retries", &__With(&self.retries))?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.service) {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.service_job.is_empty() {
            state.serialize_entry("serviceJob", &self.service_job)?;
        }
        if !wkt::internal::is_default(&self.execution_trigger) {
            state.serialize_entry("executionTrigger", &self.execution_trigger)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [JobEvent].
pub mod job_event {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified job type.
        Unspecified,
        /// Spark jobs.
        Spark,
        /// Notebook jobs.
        Notebook,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Spark => std::option::Option::Some(1),
                Self::Notebook => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Spark => std::option::Option::Some("SPARK"),
                Self::Notebook => std::option::Option::Some("NOTEBOOK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Spark,
                2 => Self::Notebook,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "SPARK" => Self::Spark,
                "NOTEBOOK" => Self::Notebook,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Spark => serializer.serialize_i32(1),
                Self::Notebook => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.JobEvent.Type",
            ))
        }
    }

    /// The completion status of the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified job state.
        Unspecified,
        /// Job successfully completed.
        Succeeded,
        /// Job was unsuccessful.
        Failed,
        /// Job was cancelled by the user.
        Cancelled,
        /// Job was cancelled or aborted via the service executing the job.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Aborted => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                3 => Self::Cancelled,
                4 => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Aborted => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.JobEvent.State",
            ))
        }
    }

    /// The service used to execute the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Service {
        /// Unspecified service.
        Unspecified,
        /// Cloud Dataproc.
        Dataproc,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Service::value] or
        /// [Service::name].
        UnknownValue(service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Service {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dataproc => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_UNSPECIFIED"),
                Self::Dataproc => std::option::Option::Some("DATAPROC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Service {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Service {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Service {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Service {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_UNSPECIFIED" => Self::Unspecified,
                "DATAPROC" => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Service {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dataproc => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Service {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Service>::new(
                ".google.cloud.dataplex.v1.JobEvent.Service",
            ))
        }
    }

    /// Job Execution trigger.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionTrigger {
        /// The job execution trigger is unspecified.
        Unspecified,
        /// The job was triggered by Dataplex based on trigger spec from task
        /// definition.
        TaskConfig,
        /// The job was triggered by the explicit call of Task API.
        RunRequest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionTrigger::value] or
        /// [ExecutionTrigger::name].
        UnknownValue(execution_trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionTrigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TaskConfig => std::option::Option::Some(1),
                Self::RunRequest => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXECUTION_TRIGGER_UNSPECIFIED"),
                Self::TaskConfig => std::option::Option::Some("TASK_CONFIG"),
                Self::RunRequest => std::option::Option::Some("RUN_REQUEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionTrigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionTrigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionTrigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TaskConfig,
                2 => Self::RunRequest,
                _ => Self::UnknownValue(execution_trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionTrigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "TASK_CONFIG" => Self::TaskConfig,
                "RUN_REQUEST" => Self::RunRequest,
                _ => Self::UnknownValue(execution_trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionTrigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TaskConfig => serializer.serialize_i32(1),
                Self::RunRequest => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionTrigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionTrigger>::new(
                ".google.cloud.dataplex.v1.JobEvent.ExecutionTrigger",
            ))
        }
    }
}

/// These messages contain information about sessions within an environment.
/// The monitored resource is 'Environment'.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SessionEvent {
    /// The log message.
    pub message: std::string::String,

    /// The information about the user that created the session. It will be the
    /// email address of the user.
    pub user_id: std::string::String,

    /// Unique identifier for the session.
    pub session_id: std::string::String,

    /// The type of the event.
    pub r#type: crate::model::session_event::EventType,

    /// The status of the event.
    pub event_succeeded: bool,

    /// If the session is associated with an environment with fast startup enabled,
    /// and was created before being assigned to a user.
    pub fast_startup_enabled: bool,

    /// The idle duration of a warm pooled session before it is assigned to user.
    pub unassigned_duration: std::option::Option<wkt::Duration>,

    /// Additional information about the Query metadata.
    pub detail: std::option::Option<crate::model::session_event::Detail>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SessionEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::SessionEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::SessionEvent::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [session_id][crate::model::SessionEvent::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SessionEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::session_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [event_succeeded][crate::model::SessionEvent::event_succeeded].
    pub fn set_event_succeeded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.event_succeeded = v.into();
        self
    }

    /// Sets the value of [fast_startup_enabled][crate::model::SessionEvent::fast_startup_enabled].
    pub fn set_fast_startup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fast_startup_enabled = v.into();
        self
    }

    /// Sets the value of [unassigned_duration][crate::model::SessionEvent::unassigned_duration].
    pub fn set_unassigned_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.unassigned_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [unassigned_duration][crate::model::SessionEvent::unassigned_duration].
    pub fn set_or_clear_unassigned_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.unassigned_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [detail][crate::model::SessionEvent::detail].
    ///
    /// Note that all the setters affecting `detail` are mutually
    /// exclusive.
    pub fn set_detail<
        T: std::convert::Into<std::option::Option<crate::model::session_event::Detail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detail = v.into();
        self
    }

    /// The value of [detail][crate::model::SessionEvent::detail]
    /// if it holds a `Query`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::session_event::QueryDetail>> {
        #[allow(unreachable_patterns)]
        self.detail.as_ref().and_then(|v| match v {
            crate::model::session_event::Detail::Query(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [detail][crate::model::SessionEvent::detail]
    /// to hold a `Query`.
    ///
    /// Note that all the setters affecting `detail` are
    /// mutually exclusive.
    pub fn set_query<
        T: std::convert::Into<std::boxed::Box<crate::model::session_event::QueryDetail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detail =
            std::option::Option::Some(crate::model::session_event::Detail::Query(v.into()));
        self
    }
}

impl wkt::message::Message for SessionEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SessionEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SessionEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __user_id,
            __session_id,
            __type,
            __query,
            __event_succeeded,
            __fast_startup_enabled,
            __unassigned_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            "type" => Ok(__FieldTag::__type),
                            "query" => Ok(__FieldTag::__query),
                            "eventSucceeded" => Ok(__FieldTag::__event_succeeded),
                            "event_succeeded" => Ok(__FieldTag::__event_succeeded),
                            "fastStartupEnabled" => Ok(__FieldTag::__fast_startup_enabled),
                            "fast_startup_enabled" => Ok(__FieldTag::__fast_startup_enabled),
                            "unassignedDuration" => Ok(__FieldTag::__unassigned_duration),
                            "unassigned_duration" => Ok(__FieldTag::__unassigned_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SessionEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            result.user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_id",
                                ));
                            }
                            result.session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::session_event::EventType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            if result.detail.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `detail`, a oneof with full ID .google.cloud.dataplex.v1.SessionEvent.query, latest field was query",
                                ));
                            }
                            result.detail = std::option::Option::Some(
                                crate::model::session_event::Detail::Query(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::session_event::QueryDetail>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__event_succeeded => {
                            if !fields.insert(__FieldTag::__event_succeeded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_succeeded",
                                ));
                            }
                            result.event_succeeded = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fast_startup_enabled => {
                            if !fields.insert(__FieldTag::__fast_startup_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fast_startup_enabled",
                                ));
                            }
                            result.fast_startup_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unassigned_duration => {
                            if !fields.insert(__FieldTag::__unassigned_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unassigned_duration",
                                ));
                            }
                            result.unassigned_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SessionEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.user_id.is_empty() {
            state.serialize_entry("userId", &self.user_id)?;
        }
        if !self.session_id.is_empty() {
            state.serialize_entry("sessionId", &self.session_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.query() {
            state.serialize_entry("query", value)?;
        }
        if !wkt::internal::is_default(&self.event_succeeded) {
            state.serialize_entry("eventSucceeded", &self.event_succeeded)?;
        }
        if !wkt::internal::is_default(&self.fast_startup_enabled) {
            state.serialize_entry("fastStartupEnabled", &self.fast_startup_enabled)?;
        }
        if self.unassigned_duration.is_some() {
            state.serialize_entry("unassignedDuration", &self.unassigned_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SessionEvent].
pub mod session_event {
    #[allow(unused_imports)]
    use super::*;

    /// Execution details of the query.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryDetail {
        /// The unique Query id identifying the query.
        pub query_id: std::string::String,

        /// The query text executed.
        pub query_text: std::string::String,

        /// Query Execution engine.
        pub engine: crate::model::session_event::query_detail::Engine,

        /// Time taken for execution of the query.
        pub duration: std::option::Option<wkt::Duration>,

        /// The size of results the query produced.
        pub result_size_bytes: i64,

        /// The data processed by the query.
        pub data_processed_bytes: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_id][crate::model::session_event::QueryDetail::query_id].
        pub fn set_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query_id = v.into();
            self
        }

        /// Sets the value of [query_text][crate::model::session_event::QueryDetail::query_text].
        pub fn set_query_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query_text = v.into();
            self
        }

        /// Sets the value of [engine][crate::model::session_event::QueryDetail::engine].
        pub fn set_engine<
            T: std::convert::Into<crate::model::session_event::query_detail::Engine>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.engine = v.into();
            self
        }

        /// Sets the value of [duration][crate::model::session_event::QueryDetail::duration].
        pub fn set_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [duration][crate::model::session_event::QueryDetail::duration].
        pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [result_size_bytes][crate::model::session_event::QueryDetail::result_size_bytes].
        pub fn set_result_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.result_size_bytes = v.into();
            self
        }

        /// Sets the value of [data_processed_bytes][crate::model::session_event::QueryDetail::data_processed_bytes].
        pub fn set_data_processed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.data_processed_bytes = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.SessionEvent.QueryDetail"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueryDetail {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __query_id,
                __query_text,
                __engine,
                __duration,
                __result_size_bytes,
                __data_processed_bytes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueryDetail")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "queryId" => Ok(__FieldTag::__query_id),
                                "query_id" => Ok(__FieldTag::__query_id),
                                "queryText" => Ok(__FieldTag::__query_text),
                                "query_text" => Ok(__FieldTag::__query_text),
                                "engine" => Ok(__FieldTag::__engine),
                                "duration" => Ok(__FieldTag::__duration),
                                "resultSizeBytes" => Ok(__FieldTag::__result_size_bytes),
                                "result_size_bytes" => Ok(__FieldTag::__result_size_bytes),
                                "dataProcessedBytes" => Ok(__FieldTag::__data_processed_bytes),
                                "data_processed_bytes" => Ok(__FieldTag::__data_processed_bytes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueryDetail;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueryDetail")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__query_id => {
                                if !fields.insert(__FieldTag::__query_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_id",
                                    ));
                                }
                                result.query_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__query_text => {
                                if !fields.insert(__FieldTag::__query_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_text",
                                    ));
                                }
                                result.query_text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__engine => {
                                if !fields.insert(__FieldTag::__engine) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for engine",
                                    ));
                                }
                                result.engine = map
                                    .next_value::<std::option::Option<
                                        crate::model::session_event::query_detail::Engine,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__duration => {
                                if !fields.insert(__FieldTag::__duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for duration",
                                    ));
                                }
                                result.duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__result_size_bytes => {
                                if !fields.insert(__FieldTag::__result_size_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for result_size_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.result_size_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__data_processed_bytes => {
                                if !fields.insert(__FieldTag::__data_processed_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_processed_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.data_processed_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueryDetail {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.query_id.is_empty() {
                state.serialize_entry("queryId", &self.query_id)?;
            }
            if !self.query_text.is_empty() {
                state.serialize_entry("queryText", &self.query_text)?;
            }
            if !wkt::internal::is_default(&self.engine) {
                state.serialize_entry("engine", &self.engine)?;
            }
            if self.duration.is_some() {
                state.serialize_entry("duration", &self.duration)?;
            }
            if !wkt::internal::is_default(&self.result_size_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("resultSizeBytes", &__With(&self.result_size_bytes))?;
            }
            if !wkt::internal::is_default(&self.data_processed_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("dataProcessedBytes", &__With(&self.data_processed_bytes))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [QueryDetail].
    pub mod query_detail {
        #[allow(unused_imports)]
        use super::*;

        /// Query Execution engine.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Engine {
            /// An unspecified Engine type.
            Unspecified,
            /// Spark-sql engine is specified in Query.
            SparkSql,
            /// BigQuery engine is specified in Query.
            Bigquery,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Engine::value] or
            /// [Engine::name].
            UnknownValue(engine::UnknownValue),
        }

        #[doc(hidden)]
        pub mod engine {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Engine {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SparkSql => std::option::Option::Some(1),
                    Self::Bigquery => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENGINE_UNSPECIFIED"),
                    Self::SparkSql => std::option::Option::Some("SPARK_SQL"),
                    Self::Bigquery => std::option::Option::Some("BIGQUERY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Engine {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Engine {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Engine {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SparkSql,
                    2 => Self::Bigquery,
                    _ => Self::UnknownValue(engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Engine {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENGINE_UNSPECIFIED" => Self::Unspecified,
                    "SPARK_SQL" => Self::SparkSql,
                    "BIGQUERY" => Self::Bigquery,
                    _ => Self::UnknownValue(engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Engine {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SparkSql => serializer.serialize_i32(1),
                    Self::Bigquery => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Engine {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Engine>::new(
                    ".google.cloud.dataplex.v1.SessionEvent.QueryDetail.Engine",
                ))
            }
        }
    }

    /// The type of the event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// Event when the session is assigned to a user.
        Start,
        /// Event for stop of a session.
        Stop,
        /// Query events in the session.
        Query,
        /// Event for creation of a cluster. It is not yet assigned to a user.
        /// This comes before START in the sequence
        Create,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Start => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::Query => std::option::Option::Some(3),
                Self::Create => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::Start => std::option::Option::Some("START"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::Query => std::option::Option::Some("QUERY"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Start,
                2 => Self::Stop,
                3 => Self::Query,
                4 => Self::Create,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "START" => Self::Start,
                "STOP" => Self::Stop,
                "QUERY" => Self::Query,
                "CREATE" => Self::Create,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Start => serializer.serialize_i32(1),
                Self::Stop => serializer.serialize_i32(2),
                Self::Query => serializer.serialize_i32(3),
                Self::Create => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.SessionEvent.EventType",
            ))
        }
    }

    /// Additional information about the Query metadata.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Detail {
        /// The execution details of the query.
        Query(std::boxed::Box<crate::model::session_event::QueryDetail>),
    }
}

/// Payload associated with Governance related log events.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GovernanceEvent {
    /// The log message.
    pub message: std::string::String,

    /// The type of the event.
    pub event_type: crate::model::governance_event::EventType,

    /// Entity resource information if the log event is associated with a
    /// specific entity.
    pub entity: std::option::Option<crate::model::governance_event::Entity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GovernanceEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::GovernanceEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::GovernanceEvent::event_type].
    pub fn set_event_type<T: std::convert::Into<crate::model::governance_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::GovernanceEvent::entity].
    pub fn set_entity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::governance_event::Entity>,
    {
        self.entity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity][crate::model::GovernanceEvent::entity].
    pub fn set_or_clear_entity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::governance_event::Entity>,
    {
        self.entity = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GovernanceEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GovernanceEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GovernanceEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __event_type,
            __entity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GovernanceEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            "entity" => Ok(__FieldTag::__entity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GovernanceEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GovernanceEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type = map.next_value::<std::option::Option<crate::model::governance_event::EventType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map.next_value::<std::option::Option<crate::model::governance_event::Entity>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GovernanceEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.event_type) {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if self.entity.is_some() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GovernanceEvent].
pub mod governance_event {
    #[allow(unused_imports)]
    use super::*;

    /// Information about Entity resource that the log event is associated with.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Entity {
        /// The Entity resource the log event is associated with.
        /// Format:
        /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`
        pub entity: std::string::String,

        /// Type of entity.
        pub entity_type: crate::model::governance_event::entity::EntityType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Entity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity][crate::model::governance_event::Entity::entity].
        pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity = v.into();
            self
        }

        /// Sets the value of [entity_type][crate::model::governance_event::Entity::entity_type].
        pub fn set_entity_type<
            T: std::convert::Into<crate::model::governance_event::entity::EntityType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entity_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Entity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.GovernanceEvent.Entity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Entity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __entity,
                __entity_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Entity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "entity" => Ok(__FieldTag::__entity),
                                "entityType" => Ok(__FieldTag::__entity_type),
                                "entity_type" => Ok(__FieldTag::__entity_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Entity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Entity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__entity => {
                                if !fields.insert(__FieldTag::__entity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity",
                                    ));
                                }
                                result.entity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__entity_type => {
                                if !fields.insert(__FieldTag::__entity_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_type",
                                    ));
                                }
                                result.entity_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::governance_event::entity::EntityType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Entity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.entity.is_empty() {
                state.serialize_entry("entity", &self.entity)?;
            }
            if !wkt::internal::is_default(&self.entity_type) {
                state.serialize_entry("entityType", &self.entity_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Entity].
    pub mod entity {
        #[allow(unused_imports)]
        use super::*;

        /// Type of entity.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EntityType {
            /// An unspecified Entity type.
            Unspecified,
            /// Table entity type.
            Table,
            /// Fileset entity type.
            Fileset,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EntityType::value] or
            /// [EntityType::name].
            UnknownValue(entity_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod entity_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EntityType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Table => std::option::Option::Some(1),
                    Self::Fileset => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENTITY_TYPE_UNSPECIFIED"),
                    Self::Table => std::option::Option::Some("TABLE"),
                    Self::Fileset => std::option::Option::Some("FILESET"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EntityType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EntityType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EntityType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Table,
                    2 => Self::Fileset,
                    _ => Self::UnknownValue(entity_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EntityType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENTITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "TABLE" => Self::Table,
                    "FILESET" => Self::Fileset,
                    _ => Self::UnknownValue(entity_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EntityType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Table => serializer.serialize_i32(1),
                    Self::Fileset => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EntityType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityType>::new(
                    ".google.cloud.dataplex.v1.GovernanceEvent.Entity.EntityType",
                ))
            }
        }
    }

    /// Type of governance log event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// Resource IAM policy update event.
        ResourceIamPolicyUpdate,
        /// BigQuery table create event.
        BigqueryTableCreate,
        /// BigQuery table update event.
        BigqueryTableUpdate,
        /// BigQuery table delete event.
        BigqueryTableDelete,
        /// BigQuery connection create event.
        BigqueryConnectionCreate,
        /// BigQuery connection update event.
        BigqueryConnectionUpdate,
        /// BigQuery connection delete event.
        BigqueryConnectionDelete,
        /// BigQuery taxonomy created.
        BigqueryTaxonomyCreate,
        /// BigQuery policy tag created.
        BigqueryPolicyTagCreate,
        /// BigQuery policy tag deleted.
        BigqueryPolicyTagDelete,
        /// BigQuery set iam policy for policy tag.
        BigqueryPolicyTagSetIamPolicy,
        /// Access policy update event.
        AccessPolicyUpdate,
        /// Number of resources matched with particular Query.
        GovernanceRuleMatchedResources,
        /// Rule processing exceeds the allowed limit.
        GovernanceRuleSearchLimitExceeds,
        /// Rule processing errors.
        GovernanceRuleErrors,
        /// Governance rule processing Event.
        GovernanceRuleProcessing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceIamPolicyUpdate => std::option::Option::Some(1),
                Self::BigqueryTableCreate => std::option::Option::Some(2),
                Self::BigqueryTableUpdate => std::option::Option::Some(3),
                Self::BigqueryTableDelete => std::option::Option::Some(4),
                Self::BigqueryConnectionCreate => std::option::Option::Some(5),
                Self::BigqueryConnectionUpdate => std::option::Option::Some(6),
                Self::BigqueryConnectionDelete => std::option::Option::Some(7),
                Self::BigqueryTaxonomyCreate => std::option::Option::Some(10),
                Self::BigqueryPolicyTagCreate => std::option::Option::Some(11),
                Self::BigqueryPolicyTagDelete => std::option::Option::Some(12),
                Self::BigqueryPolicyTagSetIamPolicy => std::option::Option::Some(13),
                Self::AccessPolicyUpdate => std::option::Option::Some(14),
                Self::GovernanceRuleMatchedResources => std::option::Option::Some(15),
                Self::GovernanceRuleSearchLimitExceeds => std::option::Option::Some(16),
                Self::GovernanceRuleErrors => std::option::Option::Some(17),
                Self::GovernanceRuleProcessing => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::ResourceIamPolicyUpdate => {
                    std::option::Option::Some("RESOURCE_IAM_POLICY_UPDATE")
                }
                Self::BigqueryTableCreate => std::option::Option::Some("BIGQUERY_TABLE_CREATE"),
                Self::BigqueryTableUpdate => std::option::Option::Some("BIGQUERY_TABLE_UPDATE"),
                Self::BigqueryTableDelete => std::option::Option::Some("BIGQUERY_TABLE_DELETE"),
                Self::BigqueryConnectionCreate => {
                    std::option::Option::Some("BIGQUERY_CONNECTION_CREATE")
                }
                Self::BigqueryConnectionUpdate => {
                    std::option::Option::Some("BIGQUERY_CONNECTION_UPDATE")
                }
                Self::BigqueryConnectionDelete => {
                    std::option::Option::Some("BIGQUERY_CONNECTION_DELETE")
                }
                Self::BigqueryTaxonomyCreate => {
                    std::option::Option::Some("BIGQUERY_TAXONOMY_CREATE")
                }
                Self::BigqueryPolicyTagCreate => {
                    std::option::Option::Some("BIGQUERY_POLICY_TAG_CREATE")
                }
                Self::BigqueryPolicyTagDelete => {
                    std::option::Option::Some("BIGQUERY_POLICY_TAG_DELETE")
                }
                Self::BigqueryPolicyTagSetIamPolicy => {
                    std::option::Option::Some("BIGQUERY_POLICY_TAG_SET_IAM_POLICY")
                }
                Self::AccessPolicyUpdate => std::option::Option::Some("ACCESS_POLICY_UPDATE"),
                Self::GovernanceRuleMatchedResources => {
                    std::option::Option::Some("GOVERNANCE_RULE_MATCHED_RESOURCES")
                }
                Self::GovernanceRuleSearchLimitExceeds => {
                    std::option::Option::Some("GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS")
                }
                Self::GovernanceRuleErrors => std::option::Option::Some("GOVERNANCE_RULE_ERRORS"),
                Self::GovernanceRuleProcessing => {
                    std::option::Option::Some("GOVERNANCE_RULE_PROCESSING")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResourceIamPolicyUpdate,
                2 => Self::BigqueryTableCreate,
                3 => Self::BigqueryTableUpdate,
                4 => Self::BigqueryTableDelete,
                5 => Self::BigqueryConnectionCreate,
                6 => Self::BigqueryConnectionUpdate,
                7 => Self::BigqueryConnectionDelete,
                10 => Self::BigqueryTaxonomyCreate,
                11 => Self::BigqueryPolicyTagCreate,
                12 => Self::BigqueryPolicyTagDelete,
                13 => Self::BigqueryPolicyTagSetIamPolicy,
                14 => Self::AccessPolicyUpdate,
                15 => Self::GovernanceRuleMatchedResources,
                16 => Self::GovernanceRuleSearchLimitExceeds,
                17 => Self::GovernanceRuleErrors,
                18 => Self::GovernanceRuleProcessing,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_IAM_POLICY_UPDATE" => Self::ResourceIamPolicyUpdate,
                "BIGQUERY_TABLE_CREATE" => Self::BigqueryTableCreate,
                "BIGQUERY_TABLE_UPDATE" => Self::BigqueryTableUpdate,
                "BIGQUERY_TABLE_DELETE" => Self::BigqueryTableDelete,
                "BIGQUERY_CONNECTION_CREATE" => Self::BigqueryConnectionCreate,
                "BIGQUERY_CONNECTION_UPDATE" => Self::BigqueryConnectionUpdate,
                "BIGQUERY_CONNECTION_DELETE" => Self::BigqueryConnectionDelete,
                "BIGQUERY_TAXONOMY_CREATE" => Self::BigqueryTaxonomyCreate,
                "BIGQUERY_POLICY_TAG_CREATE" => Self::BigqueryPolicyTagCreate,
                "BIGQUERY_POLICY_TAG_DELETE" => Self::BigqueryPolicyTagDelete,
                "BIGQUERY_POLICY_TAG_SET_IAM_POLICY" => Self::BigqueryPolicyTagSetIamPolicy,
                "ACCESS_POLICY_UPDATE" => Self::AccessPolicyUpdate,
                "GOVERNANCE_RULE_MATCHED_RESOURCES" => Self::GovernanceRuleMatchedResources,
                "GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS" => Self::GovernanceRuleSearchLimitExceeds,
                "GOVERNANCE_RULE_ERRORS" => Self::GovernanceRuleErrors,
                "GOVERNANCE_RULE_PROCESSING" => Self::GovernanceRuleProcessing,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceIamPolicyUpdate => serializer.serialize_i32(1),
                Self::BigqueryTableCreate => serializer.serialize_i32(2),
                Self::BigqueryTableUpdate => serializer.serialize_i32(3),
                Self::BigqueryTableDelete => serializer.serialize_i32(4),
                Self::BigqueryConnectionCreate => serializer.serialize_i32(5),
                Self::BigqueryConnectionUpdate => serializer.serialize_i32(6),
                Self::BigqueryConnectionDelete => serializer.serialize_i32(7),
                Self::BigqueryTaxonomyCreate => serializer.serialize_i32(10),
                Self::BigqueryPolicyTagCreate => serializer.serialize_i32(11),
                Self::BigqueryPolicyTagDelete => serializer.serialize_i32(12),
                Self::BigqueryPolicyTagSetIamPolicy => serializer.serialize_i32(13),
                Self::AccessPolicyUpdate => serializer.serialize_i32(14),
                Self::GovernanceRuleMatchedResources => serializer.serialize_i32(15),
                Self::GovernanceRuleSearchLimitExceeds => serializer.serialize_i32(16),
                Self::GovernanceRuleErrors => serializer.serialize_i32(17),
                Self::GovernanceRuleProcessing => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.GovernanceEvent.EventType",
            ))
        }
    }
}

/// These messages contain information about the execution of a datascan.
/// The monitored resource is 'DataScan'
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataScanEvent {
    /// The data source of the data scan
    pub data_source: std::string::String,

    /// The identifier of the specific data scan job this log entry is for.
    pub job_id: std::string::String,

    /// The time when the data scan job was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the data scan job started to run.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time when the data scan job finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The type of the data scan.
    pub r#type: crate::model::data_scan_event::ScanType,

    /// The status of the data scan job.
    pub state: crate::model::data_scan_event::State,

    /// The message describing the data scan job event.
    pub message: std::string::String,

    /// A version identifier of the spec which was used to execute this job.
    pub spec_version: std::string::String,

    /// The trigger type of the data scan job.
    pub trigger: crate::model::data_scan_event::Trigger,

    /// The scope of the data scan (e.g. full, incremental).
    pub scope: crate::model::data_scan_event::Scope,

    /// The result of post scan actions.
    pub post_scan_actions_result:
        std::option::Option<crate::model::data_scan_event::PostScanActionsResult>,

    /// The result of the data scan job.
    pub result: std::option::Option<crate::model::data_scan_event::Result>,

    /// The applied configs in the data scan job.
    pub applied_configs: std::option::Option<crate::model::data_scan_event::AppliedConfigs>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataScanEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source][crate::model::DataScanEvent::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::DataScanEvent::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataScanEvent::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataScanEvent::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::DataScanEvent::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::DataScanEvent::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::DataScanEvent::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::DataScanEvent::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::DataScanEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::data_scan_event::ScanType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataScanEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_scan_event::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::DataScanEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [spec_version][crate::model::DataScanEvent::spec_version].
    pub fn set_spec_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.spec_version = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::DataScanEvent::trigger].
    pub fn set_trigger<T: std::convert::Into<crate::model::data_scan_event::Trigger>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::DataScanEvent::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::data_scan_event::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [post_scan_actions_result][crate::model::DataScanEvent::post_scan_actions_result].
    pub fn set_post_scan_actions_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_scan_event::PostScanActionsResult>,
    {
        self.post_scan_actions_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [post_scan_actions_result][crate::model::DataScanEvent::post_scan_actions_result].
    pub fn set_or_clear_post_scan_actions_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_scan_event::PostScanActionsResult>,
    {
        self.post_scan_actions_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [result][crate::model::DataScanEvent::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_event::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::DataScanEvent::result]
    /// if it holds a `DataProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_scan_event::DataProfileResult>>
    {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::Result::DataProfile(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanEvent::result]
    /// to hold a `DataProfile`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::data_scan_event::DataProfileResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan_event::Result::DataProfile(v.into()));
        self
    }

    /// The value of [result][crate::model::DataScanEvent::result]
    /// if it holds a `DataQuality`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_scan_event::DataQualityResult>>
    {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::Result::DataQuality(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanEvent::result]
    /// to hold a `DataQuality`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_quality<
        T: std::convert::Into<std::boxed::Box<crate::model::data_scan_event::DataQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan_event::Result::DataQuality(v.into()));
        self
    }

    /// Sets the value of [applied_configs][crate::model::DataScanEvent::applied_configs].
    ///
    /// Note that all the setters affecting `applied_configs` are mutually
    /// exclusive.
    pub fn set_applied_configs<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_event::AppliedConfigs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.applied_configs = v.into();
        self
    }

    /// The value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// if it holds a `DataProfileConfigs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_configs(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_scan_event::DataProfileAppliedConfigs>,
    > {
        #[allow(unreachable_patterns)]
        self.applied_configs.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::AppliedConfigs::DataProfileConfigs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// to hold a `DataProfileConfigs`.
    ///
    /// Note that all the setters affecting `applied_configs` are
    /// mutually exclusive.
    pub fn set_data_profile_configs<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_scan_event::DataProfileAppliedConfigs>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.applied_configs = std::option::Option::Some(
            crate::model::data_scan_event::AppliedConfigs::DataProfileConfigs(v.into()),
        );
        self
    }

    /// The value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// if it holds a `DataQualityConfigs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_configs(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_scan_event::DataQualityAppliedConfigs>,
    > {
        #[allow(unreachable_patterns)]
        self.applied_configs.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::AppliedConfigs::DataQualityConfigs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// to hold a `DataQualityConfigs`.
    ///
    /// Note that all the setters affecting `applied_configs` are
    /// mutually exclusive.
    pub fn set_data_quality_configs<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_scan_event::DataQualityAppliedConfigs>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.applied_configs = std::option::Option::Some(
            crate::model::data_scan_event::AppliedConfigs::DataQualityConfigs(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataScanEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataScanEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_source,
            __job_id,
            __create_time,
            __start_time,
            __end_time,
            __type,
            __state,
            __message,
            __spec_version,
            __trigger,
            __scope,
            __data_profile,
            __data_quality,
            __data_profile_configs,
            __data_quality_configs,
            __post_scan_actions_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataScanEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSource" => Ok(__FieldTag::__data_source),
                            "data_source" => Ok(__FieldTag::__data_source),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "type" => Ok(__FieldTag::__type),
                            "state" => Ok(__FieldTag::__state),
                            "message" => Ok(__FieldTag::__message),
                            "specVersion" => Ok(__FieldTag::__spec_version),
                            "spec_version" => Ok(__FieldTag::__spec_version),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "scope" => Ok(__FieldTag::__scope),
                            "dataProfile" => Ok(__FieldTag::__data_profile),
                            "data_profile" => Ok(__FieldTag::__data_profile),
                            "dataQuality" => Ok(__FieldTag::__data_quality),
                            "data_quality" => Ok(__FieldTag::__data_quality),
                            "dataProfileConfigs" => Ok(__FieldTag::__data_profile_configs),
                            "data_profile_configs" => Ok(__FieldTag::__data_profile_configs),
                            "dataQualityConfigs" => Ok(__FieldTag::__data_quality_configs),
                            "data_quality_configs" => Ok(__FieldTag::__data_quality_configs),
                            "postScanActionsResult" => Ok(__FieldTag::__post_scan_actions_result),
                            "post_scan_actions_result" => {
                                Ok(__FieldTag::__post_scan_actions_result)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataScanEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataScanEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_source => {
                            if !fields.insert(__FieldTag::__data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source",
                                ));
                            }
                            result.data_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::data_scan_event::ScanType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::data_scan_event::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec_version => {
                            if !fields.insert(__FieldTag::__spec_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec_version",
                                ));
                            }
                            result.spec_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map.next_value::<std::option::Option<crate::model::data_scan_event::Trigger>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map.next_value::<std::option::Option<crate::model::data_scan_event::Scope>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_profile => {
                            if !fields.insert(__FieldTag::__data_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScanEvent.data_profile, latest field was dataProfile",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan_event::Result::DataProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_scan_event::DataProfileResult,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_quality => {
                            if !fields.insert(__FieldTag::__data_quality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_quality",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dataplex.v1.DataScanEvent.data_quality, latest field was dataQuality",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::data_scan_event::Result::DataQuality(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_scan_event::DataQualityResult,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_profile_configs => {
                            if !fields.insert(__FieldTag::__data_profile_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_configs",
                                ));
                            }
                            if result.applied_configs.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `applied_configs`, a oneof with full ID .google.cloud.dataplex.v1.DataScanEvent.data_profile_configs, latest field was dataProfileConfigs",
                                ));
                            }
                            result.applied_configs = std::option::Option::Some(
                                crate::model::data_scan_event::AppliedConfigs::DataProfileConfigs(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_scan_event::DataProfileAppliedConfigs>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__data_quality_configs => {
                            if !fields.insert(__FieldTag::__data_quality_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_quality_configs",
                                ));
                            }
                            if result.applied_configs.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `applied_configs`, a oneof with full ID .google.cloud.dataplex.v1.DataScanEvent.data_quality_configs, latest field was dataQualityConfigs",
                                ));
                            }
                            result.applied_configs = std::option::Option::Some(
                                crate::model::data_scan_event::AppliedConfigs::DataQualityConfigs(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_scan_event::DataQualityAppliedConfigs>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__post_scan_actions_result => {
                            if !fields.insert(__FieldTag::__post_scan_actions_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_scan_actions_result",
                                ));
                            }
                            result.post_scan_actions_result = map
                                .next_value::<std::option::Option<
                                    crate::model::data_scan_event::PostScanActionsResult,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataScanEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_source.is_empty() {
            state.serialize_entry("dataSource", &self.data_source)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.spec_version.is_empty() {
            state.serialize_entry("specVersion", &self.spec_version)?;
        }
        if !wkt::internal::is_default(&self.trigger) {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if let Some(value) = self.data_profile() {
            state.serialize_entry("dataProfile", value)?;
        }
        if let Some(value) = self.data_quality() {
            state.serialize_entry("dataQuality", value)?;
        }
        if let Some(value) = self.data_profile_configs() {
            state.serialize_entry("dataProfileConfigs", value)?;
        }
        if let Some(value) = self.data_quality_configs() {
            state.serialize_entry("dataQualityConfigs", value)?;
        }
        if self.post_scan_actions_result.is_some() {
            state.serialize_entry("postScanActionsResult", &self.post_scan_actions_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataScanEvent].
pub mod data_scan_event {
    #[allow(unused_imports)]
    use super::*;

    /// Data profile result for data scan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataProfileResult {
        /// The count of rows processed in the data scan job.
        pub row_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataProfileResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [row_count][crate::model::data_scan_event::DataProfileResult::row_count].
        pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.row_count = v.into();
            self
        }
    }

    impl wkt::message::Message for DataProfileResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataProfileResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataProfileResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __row_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataProfileResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rowCount" => Ok(__FieldTag::__row_count),
                                "row_count" => Ok(__FieldTag::__row_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataProfileResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataProfileResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__row_count => {
                                if !fields.insert(__FieldTag::__row_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for row_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.row_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataProfileResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.row_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("rowCount", &__With(&self.row_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Data quality result for data scan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataQualityResult {
        /// The count of rows processed in the data scan job.
        pub row_count: i64,

        /// Whether the data quality result was `pass` or not.
        pub passed: bool,

        /// The result of each dimension for data quality result.
        /// The key of the map is the name of the dimension.
        /// The value is the bool value depicting whether the dimension result was
        /// `pass` or not.
        pub dimension_passed: std::collections::HashMap<std::string::String, bool>,

        /// The table-level data quality score for the data scan job.
        ///
        /// The data quality score ranges between [0, 100] (up to two decimal
        /// points).
        pub score: f32,

        /// The score of each dimension for data quality result.
        /// The key of the map is the name of the dimension.
        /// The value is the data quality score for the dimension.
        ///
        /// The score ranges between [0, 100] (up to two decimal
        /// points).
        pub dimension_score: std::collections::HashMap<std::string::String, f32>,

        /// The score of each column scanned in the data scan job.
        /// The key of the map is the name of the column.
        /// The value is the data quality score for the column.
        ///
        /// The score ranges between [0, 100] (up to two decimal
        /// points).
        pub column_score: std::collections::HashMap<std::string::String, f32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataQualityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [row_count][crate::model::data_scan_event::DataQualityResult::row_count].
        pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.row_count = v.into();
            self
        }

        /// Sets the value of [passed][crate::model::data_scan_event::DataQualityResult::passed].
        pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.passed = v.into();
            self
        }

        /// Sets the value of [dimension_passed][crate::model::data_scan_event::DataQualityResult::dimension_passed].
        pub fn set_dimension_passed<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<bool>,
        {
            use std::iter::Iterator;
            self.dimension_passed = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [score][crate::model::data_scan_event::DataQualityResult::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [dimension_score][crate::model::data_scan_event::DataQualityResult::dimension_score].
        pub fn set_dimension_score<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.dimension_score = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [column_score][crate::model::data_scan_event::DataQualityResult::column_score].
        pub fn set_column_score<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.column_score = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for DataQualityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataQualityResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataQualityResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __row_count,
                __passed,
                __dimension_passed,
                __score,
                __dimension_score,
                __column_score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataQualityResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rowCount" => Ok(__FieldTag::__row_count),
                                "row_count" => Ok(__FieldTag::__row_count),
                                "passed" => Ok(__FieldTag::__passed),
                                "dimensionPassed" => Ok(__FieldTag::__dimension_passed),
                                "dimension_passed" => Ok(__FieldTag::__dimension_passed),
                                "score" => Ok(__FieldTag::__score),
                                "dimensionScore" => Ok(__FieldTag::__dimension_score),
                                "dimension_score" => Ok(__FieldTag::__dimension_score),
                                "columnScore" => Ok(__FieldTag::__column_score),
                                "column_score" => Ok(__FieldTag::__column_score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataQualityResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataQualityResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__row_count => {
                                if !fields.insert(__FieldTag::__row_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for row_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.row_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__passed => {
                                if !fields.insert(__FieldTag::__passed) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for passed",
                                    ));
                                }
                                result.passed = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dimension_passed => {
                                if !fields.insert(__FieldTag::__dimension_passed) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dimension_passed",
                                    ));
                                }
                                result.dimension_passed = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<std::string::String, bool>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__dimension_score => {
                                if !fields.insert(__FieldTag::__dimension_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dimension_score",
                                    ));
                                }
                                struct __With(
                                    std::option::Option<
                                        std::collections::HashMap<std::string::String, f32>,
                                    >,
                                );
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::collections::HashMap<
                                                    serde_with::Same,
                                                    wkt::internal::F32,
                                                >,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.dimension_score =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__column_score => {
                                if !fields.insert(__FieldTag::__column_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for column_score",
                                    ));
                                }
                                struct __With(
                                    std::option::Option<
                                        std::collections::HashMap<std::string::String, f32>,
                                    >,
                                );
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::collections::HashMap<
                                                    serde_with::Same,
                                                    wkt::internal::F32,
                                                >,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.column_score =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataQualityResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.row_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("rowCount", &__With(&self.row_count))?;
            }
            if !wkt::internal::is_default(&self.passed) {
                state.serialize_entry("passed", &self.passed)?;
            }
            if !self.dimension_passed.is_empty() {
                state.serialize_entry("dimensionPassed", &self.dimension_passed)?;
            }
            if !wkt::internal::is_default(&self.score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !self.dimension_score.is_empty() {
                struct __With<'a>(&'a std::collections::HashMap<std::string::String, f32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<
                            std::collections::HashMap<serde_with::Same, wkt::internal::F32>,
                        >::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("dimensionScore", &__With(&self.dimension_score))?;
            }
            if !self.column_score.is_empty() {
                struct __With<'a>(&'a std::collections::HashMap<std::string::String, f32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<
                            std::collections::HashMap<serde_with::Same, wkt::internal::F32>,
                        >::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("columnScore", &__With(&self.column_score))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Applied configs for data profile type data scan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataProfileAppliedConfigs {
        /// The percentage of the records selected from the dataset for DataScan.
        ///
        /// * Value ranges between 0.0 and 100.0.
        /// * Value 0.0 or 100.0 imply that sampling was not applied.
        pub sampling_percent: f32,

        /// Boolean indicating whether a row filter was applied in the DataScan job.
        pub row_filter_applied: bool,

        /// Boolean indicating whether a column filter was applied in the DataScan
        /// job.
        pub column_filter_applied: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataProfileAppliedConfigs {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sampling_percent][crate::model::data_scan_event::DataProfileAppliedConfigs::sampling_percent].
        pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.sampling_percent = v.into();
            self
        }

        /// Sets the value of [row_filter_applied][crate::model::data_scan_event::DataProfileAppliedConfigs::row_filter_applied].
        pub fn set_row_filter_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.row_filter_applied = v.into();
            self
        }

        /// Sets the value of [column_filter_applied][crate::model::data_scan_event::DataProfileAppliedConfigs::column_filter_applied].
        pub fn set_column_filter_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.column_filter_applied = v.into();
            self
        }
    }

    impl wkt::message::Message for DataProfileAppliedConfigs {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataProfileAppliedConfigs"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataProfileAppliedConfigs {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sampling_percent,
                __row_filter_applied,
                __column_filter_applied,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataProfileAppliedConfigs")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "samplingPercent" => Ok(__FieldTag::__sampling_percent),
                                "sampling_percent" => Ok(__FieldTag::__sampling_percent),
                                "rowFilterApplied" => Ok(__FieldTag::__row_filter_applied),
                                "row_filter_applied" => Ok(__FieldTag::__row_filter_applied),
                                "columnFilterApplied" => Ok(__FieldTag::__column_filter_applied),
                                "column_filter_applied" => Ok(__FieldTag::__column_filter_applied),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataProfileAppliedConfigs;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataProfileAppliedConfigs")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sampling_percent => {
                                if !fields.insert(__FieldTag::__sampling_percent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sampling_percent",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.sampling_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__row_filter_applied => {
                                if !fields.insert(__FieldTag::__row_filter_applied) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for row_filter_applied",
                                    ));
                                }
                                result.row_filter_applied = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__column_filter_applied => {
                                if !fields.insert(__FieldTag::__column_filter_applied) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for column_filter_applied",
                                    ));
                                }
                                result.column_filter_applied = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataProfileAppliedConfigs {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.sampling_percent) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("samplingPercent", &__With(&self.sampling_percent))?;
            }
            if !wkt::internal::is_default(&self.row_filter_applied) {
                state.serialize_entry("rowFilterApplied", &self.row_filter_applied)?;
            }
            if !wkt::internal::is_default(&self.column_filter_applied) {
                state.serialize_entry("columnFilterApplied", &self.column_filter_applied)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Applied configs for data quality type data scan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataQualityAppliedConfigs {
        /// The percentage of the records selected from the dataset for DataScan.
        ///
        /// * Value ranges between 0.0 and 100.0.
        /// * Value 0.0 or 100.0 imply that sampling was not applied.
        pub sampling_percent: f32,

        /// Boolean indicating whether a row filter was applied in the DataScan job.
        pub row_filter_applied: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataQualityAppliedConfigs {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sampling_percent][crate::model::data_scan_event::DataQualityAppliedConfigs::sampling_percent].
        pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.sampling_percent = v.into();
            self
        }

        /// Sets the value of [row_filter_applied][crate::model::data_scan_event::DataQualityAppliedConfigs::row_filter_applied].
        pub fn set_row_filter_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.row_filter_applied = v.into();
            self
        }
    }

    impl wkt::message::Message for DataQualityAppliedConfigs {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataQualityAppliedConfigs"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataQualityAppliedConfigs {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sampling_percent,
                __row_filter_applied,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataQualityAppliedConfigs")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "samplingPercent" => Ok(__FieldTag::__sampling_percent),
                                "sampling_percent" => Ok(__FieldTag::__sampling_percent),
                                "rowFilterApplied" => Ok(__FieldTag::__row_filter_applied),
                                "row_filter_applied" => Ok(__FieldTag::__row_filter_applied),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataQualityAppliedConfigs;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataQualityAppliedConfigs")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sampling_percent => {
                                if !fields.insert(__FieldTag::__sampling_percent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sampling_percent",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.sampling_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__row_filter_applied => {
                                if !fields.insert(__FieldTag::__row_filter_applied) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for row_filter_applied",
                                    ));
                                }
                                result.row_filter_applied = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataQualityAppliedConfigs {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.sampling_percent) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("samplingPercent", &__With(&self.sampling_percent))?;
            }
            if !wkt::internal::is_default(&self.row_filter_applied) {
                state.serialize_entry("rowFilterApplied", &self.row_filter_applied)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Post scan actions result for data scan job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PostScanActionsResult {
        /// The result of BigQuery export post scan action.
        pub bigquery_export_result: std::option::Option<
            crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActionsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export_result][crate::model::data_scan_event::PostScanActionsResult::bigquery_export_result].
        pub fn set_bigquery_export_result<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult,
                >,
        {
            self.bigquery_export_result = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bigquery_export_result][crate::model::data_scan_event::PostScanActionsResult::bigquery_export_result].
        pub fn set_or_clear_bigquery_export_result<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult,
                >,
        {
            self.bigquery_export_result = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PostScanActionsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.PostScanActionsResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PostScanActionsResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bigquery_export_result,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PostScanActionsResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bigqueryExportResult" => Ok(__FieldTag::__bigquery_export_result),
                                "bigquery_export_result" => {
                                    Ok(__FieldTag::__bigquery_export_result)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PostScanActionsResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PostScanActionsResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bigquery_export_result => {
                                if !fields.insert(__FieldTag::__bigquery_export_result) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bigquery_export_result",
                                    ));
                                }
                                result.bigquery_export_result = map.next_value::<std::option::Option<crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PostScanActionsResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.bigquery_export_result.is_some() {
                state.serialize_entry("bigqueryExportResult", &self.bigquery_export_result)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PostScanActionsResult].
    pub mod post_scan_actions_result {
        #[allow(unused_imports)]
        use super::*;

        /// The result of BigQuery export post scan action.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BigQueryExportResult {

            /// Execution state for the BigQuery exporting.
            pub state: crate::model::data_scan_event::post_scan_actions_result::big_query_export_result::State,

            /// Additional information about the BigQuery exporting.
            pub message: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExportResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult::state].
            pub fn set_state<T: std::convert::Into<crate::model::data_scan_event::post_scan_actions_result::big_query_export_result::State>>(mut self, v: T) -> Self{
                self.state = v.into();
                self
            }

            /// Sets the value of [message][crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult::message].
            pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.message = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExportResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.PostScanActionsResult.BigQueryExportResult"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BigQueryExportResult {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __state,
                    __message,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BigQueryExportResult")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "state" => Ok(__FieldTag::__state),
                                    "message" => Ok(__FieldTag::__message),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BigQueryExportResult;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BigQueryExportResult")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__state => {
                                    if !fields.insert(__FieldTag::__state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for state"),
                                        );
                                    }
                                    result.state = map.next_value::<std::option::Option<crate::model::data_scan_event::post_scan_actions_result::big_query_export_result::State>>()?.unwrap_or_default();
                                }
                                __FieldTag::__message => {
                                    if !fields.insert(__FieldTag::__message) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for message",
                                            ),
                                        );
                                    }
                                    result.message = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BigQueryExportResult {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.state) {
                    state.serialize_entry("state", &self.state)?;
                }
                if !self.message.is_empty() {
                    state.serialize_entry("message", &self.message)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BigQueryExportResult].
        pub mod big_query_export_result {
            #[allow(unused_imports)]
            use super::*;

            /// Execution state for the exporting.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified,
                /// The exporting completed successfully.
                Succeeded,
                /// The exporting is no longer running due to an error.
                Failed,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [State::value] or
                /// [State::name].
                UnknownValue(state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl State {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Succeeded => std::option::Option::Some(1),
                        Self::Failed => std::option::Option::Some(2),
                        Self::Skipped => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                        Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                        Self::Failed => std::option::Option::Some("FAILED"),
                        Self::Skipped => std::option::Option::Some("SKIPPED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for State {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for State {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for State {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Succeeded,
                        2 => Self::Failed,
                        3 => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for State {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATE_UNSPECIFIED" => Self::Unspecified,
                        "SUCCEEDED" => Self::Succeeded,
                        "FAILED" => Self::Failed,
                        "SKIPPED" => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for State {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Succeeded => serializer.serialize_i32(1),
                        Self::Failed => serializer.serialize_i32(2),
                        Self::Skipped => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for State {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                        ".google.cloud.dataplex.v1.DataScanEvent.PostScanActionsResult.BigQueryExportResult.State"))
                }
            }
        }
    }

    /// The type of the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScanType {
        /// An unspecified data scan type.
        Unspecified,
        /// Data scan for data profile.
        DataProfile,
        /// Data scan for data quality.
        DataQuality,
        /// Data scan for data discovery.
        DataDiscovery,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ScanType::value] or
        /// [ScanType::name].
        UnknownValue(scan_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scan_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ScanType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DataProfile => std::option::Option::Some(1),
                Self::DataQuality => std::option::Option::Some(2),
                Self::DataDiscovery => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCAN_TYPE_UNSPECIFIED"),
                Self::DataProfile => std::option::Option::Some("DATA_PROFILE"),
                Self::DataQuality => std::option::Option::Some("DATA_QUALITY"),
                Self::DataDiscovery => std::option::Option::Some("DATA_DISCOVERY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ScanType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ScanType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ScanType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DataProfile,
                2 => Self::DataQuality,
                4 => Self::DataDiscovery,
                _ => Self::UnknownValue(scan_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ScanType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCAN_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATA_PROFILE" => Self::DataProfile,
                "DATA_QUALITY" => Self::DataQuality,
                "DATA_DISCOVERY" => Self::DataDiscovery,
                _ => Self::UnknownValue(scan_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ScanType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DataProfile => serializer.serialize_i32(1),
                Self::DataQuality => serializer.serialize_i32(2),
                Self::DataDiscovery => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ScanType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScanType>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.ScanType",
            ))
        }
    }

    /// The job state of the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified job state.
        Unspecified,
        /// Data scan job started.
        Started,
        /// Data scan job successfully completed.
        Succeeded,
        /// Data scan job was unsuccessful.
        Failed,
        /// Data scan job was cancelled.
        Cancelled,
        /// Data scan job was createed.
        Created,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Created => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Started,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelled,
                5 => Self::Created,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTED" => Self::Started,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                "CREATED" => Self::Created,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Created => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.State",
            ))
        }
    }

    /// The trigger type for the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Trigger {
        /// An unspecified trigger type.
        Unspecified,
        /// Data scan triggers on demand.
        OnDemand,
        /// Data scan triggers as per schedule.
        Schedule,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Trigger::value] or
        /// [Trigger::name].
        UnknownValue(trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Trigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Schedule => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRIGGER_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Schedule => std::option::Option::Some("SCHEDULE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Trigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Trigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Trigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Schedule,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Trigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "SCHEDULE" => Self::Schedule,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Trigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Schedule => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Trigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Trigger>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.Trigger",
            ))
        }
    }

    /// The scope of job for the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// An unspecified scope type.
        Unspecified,
        /// Data scan runs on all of the data.
        Full,
        /// Data scan runs on incremental data.
        Incremental,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Full => std::option::Option::Some(1),
                Self::Incremental => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Full,
                2 => Self::Incremental,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "FULL" => Self::Full,
                "INCREMENTAL" => Self::Incremental,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Full => serializer.serialize_i32(1),
                Self::Incremental => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.Scope",
            ))
        }
    }

    /// The result of the data scan job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Data profile result for data profile type data scan.
        DataProfile(std::boxed::Box<crate::model::data_scan_event::DataProfileResult>),
        /// Data quality result for data quality type data scan.
        DataQuality(std::boxed::Box<crate::model::data_scan_event::DataQualityResult>),
    }

    /// The applied configs in the data scan job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AppliedConfigs {
        /// Applied configs for data profile type data scan.
        DataProfileConfigs(
            std::boxed::Box<crate::model::data_scan_event::DataProfileAppliedConfigs>,
        ),
        /// Applied configs for data quality type data scan.
        DataQualityConfigs(
            std::boxed::Box<crate::model::data_scan_event::DataQualityAppliedConfigs>,
        ),
    }
}

/// Information about the result of a data quality rule for data quality scan.
/// The monitored resource is 'DataScan'.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataQualityScanRuleResult {
    /// Identifier of the specific data scan job this log entry is for.
    pub job_id: std::string::String,

    /// The data source of the data scan (e.g. BigQuery table name).
    pub data_source: std::string::String,

    /// The column which this rule is evaluated against.
    pub column: std::string::String,

    /// The name of the data quality rule.
    pub rule_name: std::string::String,

    /// The type of the data quality rule.
    pub rule_type: crate::model::data_quality_scan_rule_result::RuleType,

    /// The evaluation type of the data quality rule.
    pub evalution_type: crate::model::data_quality_scan_rule_result::EvaluationType,

    /// The dimension of the data quality rule.
    pub rule_dimension: std::string::String,

    /// The passing threshold ([0.0, 100.0]) of the data quality rule.
    pub threshold_percent: f64,

    /// The result of the data quality rule.
    pub result: crate::model::data_quality_scan_rule_result::Result,

    /// The number of rows evaluated against the data quality rule.
    /// This field is only valid for rules of PER_ROW evaluation type.
    pub evaluated_row_count: i64,

    /// The number of rows which passed a rule evaluation.
    /// This field is only valid for rules of PER_ROW evaluation type.
    pub passed_row_count: i64,

    /// The number of rows with null values in the specified column.
    pub null_row_count: i64,

    /// The number of rows returned by the SQL statement in a SQL assertion rule.
    /// This field is only valid for SQL assertion rules.
    pub assertion_row_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityScanRuleResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_id][crate::model::DataQualityScanRuleResult::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [data_source][crate::model::DataQualityScanRuleResult::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }

    /// Sets the value of [column][crate::model::DataQualityScanRuleResult::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [rule_name][crate::model::DataQualityScanRuleResult::rule_name].
    pub fn set_rule_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_name = v.into();
        self
    }

    /// Sets the value of [rule_type][crate::model::DataQualityScanRuleResult::rule_type].
    pub fn set_rule_type<
        T: std::convert::Into<crate::model::data_quality_scan_rule_result::RuleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = v.into();
        self
    }

    /// Sets the value of [evalution_type][crate::model::DataQualityScanRuleResult::evalution_type].
    pub fn set_evalution_type<
        T: std::convert::Into<crate::model::data_quality_scan_rule_result::EvaluationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evalution_type = v.into();
        self
    }

    /// Sets the value of [rule_dimension][crate::model::DataQualityScanRuleResult::rule_dimension].
    pub fn set_rule_dimension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_dimension = v.into();
        self
    }

    /// Sets the value of [threshold_percent][crate::model::DataQualityScanRuleResult::threshold_percent].
    pub fn set_threshold_percent<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.threshold_percent = v.into();
        self
    }

    /// Sets the value of [result][crate::model::DataQualityScanRuleResult::result].
    pub fn set_result<
        T: std::convert::Into<crate::model::data_quality_scan_rule_result::Result>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [evaluated_row_count][crate::model::DataQualityScanRuleResult::evaluated_row_count].
    pub fn set_evaluated_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.evaluated_row_count = v.into();
        self
    }

    /// Sets the value of [passed_row_count][crate::model::DataQualityScanRuleResult::passed_row_count].
    pub fn set_passed_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.passed_row_count = v.into();
        self
    }

    /// Sets the value of [null_row_count][crate::model::DataQualityScanRuleResult::null_row_count].
    pub fn set_null_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.null_row_count = v.into();
        self
    }

    /// Sets the value of [assertion_row_count][crate::model::DataQualityScanRuleResult::assertion_row_count].
    pub fn set_assertion_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.assertion_row_count = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityScanRuleResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityScanRuleResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataQualityScanRuleResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_id,
            __data_source,
            __column,
            __rule_name,
            __rule_type,
            __evalution_type,
            __rule_dimension,
            __threshold_percent,
            __result,
            __evaluated_row_count,
            __passed_row_count,
            __null_row_count,
            __assertion_row_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataQualityScanRuleResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "dataSource" => Ok(__FieldTag::__data_source),
                            "data_source" => Ok(__FieldTag::__data_source),
                            "column" => Ok(__FieldTag::__column),
                            "ruleName" => Ok(__FieldTag::__rule_name),
                            "rule_name" => Ok(__FieldTag::__rule_name),
                            "ruleType" => Ok(__FieldTag::__rule_type),
                            "rule_type" => Ok(__FieldTag::__rule_type),
                            "evalutionType" => Ok(__FieldTag::__evalution_type),
                            "evalution_type" => Ok(__FieldTag::__evalution_type),
                            "ruleDimension" => Ok(__FieldTag::__rule_dimension),
                            "rule_dimension" => Ok(__FieldTag::__rule_dimension),
                            "thresholdPercent" => Ok(__FieldTag::__threshold_percent),
                            "threshold_percent" => Ok(__FieldTag::__threshold_percent),
                            "result" => Ok(__FieldTag::__result),
                            "evaluatedRowCount" => Ok(__FieldTag::__evaluated_row_count),
                            "evaluated_row_count" => Ok(__FieldTag::__evaluated_row_count),
                            "passedRowCount" => Ok(__FieldTag::__passed_row_count),
                            "passed_row_count" => Ok(__FieldTag::__passed_row_count),
                            "nullRowCount" => Ok(__FieldTag::__null_row_count),
                            "null_row_count" => Ok(__FieldTag::__null_row_count),
                            "assertionRowCount" => Ok(__FieldTag::__assertion_row_count),
                            "assertion_row_count" => Ok(__FieldTag::__assertion_row_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataQualityScanRuleResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataQualityScanRuleResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source => {
                            if !fields.insert(__FieldTag::__data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source",
                                ));
                            }
                            result.data_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_name => {
                            if !fields.insert(__FieldTag::__rule_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_name",
                                ));
                            }
                            result.rule_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_type => {
                            if !fields.insert(__FieldTag::__rule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_type",
                                ));
                            }
                            result.rule_type = map
                                .next_value::<std::option::Option<
                                    crate::model::data_quality_scan_rule_result::RuleType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evalution_type => {
                            if !fields.insert(__FieldTag::__evalution_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evalution_type",
                                ));
                            }
                            result.evalution_type = map
                                .next_value::<std::option::Option<
                                    crate::model::data_quality_scan_rule_result::EvaluationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_dimension => {
                            if !fields.insert(__FieldTag::__rule_dimension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_dimension",
                                ));
                            }
                            result.rule_dimension = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__threshold_percent => {
                            if !fields.insert(__FieldTag::__threshold_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threshold_percent",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threshold_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map
                                .next_value::<std::option::Option<
                                    crate::model::data_quality_scan_rule_result::Result,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluated_row_count => {
                            if !fields.insert(__FieldTag::__evaluated_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluated_row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.evaluated_row_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__passed_row_count => {
                            if !fields.insert(__FieldTag::__passed_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passed_row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.passed_row_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__null_row_count => {
                            if !fields.insert(__FieldTag::__null_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.null_row_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__assertion_row_count => {
                            if !fields.insert(__FieldTag::__assertion_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assertion_row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.assertion_row_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataQualityScanRuleResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self.data_source.is_empty() {
            state.serialize_entry("dataSource", &self.data_source)?;
        }
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if !self.rule_name.is_empty() {
            state.serialize_entry("ruleName", &self.rule_name)?;
        }
        if !wkt::internal::is_default(&self.rule_type) {
            state.serialize_entry("ruleType", &self.rule_type)?;
        }
        if !wkt::internal::is_default(&self.evalution_type) {
            state.serialize_entry("evalutionType", &self.evalution_type)?;
        }
        if !self.rule_dimension.is_empty() {
            state.serialize_entry("ruleDimension", &self.rule_dimension)?;
        }
        if !wkt::internal::is_default(&self.threshold_percent) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("thresholdPercent", &__With(&self.threshold_percent))?;
        }
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if !wkt::internal::is_default(&self.evaluated_row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("evaluatedRowCount", &__With(&self.evaluated_row_count))?;
        }
        if !wkt::internal::is_default(&self.passed_row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("passedRowCount", &__With(&self.passed_row_count))?;
        }
        if !wkt::internal::is_default(&self.null_row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nullRowCount", &__With(&self.null_row_count))?;
        }
        if !wkt::internal::is_default(&self.assertion_row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("assertionRowCount", &__With(&self.assertion_row_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataQualityScanRuleResult].
pub mod data_quality_scan_rule_result {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the data quality rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RuleType {
        /// An unspecified rule type.
        Unspecified,
        /// See
        /// [DataQualityRule.NonNullExpectation][google.cloud.dataplex.v1.DataQualityRule.NonNullExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.NonNullExpectation]: crate::model::data_quality_rule::NonNullExpectation
        NonNullExpectation,
        /// See
        /// [DataQualityRule.RangeExpectation][google.cloud.dataplex.v1.DataQualityRule.RangeExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.RangeExpectation]: crate::model::data_quality_rule::RangeExpectation
        RangeExpectation,
        /// See
        /// [DataQualityRule.RegexExpectation][google.cloud.dataplex.v1.DataQualityRule.RegexExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.RegexExpectation]: crate::model::data_quality_rule::RegexExpectation
        RegexExpectation,
        /// See
        /// [DataQualityRule.RowConditionExpectation][google.cloud.dataplex.v1.DataQualityRule.RowConditionExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.RowConditionExpectation]: crate::model::data_quality_rule::RowConditionExpectation
        RowConditionExpectation,
        /// See
        /// [DataQualityRule.SetExpectation][google.cloud.dataplex.v1.DataQualityRule.SetExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.SetExpectation]: crate::model::data_quality_rule::SetExpectation
        SetExpectation,
        /// See
        /// [DataQualityRule.StatisticRangeExpectation][google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation]: crate::model::data_quality_rule::StatisticRangeExpectation
        StatisticRangeExpectation,
        /// See
        /// [DataQualityRule.TableConditionExpectation][google.cloud.dataplex.v1.DataQualityRule.TableConditionExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.TableConditionExpectation]: crate::model::data_quality_rule::TableConditionExpectation
        TableConditionExpectation,
        /// See
        /// [DataQualityRule.UniquenessExpectation][google.cloud.dataplex.v1.DataQualityRule.UniquenessExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.UniquenessExpectation]: crate::model::data_quality_rule::UniquenessExpectation
        UniquenessExpectation,
        /// See
        /// [DataQualityRule.SqlAssertion][google.cloud.dataplex.v1.DataQualityRule.SqlAssertion].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.SqlAssertion]: crate::model::data_quality_rule::SqlAssertion
        SqlAssertion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RuleType::value] or
        /// [RuleType::name].
        UnknownValue(rule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RuleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NonNullExpectation => std::option::Option::Some(1),
                Self::RangeExpectation => std::option::Option::Some(2),
                Self::RegexExpectation => std::option::Option::Some(3),
                Self::RowConditionExpectation => std::option::Option::Some(4),
                Self::SetExpectation => std::option::Option::Some(5),
                Self::StatisticRangeExpectation => std::option::Option::Some(6),
                Self::TableConditionExpectation => std::option::Option::Some(7),
                Self::UniquenessExpectation => std::option::Option::Some(8),
                Self::SqlAssertion => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RULE_TYPE_UNSPECIFIED"),
                Self::NonNullExpectation => std::option::Option::Some("NON_NULL_EXPECTATION"),
                Self::RangeExpectation => std::option::Option::Some("RANGE_EXPECTATION"),
                Self::RegexExpectation => std::option::Option::Some("REGEX_EXPECTATION"),
                Self::RowConditionExpectation => {
                    std::option::Option::Some("ROW_CONDITION_EXPECTATION")
                }
                Self::SetExpectation => std::option::Option::Some("SET_EXPECTATION"),
                Self::StatisticRangeExpectation => {
                    std::option::Option::Some("STATISTIC_RANGE_EXPECTATION")
                }
                Self::TableConditionExpectation => {
                    std::option::Option::Some("TABLE_CONDITION_EXPECTATION")
                }
                Self::UniquenessExpectation => std::option::Option::Some("UNIQUENESS_EXPECTATION"),
                Self::SqlAssertion => std::option::Option::Some("SQL_ASSERTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RuleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RuleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RuleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NonNullExpectation,
                2 => Self::RangeExpectation,
                3 => Self::RegexExpectation,
                4 => Self::RowConditionExpectation,
                5 => Self::SetExpectation,
                6 => Self::StatisticRangeExpectation,
                7 => Self::TableConditionExpectation,
                8 => Self::UniquenessExpectation,
                9 => Self::SqlAssertion,
                _ => Self::UnknownValue(rule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RuleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NON_NULL_EXPECTATION" => Self::NonNullExpectation,
                "RANGE_EXPECTATION" => Self::RangeExpectation,
                "REGEX_EXPECTATION" => Self::RegexExpectation,
                "ROW_CONDITION_EXPECTATION" => Self::RowConditionExpectation,
                "SET_EXPECTATION" => Self::SetExpectation,
                "STATISTIC_RANGE_EXPECTATION" => Self::StatisticRangeExpectation,
                "TABLE_CONDITION_EXPECTATION" => Self::TableConditionExpectation,
                "UNIQUENESS_EXPECTATION" => Self::UniquenessExpectation,
                "SQL_ASSERTION" => Self::SqlAssertion,
                _ => Self::UnknownValue(rule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RuleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NonNullExpectation => serializer.serialize_i32(1),
                Self::RangeExpectation => serializer.serialize_i32(2),
                Self::RegexExpectation => serializer.serialize_i32(3),
                Self::RowConditionExpectation => serializer.serialize_i32(4),
                Self::SetExpectation => serializer.serialize_i32(5),
                Self::StatisticRangeExpectation => serializer.serialize_i32(6),
                Self::TableConditionExpectation => serializer.serialize_i32(7),
                Self::UniquenessExpectation => serializer.serialize_i32(8),
                Self::SqlAssertion => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RuleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RuleType>::new(
                ".google.cloud.dataplex.v1.DataQualityScanRuleResult.RuleType",
            ))
        }
    }

    /// The evaluation type of the data quality rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EvaluationType {
        /// An unspecified evaluation type.
        Unspecified,
        /// The rule evaluation is done at per row level.
        PerRow,
        /// The rule evaluation is done for an aggregate of rows.
        Aggregate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EvaluationType::value] or
        /// [EvaluationType::name].
        UnknownValue(evaluation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod evaluation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EvaluationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PerRow => std::option::Option::Some(1),
                Self::Aggregate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVALUATION_TYPE_UNSPECIFIED"),
                Self::PerRow => std::option::Option::Some("PER_ROW"),
                Self::Aggregate => std::option::Option::Some("AGGREGATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EvaluationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EvaluationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EvaluationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PerRow,
                2 => Self::Aggregate,
                _ => Self::UnknownValue(evaluation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EvaluationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVALUATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PER_ROW" => Self::PerRow,
                "AGGREGATE" => Self::Aggregate,
                _ => Self::UnknownValue(evaluation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EvaluationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PerRow => serializer.serialize_i32(1),
                Self::Aggregate => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EvaluationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EvaluationType>::new(
                ".google.cloud.dataplex.v1.DataQualityScanRuleResult.EvaluationType",
            ))
        }
    }

    /// Whether the data quality rule passed or failed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// An unspecified result.
        Unspecified,
        /// The data quality rule passed.
        Passed,
        /// The data quality rule failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Result::value] or
        /// [Result::name].
        UnknownValue(result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Result {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Passed => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Passed,
                2 => Self::Failed,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Result {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_UNSPECIFIED" => Self::Unspecified,
                "PASSED" => Self::Passed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Passed => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                ".google.cloud.dataplex.v1.DataQualityScanRuleResult.Result",
            ))
        }
    }
}

/// Payload associated with Business Glossary related log events.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BusinessGlossaryEvent {
    /// The log message.
    pub message: std::string::String,

    /// The type of the event.
    pub event_type: crate::model::business_glossary_event::EventType,

    /// Name of the resource.
    pub resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BusinessGlossaryEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::BusinessGlossaryEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::BusinessGlossaryEvent::event_type].
    pub fn set_event_type<
        T: std::convert::Into<crate::model::business_glossary_event::EventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::BusinessGlossaryEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for BusinessGlossaryEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.BusinessGlossaryEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BusinessGlossaryEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __event_type,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BusinessGlossaryEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BusinessGlossaryEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BusinessGlossaryEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type = map
                                .next_value::<std::option::Option<
                                    crate::model::business_glossary_event::EventType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BusinessGlossaryEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.event_type) {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BusinessGlossaryEvent].
pub mod business_glossary_event {
    #[allow(unused_imports)]
    use super::*;

    /// Type of glossary log event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// Glossary create event.
        GlossaryCreate,
        /// Glossary update event.
        GlossaryUpdate,
        /// Glossary delete event.
        GlossaryDelete,
        /// Glossary category create event.
        GlossaryCategoryCreate,
        /// Glossary category update event.
        GlossaryCategoryUpdate,
        /// Glossary category delete event.
        GlossaryCategoryDelete,
        /// Glossary term create event.
        GlossaryTermCreate,
        /// Glossary term update event.
        GlossaryTermUpdate,
        /// Glossary term delete event.
        GlossaryTermDelete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GlossaryCreate => std::option::Option::Some(1),
                Self::GlossaryUpdate => std::option::Option::Some(2),
                Self::GlossaryDelete => std::option::Option::Some(3),
                Self::GlossaryCategoryCreate => std::option::Option::Some(4),
                Self::GlossaryCategoryUpdate => std::option::Option::Some(5),
                Self::GlossaryCategoryDelete => std::option::Option::Some(6),
                Self::GlossaryTermCreate => std::option::Option::Some(7),
                Self::GlossaryTermUpdate => std::option::Option::Some(8),
                Self::GlossaryTermDelete => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::GlossaryCreate => std::option::Option::Some("GLOSSARY_CREATE"),
                Self::GlossaryUpdate => std::option::Option::Some("GLOSSARY_UPDATE"),
                Self::GlossaryDelete => std::option::Option::Some("GLOSSARY_DELETE"),
                Self::GlossaryCategoryCreate => {
                    std::option::Option::Some("GLOSSARY_CATEGORY_CREATE")
                }
                Self::GlossaryCategoryUpdate => {
                    std::option::Option::Some("GLOSSARY_CATEGORY_UPDATE")
                }
                Self::GlossaryCategoryDelete => {
                    std::option::Option::Some("GLOSSARY_CATEGORY_DELETE")
                }
                Self::GlossaryTermCreate => std::option::Option::Some("GLOSSARY_TERM_CREATE"),
                Self::GlossaryTermUpdate => std::option::Option::Some("GLOSSARY_TERM_UPDATE"),
                Self::GlossaryTermDelete => std::option::Option::Some("GLOSSARY_TERM_DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GlossaryCreate,
                2 => Self::GlossaryUpdate,
                3 => Self::GlossaryDelete,
                4 => Self::GlossaryCategoryCreate,
                5 => Self::GlossaryCategoryUpdate,
                6 => Self::GlossaryCategoryDelete,
                7 => Self::GlossaryTermCreate,
                8 => Self::GlossaryTermUpdate,
                9 => Self::GlossaryTermDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GLOSSARY_CREATE" => Self::GlossaryCreate,
                "GLOSSARY_UPDATE" => Self::GlossaryUpdate,
                "GLOSSARY_DELETE" => Self::GlossaryDelete,
                "GLOSSARY_CATEGORY_CREATE" => Self::GlossaryCategoryCreate,
                "GLOSSARY_CATEGORY_UPDATE" => Self::GlossaryCategoryUpdate,
                "GLOSSARY_CATEGORY_DELETE" => Self::GlossaryCategoryDelete,
                "GLOSSARY_TERM_CREATE" => Self::GlossaryTermCreate,
                "GLOSSARY_TERM_UPDATE" => Self::GlossaryTermUpdate,
                "GLOSSARY_TERM_DELETE" => Self::GlossaryTermDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GlossaryCreate => serializer.serialize_i32(1),
                Self::GlossaryUpdate => serializer.serialize_i32(2),
                Self::GlossaryDelete => serializer.serialize_i32(3),
                Self::GlossaryCategoryCreate => serializer.serialize_i32(4),
                Self::GlossaryCategoryUpdate => serializer.serialize_i32(5),
                Self::GlossaryCategoryDelete => serializer.serialize_i32(6),
                Self::GlossaryTermCreate => serializer.serialize_i32(7),
                Self::GlossaryTermUpdate => serializer.serialize_i32(8),
                Self::GlossaryTermDelete => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.BusinessGlossaryEvent.EventType",
            ))
        }
    }
}

/// Payload associated with Entry related log events.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntryLinkEvent {
    /// The log message.
    pub message: std::string::String,

    /// The type of the event.
    pub event_type: crate::model::entry_link_event::EventType,

    /// Name of the resource.
    pub resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryLinkEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::EntryLinkEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::EntryLinkEvent::event_type].
    pub fn set_event_type<T: std::convert::Into<crate::model::entry_link_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::EntryLinkEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for EntryLinkEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntryLinkEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntryLinkEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __event_type,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntryLinkEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntryLinkEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntryLinkEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type = map.next_value::<std::option::Option<crate::model::entry_link_event::EventType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntryLinkEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.event_type) {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EntryLinkEvent].
pub mod entry_link_event {
    #[allow(unused_imports)]
    use super::*;

    /// Type of entry link log event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// EntryLink create event.
        EntryLinkCreate,
        /// EntryLink delete event.
        EntryLinkDelete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EntryLinkCreate => std::option::Option::Some(1),
                Self::EntryLinkDelete => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::EntryLinkCreate => std::option::Option::Some("ENTRY_LINK_CREATE"),
                Self::EntryLinkDelete => std::option::Option::Some("ENTRY_LINK_DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EntryLinkCreate,
                2 => Self::EntryLinkDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ENTRY_LINK_CREATE" => Self::EntryLinkCreate,
                "ENTRY_LINK_DELETE" => Self::EntryLinkDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EntryLinkCreate => serializer.serialize_i32(1),
                Self::EntryLinkDelete => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.EntryLinkEvent.EventType",
            ))
        }
    }
}

/// Create a metadata entity request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntityRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub parent: std::string::String,

    /// Required. Entity resource.
    pub entity: std::option::Option<crate::model::Entity>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntityRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::CreateEntityRequest::entity].
    pub fn set_entity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entity>,
    {
        self.entity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity][crate::model::CreateEntityRequest::entity].
    pub fn set_or_clear_entity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entity>,
    {
        self.entity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEntityRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entity" => Ok(__FieldTag::__entity),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity =
                                map.next_value::<std::option::Option<crate::model::Entity>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEntityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.entity.is_some() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update a metadata entity request.
/// The exiting entity will be fully replaced by the entity in the request.
/// The entity ID is mutable. To modify the ID, use the current entity ID in the
/// request URL and specify the new ID in the request body.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntityRequest {
    /// Required. Update description.
    pub entity: std::option::Option<crate::model::Entity>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity][crate::model::UpdateEntityRequest::entity].
    pub fn set_entity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entity>,
    {
        self.entity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity][crate::model::UpdateEntityRequest::entity].
    pub fn set_or_clear_entity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entity>,
    {
        self.entity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEntityRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entity" => Ok(__FieldTag::__entity),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity =
                                map.next_value::<std::option::Option<crate::model::Entity>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entity.is_some() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete a metadata entity request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntityRequest {
    /// Required. The resource name of the entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    pub name: std::string::String,

    /// Required. The etag associated with the entity, which can be retrieved with
    /// a [GetEntity][] request.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEntityRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List metadata entities request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitiesRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub parent: std::string::String,

    /// Required. Specify the entity view to make a partial list request.
    pub view: crate::model::list_entities_request::EntityView,

    /// Optional. Maximum number of entities to return. The service may return
    /// fewer than this value. If unspecified, 100 entities will be returned by
    /// default. The maximum value is 500; larger values will will be truncated to
    /// 500.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntities` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListEntities` must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    /// Optional. The following filter parameters can be added to the URL to limit
    /// the entities returned by the API:
    ///
    /// - Entity ID: ?filter="id=entityID"
    /// - Asset ID: ?filter="asset=assetID"
    /// - Data path ?filter="data_path=gs://my-bucket"
    /// - Is HIVE compatible: ?filter="hive_compatible=true"
    /// - Is BigQuery compatible: ?filter="bigquery_compatible=true"
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListEntitiesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::list_entities_request::EntityView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntitiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntitiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::list_entities_request::EntityView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ListEntitiesRequest].
pub mod list_entities_request {
    #[allow(unused_imports)]
    use super::*;

    /// Entity views.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityView {
        /// The default unset value. Return both table and fileset entities
        /// if unspecified.
        Unspecified,
        /// Only list table entities.
        Tables,
        /// Only list fileset entities.
        Filesets,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityView::value] or
        /// [EntityView::name].
        UnknownValue(entity_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod entity_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EntityView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tables => std::option::Option::Some(1),
                Self::Filesets => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_VIEW_UNSPECIFIED"),
                Self::Tables => std::option::Option::Some("TABLES"),
                Self::Filesets => std::option::Option::Some("FILESETS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EntityView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EntityView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EntityView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tables,
                2 => Self::Filesets,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EntityView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Self::Unspecified,
                "TABLES" => Self::Tables,
                "FILESETS" => Self::Filesets,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EntityView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tables => serializer.serialize_i32(1),
                Self::Filesets => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EntityView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityView>::new(
                ".google.cloud.dataplex.v1.ListEntitiesRequest.EntityView",
            ))
        }
    }
}

/// List metadata entities response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitiesResponse {
    /// Entities in the specified parent zone.
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// remaining results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entities][crate::model::ListEntitiesResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntitiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntitiesResponse {
    type PageItem = crate::model::Entity;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entities
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntitiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entities,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entities" => Ok(__FieldTag::__entities),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntitiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entity>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntitiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get metadata entity request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntityRequest {
    /// Required. The resource name of the entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}.`
    pub name: std::string::String,

    /// Optional. Used to select the subset of entity information to return.
    /// Defaults to `BASIC`.
    pub view: crate::model::get_entity_request::EntityView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetEntityRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_entity_request::EntityView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<
                                    crate::model::get_entity_request::EntityView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEntityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GetEntityRequest].
pub mod get_entity_request {
    #[allow(unused_imports)]
    use super::*;

    /// Entity views for get entity partial result.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityView {
        /// The API will default to the `BASIC` view.
        Unspecified,
        /// Minimal view that does not include the schema.
        Basic,
        /// Include basic information and schema.
        Schema,
        /// Include everything. Currently, this is the same as the SCHEMA view.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityView::value] or
        /// [EntityView::name].
        UnknownValue(entity_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod entity_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EntityView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Schema => std::option::Option::Some(2),
                Self::Full => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Schema => std::option::Option::Some("SCHEMA"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EntityView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EntityView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EntityView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::Schema,
                4 => Self::Full,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EntityView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "SCHEMA" => Self::Schema,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EntityView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Schema => serializer.serialize_i32(2),
                Self::Full => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EntityView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityView>::new(
                ".google.cloud.dataplex.v1.GetEntityRequest.EntityView",
            ))
        }
    }
}

/// List metadata partitions request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPartitionsRequest {
    /// Required. The resource name of the parent entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of partitions to return. The service may return
    /// fewer than this value. If unspecified, 100 partitions will be returned by
    /// default. The maximum page size is 500; larger values will will be truncated
    /// to 500.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListPartitions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListPartitions` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    /// Optional. Filter the partitions returned to the caller using a key value
    /// pair expression. Supported operators and syntax:
    ///
    /// - logic operators: AND, OR
    /// - comparison operators: <, >, >=, <= ,=, !=
    /// - LIKE operators:
    ///   - The right hand of a LIKE operator supports "." and
    ///     "*" for wildcard searches, for example "value1 LIKE ".*oo.*"
    /// - parenthetical grouping: ( )
    ///
    /// Sample filter expression: `?filter="key1 < value1 OR key2 > value2"
    ///
    /// **Notes:**
    ///
    /// - Keys to the left of operators are case insensitive.
    /// - Partition results are sorted first by creation time, then by
    ///   lexicographic order.
    /// - Up to 20 key value filter pairs are allowed, but due to performance
    ///   considerations, only the first 10 will be used as a filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPartitionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPartitionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPartitionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPartitionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPartitionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPartitionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListPartitionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPartitionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPartitionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPartitionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPartitionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPartitionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create metadata partition request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePartitionRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    pub parent: std::string::String,

    /// Required. Partition resource.
    pub partition: std::option::Option<crate::model::Partition>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePartitionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [partition][crate::model::CreatePartitionRequest::partition].
    pub fn set_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Partition>,
    {
        self.partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [partition][crate::model::CreatePartitionRequest::partition].
    pub fn set_or_clear_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Partition>,
    {
        self.partition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreatePartitionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreatePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreatePartitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePartitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __partition,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePartitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "partition" => Ok(__FieldTag::__partition),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePartitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePartitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partition => {
                            if !fields.insert(__FieldTag::__partition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition",
                                ));
                            }
                            result.partition =
                                map.next_value::<std::option::Option<crate::model::Partition>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePartitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.partition.is_some() {
            state.serialize_entry("partition", &self.partition)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete metadata partition request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePartitionRequest {
    /// Required. The resource name of the partition.
    /// format:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}/partitions/{partition_value_path}`.
    /// The {partition_value_path} segment consists of an ordered sequence of
    /// partition values separated by "/". All values must be provided.
    pub name: std::string::String,

    /// Optional. The etag associated with the partition.
    #[deprecated]
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePartitionRequest::etag].
    #[deprecated]
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeletePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeletePartitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePartitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePartitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePartitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePartitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePartitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List metadata partitions response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPartitionsResponse {
    /// Partitions under the specified parent entity.
    pub partitions: std::vec::Vec<crate::model::Partition>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// remaining results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPartitionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partitions][crate::model::ListPartitionsResponse::partitions].
    pub fn set_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Partition>,
    {
        use std::iter::Iterator;
        self.partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPartitionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPartitionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListPartitionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPartitionsResponse {
    type PageItem = crate::model::Partition;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.partitions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPartitionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partitions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPartitionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitions" => Ok(__FieldTag::__partitions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPartitionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPartitionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partitions => {
                            if !fields.insert(__FieldTag::__partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partitions",
                                ));
                            }
                            result.partitions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Partition>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPartitionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.partitions.is_empty() {
            state.serialize_entry("partitions", &self.partitions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get metadata partition request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPartitionRequest {
    /// Required. The resource name of the partition:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}/partitions/{partition_value_path}`.
    /// The {partition_value_path} segment consists of an ordered sequence of
    /// partition values separated by "/". All values must be provided.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetPartitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPartitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPartitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPartitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPartitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPartitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents tables and fileset metadata contained within a zone.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Entity {
    /// Output only. The resource name of the entity, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{id}`.
    pub name: std::string::String,

    /// Optional. Display name must be shorter than or equal to 256 characters.
    pub display_name: std::string::String,

    /// Optional. User friendly longer description text. Must be shorter than or
    /// equal to 1024 characters.
    pub description: std::string::String,

    /// Output only. The time when the entity was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the entity was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. A user-provided entity ID. It is mutable, and will be used as the
    /// published table name. Specifying a new ID in an update entity
    /// request will override the existing value.
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), and
    /// underscores, and consist of 256 or fewer characters.
    pub id: std::string::String,

    /// Optional. The etag associated with the entity, which can be retrieved with
    /// a [GetEntity][] request. Required for update and delete requests.
    pub etag: std::string::String,

    /// Required. Immutable. The type of entity.
    pub r#type: crate::model::entity::Type,

    /// Required. Immutable. The ID of the asset associated with the storage
    /// location containing the entity data. The entity must be with in the same
    /// zone with the asset.
    pub asset: std::string::String,

    /// Required. Immutable. The storage path of the entity data.
    /// For Cloud Storage data, this is the fully-qualified path to the entity,
    /// such as `gs://bucket/path/to/data`. For BigQuery data, this is the name of
    /// the table resource, such as
    /// `projects/project_id/datasets/dataset_id/tables/table_id`.
    pub data_path: std::string::String,

    /// Optional. The set of items within the data path constituting the data in
    /// the entity, represented as a glob path. Example:
    /// `gs://bucket/path/to/data/**/*.csv`.
    pub data_path_pattern: std::string::String,

    /// Output only. The name of the associated Data Catalog entry.
    pub catalog_entry: std::string::String,

    /// Required. Immutable. Identifies the storage system of the entity data.
    pub system: crate::model::StorageSystem,

    /// Required. Identifies the storage format of the entity data.
    /// It does not apply to entities with data stored in BigQuery.
    pub format: std::option::Option<crate::model::StorageFormat>,

    /// Output only. Metadata stores that the entity is compatible with.
    pub compatibility: std::option::Option<crate::model::entity::CompatibilityStatus>,

    /// Output only. Identifies the access mechanism to the entity. Not user
    /// settable.
    pub access: std::option::Option<crate::model::StorageAccess>,

    /// Output only. System generated unique ID for the Entity. This ID will be
    /// different if the Entity is deleted and re-created with the same name.
    pub uid: std::string::String,

    /// Required. The description of the data structure and layout.
    /// The schema is not included in list responses. It is only included in
    /// `SCHEMA` and `FULL` entity views of a `GetEntity` response.
    pub schema: std::option::Option<crate::model::Schema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Entity::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Entity::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Entity::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Entity::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Entity::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Entity::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Entity::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Entity::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::Entity::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [data_path][crate::model::Entity::data_path].
    pub fn set_data_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_path = v.into();
        self
    }

    /// Sets the value of [data_path_pattern][crate::model::Entity::data_path_pattern].
    pub fn set_data_path_pattern<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_path_pattern = v.into();
        self
    }

    /// Sets the value of [catalog_entry][crate::model::Entity::catalog_entry].
    pub fn set_catalog_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog_entry = v.into();
        self
    }

    /// Sets the value of [system][crate::model::Entity::system].
    pub fn set_system<T: std::convert::Into<crate::model::StorageSystem>>(mut self, v: T) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Entity::format].
    pub fn set_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageFormat>,
    {
        self.format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [format][crate::model::Entity::format].
    pub fn set_or_clear_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageFormat>,
    {
        self.format = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compatibility][crate::model::Entity::compatibility].
    pub fn set_compatibility<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::entity::CompatibilityStatus>,
    {
        self.compatibility = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compatibility][crate::model::Entity::compatibility].
    pub fn set_or_clear_compatibility<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::entity::CompatibilityStatus>,
    {
        self.compatibility = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access][crate::model::Entity::access].
    pub fn set_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageAccess>,
    {
        self.access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access][crate::model::Entity::access].
    pub fn set_or_clear_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageAccess>,
    {
        self.access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uid][crate::model::Entity::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::Entity::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::Entity::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Entity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __update_time,
            __id,
            __etag,
            __type,
            __asset,
            __data_path,
            __data_path_pattern,
            __catalog_entry,
            __system,
            __format,
            __compatibility,
            __access,
            __uid,
            __schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "id" => Ok(__FieldTag::__id),
                            "etag" => Ok(__FieldTag::__etag),
                            "type" => Ok(__FieldTag::__type),
                            "asset" => Ok(__FieldTag::__asset),
                            "dataPath" => Ok(__FieldTag::__data_path),
                            "data_path" => Ok(__FieldTag::__data_path),
                            "dataPathPattern" => Ok(__FieldTag::__data_path_pattern),
                            "data_path_pattern" => Ok(__FieldTag::__data_path_pattern),
                            "catalogEntry" => Ok(__FieldTag::__catalog_entry),
                            "catalog_entry" => Ok(__FieldTag::__catalog_entry),
                            "system" => Ok(__FieldTag::__system),
                            "format" => Ok(__FieldTag::__format),
                            "compatibility" => Ok(__FieldTag::__compatibility),
                            "access" => Ok(__FieldTag::__access),
                            "uid" => Ok(__FieldTag::__uid),
                            "schema" => Ok(__FieldTag::__schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::entity::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_path => {
                            if !fields.insert(__FieldTag::__data_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_path",
                                ));
                            }
                            result.data_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_path_pattern => {
                            if !fields.insert(__FieldTag::__data_path_pattern) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_path_pattern",
                                ));
                            }
                            result.data_path_pattern = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__catalog_entry => {
                            if !fields.insert(__FieldTag::__catalog_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog_entry",
                                ));
                            }
                            result.catalog_entry = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__system => {
                            if !fields.insert(__FieldTag::__system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system",
                                ));
                            }
                            result.system = map
                                .next_value::<std::option::Option<crate::model::StorageSystem>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<crate::model::StorageFormat>>()?;
                        }
                        __FieldTag::__compatibility => {
                            if !fields.insert(__FieldTag::__compatibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compatibility",
                                ));
                            }
                            result.compatibility = map.next_value::<std::option::Option<crate::model::entity::CompatibilityStatus>>()?
                                ;
                        }
                        __FieldTag::__access => {
                            if !fields.insert(__FieldTag::__access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access",
                                ));
                            }
                            result.access = map
                                .next_value::<std::option::Option<crate::model::StorageAccess>>()?;
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::Schema>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.asset.is_empty() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !self.data_path.is_empty() {
            state.serialize_entry("dataPath", &self.data_path)?;
        }
        if !self.data_path_pattern.is_empty() {
            state.serialize_entry("dataPathPattern", &self.data_path_pattern)?;
        }
        if !self.catalog_entry.is_empty() {
            state.serialize_entry("catalogEntry", &self.catalog_entry)?;
        }
        if !wkt::internal::is_default(&self.system) {
            state.serialize_entry("system", &self.system)?;
        }
        if self.format.is_some() {
            state.serialize_entry("format", &self.format)?;
        }
        if self.compatibility.is_some() {
            state.serialize_entry("compatibility", &self.compatibility)?;
        }
        if self.access.is_some() {
            state.serialize_entry("access", &self.access)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Entity].
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// Provides compatibility information for various metadata stores.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CompatibilityStatus {
        /// Output only. Whether this entity is compatible with Hive Metastore.
        pub hive_metastore:
            std::option::Option<crate::model::entity::compatibility_status::Compatibility>,

        /// Output only. Whether this entity is compatible with BigQuery.
        pub bigquery:
            std::option::Option<crate::model::entity::compatibility_status::Compatibility>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CompatibilityStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hive_metastore][crate::model::entity::CompatibilityStatus::hive_metastore].
        pub fn set_hive_metastore<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::entity::compatibility_status::Compatibility>,
        {
            self.hive_metastore = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [hive_metastore][crate::model::entity::CompatibilityStatus::hive_metastore].
        pub fn set_or_clear_hive_metastore<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::entity::compatibility_status::Compatibility>,
        {
            self.hive_metastore = v.map(|x| x.into());
            self
        }

        /// Sets the value of [bigquery][crate::model::entity::CompatibilityStatus::bigquery].
        pub fn set_bigquery<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::entity::compatibility_status::Compatibility>,
        {
            self.bigquery = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bigquery][crate::model::entity::CompatibilityStatus::bigquery].
        pub fn set_or_clear_bigquery<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::entity::compatibility_status::Compatibility>,
        {
            self.bigquery = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for CompatibilityStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Entity.CompatibilityStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CompatibilityStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __hive_metastore,
                __bigquery,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CompatibilityStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "hiveMetastore" => Ok(__FieldTag::__hive_metastore),
                                "hive_metastore" => Ok(__FieldTag::__hive_metastore),
                                "bigquery" => Ok(__FieldTag::__bigquery),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CompatibilityStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CompatibilityStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__hive_metastore => {
                                if !fields.insert(__FieldTag::__hive_metastore) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hive_metastore",
                                    ));
                                }
                                result.hive_metastore = map.next_value::<std::option::Option<
                                    crate::model::entity::compatibility_status::Compatibility,
                                >>()?;
                            }
                            __FieldTag::__bigquery => {
                                if !fields.insert(__FieldTag::__bigquery) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bigquery",
                                    ));
                                }
                                result.bigquery = map.next_value::<std::option::Option<
                                    crate::model::entity::compatibility_status::Compatibility,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CompatibilityStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.hive_metastore.is_some() {
                state.serialize_entry("hiveMetastore", &self.hive_metastore)?;
            }
            if self.bigquery.is_some() {
                state.serialize_entry("bigquery", &self.bigquery)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [CompatibilityStatus].
    pub mod compatibility_status {
        #[allow(unused_imports)]
        use super::*;

        /// Provides compatibility information for a specific metadata store.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Compatibility {
            /// Output only. Whether the entity is compatible and can be represented in
            /// the metadata store.
            pub compatible: bool,

            /// Output only. Provides additional detail if the entity is incompatible
            /// with the metadata store.
            pub reason: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Compatibility {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [compatible][crate::model::entity::compatibility_status::Compatibility::compatible].
            pub fn set_compatible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.compatible = v.into();
                self
            }

            /// Sets the value of [reason][crate::model::entity::compatibility_status::Compatibility::reason].
            pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.reason = v.into();
                self
            }
        }

        impl wkt::message::Message for Compatibility {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Entity.CompatibilityStatus.Compatibility"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Compatibility {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __compatible,
                    __reason,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Compatibility")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "compatible" => Ok(__FieldTag::__compatible),
                                    "reason" => Ok(__FieldTag::__reason),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Compatibility;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Compatibility")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__compatible => {
                                    if !fields.insert(__FieldTag::__compatible) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for compatible",
                                            ),
                                        );
                                    }
                                    result.compatible = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__reason => {
                                    if !fields.insert(__FieldTag::__reason) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for reason"),
                                        );
                                    }
                                    result.reason = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Compatibility {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.compatible) {
                    state.serialize_entry("compatible", &self.compatible)?;
                }
                if !self.reason.is_empty() {
                    state.serialize_entry("reason", &self.reason)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// The type of entity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Type unspecified.
        Unspecified,
        /// Structured and semi-structured data.
        Table,
        /// Unstructured data.
        Fileset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Table => std::option::Option::Some(1),
                Self::Fileset => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Fileset => std::option::Option::Some("FILESET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Table,
                2 => Self::Fileset,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "TABLE" => Self::Table,
                "FILESET" => Self::Fileset,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Table => serializer.serialize_i32(1),
                Self::Fileset => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.Entity.Type",
            ))
        }
    }
}

/// Represents partition metadata contained within entity instances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Partition {
    /// Output only. Partition values used in the HTTP URL must be
    /// double encoded. For example, `url_encode(url_encode(value))` can be used
    /// to encode "US:CA/CA#Sunnyvale so that the request URL ends
    /// with "/partitions/US%253ACA/CA%2523Sunnyvale".
    /// The name field in the response retains the encoded format.
    pub name: std::string::String,

    /// Required. Immutable. The set of values representing the partition, which
    /// correspond to the partition schema defined in the parent entity.
    pub values: std::vec::Vec<std::string::String>,

    /// Required. Immutable. The location of the entity data within the partition,
    /// for example, `gs://bucket/path/to/entity/key1=value1/key2=value2`. Or
    /// `projects/<project_id>/datasets/<dataset_id>/tables/<table_id>`
    pub location: std::string::String,

    /// Optional. The etag for this partition.
    #[deprecated]
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Partition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Partition::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [values][crate::model::Partition::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location][crate::model::Partition::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Partition::etag].
    #[deprecated]
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Partition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Partition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Partition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __values,
            __location,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Partition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "values" => Ok(__FieldTag::__values),
                            "location" => Ok(__FieldTag::__location),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Partition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Partition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Partition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Schema information describing the structure and layout of the data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {
    /// Required. Set to `true` if user-managed or `false` if managed by Dataplex.
    /// The default is `false` (managed by Dataplex).
    ///
    /// - Set to `false`to enable Dataplex discovery to update the schema.
    ///   including new data discovery, schema inference, and schema evolution.
    ///   Users retain the ability to input and edit the schema. Dataplex
    ///   treats schema input by the user as though produced
    ///   by a previous Dataplex discovery operation, and it will
    ///   evolve the schema and take action based on that treatment.
    ///
    /// - Set to `true` to fully manage the entity
    ///   schema. This setting guarantees that Dataplex will not
    ///   change schema fields.
    ///
    pub user_managed: bool,

    /// Optional. The sequence of fields describing data in table entities.
    /// **Note:** BigQuery SchemaFields are immutable.
    pub fields: std::vec::Vec<crate::model::schema::SchemaField>,

    /// Optional. The sequence of fields describing the partition structure in
    /// entities. If this field is empty, there are no partitions within the data.
    pub partition_fields: std::vec::Vec<crate::model::schema::PartitionField>,

    /// Optional. The structure of paths containing partition data within the
    /// entity.
    pub partition_style: crate::model::schema::PartitionStyle,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_managed][crate::model::Schema::user_managed].
    pub fn set_user_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.user_managed = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Schema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partition_fields][crate::model::Schema::partition_fields].
    pub fn set_partition_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::PartitionField>,
    {
        use std::iter::Iterator;
        self.partition_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partition_style][crate::model::Schema::partition_style].
    pub fn set_partition_style<T: std::convert::Into<crate::model::schema::PartitionStyle>>(
        mut self,
        v: T,
    ) -> Self {
        self.partition_style = v.into();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Schema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Schema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_managed,
            __fields,
            __partition_fields,
            __partition_style,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userManaged" => Ok(__FieldTag::__user_managed),
                            "user_managed" => Ok(__FieldTag::__user_managed),
                            "fields" => Ok(__FieldTag::__fields),
                            "partitionFields" => Ok(__FieldTag::__partition_fields),
                            "partition_fields" => Ok(__FieldTag::__partition_fields),
                            "partitionStyle" => Ok(__FieldTag::__partition_style),
                            "partition_style" => Ok(__FieldTag::__partition_style),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Schema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_managed => {
                            if !fields.insert(__FieldTag::__user_managed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed",
                                ));
                            }
                            result.user_managed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::schema::SchemaField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partition_fields => {
                            if !fields.insert(__FieldTag::__partition_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_fields",
                                ));
                            }
                            result.partition_fields = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::schema::PartitionField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partition_style => {
                            if !fields.insert(__FieldTag::__partition_style) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_style",
                                ));
                            }
                            result.partition_style = map.next_value::<std::option::Option<crate::model::schema::PartitionStyle>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Schema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.user_managed) {
            state.serialize_entry("userManaged", &self.user_managed)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self.partition_fields.is_empty() {
            state.serialize_entry("partitionFields", &self.partition_fields)?;
        }
        if !wkt::internal::is_default(&self.partition_style) {
            state.serialize_entry("partitionStyle", &self.partition_style)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Schema].
pub mod schema {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a column field within a table schema.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SchemaField {
        /// Required. The name of the field. Must contain only letters, numbers and
        /// underscores, with a maximum length of 767 characters,
        /// and must begin with a letter or underscore.
        pub name: std::string::String,

        /// Optional. User friendly field description. Must be less than or equal to
        /// 1024 characters.
        pub description: std::string::String,

        /// Required. The type of field.
        pub r#type: crate::model::schema::Type,

        /// Required. Additional field semantics.
        pub mode: crate::model::schema::Mode,

        /// Optional. Any nested field for complex types.
        pub fields: std::vec::Vec<crate::model::schema::SchemaField>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SchemaField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::schema::SchemaField::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::schema::SchemaField::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::schema::SchemaField::type].
        pub fn set_type<T: std::convert::Into<crate::model::schema::Type>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [mode][crate::model::schema::SchemaField::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::schema::Mode>>(mut self, v: T) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [fields][crate::model::schema::SchemaField::fields].
        pub fn set_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::schema::SchemaField>,
        {
            use std::iter::Iterator;
            self.fields = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SchemaField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Schema.SchemaField"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SchemaField {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __description,
                __type,
                __mode,
                __fields,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SchemaField")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "description" => Ok(__FieldTag::__description),
                                "type" => Ok(__FieldTag::__type),
                                "mode" => Ok(__FieldTag::__mode),
                                "fields" => Ok(__FieldTag::__fields),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SchemaField;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SchemaField")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<crate::model::schema::Type>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode = map
                                    .next_value::<std::option::Option<crate::model::schema::Mode>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fields => {
                                if !fields.insert(__FieldTag::__fields) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fields",
                                    ));
                                }
                                result.fields = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::schema::SchemaField>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SchemaField {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.mode) {
                state.serialize_entry("mode", &self.mode)?;
            }
            if !self.fields.is_empty() {
                state.serialize_entry("fields", &self.fields)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents a key field within the entity's partition structure. You could
    /// have up to 20 partition fields, but only the first 10 partitions have the
    /// filtering ability due to performance consideration. **Note:**
    /// Partition fields are immutable.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PartitionField {
        /// Required. Partition field name must consist of letters, numbers, and
        /// underscores only, with a maximum of length of 256 characters, and must
        /// begin with a letter or underscore..
        pub name: std::string::String,

        /// Required. Immutable. The type of field.
        pub r#type: crate::model::schema::Type,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PartitionField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::schema::PartitionField::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::schema::PartitionField::type].
        pub fn set_type<T: std::convert::Into<crate::model::schema::Type>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for PartitionField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Schema.PartitionField"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PartitionField {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PartitionField")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PartitionField;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PartitionField")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<crate::model::schema::Type>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PartitionField {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Type information for fields in schemas and partition schemas.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// SchemaType unspecified.
        Unspecified,
        /// Boolean field.
        Boolean,
        /// Single byte numeric field.
        Byte,
        /// 16-bit numeric field.
        Int16,
        /// 32-bit numeric field.
        Int32,
        /// 64-bit numeric field.
        Int64,
        /// Floating point numeric field.
        Float,
        /// Double precision numeric field.
        Double,
        /// Real value numeric field.
        Decimal,
        /// Sequence of characters field.
        String,
        /// Sequence of bytes field.
        Binary,
        /// Date and time field.
        Timestamp,
        /// Date field.
        Date,
        /// Time field.
        Time,
        /// Structured field. Nested fields that define the structure of the map.
        /// If all nested fields are nullable, this field represents a union.
        Record,
        /// Null field that does not have values.
        Null,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Boolean => std::option::Option::Some(1),
                Self::Byte => std::option::Option::Some(2),
                Self::Int16 => std::option::Option::Some(3),
                Self::Int32 => std::option::Option::Some(4),
                Self::Int64 => std::option::Option::Some(5),
                Self::Float => std::option::Option::Some(6),
                Self::Double => std::option::Option::Some(7),
                Self::Decimal => std::option::Option::Some(8),
                Self::String => std::option::Option::Some(9),
                Self::Binary => std::option::Option::Some(10),
                Self::Timestamp => std::option::Option::Some(11),
                Self::Date => std::option::Option::Some(12),
                Self::Time => std::option::Option::Some(13),
                Self::Record => std::option::Option::Some(14),
                Self::Null => std::option::Option::Some(100),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Boolean => std::option::Option::Some("BOOLEAN"),
                Self::Byte => std::option::Option::Some("BYTE"),
                Self::Int16 => std::option::Option::Some("INT16"),
                Self::Int32 => std::option::Option::Some("INT32"),
                Self::Int64 => std::option::Option::Some("INT64"),
                Self::Float => std::option::Option::Some("FLOAT"),
                Self::Double => std::option::Option::Some("DOUBLE"),
                Self::Decimal => std::option::Option::Some("DECIMAL"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Binary => std::option::Option::Some("BINARY"),
                Self::Timestamp => std::option::Option::Some("TIMESTAMP"),
                Self::Date => std::option::Option::Some("DATE"),
                Self::Time => std::option::Option::Some("TIME"),
                Self::Record => std::option::Option::Some("RECORD"),
                Self::Null => std::option::Option::Some("NULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Boolean,
                2 => Self::Byte,
                3 => Self::Int16,
                4 => Self::Int32,
                5 => Self::Int64,
                6 => Self::Float,
                7 => Self::Double,
                8 => Self::Decimal,
                9 => Self::String,
                10 => Self::Binary,
                11 => Self::Timestamp,
                12 => Self::Date,
                13 => Self::Time,
                14 => Self::Record,
                100 => Self::Null,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "BOOLEAN" => Self::Boolean,
                "BYTE" => Self::Byte,
                "INT16" => Self::Int16,
                "INT32" => Self::Int32,
                "INT64" => Self::Int64,
                "FLOAT" => Self::Float,
                "DOUBLE" => Self::Double,
                "DECIMAL" => Self::Decimal,
                "STRING" => Self::String,
                "BINARY" => Self::Binary,
                "TIMESTAMP" => Self::Timestamp,
                "DATE" => Self::Date,
                "TIME" => Self::Time,
                "RECORD" => Self::Record,
                "NULL" => Self::Null,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Boolean => serializer.serialize_i32(1),
                Self::Byte => serializer.serialize_i32(2),
                Self::Int16 => serializer.serialize_i32(3),
                Self::Int32 => serializer.serialize_i32(4),
                Self::Int64 => serializer.serialize_i32(5),
                Self::Float => serializer.serialize_i32(6),
                Self::Double => serializer.serialize_i32(7),
                Self::Decimal => serializer.serialize_i32(8),
                Self::String => serializer.serialize_i32(9),
                Self::Binary => serializer.serialize_i32(10),
                Self::Timestamp => serializer.serialize_i32(11),
                Self::Date => serializer.serialize_i32(12),
                Self::Time => serializer.serialize_i32(13),
                Self::Record => serializer.serialize_i32(14),
                Self::Null => serializer.serialize_i32(100),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.Schema.Type",
            ))
        }
    }

    /// Additional qualifiers to define field semantics.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode unspecified.
        Unspecified,
        /// The field has required semantics.
        Required,
        /// The field has optional semantics, and may be null.
        Nullable,
        /// The field has repeated (0 or more) semantics, and is a list of values.
        Repeated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Required => std::option::Option::Some(1),
                Self::Nullable => std::option::Option::Some(2),
                Self::Repeated => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Required => std::option::Option::Some("REQUIRED"),
                Self::Nullable => std::option::Option::Some("NULLABLE"),
                Self::Repeated => std::option::Option::Some("REPEATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Required,
                2 => Self::Nullable,
                3 => Self::Repeated,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "REQUIRED" => Self::Required,
                "NULLABLE" => Self::Nullable,
                "REPEATED" => Self::Repeated,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Required => serializer.serialize_i32(1),
                Self::Nullable => serializer.serialize_i32(2),
                Self::Repeated => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.dataplex.v1.Schema.Mode",
            ))
        }
    }

    /// The structure of paths within the entity, which represent partitions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PartitionStyle {
        /// PartitionStyle unspecified
        Unspecified,
        /// Partitions are hive-compatible.
        /// Examples: `gs://bucket/path/to/table/dt=2019-10-31/lang=en`,
        /// `gs://bucket/path/to/table/dt=2019-10-31/lang=en/late`.
        HiveCompatible,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PartitionStyle::value] or
        /// [PartitionStyle::name].
        UnknownValue(partition_style::UnknownValue),
    }

    #[doc(hidden)]
    pub mod partition_style {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PartitionStyle {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HiveCompatible => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PARTITION_STYLE_UNSPECIFIED"),
                Self::HiveCompatible => std::option::Option::Some("HIVE_COMPATIBLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PartitionStyle {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PartitionStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PartitionStyle {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HiveCompatible,
                _ => Self::UnknownValue(partition_style::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PartitionStyle {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PARTITION_STYLE_UNSPECIFIED" => Self::Unspecified,
                "HIVE_COMPATIBLE" => Self::HiveCompatible,
                _ => Self::UnknownValue(partition_style::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PartitionStyle {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HiveCompatible => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PartitionStyle {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PartitionStyle>::new(
                ".google.cloud.dataplex.v1.Schema.PartitionStyle",
            ))
        }
    }
}

/// Describes the format of the data within its storage location.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageFormat {
    /// Output only. The data format associated with the stored data, which
    /// represents content type values. The value is inferred from mime type.
    pub format: crate::model::storage_format::Format,

    /// Optional. The compression type associated with the stored data.
    /// If unspecified, the data is uncompressed.
    pub compression_format: crate::model::storage_format::CompressionFormat,

    /// Required. The mime type descriptor for the data. Must match the pattern
    /// {type}/{subtype}. Supported values:
    ///
    /// - application/x-parquet
    /// - application/x-avro
    /// - application/x-orc
    /// - application/x-tfrecord
    /// - application/x-parquet+iceberg
    /// - application/x-avro+iceberg
    /// - application/x-orc+iceberg
    /// - application/json
    /// - application/{subtypes}
    /// - text/csv
    /// - text/\<subtypes\>
    /// - image/{image subtype}
    /// - video/{video subtype}
    /// - audio/{audio subtype}
    pub mime_type: std::string::String,

    /// Additional format-specific options.
    pub options: std::option::Option<crate::model::storage_format::Options>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::StorageFormat::format].
    pub fn set_format<T: std::convert::Into<crate::model::storage_format::Format>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [compression_format][crate::model::StorageFormat::compression_format].
    pub fn set_compression_format<
        T: std::convert::Into<crate::model::storage_format::CompressionFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compression_format = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::StorageFormat::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::StorageFormat::options].
    ///
    /// Note that all the setters affecting `options` are mutually
    /// exclusive.
    pub fn set_options<
        T: std::convert::Into<std::option::Option<crate::model::storage_format::Options>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = v.into();
        self
    }

    /// The value of [options][crate::model::StorageFormat::options]
    /// if it holds a `Csv`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::storage_format::CsvOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::storage_format::Options::Csv(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::StorageFormat::options]
    /// to hold a `Csv`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_csv<
        T: std::convert::Into<std::boxed::Box<crate::model::storage_format::CsvOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::storage_format::Options::Csv(v.into()));
        self
    }

    /// The value of [options][crate::model::StorageFormat::options]
    /// if it holds a `Json`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::storage_format::JsonOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::storage_format::Options::Json(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::StorageFormat::options]
    /// to hold a `Json`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_json<
        T: std::convert::Into<std::boxed::Box<crate::model::storage_format::JsonOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::storage_format::Options::Json(v.into()));
        self
    }

    /// The value of [options][crate::model::StorageFormat::options]
    /// if it holds a `Iceberg`, `None` if the field is not set or
    /// holds a different branch.
    pub fn iceberg(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::storage_format::IcebergOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::storage_format::Options::Iceberg(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::StorageFormat::options]
    /// to hold a `Iceberg`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_iceberg<
        T: std::convert::Into<std::boxed::Box<crate::model::storage_format::IcebergOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::storage_format::Options::Iceberg(v.into()));
        self
    }
}

impl wkt::message::Message for StorageFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __format,
            __compression_format,
            __mime_type,
            __csv,
            __json,
            __iceberg,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageFormat")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "format" => Ok(__FieldTag::__format),
                            "compressionFormat" => Ok(__FieldTag::__compression_format),
                            "compression_format" => Ok(__FieldTag::__compression_format),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "csv" => Ok(__FieldTag::__csv),
                            "json" => Ok(__FieldTag::__json),
                            "iceberg" => Ok(__FieldTag::__iceberg),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageFormat;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageFormat")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map.next_value::<std::option::Option<crate::model::storage_format::Format>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compression_format => {
                            if !fields.insert(__FieldTag::__compression_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compression_format",
                                ));
                            }
                            result.compression_format = map
                                .next_value::<std::option::Option<
                                    crate::model::storage_format::CompressionFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__csv => {
                            if !fields.insert(__FieldTag::__csv) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv",
                                ));
                            }
                            if result.options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `options`, a oneof with full ID .google.cloud.dataplex.v1.StorageFormat.csv, latest field was csv",
                                ));
                            }
                            result.options = std::option::Option::Some(
                                crate::model::storage_format::Options::Csv(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::storage_format::CsvOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__json => {
                            if !fields.insert(__FieldTag::__json) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json",
                                ));
                            }
                            if result.options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `options`, a oneof with full ID .google.cloud.dataplex.v1.StorageFormat.json, latest field was json",
                                ));
                            }
                            result.options = std::option::Option::Some(
                                crate::model::storage_format::Options::Json(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::storage_format::JsonOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__iceberg => {
                            if !fields.insert(__FieldTag::__iceberg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iceberg",
                                ));
                            }
                            if result.options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `options`, a oneof with full ID .google.cloud.dataplex.v1.StorageFormat.iceberg, latest field was iceberg",
                                ));
                            }
                            result.options = std::option::Option::Some(
                                crate::model::storage_format::Options::Iceberg(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::storage_format::IcebergOptions,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.format) {
            state.serialize_entry("format", &self.format)?;
        }
        if !wkt::internal::is_default(&self.compression_format) {
            state.serialize_entry("compressionFormat", &self.compression_format)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if let Some(value) = self.csv() {
            state.serialize_entry("csv", value)?;
        }
        if let Some(value) = self.json() {
            state.serialize_entry("json", value)?;
        }
        if let Some(value) = self.iceberg() {
            state.serialize_entry("iceberg", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StorageFormat].
pub mod storage_format {
    #[allow(unused_imports)]
    use super::*;

    /// Describes CSV and similar semi-structured data formats.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CsvOptions {
        /// Optional. The character encoding of the data. Accepts "US-ASCII",
        /// "UTF-8", and "ISO-8859-1". Defaults to UTF-8 if unspecified.
        pub encoding: std::string::String,

        /// Optional. The number of rows to interpret as header rows that should be
        /// skipped when reading data rows. Defaults to 0.
        pub header_rows: i32,

        /// Optional. The delimiter used to separate values. Defaults to ','.
        pub delimiter: std::string::String,

        /// Optional. The character used to quote column values. Accepts '"'
        /// (double quotation mark) or ''' (single quotation mark). Defaults to
        /// '"' (double quotation mark) if unspecified.
        pub quote: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::storage_format::CsvOptions::encoding].
        pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.encoding = v.into();
            self
        }

        /// Sets the value of [header_rows][crate::model::storage_format::CsvOptions::header_rows].
        pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.header_rows = v.into();
            self
        }

        /// Sets the value of [delimiter][crate::model::storage_format::CsvOptions::delimiter].
        pub fn set_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.delimiter = v.into();
            self
        }

        /// Sets the value of [quote][crate::model::storage_format::CsvOptions::quote].
        pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.quote = v.into();
            self
        }
    }

    impl wkt::message::Message for CsvOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat.CsvOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CsvOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __encoding,
                __header_rows,
                __delimiter,
                __quote,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CsvOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "encoding" => Ok(__FieldTag::__encoding),
                                "headerRows" => Ok(__FieldTag::__header_rows),
                                "header_rows" => Ok(__FieldTag::__header_rows),
                                "delimiter" => Ok(__FieldTag::__delimiter),
                                "quote" => Ok(__FieldTag::__quote),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CsvOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CsvOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__encoding => {
                                if !fields.insert(__FieldTag::__encoding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding",
                                    ));
                                }
                                result.encoding = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__header_rows => {
                                if !fields.insert(__FieldTag::__header_rows) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for header_rows",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.header_rows =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__delimiter => {
                                if !fields.insert(__FieldTag::__delimiter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for delimiter",
                                    ));
                                }
                                result.delimiter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__quote => {
                                if !fields.insert(__FieldTag::__quote) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quote",
                                    ));
                                }
                                result.quote = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CsvOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.encoding.is_empty() {
                state.serialize_entry("encoding", &self.encoding)?;
            }
            if !wkt::internal::is_default(&self.header_rows) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("headerRows", &__With(&self.header_rows))?;
            }
            if !self.delimiter.is_empty() {
                state.serialize_entry("delimiter", &self.delimiter)?;
            }
            if !self.quote.is_empty() {
                state.serialize_entry("quote", &self.quote)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Describes JSON data format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct JsonOptions {
        /// Optional. The character encoding of the data. Accepts "US-ASCII", "UTF-8"
        /// and "ISO-8859-1". Defaults to UTF-8 if not specified.
        pub encoding: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl JsonOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::storage_format::JsonOptions::encoding].
        pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.encoding = v.into();
            self
        }
    }

    impl wkt::message::Message for JsonOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat.JsonOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for JsonOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __encoding,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for JsonOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "encoding" => Ok(__FieldTag::__encoding),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = JsonOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct JsonOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__encoding => {
                                if !fields.insert(__FieldTag::__encoding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding",
                                    ));
                                }
                                result.encoding = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for JsonOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.encoding.is_empty() {
                state.serialize_entry("encoding", &self.encoding)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Describes Iceberg data format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IcebergOptions {
        /// Optional. The location of where the iceberg metadata is present, must be
        /// within the table path
        pub metadata_location: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IcebergOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metadata_location][crate::model::storage_format::IcebergOptions::metadata_location].
        pub fn set_metadata_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.metadata_location = v.into();
            self
        }
    }

    impl wkt::message::Message for IcebergOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat.IcebergOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IcebergOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __metadata_location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IcebergOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "metadataLocation" => Ok(__FieldTag::__metadata_location),
                                "metadata_location" => Ok(__FieldTag::__metadata_location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IcebergOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IcebergOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__metadata_location => {
                                if !fields.insert(__FieldTag::__metadata_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata_location",
                                    ));
                                }
                                result.metadata_location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IcebergOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.metadata_location.is_empty() {
                state.serialize_entry("metadataLocation", &self.metadata_location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The specific file format of the data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Format {
        /// Format unspecified.
        Unspecified,
        /// Parquet-formatted structured data.
        Parquet,
        /// Avro-formatted structured data.
        Avro,
        /// Orc-formatted structured data.
        Orc,
        /// Csv-formatted semi-structured data.
        Csv,
        /// Json-formatted semi-structured data.
        Json,
        /// Image data formats (such as jpg and png).
        Image,
        /// Audio data formats (such as mp3, and wav).
        Audio,
        /// Video data formats (such as mp4 and mpg).
        Video,
        /// Textual data formats (such as txt and xml).
        Text,
        /// TensorFlow record format.
        Tfrecord,
        /// Data that doesn't match a specific format.
        Other,
        /// Data of an unknown format.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Format::value] or
        /// [Format::name].
        UnknownValue(format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Format {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Parquet => std::option::Option::Some(1),
                Self::Avro => std::option::Option::Some(2),
                Self::Orc => std::option::Option::Some(3),
                Self::Csv => std::option::Option::Some(100),
                Self::Json => std::option::Option::Some(101),
                Self::Image => std::option::Option::Some(200),
                Self::Audio => std::option::Option::Some(201),
                Self::Video => std::option::Option::Some(202),
                Self::Text => std::option::Option::Some(203),
                Self::Tfrecord => std::option::Option::Some(204),
                Self::Other => std::option::Option::Some(1000),
                Self::Unknown => std::option::Option::Some(1001),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                Self::Parquet => std::option::Option::Some("PARQUET"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::Orc => std::option::Option::Some("ORC"),
                Self::Csv => std::option::Option::Some("CSV"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::Image => std::option::Option::Some("IMAGE"),
                Self::Audio => std::option::Option::Some("AUDIO"),
                Self::Video => std::option::Option::Some("VIDEO"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Tfrecord => std::option::Option::Some("TFRECORD"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Format {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Format {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Format {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Parquet,
                2 => Self::Avro,
                3 => Self::Orc,
                100 => Self::Csv,
                101 => Self::Json,
                200 => Self::Image,
                201 => Self::Audio,
                202 => Self::Video,
                203 => Self::Text,
                204 => Self::Tfrecord,
                1000 => Self::Other,
                1001 => Self::Unknown,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Format {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FORMAT_UNSPECIFIED" => Self::Unspecified,
                "PARQUET" => Self::Parquet,
                "AVRO" => Self::Avro,
                "ORC" => Self::Orc,
                "CSV" => Self::Csv,
                "JSON" => Self::Json,
                "IMAGE" => Self::Image,
                "AUDIO" => Self::Audio,
                "VIDEO" => Self::Video,
                "TEXT" => Self::Text,
                "TFRECORD" => Self::Tfrecord,
                "OTHER" => Self::Other,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Format {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Parquet => serializer.serialize_i32(1),
                Self::Avro => serializer.serialize_i32(2),
                Self::Orc => serializer.serialize_i32(3),
                Self::Csv => serializer.serialize_i32(100),
                Self::Json => serializer.serialize_i32(101),
                Self::Image => serializer.serialize_i32(200),
                Self::Audio => serializer.serialize_i32(201),
                Self::Video => serializer.serialize_i32(202),
                Self::Text => serializer.serialize_i32(203),
                Self::Tfrecord => serializer.serialize_i32(204),
                Self::Other => serializer.serialize_i32(1000),
                Self::Unknown => serializer.serialize_i32(1001),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Format {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                ".google.cloud.dataplex.v1.StorageFormat.Format",
            ))
        }
    }

    /// The specific compressed file format of the data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompressionFormat {
        /// CompressionFormat unspecified. Implies uncompressed data.
        Unspecified,
        /// GZip compressed set of files.
        Gzip,
        /// BZip2 compressed set of files.
        Bzip2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompressionFormat::value] or
        /// [CompressionFormat::name].
        UnknownValue(compression_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod compression_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompressionFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gzip => std::option::Option::Some(2),
                Self::Bzip2 => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPRESSION_FORMAT_UNSPECIFIED"),
                Self::Gzip => std::option::Option::Some("GZIP"),
                Self::Bzip2 => std::option::Option::Some("BZIP2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompressionFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompressionFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompressionFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Gzip,
                3 => Self::Bzip2,
                _ => Self::UnknownValue(compression_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompressionFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPRESSION_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "GZIP" => Self::Gzip,
                "BZIP2" => Self::Bzip2,
                _ => Self::UnknownValue(compression_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompressionFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gzip => serializer.serialize_i32(2),
                Self::Bzip2 => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompressionFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompressionFormat>::new(
                ".google.cloud.dataplex.v1.StorageFormat.CompressionFormat",
            ))
        }
    }

    /// Additional format-specific options.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Options {
        /// Optional. Additional information about CSV formatted data.
        Csv(std::boxed::Box<crate::model::storage_format::CsvOptions>),
        /// Optional. Additional information about CSV formatted data.
        Json(std::boxed::Box<crate::model::storage_format::JsonOptions>),
        /// Optional. Additional information about iceberg tables.
        Iceberg(std::boxed::Box<crate::model::storage_format::IcebergOptions>),
    }
}

/// Describes the access mechanism of the data within its storage location.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageAccess {
    /// Output only. Describes the read access mechanism of the data. Not user
    /// settable.
    pub read: crate::model::storage_access::AccessMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageAccess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read][crate::model::StorageAccess::read].
    pub fn set_read<T: std::convert::Into<crate::model::storage_access::AccessMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.read = v.into();
        self
    }
}

impl wkt::message::Message for StorageAccess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.StorageAccess"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageAccess {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __read,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageAccess")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "read" => Ok(__FieldTag::__read),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageAccess;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageAccess")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__read => {
                            if !fields.insert(__FieldTag::__read) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read",
                                ));
                            }
                            result.read = map.next_value::<std::option::Option<crate::model::storage_access::AccessMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageAccess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.read) {
            state.serialize_entry("read", &self.read)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StorageAccess].
pub mod storage_access {
    #[allow(unused_imports)]
    use super::*;

    /// Access Mode determines how data stored within the Entity is read.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessMode {
        /// Access mode unspecified.
        Unspecified,
        /// Default. Data is accessed directly using storage APIs.
        Direct,
        /// Data is accessed through a managed interface using BigQuery APIs.
        Managed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccessMode::value] or
        /// [AccessMode::name].
        UnknownValue(access_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod access_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccessMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Direct => std::option::Option::Some(1),
                Self::Managed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACCESS_MODE_UNSPECIFIED"),
                Self::Direct => std::option::Option::Some("DIRECT"),
                Self::Managed => std::option::Option::Some("MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccessMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccessMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccessMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Direct,
                2 => Self::Managed,
                _ => Self::UnknownValue(access_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccessMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCESS_MODE_UNSPECIFIED" => Self::Unspecified,
                "DIRECT" => Self::Direct,
                "MANAGED" => Self::Managed,
                _ => Self::UnknownValue(access_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccessMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Direct => serializer.serialize_i32(1),
                Self::Managed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccessMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessMode>::new(
                ".google.cloud.dataplex.v1.StorageAccess.AccessMode",
            ))
        }
    }
}

/// DataScan scheduling and trigger settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Trigger {
    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    pub mode: std::option::Option<crate::model::trigger::Mode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::Trigger::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<T: std::convert::Into<std::option::Option<crate::model::trigger::Mode>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::Trigger::mode]
    /// if it holds a `OnDemand`, `None` if the field is not set or
    /// holds a different branch.
    pub fn on_demand(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::trigger::OnDemand>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::trigger::Mode::OnDemand(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Trigger::mode]
    /// to hold a `OnDemand`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_on_demand<
        T: std::convert::Into<std::boxed::Box<crate::model::trigger::OnDemand>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(crate::model::trigger::Mode::OnDemand(v.into()));
        self
    }

    /// The value of [mode][crate::model::Trigger::mode]
    /// if it holds a `Schedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::trigger::Schedule>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::trigger::Mode::Schedule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Trigger::mode]
    /// to hold a `Schedule`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_schedule<T: std::convert::Into<std::boxed::Box<crate::model::trigger::Schedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(crate::model::trigger::Mode::Schedule(v.into()));
        self
    }
}

impl wkt::message::Message for Trigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Trigger"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Trigger {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __on_demand,
            __schedule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Trigger")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "onDemand" => Ok(__FieldTag::__on_demand),
                            "on_demand" => Ok(__FieldTag::__on_demand),
                            "schedule" => Ok(__FieldTag::__schedule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Trigger;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Trigger")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__on_demand => {
                            if !fields.insert(__FieldTag::__on_demand) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for on_demand",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.dataplex.v1.Trigger.on_demand, latest field was onDemand",
                                ));
                            }
                            result.mode =
                                std::option::Option::Some(crate::model::trigger::Mode::OnDemand(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::trigger::OnDemand>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.dataplex.v1.Trigger.schedule, latest field was schedule",
                                ));
                            }
                            result.mode =
                                std::option::Option::Some(crate::model::trigger::Mode::Schedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::trigger::Schedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Trigger {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.on_demand() {
            state.serialize_entry("onDemand", value)?;
        }
        if let Some(value) = self.schedule() {
            state.serialize_entry("schedule", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Trigger].
pub mod trigger {
    #[allow(unused_imports)]
    use super::*;

    /// The scan runs once via `RunDataScan` API.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OnDemand {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OnDemand {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for OnDemand {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Trigger.OnDemand"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OnDemand {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OnDemand")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OnDemand;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OnDemand")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OnDemand {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The scan is scheduled to run periodically.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Schedule {
        /// Required. [Cron](https://en.wikipedia.org/wiki/Cron) schedule for running
        /// scans periodically.
        ///
        /// To explicitly set a timezone in the cron tab, apply a prefix in the
        /// cron tab: **"CRON_TZ=${IANA_TIME_ZONE}"** or **"TZ=${IANA_TIME_ZONE}"**.
        /// The **${IANA_TIME_ZONE}** may only be a valid string from IANA time zone
        /// database
        /// ([wikipedia](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List)).
        /// For example, `CRON_TZ=America/New_York 1 * * * *`, or
        /// `TZ=America/New_York 1 * * * *`.
        ///
        /// This field is required for Schedule scans.
        pub cron: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Schedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cron][crate::model::trigger::Schedule::cron].
        pub fn set_cron<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cron = v.into();
            self
        }
    }

    impl wkt::message::Message for Schedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Trigger.Schedule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Schedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cron,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Schedule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cron" => Ok(__FieldTag::__cron),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Schedule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Schedule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cron => {
                                if !fields.insert(__FieldTag::__cron) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cron",
                                    ));
                                }
                                result.cron = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Schedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cron.is_empty() {
                state.serialize_entry("cron", &self.cron)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// The scan runs once via `RunDataScan` API.
        OnDemand(std::boxed::Box<crate::model::trigger::OnDemand>),
        /// The scan is scheduled to run periodically.
        Schedule(std::boxed::Box<crate::model::trigger::Schedule>),
    }
}

/// The data source for DataScan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSource {
    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    pub source: std::option::Option<crate::model::data_source::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::DataSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::data_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::DataSource::source]
    /// if it holds a `Entity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::data_source::Source::Entity(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DataSource::source]
    /// to hold a `Entity`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::data_source::Source::Entity(v.into()));
        self
    }

    /// The value of [source][crate::model::DataSource::source]
    /// if it holds a `Resource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::data_source::Source::Resource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DataSource::source]
    /// to hold a `Resource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::data_source::Source::Resource(v.into()));
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entity" => Ok(__FieldTag::__entity),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dataplex.v1.DataSource.entity, latest field was entity",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::data_source::Source::Entity(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dataplex.v1.DataSource.resource, latest field was resource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::data_source::Source::Resource(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.entity() {
            state.serialize_entry("entity", value)?;
        }
        if let Some(value) = self.resource() {
            state.serialize_entry("resource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataSource].
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;

    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Immutable. The Dataplex entity that represents the data source (e.g.
        /// BigQuery table) for DataScan, of the form:
        /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
        Entity(std::string::String),
        /// Immutable. The service-qualified full resource name of the cloud resource
        /// for a DataScan job to scan against. The field could be: BigQuery table of
        /// type "TABLE" for DataProfileScan/DataQualityScan Format:
        /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        Resource(std::string::String),
    }
}

/// The data scanned during processing (e.g. in incremental DataScan)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScannedData {
    /// The range of scanned data
    pub data_range: std::option::Option<crate::model::scanned_data::DataRange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScannedData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_range][crate::model::ScannedData::data_range].
    ///
    /// Note that all the setters affecting `data_range` are mutually
    /// exclusive.
    pub fn set_data_range<
        T: std::convert::Into<std::option::Option<crate::model::scanned_data::DataRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_range = v.into();
        self
    }

    /// The value of [data_range][crate::model::ScannedData::data_range]
    /// if it holds a `IncrementalField`, `None` if the field is not set or
    /// holds a different branch.
    pub fn incremental_field(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scanned_data::IncrementalField>> {
        #[allow(unreachable_patterns)]
        self.data_range.as_ref().and_then(|v| match v {
            crate::model::scanned_data::DataRange::IncrementalField(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_range][crate::model::ScannedData::data_range]
    /// to hold a `IncrementalField`.
    ///
    /// Note that all the setters affecting `data_range` are
    /// mutually exclusive.
    pub fn set_incremental_field<
        T: std::convert::Into<std::boxed::Box<crate::model::scanned_data::IncrementalField>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_range = std::option::Option::Some(
            crate::model::scanned_data::DataRange::IncrementalField(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ScannedData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ScannedData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScannedData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __incremental_field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScannedData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "incrementalField" => Ok(__FieldTag::__incremental_field),
                            "incremental_field" => Ok(__FieldTag::__incremental_field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScannedData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScannedData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__incremental_field => {
                            if !fields.insert(__FieldTag::__incremental_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incremental_field",
                                ));
                            }
                            if result.data_range.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_range`, a oneof with full ID .google.cloud.dataplex.v1.ScannedData.incremental_field, latest field was incrementalField",
                                ));
                            }
                            result.data_range = std::option::Option::Some(
                                crate::model::scanned_data::DataRange::IncrementalField(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::scanned_data::IncrementalField,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScannedData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.incremental_field() {
            state.serialize_entry("incrementalField", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ScannedData].
pub mod scanned_data {
    #[allow(unused_imports)]
    use super::*;

    /// A data range denoted by a pair of start/end values of a field.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IncrementalField {
        /// The field that contains values which monotonically increases over time
        /// (e.g. a timestamp column).
        pub field: std::string::String,

        /// Value that marks the start of the range.
        pub start: std::string::String,

        /// Value that marks the end of the range.
        pub end: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncrementalField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::scanned_data::IncrementalField::field].
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [start][crate::model::scanned_data::IncrementalField::start].
        pub fn set_start<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.start = v.into();
            self
        }

        /// Sets the value of [end][crate::model::scanned_data::IncrementalField::end].
        pub fn set_end<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.end = v.into();
            self
        }
    }

    impl wkt::message::Message for IncrementalField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.ScannedData.IncrementalField"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IncrementalField {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                __start,
                __end,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IncrementalField")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                "start" => Ok(__FieldTag::__start),
                                "end" => Ok(__FieldTag::__end),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IncrementalField;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IncrementalField")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__start => {
                                if !fields.insert(__FieldTag::__start) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start",
                                    ));
                                }
                                result.start = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__end => {
                                if !fields.insert(__FieldTag::__end) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end",
                                    ));
                                }
                                result.end = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IncrementalField {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.field.is_empty() {
                state.serialize_entry("field", &self.field)?;
            }
            if !self.start.is_empty() {
                state.serialize_entry("start", &self.start)?;
            }
            if !self.end.is_empty() {
                state.serialize_entry("end", &self.end)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The range of scanned data
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataRange {
        /// The range denoted by values of an incremental field
        IncrementalField(std::boxed::Box<crate::model::scanned_data::IncrementalField>),
    }
}

/// A lake is a centralized repository for managing enterprise data across the
/// organization distributed across many cloud projects, and stored in a variety
/// of storage services such as Google Cloud Storage and BigQuery. The resources
/// attached to a lake are referred to as managed resources. Data within these
/// managed resources can be structured or unstructured. A lake provides data
/// admins with tools to organize, secure and manage their data at scale, and
/// provides data scientists and data engineers an integrated experience to
/// easily search, discover, analyze and transform data and associated metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Lake {
    /// Output only. The relative resource name of the lake, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub name: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the lake. This ID will
    /// be different if the lake is deleted and re-created with the same name.
    pub uid: std::string::String,

    /// Output only. The time when the lake was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the lake was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-defined labels for the lake.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the lake.
    pub description: std::string::String,

    /// Output only. Current state of the lake.
    pub state: crate::model::State,

    /// Output only. Service account associated with this lake. This service
    /// account must be authorized to access or operate on resources managed by the
    /// lake.
    pub service_account: std::string::String,

    /// Optional. Settings to manage lake and Dataproc Metastore service instance
    /// association.
    pub metastore: std::option::Option<crate::model::lake::Metastore>,

    /// Output only. Aggregated status of the underlying assets of the lake.
    pub asset_status: std::option::Option<crate::model::AssetStatus>,

    /// Output only. Metastore status of the lake.
    pub metastore_status: std::option::Option<crate::model::lake::MetastoreStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Lake {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Lake::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Lake::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Lake::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Lake::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Lake::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Lake::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Lake::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Lake::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Lake::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Lake::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Lake::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [metastore][crate::model::Lake::metastore].
    pub fn set_metastore<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::lake::Metastore>,
    {
        self.metastore = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metastore][crate::model::Lake::metastore].
    pub fn set_or_clear_metastore<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::lake::Metastore>,
    {
        self.metastore = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset_status][crate::model::Lake::asset_status].
    pub fn set_asset_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssetStatus>,
    {
        self.asset_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [asset_status][crate::model::Lake::asset_status].
    pub fn set_or_clear_asset_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssetStatus>,
    {
        self.asset_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metastore_status][crate::model::Lake::metastore_status].
    pub fn set_metastore_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::lake::MetastoreStatus>,
    {
        self.metastore_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metastore_status][crate::model::Lake::metastore_status].
    pub fn set_or_clear_metastore_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::lake::MetastoreStatus>,
    {
        self.metastore_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Lake {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Lake"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Lake {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __create_time,
            __update_time,
            __labels,
            __description,
            __state,
            __service_account,
            __metastore,
            __asset_status,
            __metastore_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Lake")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "metastore" => Ok(__FieldTag::__metastore),
                            "assetStatus" => Ok(__FieldTag::__asset_status),
                            "asset_status" => Ok(__FieldTag::__asset_status),
                            "metastoreStatus" => Ok(__FieldTag::__metastore_status),
                            "metastore_status" => Ok(__FieldTag::__metastore_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Lake;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Lake")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metastore => {
                            if !fields.insert(__FieldTag::__metastore) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metastore",
                                ));
                            }
                            result.metastore = map
                                .next_value::<std::option::Option<crate::model::lake::Metastore>>(
                                )?;
                        }
                        __FieldTag::__asset_status => {
                            if !fields.insert(__FieldTag::__asset_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_status",
                                ));
                            }
                            result.asset_status =
                                map.next_value::<std::option::Option<crate::model::AssetStatus>>()?;
                        }
                        __FieldTag::__metastore_status => {
                            if !fields.insert(__FieldTag::__metastore_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metastore_status",
                                ));
                            }
                            result.metastore_status = map.next_value::<std::option::Option<crate::model::lake::MetastoreStatus>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Lake {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.metastore.is_some() {
            state.serialize_entry("metastore", &self.metastore)?;
        }
        if self.asset_status.is_some() {
            state.serialize_entry("assetStatus", &self.asset_status)?;
        }
        if self.metastore_status.is_some() {
            state.serialize_entry("metastoreStatus", &self.metastore_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Lake].
pub mod lake {
    #[allow(unused_imports)]
    use super::*;

    /// Settings to manage association of Dataproc Metastore with a lake.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Metastore {
        /// Optional. A relative reference to the Dataproc Metastore
        /// (<https://cloud.google.com/dataproc-metastore/docs>) service associated
        /// with the lake:
        /// `projects/{project_id}/locations/{location_id}/services/{service_id}`
        pub service: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metastore {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::lake::Metastore::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }
    }

    impl wkt::message::Message for Metastore {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Lake.Metastore"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Metastore {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Metastore")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "service" => Ok(__FieldTag::__service),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Metastore;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Metastore")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service => {
                                if !fields.insert(__FieldTag::__service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service",
                                    ));
                                }
                                result.service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Metastore {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service.is_empty() {
                state.serialize_entry("service", &self.service)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Status of Lake and Dataproc Metastore service instance association.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MetastoreStatus {
        /// Current state of association.
        pub state: crate::model::lake::metastore_status::State,

        /// Additional information about the current status.
        pub message: std::string::String,

        /// Last update time of the metastore status of the lake.
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// The URI of the endpoint used to access the Metastore service.
        pub endpoint: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MetastoreStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::lake::MetastoreStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::lake::metastore_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::lake::MetastoreStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::lake::MetastoreStatus::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::lake::MetastoreStatus::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [endpoint][crate::model::lake::MetastoreStatus::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }
    }

    impl wkt::message::Message for MetastoreStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Lake.MetastoreStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MetastoreStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __message,
                __update_time,
                __endpoint,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MetastoreStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "message" => Ok(__FieldTag::__message),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                "endpoint" => Ok(__FieldTag::__endpoint),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MetastoreStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MetastoreStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::lake::metastore_status::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__message => {
                                if !fields.insert(__FieldTag::__message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message",
                                    ));
                                }
                                result.message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__endpoint => {
                                if !fields.insert(__FieldTag::__endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for endpoint",
                                    ));
                                }
                                result.endpoint = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MetastoreStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.message.is_empty() {
                state.serialize_entry("message", &self.message)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self.endpoint.is_empty() {
                state.serialize_entry("endpoint", &self.endpoint)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [MetastoreStatus].
    pub mod metastore_status {
        #[allow(unused_imports)]
        use super::*;

        /// Current state of association.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unspecified.
            Unspecified,
            /// A Metastore service instance is not associated with the lake.
            None,
            /// A Metastore service instance is attached to the lake.
            Ready,
            /// Attach/detach is in progress.
            Updating,
            /// Attach/detach could not be done due to errors.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::None => std::option::Option::Some(1),
                    Self::Ready => std::option::Option::Some(2),
                    Self::Updating => std::option::Option::Some(3),
                    Self::Error => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::None => std::option::Option::Some("NONE"),
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::Updating => std::option::Option::Some("UPDATING"),
                    Self::Error => std::option::Option::Some("ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::None,
                    2 => Self::Ready,
                    3 => Self::Updating,
                    4 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "NONE" => Self::None,
                    "READY" => Self::Ready,
                    "UPDATING" => Self::Updating,
                    "ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::None => serializer.serialize_i32(1),
                    Self::Ready => serializer.serialize_i32(2),
                    Self::Updating => serializer.serialize_i32(3),
                    Self::Error => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Lake.MetastoreStatus.State",
                ))
            }
        }
    }
}

/// Aggregated status of the underlying assets of a lake or zone.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AssetStatus {
    /// Last update time of the status.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Number of active assets.
    pub active_assets: i32,

    /// Number of assets that are in process of updating the security policy on
    /// attached resources.
    pub security_policy_applying_assets: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssetStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::AssetStatus::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AssetStatus::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [active_assets][crate::model::AssetStatus::active_assets].
    pub fn set_active_assets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.active_assets = v.into();
        self
    }

    /// Sets the value of [security_policy_applying_assets][crate::model::AssetStatus::security_policy_applying_assets].
    pub fn set_security_policy_applying_assets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.security_policy_applying_assets = v.into();
        self
    }
}

impl wkt::message::Message for AssetStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.AssetStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssetStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_time,
            __active_assets,
            __security_policy_applying_assets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssetStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "activeAssets" => Ok(__FieldTag::__active_assets),
                            "active_assets" => Ok(__FieldTag::__active_assets),
                            "securityPolicyApplyingAssets" => {
                                Ok(__FieldTag::__security_policy_applying_assets)
                            }
                            "security_policy_applying_assets" => {
                                Ok(__FieldTag::__security_policy_applying_assets)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssetStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssetStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__active_assets => {
                            if !fields.insert(__FieldTag::__active_assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_assets",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.active_assets =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__security_policy_applying_assets => {
                            if !fields.insert(__FieldTag::__security_policy_applying_assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_policy_applying_assets",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.security_policy_applying_assets =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssetStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.active_assets) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("activeAssets", &__With(&self.active_assets))?;
        }
        if !wkt::internal::is_default(&self.security_policy_applying_assets) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "securityPolicyApplyingAssets",
                &__With(&self.security_policy_applying_assets),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A zone represents a logical group of related assets within a lake. A zone can
/// be used to map to organizational structure or represent stages of data
/// readiness from raw to curated. It provides managing behavior that is shared
/// or inherited by all contained assets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Zone {
    /// Output only. The relative resource name of the zone, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub name: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the zone. This ID will
    /// be different if the zone is deleted and re-created with the same name.
    pub uid: std::string::String,

    /// Output only. The time when the zone was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the zone was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the zone.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the zone.
    pub description: std::string::String,

    /// Output only. Current state of the zone.
    pub state: crate::model::State,

    /// Required. Immutable. The type of the zone.
    pub r#type: crate::model::zone::Type,

    /// Optional. Specification of the discovery feature applied to data in this
    /// zone.
    pub discovery_spec: std::option::Option<crate::model::zone::DiscoverySpec>,

    /// Required. Specification of the resources that are referenced by the assets
    /// within this zone.
    pub resource_spec: std::option::Option<crate::model::zone::ResourceSpec>,

    /// Output only. Aggregated status of the underlying assets of the zone.
    pub asset_status: std::option::Option<crate::model::AssetStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Zone {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Zone::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Zone::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Zone::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Zone::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Zone::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Zone::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Zone::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Zone::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Zone::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Zone::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Zone::type].
    pub fn set_type<T: std::convert::Into<crate::model::zone::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [discovery_spec][crate::model::Zone::discovery_spec].
    pub fn set_discovery_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::zone::DiscoverySpec>,
    {
        self.discovery_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discovery_spec][crate::model::Zone::discovery_spec].
    pub fn set_or_clear_discovery_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::zone::DiscoverySpec>,
    {
        self.discovery_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_spec][crate::model::Zone::resource_spec].
    pub fn set_resource_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::zone::ResourceSpec>,
    {
        self.resource_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_spec][crate::model::Zone::resource_spec].
    pub fn set_or_clear_resource_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::zone::ResourceSpec>,
    {
        self.resource_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset_status][crate::model::Zone::asset_status].
    pub fn set_asset_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssetStatus>,
    {
        self.asset_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [asset_status][crate::model::Zone::asset_status].
    pub fn set_or_clear_asset_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssetStatus>,
    {
        self.asset_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Zone {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Zone"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Zone {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __create_time,
            __update_time,
            __labels,
            __description,
            __state,
            __type,
            __discovery_spec,
            __resource_spec,
            __asset_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Zone")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "type" => Ok(__FieldTag::__type),
                            "discoverySpec" => Ok(__FieldTag::__discovery_spec),
                            "discovery_spec" => Ok(__FieldTag::__discovery_spec),
                            "resourceSpec" => Ok(__FieldTag::__resource_spec),
                            "resource_spec" => Ok(__FieldTag::__resource_spec),
                            "assetStatus" => Ok(__FieldTag::__asset_status),
                            "asset_status" => Ok(__FieldTag::__asset_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Zone;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Zone")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::zone::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_spec => {
                            if !fields.insert(__FieldTag::__discovery_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_spec",
                                ));
                            }
                            result.discovery_spec = map.next_value::<std::option::Option<crate::model::zone::DiscoverySpec>>()?
                                ;
                        }
                        __FieldTag::__resource_spec => {
                            if !fields.insert(__FieldTag::__resource_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_spec",
                                ));
                            }
                            result.resource_spec = map.next_value::<std::option::Option<crate::model::zone::ResourceSpec>>()?
                                ;
                        }
                        __FieldTag::__asset_status => {
                            if !fields.insert(__FieldTag::__asset_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_status",
                                ));
                            }
                            result.asset_status =
                                map.next_value::<std::option::Option<crate::model::AssetStatus>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Zone {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.discovery_spec.is_some() {
            state.serialize_entry("discoverySpec", &self.discovery_spec)?;
        }
        if self.resource_spec.is_some() {
            state.serialize_entry("resourceSpec", &self.resource_spec)?;
        }
        if self.asset_status.is_some() {
            state.serialize_entry("assetStatus", &self.asset_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Zone].
pub mod zone {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for resources attached as assets within a zone.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceSpec {
        /// Required. Immutable. The location type of the resources that are allowed
        /// to be attached to the assets within this zone.
        pub location_type: crate::model::zone::resource_spec::LocationType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location_type][crate::model::zone::ResourceSpec::location_type].
        pub fn set_location_type<
            T: std::convert::Into<crate::model::zone::resource_spec::LocationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.location_type = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Zone.ResourceSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __location_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "locationType" => Ok(__FieldTag::__location_type),
                                "location_type" => Ok(__FieldTag::__location_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__location_type => {
                                if !fields.insert(__FieldTag::__location_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location_type",
                                    ));
                                }
                                result.location_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::zone::resource_spec::LocationType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.location_type) {
                state.serialize_entry("locationType", &self.location_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ResourceSpec].
    pub mod resource_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Location type of the resources attached to a zone.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LocationType {
            /// Unspecified location type.
            Unspecified,
            /// Resources that are associated with a single region.
            SingleRegion,
            /// Resources that are associated with a multi-region location.
            MultiRegion,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LocationType::value] or
            /// [LocationType::name].
            UnknownValue(location_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod location_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LocationType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SingleRegion => std::option::Option::Some(1),
                    Self::MultiRegion => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LOCATION_TYPE_UNSPECIFIED"),
                    Self::SingleRegion => std::option::Option::Some("SINGLE_REGION"),
                    Self::MultiRegion => std::option::Option::Some("MULTI_REGION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LocationType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LocationType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LocationType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SingleRegion,
                    2 => Self::MultiRegion,
                    _ => Self::UnknownValue(location_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LocationType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOCATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SINGLE_REGION" => Self::SingleRegion,
                    "MULTI_REGION" => Self::MultiRegion,
                    _ => Self::UnknownValue(location_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LocationType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SingleRegion => serializer.serialize_i32(1),
                    Self::MultiRegion => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LocationType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocationType>::new(
                    ".google.cloud.dataplex.v1.Zone.ResourceSpec.LocationType",
                ))
            }
        }
    }

    /// Settings to manage the metadata discovery and publishing in a zone.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DiscoverySpec {
        /// Required. Whether discovery is enabled.
        pub enabled: bool,

        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered. For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        pub include_patterns: std::vec::Vec<std::string::String>,

        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        pub exclude_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Configuration for CSV data.
        pub csv_options: std::option::Option<crate::model::zone::discovery_spec::CsvOptions>,

        /// Optional. Configuration for Json data.
        pub json_options: std::option::Option<crate::model::zone::discovery_spec::JsonOptions>,

        /// Determines when discovery is triggered.
        pub trigger: std::option::Option<crate::model::zone::discovery_spec::Trigger>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiscoverySpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::zone::DiscoverySpec::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [include_patterns][crate::model::zone::DiscoverySpec::include_patterns].
        pub fn set_include_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclude_patterns][crate::model::zone::DiscoverySpec::exclude_patterns].
        pub fn set_exclude_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.exclude_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [csv_options][crate::model::zone::DiscoverySpec::csv_options].
        pub fn set_csv_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::zone::discovery_spec::CsvOptions>,
        {
            self.csv_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [csv_options][crate::model::zone::DiscoverySpec::csv_options].
        pub fn set_or_clear_csv_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::zone::discovery_spec::CsvOptions>,
        {
            self.csv_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [json_options][crate::model::zone::DiscoverySpec::json_options].
        pub fn set_json_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::zone::discovery_spec::JsonOptions>,
        {
            self.json_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [json_options][crate::model::zone::DiscoverySpec::json_options].
        pub fn set_or_clear_json_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::zone::discovery_spec::JsonOptions>,
        {
            self.json_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [trigger][crate::model::zone::DiscoverySpec::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::zone::discovery_spec::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::zone::DiscoverySpec::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::zone::discovery_spec::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::zone::DiscoverySpec::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::zone::discovery_spec::Trigger::Schedule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DiscoverySpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Zone.DiscoverySpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DiscoverySpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __include_patterns,
                __exclude_patterns,
                __csv_options,
                __json_options,
                __schedule,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DiscoverySpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "includePatterns" => Ok(__FieldTag::__include_patterns),
                                "include_patterns" => Ok(__FieldTag::__include_patterns),
                                "excludePatterns" => Ok(__FieldTag::__exclude_patterns),
                                "exclude_patterns" => Ok(__FieldTag::__exclude_patterns),
                                "csvOptions" => Ok(__FieldTag::__csv_options),
                                "csv_options" => Ok(__FieldTag::__csv_options),
                                "jsonOptions" => Ok(__FieldTag::__json_options),
                                "json_options" => Ok(__FieldTag::__json_options),
                                "schedule" => Ok(__FieldTag::__schedule),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DiscoverySpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DiscoverySpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__include_patterns => {
                                if !fields.insert(__FieldTag::__include_patterns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_patterns",
                                    ));
                                }
                                result.include_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__exclude_patterns => {
                                if !fields.insert(__FieldTag::__exclude_patterns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exclude_patterns",
                                    ));
                                }
                                result.exclude_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__csv_options => {
                                if !fields.insert(__FieldTag::__csv_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for csv_options",
                                    ));
                                }
                                result.csv_options = map.next_value::<std::option::Option<
                                    crate::model::zone::discovery_spec::CsvOptions,
                                >>()?;
                            }
                            __FieldTag::__json_options => {
                                if !fields.insert(__FieldTag::__json_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for json_options",
                                    ));
                                }
                                result.json_options = map.next_value::<std::option::Option<
                                    crate::model::zone::discovery_spec::JsonOptions,
                                >>()?;
                            }
                            __FieldTag::__schedule => {
                                if !fields.insert(__FieldTag::__schedule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule",
                                    ));
                                }
                                if result.trigger.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `trigger`, a oneof with full ID .google.cloud.dataplex.v1.Zone.DiscoverySpec.schedule, latest field was schedule",
                                    ));
                                }
                                result.trigger = std::option::Option::Some(
                                    crate::model::zone::discovery_spec::Trigger::Schedule(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DiscoverySpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self.include_patterns.is_empty() {
                state.serialize_entry("includePatterns", &self.include_patterns)?;
            }
            if !self.exclude_patterns.is_empty() {
                state.serialize_entry("excludePatterns", &self.exclude_patterns)?;
            }
            if self.csv_options.is_some() {
                state.serialize_entry("csvOptions", &self.csv_options)?;
            }
            if self.json_options.is_some() {
                state.serialize_entry("jsonOptions", &self.json_options)?;
            }
            if let Some(value) = self.schedule() {
                state.serialize_entry("schedule", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DiscoverySpec].
    pub mod discovery_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Describe CSV and similar semi-structured data formats.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            pub header_rows: i32,

            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            pub delimiter: std::string::String,

            /// Optional. The character encoding of the data. The default is UTF-8.
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            pub disable_type_inference: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CsvOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [header_rows][crate::model::zone::discovery_spec::CsvOptions::header_rows].
            pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.header_rows = v.into();
                self
            }

            /// Sets the value of [delimiter][crate::model::zone::discovery_spec::CsvOptions::delimiter].
            pub fn set_delimiter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.delimiter = v.into();
                self
            }

            /// Sets the value of [encoding][crate::model::zone::discovery_spec::CsvOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::zone::discovery_spec::CsvOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for CsvOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Zone.DiscoverySpec.CsvOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CsvOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __header_rows,
                    __delimiter,
                    __encoding,
                    __disable_type_inference,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CsvOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "headerRows" => Ok(__FieldTag::__header_rows),
                                    "header_rows" => Ok(__FieldTag::__header_rows),
                                    "delimiter" => Ok(__FieldTag::__delimiter),
                                    "encoding" => Ok(__FieldTag::__encoding),
                                    "disableTypeInference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    "disable_type_inference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CsvOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CsvOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__header_rows => {
                                    if !fields.insert(__FieldTag::__header_rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for header_rows",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.header_rows =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__delimiter => {
                                    if !fields.insert(__FieldTag::__delimiter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for delimiter",
                                            ),
                                        );
                                    }
                                    result.delimiter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__encoding => {
                                    if !fields.insert(__FieldTag::__encoding) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for encoding",
                                            ),
                                        );
                                    }
                                    result.encoding = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__disable_type_inference => {
                                    if !fields.insert(__FieldTag::__disable_type_inference) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disable_type_inference",
                                            ),
                                        );
                                    }
                                    result.disable_type_inference = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CsvOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.header_rows) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("headerRows", &__With(&self.header_rows))?;
                }
                if !self.delimiter.is_empty() {
                    state.serialize_entry("delimiter", &self.delimiter)?;
                }
                if !self.encoding.is_empty() {
                    state.serialize_entry("encoding", &self.encoding)?;
                }
                if !wkt::internal::is_default(&self.disable_type_inference) {
                    state.serialize_entry("disableTypeInference", &self.disable_type_inference)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Describe JSON data format.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            pub disable_type_inference: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::zone::discovery_spec::JsonOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::zone::discovery_spec::JsonOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Zone.DiscoverySpec.JsonOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JsonOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __encoding,
                    __disable_type_inference,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JsonOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "encoding" => Ok(__FieldTag::__encoding),
                                    "disableTypeInference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    "disable_type_inference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JsonOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JsonOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__encoding => {
                                    if !fields.insert(__FieldTag::__encoding) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for encoding",
                                            ),
                                        );
                                    }
                                    result.encoding = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__disable_type_inference => {
                                    if !fields.insert(__FieldTag::__disable_type_inference) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disable_type_inference",
                                            ),
                                        );
                                    }
                                    result.disable_type_inference = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JsonOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.encoding.is_empty() {
                    state.serialize_entry("encoding", &self.encoding)?;
                }
                if !wkt::internal::is_default(&self.disable_type_inference) {
                    state.serialize_entry("disableTypeInference", &self.disable_type_inference)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Determines when discovery is triggered.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes.
            ///
            /// To explicitly set a timezone to the cron tab, apply a prefix in the
            /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}".
            /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
            /// database. For example, `CRON_TZ=America/New_York 1 * * * *`, or
            /// `TZ=America/New_York 1 * * * *`.
            Schedule(std::string::String),
        }
    }

    /// Type of zone.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Zone type not specified.
        Unspecified,
        /// A zone that contains data that needs further processing before it is
        /// considered generally ready for consumption and analytics workloads.
        Raw,
        /// A zone that contains data that is considered to be ready for broader
        /// consumption and analytics workloads. Curated structured data stored in
        /// Cloud Storage must conform to certain file formats (parquet, avro and
        /// orc) and organized in a hive-compatible directory layout.
        Curated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Raw => std::option::Option::Some(1),
                Self::Curated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Raw => std::option::Option::Some("RAW"),
                Self::Curated => std::option::Option::Some("CURATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Raw,
                2 => Self::Curated,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "RAW" => Self::Raw,
                "CURATED" => Self::Curated,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Raw => serializer.serialize_i32(1),
                Self::Curated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.Zone.Type",
            ))
        }
    }
}

/// Action represents an issue requiring administrator action for resolution.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Action {
    /// The category of issue associated with the action.
    pub category: crate::model::action::Category,

    /// Detailed description of the issue requiring action.
    pub issue: std::string::String,

    /// The time that the issue was detected.
    pub detect_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The relative resource name of the action, of the form:
    /// `projects/{project}/locations/{location}/lakes/{lake}/actions/{action}`
    /// `projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/actions/{action}`
    /// `projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/assets/{asset}/actions/{action}`.
    pub name: std::string::String,

    /// Output only. The relative resource name of the lake, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub lake: std::string::String,

    /// Output only. The relative resource name of the zone, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub zone: std::string::String,

    /// Output only. The relative resource name of the asset, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    pub asset: std::string::String,

    /// The list of data locations associated with this action. Cloud Storage
    /// locations are represented as URI paths(E.g.
    /// `gs://bucket/table1/year=2020/month=Jan/`). BigQuery locations refer to
    /// resource names(E.g.
    /// `bigquery.googleapis.com/projects/project-id/datasets/dataset-id`).
    pub data_locations: std::vec::Vec<std::string::String>,

    /// Additional details about the action based on the action category.
    pub details: std::option::Option<crate::model::action::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Action {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::Action::category].
    pub fn set_category<T: std::convert::Into<crate::model::action::Category>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [issue][crate::model::Action::issue].
    pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue = v.into();
        self
    }

    /// Sets the value of [detect_time][crate::model::Action::detect_time].
    pub fn set_detect_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detect_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detect_time][crate::model::Action::detect_time].
    pub fn set_or_clear_detect_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.detect_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Action::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [lake][crate::model::Action::lake].
    pub fn set_lake<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lake = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Action::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::Action::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [data_locations][crate::model::Action::data_locations].
    pub fn set_data_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [details][crate::model::Action::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::action::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `InvalidDataFormat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn invalid_data_format(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::InvalidDataFormat>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::InvalidDataFormat(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `InvalidDataFormat`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_invalid_data_format<
        T: std::convert::Into<std::boxed::Box<crate::model::action::InvalidDataFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::action::Details::InvalidDataFormat(v.into()));
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `IncompatibleDataSchema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn incompatible_data_schema(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::IncompatibleDataSchema>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::IncompatibleDataSchema(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `IncompatibleDataSchema`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_incompatible_data_schema<
        T: std::convert::Into<std::boxed::Box<crate::model::action::IncompatibleDataSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::IncompatibleDataSchema(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `InvalidDataPartition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn invalid_data_partition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::InvalidDataPartition>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::InvalidDataPartition(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `InvalidDataPartition`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_invalid_data_partition<
        T: std::convert::Into<std::boxed::Box<crate::model::action::InvalidDataPartition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::InvalidDataPartition(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `MissingData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn missing_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::MissingData>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::MissingData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `MissingData`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_missing_data<
        T: std::convert::Into<std::boxed::Box<crate::model::action::MissingData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::action::Details::MissingData(v.into()));
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `MissingResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn missing_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::MissingResource>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::MissingResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `MissingResource`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_missing_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::action::MissingResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::action::Details::MissingResource(v.into()));
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `UnauthorizedResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn unauthorized_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::UnauthorizedResource>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::UnauthorizedResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `UnauthorizedResource`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_unauthorized_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::action::UnauthorizedResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::UnauthorizedResource(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `FailedSecurityPolicyApply`, `None` if the field is not set or
    /// holds a different branch.
    pub fn failed_security_policy_apply(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::FailedSecurityPolicyApply>>
    {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::FailedSecurityPolicyApply(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `FailedSecurityPolicyApply`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_failed_security_policy_apply<
        T: std::convert::Into<std::boxed::Box<crate::model::action::FailedSecurityPolicyApply>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::FailedSecurityPolicyApply(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `InvalidDataOrganization`, `None` if the field is not set or
    /// holds a different branch.
    pub fn invalid_data_organization(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::InvalidDataOrganization>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::InvalidDataOrganization(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `InvalidDataOrganization`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_invalid_data_organization<
        T: std::convert::Into<std::boxed::Box<crate::model::action::InvalidDataOrganization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::InvalidDataOrganization(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Action {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Action"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Action {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __category,
            __issue,
            __detect_time,
            __name,
            __lake,
            __zone,
            __asset,
            __data_locations,
            __invalid_data_format,
            __incompatible_data_schema,
            __invalid_data_partition,
            __missing_data,
            __missing_resource,
            __unauthorized_resource,
            __failed_security_policy_apply,
            __invalid_data_organization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Action")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "category" => Ok(__FieldTag::__category),
                            "issue" => Ok(__FieldTag::__issue),
                            "detectTime" => Ok(__FieldTag::__detect_time),
                            "detect_time" => Ok(__FieldTag::__detect_time),
                            "name" => Ok(__FieldTag::__name),
                            "lake" => Ok(__FieldTag::__lake),
                            "zone" => Ok(__FieldTag::__zone),
                            "asset" => Ok(__FieldTag::__asset),
                            "dataLocations" => Ok(__FieldTag::__data_locations),
                            "data_locations" => Ok(__FieldTag::__data_locations),
                            "invalidDataFormat" => Ok(__FieldTag::__invalid_data_format),
                            "invalid_data_format" => Ok(__FieldTag::__invalid_data_format),
                            "incompatibleDataSchema" => Ok(__FieldTag::__incompatible_data_schema),
                            "incompatible_data_schema" => {
                                Ok(__FieldTag::__incompatible_data_schema)
                            }
                            "invalidDataPartition" => Ok(__FieldTag::__invalid_data_partition),
                            "invalid_data_partition" => Ok(__FieldTag::__invalid_data_partition),
                            "missingData" => Ok(__FieldTag::__missing_data),
                            "missing_data" => Ok(__FieldTag::__missing_data),
                            "missingResource" => Ok(__FieldTag::__missing_resource),
                            "missing_resource" => Ok(__FieldTag::__missing_resource),
                            "unauthorizedResource" => Ok(__FieldTag::__unauthorized_resource),
                            "unauthorized_resource" => Ok(__FieldTag::__unauthorized_resource),
                            "failedSecurityPolicyApply" => {
                                Ok(__FieldTag::__failed_security_policy_apply)
                            }
                            "failed_security_policy_apply" => {
                                Ok(__FieldTag::__failed_security_policy_apply)
                            }
                            "invalidDataOrganization" => {
                                Ok(__FieldTag::__invalid_data_organization)
                            }
                            "invalid_data_organization" => {
                                Ok(__FieldTag::__invalid_data_organization)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Action;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Action")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<crate::model::action::Category>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issue => {
                            if !fields.insert(__FieldTag::__issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue",
                                ));
                            }
                            result.issue = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detect_time => {
                            if !fields.insert(__FieldTag::__detect_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detect_time",
                                ));
                            }
                            result.detect_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lake => {
                            if !fields.insert(__FieldTag::__lake) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lake",
                                ));
                            }
                            result.lake = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_locations => {
                            if !fields.insert(__FieldTag::__data_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_locations",
                                ));
                            }
                            result.data_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__invalid_data_format => {
                            if !fields.insert(__FieldTag::__invalid_data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invalid_data_format",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.invalid_data_format, latest field was invalidDataFormat",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::InvalidDataFormat(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::InvalidDataFormat>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__incompatible_data_schema => {
                            if !fields.insert(__FieldTag::__incompatible_data_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incompatible_data_schema",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.incompatible_data_schema, latest field was incompatibleDataSchema",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::IncompatibleDataSchema(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::action::IncompatibleDataSchema,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__invalid_data_partition => {
                            if !fields.insert(__FieldTag::__invalid_data_partition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invalid_data_partition",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.invalid_data_partition, latest field was invalidDataPartition",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::InvalidDataPartition(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::InvalidDataPartition>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__missing_data => {
                            if !fields.insert(__FieldTag::__missing_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_data",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.missing_data, latest field was missingData",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::MissingData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::MissingData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__missing_resource => {
                            if !fields.insert(__FieldTag::__missing_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_resource",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.missing_resource, latest field was missingResource",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::MissingResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::MissingResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__unauthorized_resource => {
                            if !fields.insert(__FieldTag::__unauthorized_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unauthorized_resource",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.unauthorized_resource, latest field was unauthorizedResource",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::UnauthorizedResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::UnauthorizedResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__failed_security_policy_apply => {
                            if !fields.insert(__FieldTag::__failed_security_policy_apply) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_security_policy_apply",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.failed_security_policy_apply, latest field was failedSecurityPolicyApply",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::FailedSecurityPolicyApply(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::action::FailedSecurityPolicyApply,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__invalid_data_organization => {
                            if !fields.insert(__FieldTag::__invalid_data_organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invalid_data_organization",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.dataplex.v1.Action.invalid_data_organization, latest field was invalidDataOrganization",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action::Details::InvalidDataOrganization(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::action::InvalidDataOrganization,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Action {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if !self.issue.is_empty() {
            state.serialize_entry("issue", &self.issue)?;
        }
        if self.detect_time.is_some() {
            state.serialize_entry("detectTime", &self.detect_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.lake.is_empty() {
            state.serialize_entry("lake", &self.lake)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.asset.is_empty() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !self.data_locations.is_empty() {
            state.serialize_entry("dataLocations", &self.data_locations)?;
        }
        if let Some(value) = self.invalid_data_format() {
            state.serialize_entry("invalidDataFormat", value)?;
        }
        if let Some(value) = self.incompatible_data_schema() {
            state.serialize_entry("incompatibleDataSchema", value)?;
        }
        if let Some(value) = self.invalid_data_partition() {
            state.serialize_entry("invalidDataPartition", value)?;
        }
        if let Some(value) = self.missing_data() {
            state.serialize_entry("missingData", value)?;
        }
        if let Some(value) = self.missing_resource() {
            state.serialize_entry("missingResource", value)?;
        }
        if let Some(value) = self.unauthorized_resource() {
            state.serialize_entry("unauthorizedResource", value)?;
        }
        if let Some(value) = self.failed_security_policy_apply() {
            state.serialize_entry("failedSecurityPolicyApply", value)?;
        }
        if let Some(value) = self.invalid_data_organization() {
            state.serialize_entry("invalidDataOrganization", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Action].
pub mod action {
    #[allow(unused_imports)]
    use super::*;

    /// Action details for resource references in assets that cannot be located.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MissingResource {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MissingResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MissingResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.MissingResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MissingResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MissingResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MissingResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MissingResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MissingResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Action details for unauthorized resource issues raised to indicate that the
    /// service account associated with the lake instance is not authorized to
    /// access or manage the resource associated with an asset.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UnauthorizedResource {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UnauthorizedResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for UnauthorizedResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.UnauthorizedResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UnauthorizedResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UnauthorizedResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UnauthorizedResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UnauthorizedResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UnauthorizedResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Failed to apply security policy to the managed resource(s) under a
    /// lake, zone or an asset. For a lake or zone resource, one or more underlying
    /// assets has a failure applying security policy to the associated managed
    /// resource.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FailedSecurityPolicyApply {
        /// Resource name of one of the assets with failing security policy
        /// application. Populated for a lake or zone resource only.
        pub asset: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailedSecurityPolicyApply {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [asset][crate::model::action::FailedSecurityPolicyApply::asset].
        pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.asset = v.into();
            self
        }
    }

    impl wkt::message::Message for FailedSecurityPolicyApply {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.FailedSecurityPolicyApply"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FailedSecurityPolicyApply {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __asset,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FailedSecurityPolicyApply")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "asset" => Ok(__FieldTag::__asset),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FailedSecurityPolicyApply;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FailedSecurityPolicyApply")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__asset => {
                                if !fields.insert(__FieldTag::__asset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for asset",
                                    ));
                                }
                                result.asset = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FailedSecurityPolicyApply {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.asset.is_empty() {
                state.serialize_entry("asset", &self.asset)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Action details for invalid or unsupported data files detected by discovery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InvalidDataFormat {
        /// The list of data locations sampled and used for format/schema
        /// inference.
        pub sampled_data_locations: std::vec::Vec<std::string::String>,

        /// The expected data format of the entity.
        pub expected_format: std::string::String,

        /// The new unexpected data format within the entity.
        pub new_format: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InvalidDataFormat {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sampled_data_locations][crate::model::action::InvalidDataFormat::sampled_data_locations].
        pub fn set_sampled_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.sampled_data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [expected_format][crate::model::action::InvalidDataFormat::expected_format].
        pub fn set_expected_format<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.expected_format = v.into();
            self
        }

        /// Sets the value of [new_format][crate::model::action::InvalidDataFormat::new_format].
        pub fn set_new_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.new_format = v.into();
            self
        }
    }

    impl wkt::message::Message for InvalidDataFormat {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.InvalidDataFormat"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InvalidDataFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sampled_data_locations,
                __expected_format,
                __new_format,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InvalidDataFormat")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sampledDataLocations" => Ok(__FieldTag::__sampled_data_locations),
                                "sampled_data_locations" => {
                                    Ok(__FieldTag::__sampled_data_locations)
                                }
                                "expectedFormat" => Ok(__FieldTag::__expected_format),
                                "expected_format" => Ok(__FieldTag::__expected_format),
                                "newFormat" => Ok(__FieldTag::__new_format),
                                "new_format" => Ok(__FieldTag::__new_format),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InvalidDataFormat;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InvalidDataFormat")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sampled_data_locations => {
                                if !fields.insert(__FieldTag::__sampled_data_locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sampled_data_locations",
                                    ));
                                }
                                result.sampled_data_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__expected_format => {
                                if !fields.insert(__FieldTag::__expected_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expected_format",
                                    ));
                                }
                                result.expected_format = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__new_format => {
                                if !fields.insert(__FieldTag::__new_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for new_format",
                                    ));
                                }
                                result.new_format = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InvalidDataFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sampled_data_locations.is_empty() {
                state.serialize_entry("sampledDataLocations", &self.sampled_data_locations)?;
            }
            if !self.expected_format.is_empty() {
                state.serialize_entry("expectedFormat", &self.expected_format)?;
            }
            if !self.new_format.is_empty() {
                state.serialize_entry("newFormat", &self.new_format)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Action details for incompatible schemas detected by discovery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IncompatibleDataSchema {
        /// The name of the table containing invalid data.
        pub table: std::string::String,

        /// The existing and expected schema of the table. The schema is provided as
        /// a JSON formatted structure listing columns and data types.
        pub existing_schema: std::string::String,

        /// The new and incompatible schema within the table. The schema is provided
        /// as a JSON formatted structured listing columns and data types.
        pub new_schema: std::string::String,

        /// The list of data locations sampled and used for format/schema
        /// inference.
        pub sampled_data_locations: std::vec::Vec<std::string::String>,

        /// Whether the action relates to a schema that is incompatible or modified.
        pub schema_change: crate::model::action::incompatible_data_schema::SchemaChange,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncompatibleDataSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::action::IncompatibleDataSchema::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [existing_schema][crate::model::action::IncompatibleDataSchema::existing_schema].
        pub fn set_existing_schema<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.existing_schema = v.into();
            self
        }

        /// Sets the value of [new_schema][crate::model::action::IncompatibleDataSchema::new_schema].
        pub fn set_new_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.new_schema = v.into();
            self
        }

        /// Sets the value of [sampled_data_locations][crate::model::action::IncompatibleDataSchema::sampled_data_locations].
        pub fn set_sampled_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.sampled_data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [schema_change][crate::model::action::IncompatibleDataSchema::schema_change].
        pub fn set_schema_change<
            T: std::convert::Into<crate::model::action::incompatible_data_schema::SchemaChange>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.schema_change = v.into();
            self
        }
    }

    impl wkt::message::Message for IncompatibleDataSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.IncompatibleDataSchema"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IncompatibleDataSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __table,
                __existing_schema,
                __new_schema,
                __sampled_data_locations,
                __schema_change,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IncompatibleDataSchema")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "table" => Ok(__FieldTag::__table),
                                "existingSchema" => Ok(__FieldTag::__existing_schema),
                                "existing_schema" => Ok(__FieldTag::__existing_schema),
                                "newSchema" => Ok(__FieldTag::__new_schema),
                                "new_schema" => Ok(__FieldTag::__new_schema),
                                "sampledDataLocations" => Ok(__FieldTag::__sampled_data_locations),
                                "sampled_data_locations" => {
                                    Ok(__FieldTag::__sampled_data_locations)
                                }
                                "schemaChange" => Ok(__FieldTag::__schema_change),
                                "schema_change" => Ok(__FieldTag::__schema_change),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IncompatibleDataSchema;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IncompatibleDataSchema")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__existing_schema => {
                                if !fields.insert(__FieldTag::__existing_schema) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for existing_schema",
                                    ));
                                }
                                result.existing_schema = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__new_schema => {
                                if !fields.insert(__FieldTag::__new_schema) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for new_schema",
                                    ));
                                }
                                result.new_schema = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__sampled_data_locations => {
                                if !fields.insert(__FieldTag::__sampled_data_locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sampled_data_locations",
                                    ));
                                }
                                result.sampled_data_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__schema_change => {
                                if !fields.insert(__FieldTag::__schema_change) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schema_change",
                                    ));
                                }
                                result.schema_change = map.next_value::<std::option::Option<crate::model::action::incompatible_data_schema::SchemaChange>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IncompatibleDataSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self.existing_schema.is_empty() {
                state.serialize_entry("existingSchema", &self.existing_schema)?;
            }
            if !self.new_schema.is_empty() {
                state.serialize_entry("newSchema", &self.new_schema)?;
            }
            if !self.sampled_data_locations.is_empty() {
                state.serialize_entry("sampledDataLocations", &self.sampled_data_locations)?;
            }
            if !wkt::internal::is_default(&self.schema_change) {
                state.serialize_entry("schemaChange", &self.schema_change)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IncompatibleDataSchema].
    pub mod incompatible_data_schema {
        #[allow(unused_imports)]
        use super::*;

        /// Whether the action relates to a schema that is incompatible or modified.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SchemaChange {
            /// Schema change unspecified.
            Unspecified,
            /// Newly discovered schema is incompatible with existing schema.
            Incompatible,
            /// Newly discovered schema has changed from existing schema for data in a
            /// curated zone.
            Modified,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SchemaChange::value] or
            /// [SchemaChange::name].
            UnknownValue(schema_change::UnknownValue),
        }

        #[doc(hidden)]
        pub mod schema_change {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SchemaChange {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Incompatible => std::option::Option::Some(1),
                    Self::Modified => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SCHEMA_CHANGE_UNSPECIFIED"),
                    Self::Incompatible => std::option::Option::Some("INCOMPATIBLE"),
                    Self::Modified => std::option::Option::Some("MODIFIED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SchemaChange {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SchemaChange {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SchemaChange {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Incompatible,
                    2 => Self::Modified,
                    _ => Self::UnknownValue(schema_change::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SchemaChange {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SCHEMA_CHANGE_UNSPECIFIED" => Self::Unspecified,
                    "INCOMPATIBLE" => Self::Incompatible,
                    "MODIFIED" => Self::Modified,
                    _ => Self::UnknownValue(schema_change::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SchemaChange {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Incompatible => serializer.serialize_i32(1),
                    Self::Modified => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SchemaChange {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaChange>::new(
                    ".google.cloud.dataplex.v1.Action.IncompatibleDataSchema.SchemaChange",
                ))
            }
        }
    }

    /// Action details for invalid or unsupported partitions detected by discovery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InvalidDataPartition {
        /// The issue type of InvalidDataPartition.
        pub expected_structure: crate::model::action::invalid_data_partition::PartitionStructure,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InvalidDataPartition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [expected_structure][crate::model::action::InvalidDataPartition::expected_structure].
        pub fn set_expected_structure<
            T: std::convert::Into<crate::model::action::invalid_data_partition::PartitionStructure>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.expected_structure = v.into();
            self
        }
    }

    impl wkt::message::Message for InvalidDataPartition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.InvalidDataPartition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InvalidDataPartition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __expected_structure,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InvalidDataPartition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "expectedStructure" => Ok(__FieldTag::__expected_structure),
                                "expected_structure" => Ok(__FieldTag::__expected_structure),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InvalidDataPartition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InvalidDataPartition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__expected_structure => {
                                if !fields.insert(__FieldTag::__expected_structure) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expected_structure",
                                    ));
                                }
                                result.expected_structure = map.next_value::<std::option::Option<crate::model::action::invalid_data_partition::PartitionStructure>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InvalidDataPartition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.expected_structure) {
                state.serialize_entry("expectedStructure", &self.expected_structure)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [InvalidDataPartition].
    pub mod invalid_data_partition {
        #[allow(unused_imports)]
        use super::*;

        /// The expected partition structure.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PartitionStructure {
            /// PartitionStructure unspecified.
            Unspecified,
            /// Consistent hive-style partition definition (both raw and curated zone).
            ConsistentKeys,
            /// Hive style partition definition (curated zone only).
            HiveStyleKeys,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PartitionStructure::value] or
            /// [PartitionStructure::name].
            UnknownValue(partition_structure::UnknownValue),
        }

        #[doc(hidden)]
        pub mod partition_structure {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PartitionStructure {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ConsistentKeys => std::option::Option::Some(1),
                    Self::HiveStyleKeys => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("PARTITION_STRUCTURE_UNSPECIFIED")
                    }
                    Self::ConsistentKeys => std::option::Option::Some("CONSISTENT_KEYS"),
                    Self::HiveStyleKeys => std::option::Option::Some("HIVE_STYLE_KEYS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PartitionStructure {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PartitionStructure {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PartitionStructure {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ConsistentKeys,
                    2 => Self::HiveStyleKeys,
                    _ => Self::UnknownValue(partition_structure::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PartitionStructure {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PARTITION_STRUCTURE_UNSPECIFIED" => Self::Unspecified,
                    "CONSISTENT_KEYS" => Self::ConsistentKeys,
                    "HIVE_STYLE_KEYS" => Self::HiveStyleKeys,
                    _ => Self::UnknownValue(partition_structure::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PartitionStructure {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ConsistentKeys => serializer.serialize_i32(1),
                    Self::HiveStyleKeys => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PartitionStructure {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PartitionStructure>::new(
                    ".google.cloud.dataplex.v1.Action.InvalidDataPartition.PartitionStructure",
                ))
            }
        }
    }

    /// Action details for absence of data detected by discovery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MissingData {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MissingData {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MissingData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.MissingData"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MissingData {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MissingData")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MissingData;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MissingData")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MissingData {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Action details for invalid data arrangement.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InvalidDataOrganization {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InvalidDataOrganization {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for InvalidDataOrganization {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.InvalidDataOrganization"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InvalidDataOrganization {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InvalidDataOrganization")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InvalidDataOrganization;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InvalidDataOrganization")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InvalidDataOrganization {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The category of issues.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Category {
        /// Unspecified category.
        Unspecified,
        /// Resource management related issues.
        ResourceManagement,
        /// Security policy related issues.
        SecurityPolicy,
        /// Data and discovery related issues.
        DataDiscovery,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Category::value] or
        /// [Category::name].
        UnknownValue(category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Category {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceManagement => std::option::Option::Some(1),
                Self::SecurityPolicy => std::option::Option::Some(2),
                Self::DataDiscovery => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CATEGORY_UNSPECIFIED"),
                Self::ResourceManagement => std::option::Option::Some("RESOURCE_MANAGEMENT"),
                Self::SecurityPolicy => std::option::Option::Some("SECURITY_POLICY"),
                Self::DataDiscovery => std::option::Option::Some("DATA_DISCOVERY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Category {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Category {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Category {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResourceManagement,
                2 => Self::SecurityPolicy,
                3 => Self::DataDiscovery,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Category {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_MANAGEMENT" => Self::ResourceManagement,
                "SECURITY_POLICY" => Self::SecurityPolicy,
                "DATA_DISCOVERY" => Self::DataDiscovery,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Category {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceManagement => serializer.serialize_i32(1),
                Self::SecurityPolicy => serializer.serialize_i32(2),
                Self::DataDiscovery => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Category {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Category>::new(
                ".google.cloud.dataplex.v1.Action.Category",
            ))
        }
    }

    /// Additional details about the action based on the action category.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Details for issues related to invalid or unsupported data formats.
        InvalidDataFormat(std::boxed::Box<crate::model::action::InvalidDataFormat>),
        /// Details for issues related to incompatible schemas detected within data.
        IncompatibleDataSchema(std::boxed::Box<crate::model::action::IncompatibleDataSchema>),
        /// Details for issues related to invalid or unsupported data partition
        /// structure.
        InvalidDataPartition(std::boxed::Box<crate::model::action::InvalidDataPartition>),
        /// Details for issues related to absence of data within managed resources.
        MissingData(std::boxed::Box<crate::model::action::MissingData>),
        /// Details for issues related to absence of a managed resource.
        MissingResource(std::boxed::Box<crate::model::action::MissingResource>),
        /// Details for issues related to lack of permissions to access data
        /// resources.
        UnauthorizedResource(std::boxed::Box<crate::model::action::UnauthorizedResource>),
        /// Details for issues related to applying security policy.
        FailedSecurityPolicyApply(std::boxed::Box<crate::model::action::FailedSecurityPolicyApply>),
        /// Details for issues related to invalid data arrangement.
        InvalidDataOrganization(std::boxed::Box<crate::model::action::InvalidDataOrganization>),
    }
}

/// An asset represents a cloud resource that is being managed within a lake as a
/// member of a zone.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Asset {
    /// Output only. The relative resource name of the asset, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    pub name: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the asset. This ID
    /// will be different if the asset is deleted and re-created with the same
    /// name.
    pub uid: std::string::String,

    /// Output only. The time when the asset was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the asset was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the asset.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the asset.
    pub description: std::string::String,

    /// Output only. Current state of the asset.
    pub state: crate::model::State,

    /// Required. Specification of the resource that is referenced by this asset.
    pub resource_spec: std::option::Option<crate::model::asset::ResourceSpec>,

    /// Output only. Status of the resource referenced by this asset.
    pub resource_status: std::option::Option<crate::model::asset::ResourceStatus>,

    /// Output only. Status of the security policy applied to resource referenced
    /// by this asset.
    pub security_status: std::option::Option<crate::model::asset::SecurityStatus>,

    /// Optional. Specification of the discovery feature applied to data referenced
    /// by this asset. When this spec is left unset, the asset will use the spec
    /// set on the parent zone.
    pub discovery_spec: std::option::Option<crate::model::asset::DiscoverySpec>,

    /// Output only. Status of the discovery feature applied to data referenced by
    /// this asset.
    pub discovery_status: std::option::Option<crate::model::asset::DiscoveryStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Asset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Asset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Asset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Asset::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Asset::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Asset::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Asset::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Asset::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Asset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Asset::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Asset::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [resource_spec][crate::model::Asset::resource_spec].
    pub fn set_resource_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::asset::ResourceSpec>,
    {
        self.resource_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_spec][crate::model::Asset::resource_spec].
    pub fn set_or_clear_resource_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::asset::ResourceSpec>,
    {
        self.resource_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_status][crate::model::Asset::resource_status].
    pub fn set_resource_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::asset::ResourceStatus>,
    {
        self.resource_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_status][crate::model::Asset::resource_status].
    pub fn set_or_clear_resource_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::asset::ResourceStatus>,
    {
        self.resource_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_status][crate::model::Asset::security_status].
    pub fn set_security_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::asset::SecurityStatus>,
    {
        self.security_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_status][crate::model::Asset::security_status].
    pub fn set_or_clear_security_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::asset::SecurityStatus>,
    {
        self.security_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [discovery_spec][crate::model::Asset::discovery_spec].
    pub fn set_discovery_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::asset::DiscoverySpec>,
    {
        self.discovery_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discovery_spec][crate::model::Asset::discovery_spec].
    pub fn set_or_clear_discovery_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::asset::DiscoverySpec>,
    {
        self.discovery_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [discovery_status][crate::model::Asset::discovery_status].
    pub fn set_discovery_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::asset::DiscoveryStatus>,
    {
        self.discovery_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discovery_status][crate::model::Asset::discovery_status].
    pub fn set_or_clear_discovery_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::asset::DiscoveryStatus>,
    {
        self.discovery_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Asset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Asset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Asset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __create_time,
            __update_time,
            __labels,
            __description,
            __state,
            __resource_spec,
            __resource_status,
            __security_status,
            __discovery_spec,
            __discovery_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Asset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "resourceSpec" => Ok(__FieldTag::__resource_spec),
                            "resource_spec" => Ok(__FieldTag::__resource_spec),
                            "resourceStatus" => Ok(__FieldTag::__resource_status),
                            "resource_status" => Ok(__FieldTag::__resource_status),
                            "securityStatus" => Ok(__FieldTag::__security_status),
                            "security_status" => Ok(__FieldTag::__security_status),
                            "discoverySpec" => Ok(__FieldTag::__discovery_spec),
                            "discovery_spec" => Ok(__FieldTag::__discovery_spec),
                            "discoveryStatus" => Ok(__FieldTag::__discovery_status),
                            "discovery_status" => Ok(__FieldTag::__discovery_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Asset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Asset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_spec => {
                            if !fields.insert(__FieldTag::__resource_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_spec",
                                ));
                            }
                            result.resource_spec = map.next_value::<std::option::Option<crate::model::asset::ResourceSpec>>()?
                                ;
                        }
                        __FieldTag::__resource_status => {
                            if !fields.insert(__FieldTag::__resource_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_status",
                                ));
                            }
                            result.resource_status = map.next_value::<std::option::Option<crate::model::asset::ResourceStatus>>()?
                                ;
                        }
                        __FieldTag::__security_status => {
                            if !fields.insert(__FieldTag::__security_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_status",
                                ));
                            }
                            result.security_status = map.next_value::<std::option::Option<crate::model::asset::SecurityStatus>>()?
                                ;
                        }
                        __FieldTag::__discovery_spec => {
                            if !fields.insert(__FieldTag::__discovery_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_spec",
                                ));
                            }
                            result.discovery_spec = map.next_value::<std::option::Option<crate::model::asset::DiscoverySpec>>()?
                                ;
                        }
                        __FieldTag::__discovery_status => {
                            if !fields.insert(__FieldTag::__discovery_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_status",
                                ));
                            }
                            result.discovery_status = map.next_value::<std::option::Option<crate::model::asset::DiscoveryStatus>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Asset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.resource_spec.is_some() {
            state.serialize_entry("resourceSpec", &self.resource_spec)?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if self.security_status.is_some() {
            state.serialize_entry("securityStatus", &self.security_status)?;
        }
        if self.discovery_spec.is_some() {
            state.serialize_entry("discoverySpec", &self.discovery_spec)?;
        }
        if self.discovery_status.is_some() {
            state.serialize_entry("discoveryStatus", &self.discovery_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Asset].
pub mod asset {
    #[allow(unused_imports)]
    use super::*;

    /// Security policy status of the asset. Data security policy, i.e., readers,
    /// writers & owners, should be specified in the lake/zone/asset IAM policy.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SecurityStatus {
        /// The current state of the security policy applied to the attached
        /// resource.
        pub state: crate::model::asset::security_status::State,

        /// Additional information about the current state.
        pub message: std::string::String,

        /// Last update time of the status.
        pub update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SecurityStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::asset::SecurityStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::asset::security_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::asset::SecurityStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::asset::SecurityStatus::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::asset::SecurityStatus::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SecurityStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.SecurityStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SecurityStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __message,
                __update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SecurityStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "message" => Ok(__FieldTag::__message),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SecurityStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SecurityStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::asset::security_status::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__message => {
                                if !fields.insert(__FieldTag::__message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message",
                                    ));
                                }
                                result.message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SecurityStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.message.is_empty() {
                state.serialize_entry("message", &self.message)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SecurityStatus].
    pub mod security_status {
        #[allow(unused_imports)]
        use super::*;

        /// The state of the security policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State unspecified.
            Unspecified,
            /// Security policy has been successfully applied to the attached resource.
            Ready,
            /// Security policy is in the process of being applied to the attached
            /// resource.
            Applying,
            /// Security policy could not be applied to the attached resource due to
            /// errors.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Ready => std::option::Option::Some(1),
                    Self::Applying => std::option::Option::Some(2),
                    Self::Error => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::Applying => std::option::Option::Some("APPLYING"),
                    Self::Error => std::option::Option::Some("ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Ready,
                    2 => Self::Applying,
                    3 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "READY" => Self::Ready,
                    "APPLYING" => Self::Applying,
                    "ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Ready => serializer.serialize_i32(1),
                    Self::Applying => serializer.serialize_i32(2),
                    Self::Error => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Asset.SecurityStatus.State",
                ))
            }
        }
    }

    /// Settings to manage the metadata discovery and publishing for an asset.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DiscoverySpec {
        /// Optional. Whether discovery is enabled.
        pub enabled: bool,

        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered.  For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        pub include_patterns: std::vec::Vec<std::string::String>,

        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        pub exclude_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Configuration for CSV data.
        pub csv_options: std::option::Option<crate::model::asset::discovery_spec::CsvOptions>,

        /// Optional. Configuration for Json data.
        pub json_options: std::option::Option<crate::model::asset::discovery_spec::JsonOptions>,

        /// Determines when discovery is triggered.
        pub trigger: std::option::Option<crate::model::asset::discovery_spec::Trigger>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiscoverySpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::asset::DiscoverySpec::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [include_patterns][crate::model::asset::DiscoverySpec::include_patterns].
        pub fn set_include_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclude_patterns][crate::model::asset::DiscoverySpec::exclude_patterns].
        pub fn set_exclude_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.exclude_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [csv_options][crate::model::asset::DiscoverySpec::csv_options].
        pub fn set_csv_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::asset::discovery_spec::CsvOptions>,
        {
            self.csv_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [csv_options][crate::model::asset::DiscoverySpec::csv_options].
        pub fn set_or_clear_csv_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::asset::discovery_spec::CsvOptions>,
        {
            self.csv_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [json_options][crate::model::asset::DiscoverySpec::json_options].
        pub fn set_json_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::asset::discovery_spec::JsonOptions>,
        {
            self.json_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [json_options][crate::model::asset::DiscoverySpec::json_options].
        pub fn set_or_clear_json_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::asset::discovery_spec::JsonOptions>,
        {
            self.json_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [trigger][crate::model::asset::DiscoverySpec::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::asset::discovery_spec::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::asset::DiscoverySpec::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::asset::discovery_spec::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::asset::DiscoverySpec::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::asset::discovery_spec::Trigger::Schedule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DiscoverySpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoverySpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DiscoverySpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __include_patterns,
                __exclude_patterns,
                __csv_options,
                __json_options,
                __schedule,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DiscoverySpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "includePatterns" => Ok(__FieldTag::__include_patterns),
                                "include_patterns" => Ok(__FieldTag::__include_patterns),
                                "excludePatterns" => Ok(__FieldTag::__exclude_patterns),
                                "exclude_patterns" => Ok(__FieldTag::__exclude_patterns),
                                "csvOptions" => Ok(__FieldTag::__csv_options),
                                "csv_options" => Ok(__FieldTag::__csv_options),
                                "jsonOptions" => Ok(__FieldTag::__json_options),
                                "json_options" => Ok(__FieldTag::__json_options),
                                "schedule" => Ok(__FieldTag::__schedule),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DiscoverySpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DiscoverySpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__include_patterns => {
                                if !fields.insert(__FieldTag::__include_patterns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_patterns",
                                    ));
                                }
                                result.include_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__exclude_patterns => {
                                if !fields.insert(__FieldTag::__exclude_patterns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exclude_patterns",
                                    ));
                                }
                                result.exclude_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__csv_options => {
                                if !fields.insert(__FieldTag::__csv_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for csv_options",
                                    ));
                                }
                                result.csv_options = map.next_value::<std::option::Option<
                                    crate::model::asset::discovery_spec::CsvOptions,
                                >>()?;
                            }
                            __FieldTag::__json_options => {
                                if !fields.insert(__FieldTag::__json_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for json_options",
                                    ));
                                }
                                result.json_options = map.next_value::<std::option::Option<
                                    crate::model::asset::discovery_spec::JsonOptions,
                                >>()?;
                            }
                            __FieldTag::__schedule => {
                                if !fields.insert(__FieldTag::__schedule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule",
                                    ));
                                }
                                if result.trigger.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `trigger`, a oneof with full ID .google.cloud.dataplex.v1.Asset.DiscoverySpec.schedule, latest field was schedule",
                                    ));
                                }
                                result.trigger = std::option::Option::Some(
                                    crate::model::asset::discovery_spec::Trigger::Schedule(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DiscoverySpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self.include_patterns.is_empty() {
                state.serialize_entry("includePatterns", &self.include_patterns)?;
            }
            if !self.exclude_patterns.is_empty() {
                state.serialize_entry("excludePatterns", &self.exclude_patterns)?;
            }
            if self.csv_options.is_some() {
                state.serialize_entry("csvOptions", &self.csv_options)?;
            }
            if self.json_options.is_some() {
                state.serialize_entry("jsonOptions", &self.json_options)?;
            }
            if let Some(value) = self.schedule() {
                state.serialize_entry("schedule", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DiscoverySpec].
    pub mod discovery_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Describe CSV and similar semi-structured data formats.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            pub header_rows: i32,

            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            pub delimiter: std::string::String,

            /// Optional. The character encoding of the data. The default is UTF-8.
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            pub disable_type_inference: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CsvOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [header_rows][crate::model::asset::discovery_spec::CsvOptions::header_rows].
            pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.header_rows = v.into();
                self
            }

            /// Sets the value of [delimiter][crate::model::asset::discovery_spec::CsvOptions::delimiter].
            pub fn set_delimiter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.delimiter = v.into();
                self
            }

            /// Sets the value of [encoding][crate::model::asset::discovery_spec::CsvOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::asset::discovery_spec::CsvOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for CsvOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoverySpec.CsvOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CsvOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __header_rows,
                    __delimiter,
                    __encoding,
                    __disable_type_inference,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CsvOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "headerRows" => Ok(__FieldTag::__header_rows),
                                    "header_rows" => Ok(__FieldTag::__header_rows),
                                    "delimiter" => Ok(__FieldTag::__delimiter),
                                    "encoding" => Ok(__FieldTag::__encoding),
                                    "disableTypeInference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    "disable_type_inference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CsvOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CsvOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__header_rows => {
                                    if !fields.insert(__FieldTag::__header_rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for header_rows",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.header_rows =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__delimiter => {
                                    if !fields.insert(__FieldTag::__delimiter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for delimiter",
                                            ),
                                        );
                                    }
                                    result.delimiter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__encoding => {
                                    if !fields.insert(__FieldTag::__encoding) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for encoding",
                                            ),
                                        );
                                    }
                                    result.encoding = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__disable_type_inference => {
                                    if !fields.insert(__FieldTag::__disable_type_inference) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disable_type_inference",
                                            ),
                                        );
                                    }
                                    result.disable_type_inference = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CsvOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.header_rows) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("headerRows", &__With(&self.header_rows))?;
                }
                if !self.delimiter.is_empty() {
                    state.serialize_entry("delimiter", &self.delimiter)?;
                }
                if !self.encoding.is_empty() {
                    state.serialize_entry("encoding", &self.encoding)?;
                }
                if !wkt::internal::is_default(&self.disable_type_inference) {
                    state.serialize_entry("disableTypeInference", &self.disable_type_inference)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Describe JSON data format.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            pub disable_type_inference: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::asset::discovery_spec::JsonOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::asset::discovery_spec::JsonOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoverySpec.JsonOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JsonOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __encoding,
                    __disable_type_inference,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JsonOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "encoding" => Ok(__FieldTag::__encoding),
                                    "disableTypeInference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    "disable_type_inference" => {
                                        Ok(__FieldTag::__disable_type_inference)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JsonOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JsonOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__encoding => {
                                    if !fields.insert(__FieldTag::__encoding) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for encoding",
                                            ),
                                        );
                                    }
                                    result.encoding = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__disable_type_inference => {
                                    if !fields.insert(__FieldTag::__disable_type_inference) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disable_type_inference",
                                            ),
                                        );
                                    }
                                    result.disable_type_inference = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JsonOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.encoding.is_empty() {
                    state.serialize_entry("encoding", &self.encoding)?;
                }
                if !wkt::internal::is_default(&self.disable_type_inference) {
                    state.serialize_entry("disableTypeInference", &self.disable_type_inference)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Determines when discovery is triggered.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes.
            ///
            /// To explicitly set a timezone to the cron tab, apply a prefix in the
            /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}".
            /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
            /// database. For example, `CRON_TZ=America/New_York 1 * * * *`, or
            /// `TZ=America/New_York 1 * * * *`.
            Schedule(std::string::String),
        }
    }

    /// Identifies the cloud resource that is referenced by this asset.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceSpec {
        /// Immutable. Relative name of the cloud resource that contains the data
        /// that is being managed within a lake. For example:
        /// `projects/{project_number}/buckets/{bucket_id}`
        /// `projects/{project_number}/datasets/{dataset_id}`
        pub name: std::string::String,

        /// Required. Immutable. Type of resource.
        pub r#type: crate::model::asset::resource_spec::Type,

        /// Optional. Determines how read permissions are handled for each asset and
        /// their associated tables. Only available to storage buckets assets.
        pub read_access_mode: crate::model::asset::resource_spec::AccessMode,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::asset::ResourceSpec::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::asset::ResourceSpec::type].
        pub fn set_type<T: std::convert::Into<crate::model::asset::resource_spec::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [read_access_mode][crate::model::asset::ResourceSpec::read_access_mode].
        pub fn set_read_access_mode<
            T: std::convert::Into<crate::model::asset::resource_spec::AccessMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.read_access_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.ResourceSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __type,
                __read_access_mode,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                "readAccessMode" => Ok(__FieldTag::__read_access_mode),
                                "read_access_mode" => Ok(__FieldTag::__read_access_mode),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type =
                                    map.next_value::<std::option::Option<
                                        crate::model::asset::resource_spec::Type,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__read_access_mode => {
                                if !fields.insert(__FieldTag::__read_access_mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for read_access_mode",
                                    ));
                                }
                                result.read_access_mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::asset::resource_spec::AccessMode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.read_access_mode) {
                state.serialize_entry("readAccessMode", &self.read_access_mode)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ResourceSpec].
    pub mod resource_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Type of resource.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Type not specified.
            Unspecified,
            /// Cloud Storage bucket.
            StorageBucket,
            /// BigQuery dataset.
            BigqueryDataset,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::StorageBucket => std::option::Option::Some(1),
                    Self::BigqueryDataset => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::StorageBucket => std::option::Option::Some("STORAGE_BUCKET"),
                    Self::BigqueryDataset => std::option::Option::Some("BIGQUERY_DATASET"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::StorageBucket,
                    2 => Self::BigqueryDataset,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "STORAGE_BUCKET" => Self::StorageBucket,
                    "BIGQUERY_DATASET" => Self::BigqueryDataset,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::StorageBucket => serializer.serialize_i32(1),
                    Self::BigqueryDataset => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.dataplex.v1.Asset.ResourceSpec.Type",
                ))
            }
        }

        /// Access Mode determines how data stored within the resource is read. This
        /// is only applicable to storage bucket assets.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AccessMode {
            /// Access mode unspecified.
            Unspecified,
            /// Default. Data is accessed directly using storage APIs.
            Direct,
            /// Data is accessed through a managed interface using BigQuery APIs.
            Managed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [AccessMode::value] or
            /// [AccessMode::name].
            UnknownValue(access_mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod access_mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl AccessMode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Direct => std::option::Option::Some(1),
                    Self::Managed => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ACCESS_MODE_UNSPECIFIED"),
                    Self::Direct => std::option::Option::Some("DIRECT"),
                    Self::Managed => std::option::Option::Some("MANAGED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for AccessMode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for AccessMode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for AccessMode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Direct,
                    2 => Self::Managed,
                    _ => Self::UnknownValue(access_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for AccessMode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ACCESS_MODE_UNSPECIFIED" => Self::Unspecified,
                    "DIRECT" => Self::Direct,
                    "MANAGED" => Self::Managed,
                    _ => Self::UnknownValue(access_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for AccessMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Direct => serializer.serialize_i32(1),
                    Self::Managed => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for AccessMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessMode>::new(
                    ".google.cloud.dataplex.v1.Asset.ResourceSpec.AccessMode",
                ))
            }
        }
    }

    /// Status of the resource referenced by an asset.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceStatus {
        /// The current state of the managed resource.
        pub state: crate::model::asset::resource_status::State,

        /// Additional information about the current state.
        pub message: std::string::String,

        /// Last update time of the status.
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. Service account associated with the BigQuery Connection.
        pub managed_access_identity: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::asset::ResourceStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::asset::resource_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::asset::ResourceStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::asset::ResourceStatus::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::asset::ResourceStatus::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [managed_access_identity][crate::model::asset::ResourceStatus::managed_access_identity].
        pub fn set_managed_access_identity<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.managed_access_identity = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.ResourceStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __message,
                __update_time,
                __managed_access_identity,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "message" => Ok(__FieldTag::__message),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                "managedAccessIdentity" => {
                                    Ok(__FieldTag::__managed_access_identity)
                                }
                                "managed_access_identity" => {
                                    Ok(__FieldTag::__managed_access_identity)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::asset::resource_status::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__message => {
                                if !fields.insert(__FieldTag::__message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message",
                                    ));
                                }
                                result.message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__managed_access_identity => {
                                if !fields.insert(__FieldTag::__managed_access_identity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for managed_access_identity",
                                    ));
                                }
                                result.managed_access_identity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.message.is_empty() {
                state.serialize_entry("message", &self.message)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self.managed_access_identity.is_empty() {
                state.serialize_entry("managedAccessIdentity", &self.managed_access_identity)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ResourceStatus].
    pub mod resource_status {
        #[allow(unused_imports)]
        use super::*;

        /// The state of a resource.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State unspecified.
            Unspecified,
            /// Resource does not have any errors.
            Ready,
            /// Resource has errors.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Ready => std::option::Option::Some(1),
                    Self::Error => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::Error => std::option::Option::Some("ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Ready,
                    2 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "READY" => Self::Ready,
                    "ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Ready => serializer.serialize_i32(1),
                    Self::Error => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Asset.ResourceStatus.State",
                ))
            }
        }
    }

    /// Status of discovery for an asset.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DiscoveryStatus {
        /// The current status of the discovery feature.
        pub state: crate::model::asset::discovery_status::State,

        /// Additional information about the current state.
        pub message: std::string::String,

        /// Last update time of the status.
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// The start time of the last discovery run.
        pub last_run_time: std::option::Option<wkt::Timestamp>,

        /// Data Stats of the asset reported by discovery.
        pub stats: std::option::Option<crate::model::asset::discovery_status::Stats>,

        /// The duration of the last discovery run.
        pub last_run_duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiscoveryStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::asset::DiscoveryStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::asset::discovery_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::asset::DiscoveryStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::asset::DiscoveryStatus::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::asset::DiscoveryStatus::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [last_run_time][crate::model::asset::DiscoveryStatus::last_run_time].
        pub fn set_last_run_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_run_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_run_time][crate::model::asset::DiscoveryStatus::last_run_time].
        pub fn set_or_clear_last_run_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_run_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [stats][crate::model::asset::DiscoveryStatus::stats].
        pub fn set_stats<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::asset::discovery_status::Stats>,
        {
            self.stats = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [stats][crate::model::asset::DiscoveryStatus::stats].
        pub fn set_or_clear_stats<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::asset::discovery_status::Stats>,
        {
            self.stats = v.map(|x| x.into());
            self
        }

        /// Sets the value of [last_run_duration][crate::model::asset::DiscoveryStatus::last_run_duration].
        pub fn set_last_run_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.last_run_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_run_duration][crate::model::asset::DiscoveryStatus::last_run_duration].
        pub fn set_or_clear_last_run_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.last_run_duration = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DiscoveryStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoveryStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DiscoveryStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __message,
                __update_time,
                __last_run_time,
                __stats,
                __last_run_duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DiscoveryStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "message" => Ok(__FieldTag::__message),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                "lastRunTime" => Ok(__FieldTag::__last_run_time),
                                "last_run_time" => Ok(__FieldTag::__last_run_time),
                                "stats" => Ok(__FieldTag::__stats),
                                "lastRunDuration" => Ok(__FieldTag::__last_run_duration),
                                "last_run_duration" => Ok(__FieldTag::__last_run_duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DiscoveryStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DiscoveryStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::asset::discovery_status::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__message => {
                                if !fields.insert(__FieldTag::__message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message",
                                    ));
                                }
                                result.message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__last_run_time => {
                                if !fields.insert(__FieldTag::__last_run_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_run_time",
                                    ));
                                }
                                result.last_run_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__stats => {
                                if !fields.insert(__FieldTag::__stats) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stats",
                                    ));
                                }
                                result.stats = map.next_value::<std::option::Option<
                                    crate::model::asset::discovery_status::Stats,
                                >>()?;
                            }
                            __FieldTag::__last_run_duration => {
                                if !fields.insert(__FieldTag::__last_run_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_run_duration",
                                    ));
                                }
                                result.last_run_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DiscoveryStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.message.is_empty() {
                state.serialize_entry("message", &self.message)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if self.last_run_time.is_some() {
                state.serialize_entry("lastRunTime", &self.last_run_time)?;
            }
            if self.stats.is_some() {
                state.serialize_entry("stats", &self.stats)?;
            }
            if self.last_run_duration.is_some() {
                state.serialize_entry("lastRunDuration", &self.last_run_duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DiscoveryStatus].
    pub mod discovery_status {
        #[allow(unused_imports)]
        use super::*;

        /// The aggregated data statistics for the asset reported by discovery.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Stats {
            /// The count of data items within the referenced resource.
            pub data_items: i64,

            /// The number of stored data bytes within the referenced resource.
            pub data_size: i64,

            /// The count of table entities within the referenced resource.
            pub tables: i64,

            /// The count of fileset entities within the referenced resource.
            pub filesets: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Stats {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [data_items][crate::model::asset::discovery_status::Stats::data_items].
            pub fn set_data_items<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.data_items = v.into();
                self
            }

            /// Sets the value of [data_size][crate::model::asset::discovery_status::Stats::data_size].
            pub fn set_data_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.data_size = v.into();
                self
            }

            /// Sets the value of [tables][crate::model::asset::discovery_status::Stats::tables].
            pub fn set_tables<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.tables = v.into();
                self
            }

            /// Sets the value of [filesets][crate::model::asset::discovery_status::Stats::filesets].
            pub fn set_filesets<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.filesets = v.into();
                self
            }
        }

        impl wkt::message::Message for Stats {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoveryStatus.Stats"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Stats {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __data_items,
                    __data_size,
                    __tables,
                    __filesets,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Stats")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "dataItems" => Ok(__FieldTag::__data_items),
                                    "data_items" => Ok(__FieldTag::__data_items),
                                    "dataSize" => Ok(__FieldTag::__data_size),
                                    "data_size" => Ok(__FieldTag::__data_size),
                                    "tables" => Ok(__FieldTag::__tables),
                                    "filesets" => Ok(__FieldTag::__filesets),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Stats;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Stats")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__data_items => {
                                    if !fields.insert(__FieldTag::__data_items) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_items",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.data_items =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__data_size => {
                                    if !fields.insert(__FieldTag::__data_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.data_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__tables => {
                                    if !fields.insert(__FieldTag::__tables) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for tables"),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.tables =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__filesets => {
                                    if !fields.insert(__FieldTag::__filesets) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for filesets",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.filesets =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Stats {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.data_items) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("dataItems", &__With(&self.data_items))?;
                }
                if !wkt::internal::is_default(&self.data_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("dataSize", &__With(&self.data_size))?;
                }
                if !wkt::internal::is_default(&self.tables) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("tables", &__With(&self.tables))?;
                }
                if !wkt::internal::is_default(&self.filesets) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("filesets", &__With(&self.filesets))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Current state of discovery.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State is unspecified.
            Unspecified,
            /// Discovery for the asset is scheduled.
            Scheduled,
            /// Discovery for the asset is running.
            InProgress,
            /// Discovery for the asset is currently paused (e.g. due to a lack
            /// of available resources). It will be automatically resumed.
            Paused,
            /// Discovery for the asset is disabled.
            Disabled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Scheduled => std::option::Option::Some(1),
                    Self::InProgress => std::option::Option::Some(2),
                    Self::Paused => std::option::Option::Some(3),
                    Self::Disabled => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                    Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                    Self::Paused => std::option::Option::Some("PAUSED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Scheduled,
                    2 => Self::InProgress,
                    3 => Self::Paused,
                    5 => Self::Disabled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "SCHEDULED" => Self::Scheduled,
                    "IN_PROGRESS" => Self::InProgress,
                    "PAUSED" => Self::Paused,
                    "DISABLED" => Self::Disabled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Scheduled => serializer.serialize_i32(1),
                    Self::InProgress => serializer.serialize_i32(2),
                    Self::Paused => serializer.serialize_i32(3),
                    Self::Disabled => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Asset.DiscoveryStatus.State",
                ))
            }
        }
    }
}

/// ResourceAccessSpec holds the access control configuration to be enforced
/// on the resources, for example, Cloud Storage bucket, BigQuery dataset,
/// BigQuery table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on the resource.
    pub readers: std::vec::Vec<std::string::String>,

    /// Optional. The set of principals to be granted writer role on the resource.
    pub writers: std::vec::Vec<std::string::String>,

    /// Optional. The set of principals to be granted owner role on the resource.
    pub owners: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceAccessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [readers][crate::model::ResourceAccessSpec::readers].
    pub fn set_readers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.readers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [writers][crate::model::ResourceAccessSpec::writers].
    pub fn set_writers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.writers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [owners][crate::model::ResourceAccessSpec::owners].
    pub fn set_owners<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.owners = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ResourceAccessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ResourceAccessSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceAccessSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __readers,
            __writers,
            __owners,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceAccessSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "readers" => Ok(__FieldTag::__readers),
                            "writers" => Ok(__FieldTag::__writers),
                            "owners" => Ok(__FieldTag::__owners),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceAccessSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceAccessSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__readers => {
                            if !fields.insert(__FieldTag::__readers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for readers",
                                ));
                            }
                            result.readers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__writers => {
                            if !fields.insert(__FieldTag::__writers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for writers",
                                ));
                            }
                            result.writers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__owners => {
                            if !fields.insert(__FieldTag::__owners) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owners",
                                ));
                            }
                            result.owners = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceAccessSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.readers.is_empty() {
            state.serialize_entry("readers", &self.readers)?;
        }
        if !self.writers.is_empty() {
            state.serialize_entry("writers", &self.writers)?;
        }
        if !self.owners.is_empty() {
            state.serialize_entry("owners", &self.owners)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DataAccessSpec holds the access control configuration to be enforced on data
/// stored within resources (eg: rows, columns in BigQuery Tables). When
/// associated with data, the data is only accessible to
/// principals explicitly granted access through the DataAccessSpec. Principals
/// with access to the containing resource are not implicitly granted access.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on data
    /// stored within resources.
    pub readers: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataAccessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [readers][crate::model::DataAccessSpec::readers].
    pub fn set_readers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.readers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataAccessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataAccessSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataAccessSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __readers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataAccessSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "readers" => Ok(__FieldTag::__readers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataAccessSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataAccessSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__readers => {
                            if !fields.insert(__FieldTag::__readers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for readers",
                                ));
                            }
                            result.readers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataAccessSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.readers.is_empty() {
            state.serialize_entry("readers", &self.readers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create lake request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateLakeRequest {
    /// Required. The resource name of the lake location, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Required. Lake identifier.
    /// This ID will be used to generate names such as database and dataset names
    /// when publishing metadata to Hive Metastore and BigQuery.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the customer project / location.
    pub lake_id: std::string::String,

    /// Required. Lake resource
    pub lake: std::option::Option<crate::model::Lake>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLakeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [lake_id][crate::model::CreateLakeRequest::lake_id].
    pub fn set_lake_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lake_id = v.into();
        self
    }

    /// Sets the value of [lake][crate::model::CreateLakeRequest::lake].
    pub fn set_lake<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Lake>,
    {
        self.lake = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lake][crate::model::CreateLakeRequest::lake].
    pub fn set_or_clear_lake<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Lake>,
    {
        self.lake = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateLakeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateLakeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateLakeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __lake_id,
            __lake,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateLakeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "lakeId" => Ok(__FieldTag::__lake_id),
                            "lake_id" => Ok(__FieldTag::__lake_id),
                            "lake" => Ok(__FieldTag::__lake),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateLakeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateLakeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lake_id => {
                            if !fields.insert(__FieldTag::__lake_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lake_id",
                                ));
                            }
                            result.lake_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lake => {
                            if !fields.insert(__FieldTag::__lake) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lake",
                                ));
                            }
                            result.lake =
                                map.next_value::<std::option::Option<crate::model::Lake>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateLakeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.lake_id.is_empty() {
            state.serialize_entry("lakeId", &self.lake_id)?;
        }
        if self.lake.is_some() {
            state.serialize_entry("lake", &self.lake)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update lake request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateLakeRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    pub lake: std::option::Option<crate::model::Lake>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateLakeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateLakeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lake][crate::model::UpdateLakeRequest::lake].
    pub fn set_lake<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Lake>,
    {
        self.lake = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lake][crate::model::UpdateLakeRequest::lake].
    pub fn set_or_clear_lake<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Lake>,
    {
        self.lake = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateLakeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateLakeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateLakeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __lake,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateLakeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "lake" => Ok(__FieldTag::__lake),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateLakeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateLakeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__lake => {
                            if !fields.insert(__FieldTag::__lake) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lake",
                                ));
                            }
                            result.lake =
                                map.next_value::<std::option::Option<crate::model::Lake>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateLakeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.lake.is_some() {
            state.serialize_entry("lake", &self.lake)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete lake request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteLakeRequest {
    /// Required. The resource name of the lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLakeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteLakeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteLakeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteLakeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteLakeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteLakeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteLakeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List lakes request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLakesRequest {
    /// Required. The resource name of the lake location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Optional. Maximum number of Lakes to return. The service may return fewer
    /// than this value. If unspecified, at most 10 lakes will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListLakes` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListLakes` must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLakesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLakesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLakesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLakesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListLakesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListLakesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListLakesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListLakesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLakesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLakesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLakesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLakesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLakesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List lakes response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLakesResponse {
    /// Lakes under the given parent location.
    pub lakes: std::vec::Vec<crate::model::Lake>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLakesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lakes][crate::model::ListLakesResponse::lakes].
    pub fn set_lakes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lake>,
    {
        use std::iter::Iterator;
        self.lakes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLakesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListLakesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLakesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListLakesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLakesResponse {
    type PageItem = crate::model::Lake;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.lakes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLakesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lakes,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLakesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lakes" => Ok(__FieldTag::__lakes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLakesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLakesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lakes => {
                            if !fields.insert(__FieldTag::__lakes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lakes",
                                ));
                            }
                            result.lakes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Lake>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLakesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.lakes.is_empty() {
            state.serialize_entry("lakes", &self.lakes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List lake actions request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLakeActionsRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListLakeActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListLakeActions` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLakeActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLakeActionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLakeActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLakeActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLakeActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListLakeActionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLakeActionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLakeActionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLakeActionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLakeActionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLakeActionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List actions response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListActionsResponse {
    /// Actions under the given parent lake/zone/asset.
    pub actions: std::vec::Vec<crate::model::Action>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListActionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::ListActionsResponse::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListActionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListActionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListActionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListActionsResponse {
    type PageItem = crate::model::Action;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.actions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListActionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __actions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListActionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actions" => Ok(__FieldTag::__actions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListActionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListActionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Action>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListActionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get lake request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLakeRequest {
    /// Required. The resource name of the lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLakeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetLakeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLakeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLakeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLakeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLakeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLakeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create zone request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateZoneRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub parent: std::string::String,

    /// Required. Zone identifier.
    /// This ID will be used to generate names such as database and dataset names
    /// when publishing metadata to Hive Metastore and BigQuery.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique across all lakes from all locations in a project.
    /// * Must not be one of the reserved IDs (i.e. "default", "global-temp")
    pub zone_id: std::string::String,

    /// Required. Zone resource.
    pub zone: std::option::Option<crate::model::Zone>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateZoneRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [zone_id][crate::model::CreateZoneRequest::zone_id].
    pub fn set_zone_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CreateZoneRequest::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Zone>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::CreateZoneRequest::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Zone>,
    {
        self.zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateZoneRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateZoneRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateZoneRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __zone_id,
            __zone,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateZoneRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "zoneId" => Ok(__FieldTag::__zone_id),
                            "zone_id" => Ok(__FieldTag::__zone_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateZoneRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateZoneRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone_id => {
                            if !fields.insert(__FieldTag::__zone_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone_id",
                                ));
                            }
                            result.zone_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone =
                                map.next_value::<std::option::Option<crate::model::Zone>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateZoneRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.zone_id.is_empty() {
            state.serialize_entry("zoneId", &self.zone_id)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update zone request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateZoneRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    pub zone: std::option::Option<crate::model::Zone>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateZoneRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateZoneRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::UpdateZoneRequest::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Zone>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::UpdateZoneRequest::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Zone>,
    {
        self.zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateZoneRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateZoneRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateZoneRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __zone,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateZoneRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "zone" => Ok(__FieldTag::__zone),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateZoneRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateZoneRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone =
                                map.next_value::<std::option::Option<crate::model::Zone>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateZoneRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete zone request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteZoneRequest {
    /// Required. The resource name of the zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteZoneRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteZoneRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteZoneRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteZoneRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteZoneRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteZoneRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteZoneRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List zones request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListZonesRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of zones to return. The service may return fewer
    /// than this value. If unspecified, at most 10 zones will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListZones` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListZones` must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListZonesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListZonesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListZonesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListZonesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListZonesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListZonesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListZonesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListZonesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListZonesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListZonesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListZonesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListZonesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListZonesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List zones response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListZonesResponse {
    /// Zones under the given parent lake.
    pub zones: std::vec::Vec<crate::model::Zone>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListZonesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zones][crate::model::ListZonesResponse::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Zone>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListZonesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListZonesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListZonesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListZonesResponse {
    type PageItem = crate::model::Zone;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.zones
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListZonesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __zones,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListZonesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "zones" => Ok(__FieldTag::__zones),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListZonesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListZonesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__zones => {
                            if !fields.insert(__FieldTag::__zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zones",
                                ));
                            }
                            result.zones = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Zone>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListZonesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List zone actions request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListZoneActionsRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListZoneActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListZoneActions` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListZoneActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListZoneActionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListZoneActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListZoneActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListZoneActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListZoneActionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListZoneActionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListZoneActionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListZoneActionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListZoneActionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListZoneActionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get zone request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetZoneRequest {
    /// Required. The resource name of the zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetZoneRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetZoneRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetZoneRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetZoneRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetZoneRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetZoneRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetZoneRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create asset request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAssetRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub parent: std::string::String,

    /// Required. Asset identifier.
    /// This ID will be used to generate names such as table names when publishing
    /// metadata to Hive Metastore and BigQuery.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the zone.
    pub asset_id: std::string::String,

    /// Required. Asset resource.
    pub asset: std::option::Option<crate::model::Asset>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAssetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [asset_id][crate::model::CreateAssetRequest::asset_id].
    pub fn set_asset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_id = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::CreateAssetRequest::asset].
    pub fn set_asset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [asset][crate::model::CreateAssetRequest::asset].
    pub fn set_or_clear_asset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAssetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __asset_id,
            __asset,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "assetId" => Ok(__FieldTag::__asset_id),
                            "asset_id" => Ok(__FieldTag::__asset_id),
                            "asset" => Ok(__FieldTag::__asset),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_id => {
                            if !fields.insert(__FieldTag::__asset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_id",
                                ));
                            }
                            result.asset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset =
                                map.next_value::<std::option::Option<crate::model::Asset>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.asset_id.is_empty() {
            state.serialize_entry("assetId", &self.asset_id)?;
        }
        if self.asset.is_some() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update asset request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAssetRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    pub asset: std::option::Option<crate::model::Asset>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAssetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAssetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset][crate::model::UpdateAssetRequest::asset].
    pub fn set_asset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [asset][crate::model::UpdateAssetRequest::asset].
    pub fn set_or_clear_asset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAssetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __asset,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "asset" => Ok(__FieldTag::__asset),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset =
                                map.next_value::<std::option::Option<crate::model::Asset>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.asset.is_some() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete asset request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAssetRequest {
    /// Required. The resource name of the asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List assets request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of asset to return. The service may return fewer
    /// than this value. If unspecified, at most 10 assets will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListAssets` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListAssets` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAssetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAssetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List assets response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsResponse {
    /// Asset under the given parent zone.
    pub assets: std::vec::Vec<crate::model::Asset>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assets][crate::model::ListAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAssetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAssetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAssetsResponse {
    type PageItem = crate::model::Asset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assets" => Ok(__FieldTag::__assets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Asset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assets.is_empty() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List asset actions request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetActionsRequest {
    /// Required. The resource name of the parent asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListAssetActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListAssetActions` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetActionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAssetActionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetActionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetActionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetActionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetActionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetActionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get asset request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAssetRequest {
    /// Required. The resource name of the asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of a long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create task request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTaskRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub parent: std::string::String,

    /// Required. Task identifier.
    pub task_id: std::string::String,

    /// Required. Task resource.
    pub task: std::option::Option<crate::model::Task>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTaskRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [task_id][crate::model::CreateTaskRequest::task_id].
    pub fn set_task_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.task_id = v.into();
        self
    }

    /// Sets the value of [task][crate::model::CreateTaskRequest::task].
    pub fn set_task<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Task>,
    {
        self.task = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [task][crate::model::CreateTaskRequest::task].
    pub fn set_or_clear_task<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Task>,
    {
        self.task = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateTaskRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __task_id,
            __task,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "taskId" => Ok(__FieldTag::__task_id),
                            "task_id" => Ok(__FieldTag::__task_id),
                            "task" => Ok(__FieldTag::__task),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__task_id => {
                            if !fields.insert(__FieldTag::__task_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task_id",
                                ));
                            }
                            result.task_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__task => {
                            if !fields.insert(__FieldTag::__task) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task",
                                ));
                            }
                            result.task =
                                map.next_value::<std::option::Option<crate::model::Task>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.task_id.is_empty() {
            state.serialize_entry("taskId", &self.task_id)?;
        }
        if self.task.is_some() {
            state.serialize_entry("task", &self.task)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update task request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTaskRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    pub task: std::option::Option<crate::model::Task>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTaskRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTaskRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [task][crate::model::UpdateTaskRequest::task].
    pub fn set_task<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Task>,
    {
        self.task = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [task][crate::model::UpdateTaskRequest::task].
    pub fn set_or_clear_task<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Task>,
    {
        self.task = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateTaskRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __task,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "task" => Ok(__FieldTag::__task),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__task => {
                            if !fields.insert(__FieldTag::__task) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task",
                                ));
                            }
                            result.task =
                                map.next_value::<std::option::Option<crate::model::Task>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.task.is_some() {
            state.serialize_entry("task", &self.task)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete task request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/task/{task_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List tasks request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTasksRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of tasks to return. The service may return fewer
    /// than this value. If unspecified, at most 10 tasks will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListZones` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListZones` must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTasksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTasksRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListTasksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTasksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTasksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTasksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTasksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTasksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List tasks response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTasksResponse {
    /// Tasks under the given parent lake.
    pub tasks: std::vec::Vec<crate::model::Task>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tasks][crate::model::ListTasksResponse::tasks].
    pub fn set_tasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Task>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListTasksResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListTasksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTasksResponse {
    type PageItem = crate::model::Task;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tasks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTasksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tasks,
            __next_page_token,
            __unreachable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTasksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tasks" => Ok(__FieldTag::__tasks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableLocations" => Ok(__FieldTag::__unreachable_locations),
                            "unreachable_locations" => Ok(__FieldTag::__unreachable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTasksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTasksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tasks => {
                            if !fields.insert(__FieldTag::__tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tasks",
                                ));
                            }
                            result.tasks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Task>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_locations => {
                            if !fields.insert(__FieldTag::__unreachable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_locations",
                                ));
                            }
                            result.unreachable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTasksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tasks.is_empty() {
            state.serialize_entry("tasks", &self.tasks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_locations.is_empty() {
            state.serialize_entry("unreachableLocations", &self.unreachable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get task request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{tasks_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get job request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The resource name of the job:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}/jobs/{job_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}`.
    pub name: std::string::String,

    /// Optional. User-defined labels for the task. If the map is left empty, the
    /// task will run with existing labels from task definition. If the map
    /// contains an entry with a new key, the same will be added to existing set of
    /// labels. If the map contains an entry with an existing label key in task
    /// definition, the task will run with new label value for that entry. Clearing
    /// an existing label will require label value to be explicitly set to a hyphen
    /// "-". The label value cannot be empty.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Execution spec arguments. If the map is left empty, the task will
    /// run with existing execution spec args from task definition. If the map
    /// contains an entry with a new key, the same will be added to existing set of
    /// args. If the map contains an entry with an existing arg key in task
    /// definition, the task will run with new arg value for that entry. Clearing
    /// an existing arg will require arg value to be explicitly set to a hyphen
    /// "-". The arg value cannot be empty.
    pub args: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::RunTaskRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [args][crate::model::RunTaskRequest::args].
    pub fn set_args<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RunTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __labels,
            __args,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "labels" => Ok(__FieldTag::__labels),
                            "args" => Ok(__FieldTag::__args),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunTaskResponse {
    /// Jobs created by RunTask API.
    pub job: std::option::Option<crate::model::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunTaskResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::RunTaskResponse::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::RunTaskResponse::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RunTaskResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunTaskResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunTaskResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTaskResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "job" => Ok(__FieldTag::__job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunTaskResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTaskResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunTaskResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List jobs request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of jobs to return. The service may return fewer
    /// than this value. If unspecified, at most 10 jobs will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListJobs` call. Provide this
    /// to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListJobs` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List jobs response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// Jobs under a given task.
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobs" => Ok(__FieldTag::__jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cancel task jobs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelJobRequest {
    /// Required. The resource name of the job:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/task/{task_id}/job/{job_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CancelJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Create environment request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEnvironmentRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}`.
    pub parent: std::string::String,

    /// Required. Environment identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the lake.
    pub environment_id: std::string::String,

    /// Required. Environment resource.
    pub environment: std::option::Option<crate::model::Environment>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnvironmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [environment_id][crate::model::CreateEnvironmentRequest::environment_id].
    pub fn set_environment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment_id = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEnvironmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __environment_id,
            __environment,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "environmentId" => Ok(__FieldTag::__environment_id),
                            "environment_id" => Ok(__FieldTag::__environment_id),
                            "environment" => Ok(__FieldTag::__environment),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment_id => {
                            if !fields.insert(__FieldTag::__environment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment_id",
                                ));
                            }
                            result.environment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.environment_id.is_empty() {
            state.serialize_entry("environmentId", &self.environment_id)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Update environment request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEnvironmentRequest {
    /// Required. Mask of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    pub environment: std::option::Option<crate::model::Environment>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEnvironmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __environment,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "environment" => Ok(__FieldTag::__environment),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Delete environment request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEnvironmentRequest {
    /// Required. The resource name of the environment:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environments/{environment_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List environments request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of environments to return. The service may return
    /// fewer than this value. If unspecified, at most 10 environments will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEnvironments` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListEnvironments` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    /// Optional. Filter request.
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnvironmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnvironmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnvironmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnvironmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEnvironmentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEnvironmentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEnvironmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List environments response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsResponse {
    /// Environments under the given parent lake.
    pub environments: std::vec::Vec<crate::model::Environment>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnvironmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environments][crate::model::ListEnvironmentsResponse::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEnvironmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEnvironmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnvironmentsResponse {
    type PageItem = crate::model::Environment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.environments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environments" => Ok(__FieldTag::__environments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environments => {
                            if !fields.insert(__FieldTag::__environments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environments",
                                ));
                            }
                            result.environments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Environment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Get environment request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEnvironmentRequest {
    /// Required. The resource name of the environment:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environments/{environment_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List sessions request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of sessions to return. The service may return
    /// fewer than this value. If unspecified, at most 10 sessions will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListSessions` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListSessions` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. Filter request. The following `mode` filter is supported to
    /// return only the sessions belonging to the requester when the mode is USER
    /// and return sessions of all the users when the mode is ADMIN. When no filter
    /// is sent default to USER mode. NOTE: When the mode is ADMIN, the requester
    /// should have `dataplex.environments.listAllSessions` permission to list all
    /// sessions, in absence of the permission, the request fails.
    ///
    /// mode = ADMIN | USER
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSessionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListSessionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List sessions response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionsResponse {
    /// Sessions under a given environment.
    pub sessions: std::vec::Vec<crate::model::Session>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sessions][crate::model::ListSessionsResponse::sessions].
    pub fn set_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Session>,
    {
        use std::iter::Iterator;
        self.sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionsResponse {
    type PageItem = crate::model::Session;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sessions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessions" => Ok(__FieldTag::__sessions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sessions => {
                            if !fields.insert(__FieldTag::__sessions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sessions",
                                ));
                            }
                            result.sessions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Session>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sessions.is_empty() {
            state.serialize_entry("sessions", &self.sessions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A task represents a user-visible job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Task {
    /// Output only. The relative resource name of the task, of the form:
    /// projects/{project_number}/locations/{location_id}/lakes/{lake_id}/
    /// tasks/{task_id}.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the task. This ID will
    /// be different if the task is deleted and re-created with the same name.
    pub uid: std::string::String,

    /// Output only. The time when the task was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the task was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the task.
    pub description: std::string::String,

    /// Optional. User friendly display name.
    pub display_name: std::string::String,

    /// Output only. Current state of the task.
    pub state: crate::model::State,

    /// Optional. User-defined labels for the task.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Spec related to how often and when a task should be triggered.
    pub trigger_spec: std::option::Option<crate::model::task::TriggerSpec>,

    /// Required. Spec related to how a task is executed.
    pub execution_spec: std::option::Option<crate::model::task::ExecutionSpec>,

    /// Output only. Status of the latest task executions.
    pub execution_status: std::option::Option<crate::model::task::ExecutionStatus>,

    /// Task template specific user-specified config.
    pub config: std::option::Option<crate::model::task::Config>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Task {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Task::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Task::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Task::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Task::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Task::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Task::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Task::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Task::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Task::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Task::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [trigger_spec][crate::model::Task::trigger_spec].
    pub fn set_trigger_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::task::TriggerSpec>,
    {
        self.trigger_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger_spec][crate::model::Task::trigger_spec].
    pub fn set_or_clear_trigger_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::task::TriggerSpec>,
    {
        self.trigger_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [execution_spec][crate::model::Task::execution_spec].
    pub fn set_execution_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::task::ExecutionSpec>,
    {
        self.execution_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_spec][crate::model::Task::execution_spec].
    pub fn set_or_clear_execution_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::task::ExecutionSpec>,
    {
        self.execution_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [execution_status][crate::model::Task::execution_status].
    pub fn set_execution_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::task::ExecutionStatus>,
    {
        self.execution_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_status][crate::model::Task::execution_status].
    pub fn set_or_clear_execution_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::task::ExecutionStatus>,
    {
        self.execution_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config][crate::model::Task::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::task::Config>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::Task::config]
    /// if it holds a `Spark`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::task::SparkTaskConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::task::Config::Spark(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::Task::config]
    /// to hold a `Spark`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_spark<
        T: std::convert::Into<std::boxed::Box<crate::model::task::SparkTaskConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(crate::model::task::Config::Spark(v.into()));
        self
    }

    /// The value of [config][crate::model::Task::config]
    /// if it holds a `Notebook`, `None` if the field is not set or
    /// holds a different branch.
    pub fn notebook(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::task::NotebookTaskConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::task::Config::Notebook(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::Task::config]
    /// to hold a `Notebook`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_notebook<
        T: std::convert::Into<std::boxed::Box<crate::model::task::NotebookTaskConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(crate::model::task::Config::Notebook(v.into()));
        self
    }
}

impl wkt::message::Message for Task {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Task"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Task {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __state,
            __labels,
            __trigger_spec,
            __execution_spec,
            __execution_status,
            __spark,
            __notebook,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Task")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "labels" => Ok(__FieldTag::__labels),
                            "triggerSpec" => Ok(__FieldTag::__trigger_spec),
                            "trigger_spec" => Ok(__FieldTag::__trigger_spec),
                            "executionSpec" => Ok(__FieldTag::__execution_spec),
                            "execution_spec" => Ok(__FieldTag::__execution_spec),
                            "executionStatus" => Ok(__FieldTag::__execution_status),
                            "execution_status" => Ok(__FieldTag::__execution_status),
                            "spark" => Ok(__FieldTag::__spark),
                            "notebook" => Ok(__FieldTag::__notebook),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Task;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Task")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_spec => {
                            if !fields.insert(__FieldTag::__trigger_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_spec",
                                ));
                            }
                            result.trigger_spec = map
                                .next_value::<std::option::Option<crate::model::task::TriggerSpec>>(
                                )?;
                        }
                        __FieldTag::__execution_spec => {
                            if !fields.insert(__FieldTag::__execution_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_spec",
                                ));
                            }
                            result.execution_spec = map.next_value::<std::option::Option<crate::model::task::ExecutionSpec>>()?
                                ;
                        }
                        __FieldTag::__execution_status => {
                            if !fields.insert(__FieldTag::__execution_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_status",
                                ));
                            }
                            result.execution_status = map.next_value::<std::option::Option<crate::model::task::ExecutionStatus>>()?
                                ;
                        }
                        __FieldTag::__spark => {
                            if !fields.insert(__FieldTag::__spark) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dataplex.v1.Task.spark, latest field was spark",
                                ));
                            }
                            result.config =
                                std::option::Option::Some(crate::model::task::Config::Spark(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::task::SparkTaskConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__notebook => {
                            if !fields.insert(__FieldTag::__notebook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notebook",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dataplex.v1.Task.notebook, latest field was notebook",
                                ));
                            }
                            result.config =
                                std::option::Option::Some(crate::model::task::Config::Notebook(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::task::NotebookTaskConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Task {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.trigger_spec.is_some() {
            state.serialize_entry("triggerSpec", &self.trigger_spec)?;
        }
        if self.execution_spec.is_some() {
            state.serialize_entry("executionSpec", &self.execution_spec)?;
        }
        if self.execution_status.is_some() {
            state.serialize_entry("executionStatus", &self.execution_status)?;
        }
        if let Some(value) = self.spark() {
            state.serialize_entry("spark", value)?;
        }
        if let Some(value) = self.notebook() {
            state.serialize_entry("notebook", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Task].
pub mod task {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the underlying infrastructure used to run workloads.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InfrastructureSpec {
        /// Hardware config.
        pub resources: std::option::Option<crate::model::task::infrastructure_spec::Resources>,

        /// Software config.
        pub runtime: std::option::Option<crate::model::task::infrastructure_spec::Runtime>,

        /// Networking config.
        pub network: std::option::Option<crate::model::task::infrastructure_spec::Network>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfrastructureSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resources][crate::model::task::InfrastructureSpec::resources].
        ///
        /// Note that all the setters affecting `resources` are mutually
        /// exclusive.
        pub fn set_resources<
            T: std::convert::Into<
                    std::option::Option<crate::model::task::infrastructure_spec::Resources>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = v.into();
            self
        }

        /// The value of [resources][crate::model::task::InfrastructureSpec::resources]
        /// if it holds a `Batch`, `None` if the field is not set or
        /// holds a different branch.
        pub fn batch(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::task::infrastructure_spec::BatchComputeResources>,
        > {
            #[allow(unreachable_patterns)]
            self.resources.as_ref().and_then(|v| match v {
                crate::model::task::infrastructure_spec::Resources::Batch(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resources][crate::model::task::InfrastructureSpec::resources]
        /// to hold a `Batch`.
        ///
        /// Note that all the setters affecting `resources` are
        /// mutually exclusive.
        pub fn set_batch<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::task::infrastructure_spec::BatchComputeResources>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = std::option::Option::Some(
                crate::model::task::infrastructure_spec::Resources::Batch(v.into()),
            );
            self
        }

        /// Sets the value of [runtime][crate::model::task::InfrastructureSpec::runtime].
        ///
        /// Note that all the setters affecting `runtime` are mutually
        /// exclusive.
        pub fn set_runtime<
            T: std::convert::Into<
                    std::option::Option<crate::model::task::infrastructure_spec::Runtime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = v.into();
            self
        }

        /// The value of [runtime][crate::model::task::InfrastructureSpec::runtime]
        /// if it holds a `ContainerImage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn container_image(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::task::infrastructure_spec::ContainerImageRuntime>,
        > {
            #[allow(unreachable_patterns)]
            self.runtime.as_ref().and_then(|v| match v {
                crate::model::task::infrastructure_spec::Runtime::ContainerImage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [runtime][crate::model::task::InfrastructureSpec::runtime]
        /// to hold a `ContainerImage`.
        ///
        /// Note that all the setters affecting `runtime` are
        /// mutually exclusive.
        pub fn set_container_image<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::task::infrastructure_spec::ContainerImageRuntime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = std::option::Option::Some(
                crate::model::task::infrastructure_spec::Runtime::ContainerImage(v.into()),
            );
            self
        }

        /// Sets the value of [network][crate::model::task::InfrastructureSpec::network].
        ///
        /// Note that all the setters affecting `network` are mutually
        /// exclusive.
        pub fn set_network<
            T: std::convert::Into<
                    std::option::Option<crate::model::task::infrastructure_spec::Network>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.network = v.into();
            self
        }

        /// The value of [network][crate::model::task::InfrastructureSpec::network]
        /// if it holds a `VpcNetwork`, `None` if the field is not set or
        /// holds a different branch.
        pub fn vpc_network(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::task::infrastructure_spec::VpcNetwork>,
        > {
            #[allow(unreachable_patterns)]
            self.network.as_ref().and_then(|v| match v {
                crate::model::task::infrastructure_spec::Network::VpcNetwork(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [network][crate::model::task::InfrastructureSpec::network]
        /// to hold a `VpcNetwork`.
        ///
        /// Note that all the setters affecting `network` are
        /// mutually exclusive.
        pub fn set_vpc_network<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::task::infrastructure_spec::VpcNetwork>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.network = std::option::Option::Some(
                crate::model::task::infrastructure_spec::Network::VpcNetwork(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for InfrastructureSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InfrastructureSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __batch,
                __container_image,
                __vpc_network,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InfrastructureSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "batch" => Ok(__FieldTag::__batch),
                                "containerImage" => Ok(__FieldTag::__container_image),
                                "container_image" => Ok(__FieldTag::__container_image),
                                "vpcNetwork" => Ok(__FieldTag::__vpc_network),
                                "vpc_network" => Ok(__FieldTag::__vpc_network),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InfrastructureSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InfrastructureSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__batch => {
                                if !fields.insert(__FieldTag::__batch) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for batch",
                                    ));
                                }
                                if result.resources.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `resources`, a oneof with full ID .google.cloud.dataplex.v1.Task.InfrastructureSpec.batch, latest field was batch",
                                    ));
                                }
                                result.resources = std::option::Option::Some(
                                    crate::model::task::infrastructure_spec::Resources::Batch(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::task::infrastructure_spec::BatchComputeResources>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__container_image => {
                                if !fields.insert(__FieldTag::__container_image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for container_image",
                                    ));
                                }
                                if result.runtime.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `runtime`, a oneof with full ID .google.cloud.dataplex.v1.Task.InfrastructureSpec.container_image, latest field was containerImage",
                                    ));
                                }
                                result.runtime = std::option::Option::Some(
                                    crate::model::task::infrastructure_spec::Runtime::ContainerImage(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::task::infrastructure_spec::ContainerImageRuntime>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__vpc_network => {
                                if !fields.insert(__FieldTag::__vpc_network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vpc_network",
                                    ));
                                }
                                if result.network.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `network`, a oneof with full ID .google.cloud.dataplex.v1.Task.InfrastructureSpec.vpc_network, latest field was vpcNetwork",
                                    ));
                                }
                                result.network = std::option::Option::Some(
                                    crate::model::task::infrastructure_spec::Network::VpcNetwork(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::task::infrastructure_spec::VpcNetwork,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InfrastructureSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.batch() {
                state.serialize_entry("batch", value)?;
            }
            if let Some(value) = self.container_image() {
                state.serialize_entry("containerImage", value)?;
            }
            if let Some(value) = self.vpc_network() {
                state.serialize_entry("vpcNetwork", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [InfrastructureSpec].
    pub mod infrastructure_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Batch compute resources associated with the task.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BatchComputeResources {
            /// Optional. Total number of job executors.
            /// Executor Count should be between 2 and 100. [Default=2]
            pub executors_count: i32,

            /// Optional. Max configurable executors.
            /// If max_executors_count > executors_count, then auto-scaling is enabled.
            /// Max Executor Count should be between 2 and 1000. [Default=1000]
            pub max_executors_count: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BatchComputeResources {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [executors_count][crate::model::task::infrastructure_spec::BatchComputeResources::executors_count].
            pub fn set_executors_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.executors_count = v.into();
                self
            }

            /// Sets the value of [max_executors_count][crate::model::task::infrastructure_spec::BatchComputeResources::max_executors_count].
            pub fn set_max_executors_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_executors_count = v.into();
                self
            }
        }

        impl wkt::message::Message for BatchComputeResources {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec.BatchComputeResources"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BatchComputeResources {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __executors_count,
                    __max_executors_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BatchComputeResources")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "executorsCount" => Ok(__FieldTag::__executors_count),
                                    "executors_count" => Ok(__FieldTag::__executors_count),
                                    "maxExecutorsCount" => Ok(__FieldTag::__max_executors_count),
                                    "max_executors_count" => Ok(__FieldTag::__max_executors_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BatchComputeResources;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BatchComputeResources")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__executors_count => {
                                    if !fields.insert(__FieldTag::__executors_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for executors_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.executors_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__max_executors_count => {
                                    if !fields.insert(__FieldTag::__max_executors_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_executors_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_executors_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BatchComputeResources {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.executors_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("executorsCount", &__With(&self.executors_count))?;
                }
                if !wkt::internal::is_default(&self.max_executors_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state
                        .serialize_entry("maxExecutorsCount", &__With(&self.max_executors_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Container Image Runtime Configuration used with Batch execution.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ContainerImageRuntime {
            /// Optional. Container image to use.
            pub image: std::string::String,

            /// Optional. A list of Java JARS to add to the classpath.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            pub java_jars: std::vec::Vec<std::string::String>,

            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            pub python_packages: std::vec::Vec<std::string::String>,

            /// Optional. Override to common configuration of open source components
            /// installed on the Dataproc cluster. The properties to set on daemon
            /// config files. Property keys are specified in `prefix:property` format,
            /// for example `core:hadoop.tmp.dir`. For more information, see [Cluster
            /// properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).
            pub properties: std::collections::HashMap<std::string::String, std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ContainerImageRuntime {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [image][crate::model::task::infrastructure_spec::ContainerImageRuntime::image].
            pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.image = v.into();
                self
            }

            /// Sets the value of [java_jars][crate::model::task::infrastructure_spec::ContainerImageRuntime::java_jars].
            pub fn set_java_jars<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.java_jars = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [python_packages][crate::model::task::infrastructure_spec::ContainerImageRuntime::python_packages].
            pub fn set_python_packages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.python_packages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [properties][crate::model::task::infrastructure_spec::ContainerImageRuntime::properties].
            pub fn set_properties<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for ContainerImageRuntime {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec.ContainerImageRuntime"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ContainerImageRuntime {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __image,
                    __java_jars,
                    __python_packages,
                    __properties,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ContainerImageRuntime")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "image" => Ok(__FieldTag::__image),
                                    "javaJars" => Ok(__FieldTag::__java_jars),
                                    "java_jars" => Ok(__FieldTag::__java_jars),
                                    "pythonPackages" => Ok(__FieldTag::__python_packages),
                                    "python_packages" => Ok(__FieldTag::__python_packages),
                                    "properties" => Ok(__FieldTag::__properties),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ContainerImageRuntime;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ContainerImageRuntime")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__image => {
                                    if !fields.insert(__FieldTag::__image) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for image"),
                                        );
                                    }
                                    result.image = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__java_jars => {
                                    if !fields.insert(__FieldTag::__java_jars) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for java_jars",
                                            ),
                                        );
                                    }
                                    result.java_jars = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__python_packages => {
                                    if !fields.insert(__FieldTag::__python_packages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for python_packages",
                                            ),
                                        );
                                    }
                                    result.python_packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__properties => {
                                    if !fields.insert(__FieldTag::__properties) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for properties",
                                            ),
                                        );
                                    }
                                    result.properties = map
                                        .next_value::<std::option::Option<
                                            std::collections::HashMap<
                                                std::string::String,
                                                std::string::String,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ContainerImageRuntime {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.image.is_empty() {
                    state.serialize_entry("image", &self.image)?;
                }
                if !self.java_jars.is_empty() {
                    state.serialize_entry("javaJars", &self.java_jars)?;
                }
                if !self.python_packages.is_empty() {
                    state.serialize_entry("pythonPackages", &self.python_packages)?;
                }
                if !self.properties.is_empty() {
                    state.serialize_entry("properties", &self.properties)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Cloud VPC Network used to run the infrastructure.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct VpcNetwork {
            /// Optional. List of network tags to apply to the job.
            pub network_tags: std::vec::Vec<std::string::String>,

            /// The Cloud VPC network identifier.
            pub network_name: std::option::Option<
                crate::model::task::infrastructure_spec::vpc_network::NetworkName,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VpcNetwork {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [network_tags][crate::model::task::infrastructure_spec::VpcNetwork::network_tags].
            pub fn set_network_tags<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.network_tags = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name].
            ///
            /// Note that all the setters affecting `network_name` are mutually
            /// exclusive.
            pub fn set_network_name<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::task::infrastructure_spec::vpc_network::NetworkName,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.network_name = v.into();
                self
            }

            /// The value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// if it holds a `Network`, `None` if the field is not set or
            /// holds a different branch.
            pub fn network(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.network_name.as_ref().and_then(|v| match v {
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::Network(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// to hold a `Network`.
            ///
            /// Note that all the setters affecting `network_name` are
            /// mutually exclusive.
            pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.network_name = std::option::Option::Some(
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::Network(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// if it holds a `SubNetwork`, `None` if the field is not set or
            /// holds a different branch.
            pub fn sub_network(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.network_name.as_ref().and_then(|v| match v {
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::SubNetwork(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// to hold a `SubNetwork`.
            ///
            /// Note that all the setters affecting `network_name` are
            /// mutually exclusive.
            pub fn set_sub_network<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.network_name = std::option::Option::Some(
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::SubNetwork(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for VpcNetwork {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec.VpcNetwork"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for VpcNetwork {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __network,
                    __sub_network,
                    __network_tags,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for VpcNetwork")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "network" => Ok(__FieldTag::__network),
                                    "subNetwork" => Ok(__FieldTag::__sub_network),
                                    "sub_network" => Ok(__FieldTag::__sub_network),
                                    "networkTags" => Ok(__FieldTag::__network_tags),
                                    "network_tags" => Ok(__FieldTag::__network_tags),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = VpcNetwork;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct VpcNetwork")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__network => {
                                    if !fields.insert(__FieldTag::__network) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for network",
                                            ),
                                        );
                                    }
                                    if result.network_name.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `network_name`, a oneof with full ID .google.cloud.dataplex.v1.Task.InfrastructureSpec.VpcNetwork.network, latest field was network",
                                            ),
                                        );
                                    }
                                    result.network_name = std::option::Option::Some(
                                        crate::model::task::infrastructure_spec::vpc_network::NetworkName::Network(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__sub_network => {
                                    if !fields.insert(__FieldTag::__sub_network) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for sub_network",
                                            ),
                                        );
                                    }
                                    if result.network_name.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `network_name`, a oneof with full ID .google.cloud.dataplex.v1.Task.InfrastructureSpec.VpcNetwork.sub_network, latest field was subNetwork",
                                            ),
                                        );
                                    }
                                    result.network_name = std::option::Option::Some(
                                        crate::model::task::infrastructure_spec::vpc_network::NetworkName::SubNetwork(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__network_tags => {
                                    if !fields.insert(__FieldTag::__network_tags) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for network_tags",
                                            ),
                                        );
                                    }
                                    result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for VpcNetwork {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.network() {
                    state.serialize_entry("network", value)?;
                }
                if let Some(value) = self.sub_network() {
                    state.serialize_entry("subNetwork", value)?;
                }
                if !self.network_tags.is_empty() {
                    state.serialize_entry("networkTags", &self.network_tags)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [VpcNetwork].
        pub mod vpc_network {
            #[allow(unused_imports)]
            use super::*;

            /// The Cloud VPC network identifier.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum NetworkName {
                /// Optional. The Cloud VPC network in which the job is run. By default,
                /// the Cloud VPC network named Default within the project is used.
                Network(std::string::String),
                /// Optional. The Cloud VPC sub-network in which the job is run.
                SubNetwork(std::string::String),
            }
        }

        /// Hardware config.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Resources {
            /// Compute resources needed for a Task when using Dataproc Serverless.
            Batch(std::boxed::Box<crate::model::task::infrastructure_spec::BatchComputeResources>),
        }

        /// Software config.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Runtime {
            /// Container Image Runtime Configuration.
            ContainerImage(
                std::boxed::Box<crate::model::task::infrastructure_spec::ContainerImageRuntime>,
            ),
        }

        /// Networking config.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Network {
            /// Vpc network.
            VpcNetwork(std::boxed::Box<crate::model::task::infrastructure_spec::VpcNetwork>),
        }
    }

    /// Task scheduling and trigger settings.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TriggerSpec {
        /// Required. Immutable. Trigger type of the user-specified Task.
        pub r#type: crate::model::task::trigger_spec::Type,

        /// Optional. The first run of the task will be after this time.
        /// If not specified, the task will run shortly after being submitted if
        /// ON_DEMAND and based on the schedule if RECURRING.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Optional. Prevent the task from executing.
        /// This does not cancel already running tasks. It is intended to temporarily
        /// disable RECURRING tasks.
        pub disabled: bool,

        /// Optional. Number of retry attempts before aborting.
        /// Set to zero to never attempt to retry a failed task.
        pub max_retries: i32,

        /// Trigger only applies for RECURRING tasks.
        pub trigger: std::option::Option<crate::model::task::trigger_spec::Trigger>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TriggerSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::task::TriggerSpec::type].
        pub fn set_type<T: std::convert::Into<crate::model::task::trigger_spec::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::task::TriggerSpec::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::task::TriggerSpec::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [disabled][crate::model::task::TriggerSpec::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [max_retries][crate::model::task::TriggerSpec::max_retries].
        pub fn set_max_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_retries = v.into();
            self
        }

        /// Sets the value of [trigger][crate::model::task::TriggerSpec::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::task::trigger_spec::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::task::TriggerSpec::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::task::trigger_spec::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::task::TriggerSpec::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::task::trigger_spec::Trigger::Schedule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for TriggerSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.TriggerSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TriggerSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __start_time,
                __disabled,
                __max_retries,
                __schedule,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TriggerSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "disabled" => Ok(__FieldTag::__disabled),
                                "maxRetries" => Ok(__FieldTag::__max_retries),
                                "max_retries" => Ok(__FieldTag::__max_retries),
                                "schedule" => Ok(__FieldTag::__schedule),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TriggerSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TriggerSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map.next_value::<std::option::Option<crate::model::task::trigger_spec::Type>>()?.unwrap_or_default();
                            }
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__disabled => {
                                if !fields.insert(__FieldTag::__disabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disabled",
                                    ));
                                }
                                result.disabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_retries => {
                                if !fields.insert(__FieldTag::__max_retries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_retries",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_retries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__schedule => {
                                if !fields.insert(__FieldTag::__schedule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule",
                                    ));
                                }
                                if result.trigger.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `trigger`, a oneof with full ID .google.cloud.dataplex.v1.Task.TriggerSpec.schedule, latest field was schedule",
                                    ));
                                }
                                result.trigger = std::option::Option::Some(
                                    crate::model::task::trigger_spec::Trigger::Schedule(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TriggerSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if !wkt::internal::is_default(&self.disabled) {
                state.serialize_entry("disabled", &self.disabled)?;
            }
            if !wkt::internal::is_default(&self.max_retries) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxRetries", &__With(&self.max_retries))?;
            }
            if let Some(value) = self.schedule() {
                state.serialize_entry("schedule", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TriggerSpec].
    pub mod trigger_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Determines how often and when the job will run.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Unspecified trigger type.
            Unspecified,
            /// The task runs one-time shortly after Task Creation.
            OnDemand,
            /// The task is scheduled to run periodically.
            Recurring,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::OnDemand => std::option::Option::Some(1),
                    Self::Recurring => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                    Self::Recurring => std::option::Option::Some("RECURRING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::OnDemand,
                    2 => Self::Recurring,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ON_DEMAND" => Self::OnDemand,
                    "RECURRING" => Self::Recurring,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::OnDemand => serializer.serialize_i32(1),
                    Self::Recurring => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.dataplex.v1.Task.TriggerSpec.Type",
                ))
            }
        }

        /// Trigger only applies for RECURRING tasks.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running tasks periodically. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid
            /// string from IANA time zone database. For example,
            /// `CRON_TZ=America/New_York 1 * * * *`, or `TZ=America/New_York 1 * * *
            /// *`. This field is required for RECURRING tasks.
            Schedule(std::string::String),
        }
    }

    /// Execution related settings, like retry and service_account.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExecutionSpec {
        /// Optional. The arguments to pass to the task.
        /// The args can use placeholders of the format ${placeholder} as
        /// part of key/value string. These will be interpolated before passing the
        /// args to the driver. Currently supported placeholders:
        ///
        /// - ${task_id}
        /// - ${job_time}
        ///   To pass positional args, set the key as TASK_ARGS. The value should be a
        ///   comma-separated string of all the positional arguments. To use a
        ///   delimiter other than comma, refer to
        ///   <https://cloud.google.com/sdk/gcloud/reference/topic/escaping>. In case of
        ///   other keys being present in the args, then TASK_ARGS will be passed as
        ///   the last argument.
        pub args: std::collections::HashMap<std::string::String, std::string::String>,

        /// Required. Service account to use to execute a task.
        /// If not provided, the default Compute service account for the project is
        /// used.
        pub service_account: std::string::String,

        /// Optional. The project in which jobs are run. By default, the project
        /// containing the Lake is used. If a project is provided, the
        /// [ExecutionSpec.service_account][google.cloud.dataplex.v1.Task.ExecutionSpec.service_account]
        /// must belong to this project.
        ///
        /// [google.cloud.dataplex.v1.Task.ExecutionSpec.service_account]: crate::model::task::ExecutionSpec::service_account
        pub project: std::string::String,

        /// Optional. The maximum duration after which the job execution is expired.
        pub max_job_execution_lifetime: std::option::Option<wkt::Duration>,

        /// Optional. The Cloud KMS key to use for encryption, of the form:
        /// `projects/{project_number}/locations/{location_id}/keyRings/{key-ring-name}/cryptoKeys/{key-name}`.
        pub kms_key: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [args][crate::model::task::ExecutionSpec::args].
        pub fn set_args<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.args = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [service_account][crate::model::task::ExecutionSpec::service_account].
        pub fn set_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_account = v.into();
            self
        }

        /// Sets the value of [project][crate::model::task::ExecutionSpec::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [max_job_execution_lifetime][crate::model::task::ExecutionSpec::max_job_execution_lifetime].
        pub fn set_max_job_execution_lifetime<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.max_job_execution_lifetime = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_job_execution_lifetime][crate::model::task::ExecutionSpec::max_job_execution_lifetime].
        pub fn set_or_clear_max_job_execution_lifetime<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.max_job_execution_lifetime = v.map(|x| x.into());
            self
        }

        /// Sets the value of [kms_key][crate::model::task::ExecutionSpec::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }
    }

    impl wkt::message::Message for ExecutionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.ExecutionSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExecutionSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __args,
                __service_account,
                __project,
                __max_job_execution_lifetime,
                __kms_key,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExecutionSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "args" => Ok(__FieldTag::__args),
                                "serviceAccount" => Ok(__FieldTag::__service_account),
                                "service_account" => Ok(__FieldTag::__service_account),
                                "project" => Ok(__FieldTag::__project),
                                "maxJobExecutionLifetime" => {
                                    Ok(__FieldTag::__max_job_execution_lifetime)
                                }
                                "max_job_execution_lifetime" => {
                                    Ok(__FieldTag::__max_job_execution_lifetime)
                                }
                                "kmsKey" => Ok(__FieldTag::__kms_key),
                                "kms_key" => Ok(__FieldTag::__kms_key),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExecutionSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExecutionSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__args => {
                                if !fields.insert(__FieldTag::__args) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for args",
                                    ));
                                }
                                result.args = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_account => {
                                if !fields.insert(__FieldTag::__service_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_account",
                                    ));
                                }
                                result.service_account = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__project => {
                                if !fields.insert(__FieldTag::__project) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project",
                                    ));
                                }
                                result.project = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_job_execution_lifetime => {
                                if !fields.insert(__FieldTag::__max_job_execution_lifetime) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_job_execution_lifetime",
                                    ));
                                }
                                result.max_job_execution_lifetime =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__kms_key => {
                                if !fields.insert(__FieldTag::__kms_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key",
                                    ));
                                }
                                result.kms_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExecutionSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.args.is_empty() {
                state.serialize_entry("args", &self.args)?;
            }
            if !self.service_account.is_empty() {
                state.serialize_entry("serviceAccount", &self.service_account)?;
            }
            if !self.project.is_empty() {
                state.serialize_entry("project", &self.project)?;
            }
            if self.max_job_execution_lifetime.is_some() {
                state
                    .serialize_entry("maxJobExecutionLifetime", &self.max_job_execution_lifetime)?;
            }
            if !self.kms_key.is_empty() {
                state.serialize_entry("kmsKey", &self.kms_key)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// User-specified config for running a Spark task.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SparkTaskConfig {
        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        pub file_uris: std::vec::Vec<std::string::String>,

        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        pub archive_uris: std::vec::Vec<std::string::String>,

        /// Optional. Infrastructure specification for the execution.
        pub infrastructure_spec: std::option::Option<crate::model::task::InfrastructureSpec>,

        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        pub driver: std::option::Option<crate::model::task::spark_task_config::Driver>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SparkTaskConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [file_uris][crate::model::task::SparkTaskConfig::file_uris].
        pub fn set_file_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.file_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [archive_uris][crate::model::task::SparkTaskConfig::archive_uris].
        pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.archive_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [infrastructure_spec][crate::model::task::SparkTaskConfig::infrastructure_spec].
        pub fn set_infrastructure_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::task::InfrastructureSpec>,
        {
            self.infrastructure_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [infrastructure_spec][crate::model::task::SparkTaskConfig::infrastructure_spec].
        pub fn set_or_clear_infrastructure_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::task::InfrastructureSpec>,
        {
            self.infrastructure_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver].
        ///
        /// Note that all the setters affecting `driver` are mutually
        /// exclusive.
        pub fn set_driver<
            T: std::convert::Into<std::option::Option<crate::model::task::spark_task_config::Driver>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.driver = v.into();
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `MainJarFileUri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::MainJarFileUri(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `MainJarFileUri`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::MainJarFileUri(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `MainClass`, `None` if the field is not set or
        /// holds a different branch.
        pub fn main_class(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::MainClass(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `MainClass`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::MainClass(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `PythonScriptFile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn python_script_file(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::PythonScriptFile(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `PythonScriptFile`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_python_script_file<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::PythonScriptFile(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `SqlScriptFile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_script_file(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::SqlScriptFile(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `SqlScriptFile`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_sql_script_file<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::SqlScriptFile(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `SqlScript`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_script(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::SqlScript(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `SqlScript`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_sql_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::SqlScript(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SparkTaskConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.SparkTaskConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SparkTaskConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __main_jar_file_uri,
                __main_class,
                __python_script_file,
                __sql_script_file,
                __sql_script,
                __file_uris,
                __archive_uris,
                __infrastructure_spec,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SparkTaskConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mainJarFileUri" => Ok(__FieldTag::__main_jar_file_uri),
                                "main_jar_file_uri" => Ok(__FieldTag::__main_jar_file_uri),
                                "mainClass" => Ok(__FieldTag::__main_class),
                                "main_class" => Ok(__FieldTag::__main_class),
                                "pythonScriptFile" => Ok(__FieldTag::__python_script_file),
                                "python_script_file" => Ok(__FieldTag::__python_script_file),
                                "sqlScriptFile" => Ok(__FieldTag::__sql_script_file),
                                "sql_script_file" => Ok(__FieldTag::__sql_script_file),
                                "sqlScript" => Ok(__FieldTag::__sql_script),
                                "sql_script" => Ok(__FieldTag::__sql_script),
                                "fileUris" => Ok(__FieldTag::__file_uris),
                                "file_uris" => Ok(__FieldTag::__file_uris),
                                "archiveUris" => Ok(__FieldTag::__archive_uris),
                                "archive_uris" => Ok(__FieldTag::__archive_uris),
                                "infrastructureSpec" => Ok(__FieldTag::__infrastructure_spec),
                                "infrastructure_spec" => Ok(__FieldTag::__infrastructure_spec),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SparkTaskConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SparkTaskConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__main_jar_file_uri => {
                                if !fields.insert(__FieldTag::__main_jar_file_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for main_jar_file_uri",
                                    ));
                                }
                                if result.driver.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `driver`, a oneof with full ID .google.cloud.dataplex.v1.Task.SparkTaskConfig.main_jar_file_uri, latest field was mainJarFileUri",
                                    ));
                                }
                                result.driver = std::option::Option::Some(
                                    crate::model::task::spark_task_config::Driver::MainJarFileUri(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__main_class => {
                                if !fields.insert(__FieldTag::__main_class) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for main_class",
                                    ));
                                }
                                if result.driver.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `driver`, a oneof with full ID .google.cloud.dataplex.v1.Task.SparkTaskConfig.main_class, latest field was mainClass",
                                    ));
                                }
                                result.driver = std::option::Option::Some(
                                    crate::model::task::spark_task_config::Driver::MainClass(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__python_script_file => {
                                if !fields.insert(__FieldTag::__python_script_file) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for python_script_file",
                                    ));
                                }
                                if result.driver.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `driver`, a oneof with full ID .google.cloud.dataplex.v1.Task.SparkTaskConfig.python_script_file, latest field was pythonScriptFile",
                                    ));
                                }
                                result.driver = std::option::Option::Some(
                                    crate::model::task::spark_task_config::Driver::PythonScriptFile(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__sql_script_file => {
                                if !fields.insert(__FieldTag::__sql_script_file) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_script_file",
                                    ));
                                }
                                if result.driver.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `driver`, a oneof with full ID .google.cloud.dataplex.v1.Task.SparkTaskConfig.sql_script_file, latest field was sqlScriptFile",
                                    ));
                                }
                                result.driver = std::option::Option::Some(
                                    crate::model::task::spark_task_config::Driver::SqlScriptFile(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__sql_script => {
                                if !fields.insert(__FieldTag::__sql_script) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_script",
                                    ));
                                }
                                if result.driver.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `driver`, a oneof with full ID .google.cloud.dataplex.v1.Task.SparkTaskConfig.sql_script, latest field was sqlScript",
                                    ));
                                }
                                result.driver = std::option::Option::Some(
                                    crate::model::task::spark_task_config::Driver::SqlScript(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__file_uris => {
                                if !fields.insert(__FieldTag::__file_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_uris",
                                    ));
                                }
                                result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__archive_uris => {
                                if !fields.insert(__FieldTag::__archive_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for archive_uris",
                                    ));
                                }
                                result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__infrastructure_spec => {
                                if !fields.insert(__FieldTag::__infrastructure_spec) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for infrastructure_spec",
                                    ));
                                }
                                result.infrastructure_spec = map.next_value::<std::option::Option<crate::model::task::InfrastructureSpec>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SparkTaskConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.main_jar_file_uri() {
                state.serialize_entry("mainJarFileUri", value)?;
            }
            if let Some(value) = self.main_class() {
                state.serialize_entry("mainClass", value)?;
            }
            if let Some(value) = self.python_script_file() {
                state.serialize_entry("pythonScriptFile", value)?;
            }
            if let Some(value) = self.sql_script_file() {
                state.serialize_entry("sqlScriptFile", value)?;
            }
            if let Some(value) = self.sql_script() {
                state.serialize_entry("sqlScript", value)?;
            }
            if !self.file_uris.is_empty() {
                state.serialize_entry("fileUris", &self.file_uris)?;
            }
            if !self.archive_uris.is_empty() {
                state.serialize_entry("archiveUris", &self.archive_uris)?;
            }
            if self.infrastructure_spec.is_some() {
                state.serialize_entry("infrastructureSpec", &self.infrastructure_spec)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SparkTaskConfig].
    pub mod spark_task_config {
        #[allow(unused_imports)]
        use super::*;

        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Driver {
            /// The Cloud Storage URI of the jar file that contains the main class.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            MainJarFileUri(std::string::String),
            /// The name of the driver's main class. The jar file that contains the
            /// class must be in the default CLASSPATH or specified in
            /// `jar_file_uris`.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            MainClass(std::string::String),
            /// The Gcloud Storage URI of the main Python file to use as the driver.
            /// Must be a .py file. The execution args are passed in as a sequence of
            /// named process arguments (`--key=value`).
            PythonScriptFile(std::string::String),
            /// A reference to a query file. This should be the Cloud Storage URI of
            /// the query file. The execution args are used to declare a set of script
            /// variables (`set key="value";`).
            SqlScriptFile(std::string::String),
            /// The query text.
            /// The execution args are used to declare a set of script variables
            /// (`set key="value";`).
            SqlScript(std::string::String),
        }
    }

    /// Config for running scheduled notebooks.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NotebookTaskConfig {
        /// Required. Path to input notebook. This can be the Cloud Storage URI of
        /// the notebook file or the path to a Notebook Content. The execution args
        /// are accessible as environment variables
        /// (`TASK_key=value`).
        pub notebook: std::string::String,

        /// Optional. Infrastructure specification for the execution.
        pub infrastructure_spec: std::option::Option<crate::model::task::InfrastructureSpec>,

        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        pub file_uris: std::vec::Vec<std::string::String>,

        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        pub archive_uris: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NotebookTaskConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [notebook][crate::model::task::NotebookTaskConfig::notebook].
        pub fn set_notebook<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.notebook = v.into();
            self
        }

        /// Sets the value of [infrastructure_spec][crate::model::task::NotebookTaskConfig::infrastructure_spec].
        pub fn set_infrastructure_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::task::InfrastructureSpec>,
        {
            self.infrastructure_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [infrastructure_spec][crate::model::task::NotebookTaskConfig::infrastructure_spec].
        pub fn set_or_clear_infrastructure_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::task::InfrastructureSpec>,
        {
            self.infrastructure_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [file_uris][crate::model::task::NotebookTaskConfig::file_uris].
        pub fn set_file_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.file_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [archive_uris][crate::model::task::NotebookTaskConfig::archive_uris].
        pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.archive_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NotebookTaskConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.NotebookTaskConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NotebookTaskConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __notebook,
                __infrastructure_spec,
                __file_uris,
                __archive_uris,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NotebookTaskConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "notebook" => Ok(__FieldTag::__notebook),
                                "infrastructureSpec" => Ok(__FieldTag::__infrastructure_spec),
                                "infrastructure_spec" => Ok(__FieldTag::__infrastructure_spec),
                                "fileUris" => Ok(__FieldTag::__file_uris),
                                "file_uris" => Ok(__FieldTag::__file_uris),
                                "archiveUris" => Ok(__FieldTag::__archive_uris),
                                "archive_uris" => Ok(__FieldTag::__archive_uris),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NotebookTaskConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NotebookTaskConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__notebook => {
                                if !fields.insert(__FieldTag::__notebook) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for notebook",
                                    ));
                                }
                                result.notebook = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__infrastructure_spec => {
                                if !fields.insert(__FieldTag::__infrastructure_spec) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for infrastructure_spec",
                                    ));
                                }
                                result.infrastructure_spec = map.next_value::<std::option::Option<crate::model::task::InfrastructureSpec>>()?
                                    ;
                            }
                            __FieldTag::__file_uris => {
                                if !fields.insert(__FieldTag::__file_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_uris",
                                    ));
                                }
                                result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__archive_uris => {
                                if !fields.insert(__FieldTag::__archive_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for archive_uris",
                                    ));
                                }
                                result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NotebookTaskConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.notebook.is_empty() {
                state.serialize_entry("notebook", &self.notebook)?;
            }
            if self.infrastructure_spec.is_some() {
                state.serialize_entry("infrastructureSpec", &self.infrastructure_spec)?;
            }
            if !self.file_uris.is_empty() {
                state.serialize_entry("fileUris", &self.file_uris)?;
            }
            if !self.archive_uris.is_empty() {
                state.serialize_entry("archiveUris", &self.archive_uris)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Status of the task execution (e.g. Jobs).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExecutionStatus {
        /// Output only. Last update time of the status.
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. latest job execution
        pub latest_job: std::option::Option<crate::model::Job>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [update_time][crate::model::task::ExecutionStatus::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::task::ExecutionStatus::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [latest_job][crate::model::task::ExecutionStatus::latest_job].
        pub fn set_latest_job<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Job>,
        {
            self.latest_job = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [latest_job][crate::model::task::ExecutionStatus::latest_job].
        pub fn set_or_clear_latest_job<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Job>,
        {
            self.latest_job = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ExecutionStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.ExecutionStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExecutionStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __update_time,
                __latest_job,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExecutionStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                "latestJob" => Ok(__FieldTag::__latest_job),
                                "latest_job" => Ok(__FieldTag::__latest_job),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExecutionStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExecutionStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__latest_job => {
                                if !fields.insert(__FieldTag::__latest_job) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for latest_job",
                                    ));
                                }
                                result.latest_job =
                                    map.next_value::<std::option::Option<crate::model::Job>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExecutionStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if self.latest_job.is_some() {
                state.serialize_entry("latestJob", &self.latest_job)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Task template specific user-specified config.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// Config related to running custom Spark tasks.
        Spark(std::boxed::Box<crate::model::task::SparkTaskConfig>),
        /// Config related to running scheduled Notebooks.
        Notebook(std::boxed::Box<crate::model::task::NotebookTaskConfig>),
    }
}

/// A job represents an instance of a task.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Job {
    /// Output only. The relative resource name of the job, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}/jobs/{job_id}`.
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the job.
    pub uid: std::string::String,

    /// Output only. The time when the job was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the job ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Execution state for the job.
    pub state: crate::model::job::State,

    /// Output only. The number of times the job has been retried (excluding the
    /// initial attempt).
    pub retry_count: u32,

    /// Output only. The underlying service running a job.
    pub service: crate::model::job::Service,

    /// Output only. The full resource name for the job run under a particular
    /// service.
    pub service_job: std::string::String,

    /// Output only. Additional information about the current state.
    pub message: std::string::String,

    /// Output only. User-defined labels for the task.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Job execution trigger.
    pub trigger: crate::model::job::Trigger,

    /// Output only. Spec related to how a task is executed.
    pub execution_spec: std::option::Option<crate::model::task::ExecutionSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Job::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Job::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Job::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Job::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Job::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Job::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Job::state].
    pub fn set_state<T: std::convert::Into<crate::model::job::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [retry_count][crate::model::Job::retry_count].
    pub fn set_retry_count<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.retry_count = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Job::service].
    pub fn set_service<T: std::convert::Into<crate::model::job::Service>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [service_job][crate::model::Job::service_job].
    pub fn set_service_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_job = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Job::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Job::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [trigger][crate::model::Job::trigger].
    pub fn set_trigger<T: std::convert::Into<crate::model::job::Trigger>>(mut self, v: T) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [execution_spec][crate::model::Job::execution_spec].
    pub fn set_execution_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::task::ExecutionSpec>,
    {
        self.execution_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_spec][crate::model::Job::execution_spec].
    pub fn set_or_clear_execution_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::task::ExecutionSpec>,
    {
        self.execution_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Job"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __start_time,
            __end_time,
            __state,
            __retry_count,
            __service,
            __service_job,
            __message,
            __labels,
            __trigger,
            __execution_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "state" => Ok(__FieldTag::__state),
                            "retryCount" => Ok(__FieldTag::__retry_count),
                            "retry_count" => Ok(__FieldTag::__retry_count),
                            "service" => Ok(__FieldTag::__service),
                            "serviceJob" => Ok(__FieldTag::__service_job),
                            "service_job" => Ok(__FieldTag::__service_job),
                            "message" => Ok(__FieldTag::__message),
                            "labels" => Ok(__FieldTag::__labels),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "executionSpec" => Ok(__FieldTag::__execution_spec),
                            "execution_spec" => Ok(__FieldTag::__execution_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::job::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retry_count => {
                            if !fields.insert(__FieldTag::__retry_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_count",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retry_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<crate::model::job::Service>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_job => {
                            if !fields.insert(__FieldTag::__service_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_job",
                                ));
                            }
                            result.service_job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map
                                .next_value::<std::option::Option<crate::model::job::Trigger>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_spec => {
                            if !fields.insert(__FieldTag::__execution_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_spec",
                                ));
                            }
                            result.execution_spec = map.next_value::<std::option::Option<crate::model::task::ExecutionSpec>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Job {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.retry_count) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retryCount", &__With(&self.retry_count))?;
        }
        if !wkt::internal::is_default(&self.service) {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.service_job.is_empty() {
            state.serialize_entry("serviceJob", &self.service_job)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.trigger) {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if self.execution_spec.is_some() {
            state.serialize_entry("executionSpec", &self.execution_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Service {
        /// Service used to run the job is unspecified.
        Unspecified,
        /// Dataproc service is used to run this job.
        Dataproc,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Service::value] or
        /// [Service::name].
        UnknownValue(service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Service {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dataproc => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_UNSPECIFIED"),
                Self::Dataproc => std::option::Option::Some("DATAPROC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Service {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Service {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Service {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Service {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_UNSPECIFIED" => Self::Unspecified,
                "DATAPROC" => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Service {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dataproc => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Service {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Service>::new(
                ".google.cloud.dataplex.v1.Job.Service",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The job state is unknown.
        Unspecified,
        /// The job is running.
        Running,
        /// The job is cancelling.
        Cancelling,
        /// The job cancellation was successful.
        Cancelled,
        /// The job completed successfully.
        Succeeded,
        /// The job is no longer running due to an error.
        Failed,
        /// The job was cancelled outside of Dataplex.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Cancelling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Cancelling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                5 => Self::Failed,
                6 => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Cancelling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.Job.State",
            ))
        }
    }

    /// Job execution trigger.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Trigger {
        /// The trigger is unspecified.
        Unspecified,
        /// The job was triggered by Dataplex based on trigger spec from task
        /// definition.
        TaskConfig,
        /// The job was triggered by the explicit call of Task API.
        RunRequest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Trigger::value] or
        /// [Trigger::name].
        UnknownValue(trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Trigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TaskConfig => std::option::Option::Some(1),
                Self::RunRequest => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRIGGER_UNSPECIFIED"),
                Self::TaskConfig => std::option::Option::Some("TASK_CONFIG"),
                Self::RunRequest => std::option::Option::Some("RUN_REQUEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Trigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Trigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Trigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TaskConfig,
                2 => Self::RunRequest,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Trigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "TASK_CONFIG" => Self::TaskConfig,
                "RUN_REQUEST" => Self::RunRequest,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Trigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TaskConfig => serializer.serialize_i32(1),
                Self::RunRequest => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Trigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Trigger>::new(
                ".google.cloud.dataplex.v1.Job.Trigger",
            ))
        }
    }
}

/// View for controlling which parts of an entry are to be returned.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EntryView {
    /// Unspecified EntryView. Defaults to FULL.
    Unspecified,
    /// Returns entry only, without aspects.
    Basic,
    /// Returns all required aspects as well as the keys of all non-required
    /// aspects.
    Full,
    /// Returns aspects matching custom fields in GetEntryRequest. If the number of
    /// aspects exceeds 100, the first 100 will be returned.
    Custom,
    /// Returns all aspects. If the number of aspects exceeds 100, the first
    /// 100 will be returned.
    All,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EntryView::value] or
    /// [EntryView::name].
    UnknownValue(entry_view::UnknownValue),
}

#[doc(hidden)]
pub mod entry_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EntryView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::Custom => std::option::Option::Some(3),
            Self::All => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENTRY_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::Custom => std::option::Option::Some("CUSTOM"),
            Self::All => std::option::Option::Some("ALL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EntryView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EntryView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EntryView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            3 => Self::Custom,
            4 => Self::All,
            _ => Self::UnknownValue(entry_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EntryView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENTRY_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            "CUSTOM" => Self::Custom,
            "ALL" => Self::All,
            _ => Self::UnknownValue(entry_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EntryView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::Custom => serializer.serialize_i32(3),
            Self::All => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EntryView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntryView>::new(
            ".google.cloud.dataplex.v1.EntryView",
        ))
    }
}

/// Denotes the transfer status of a resource. It is unspecified for resources
/// created from Dataplex API.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransferStatus {
    /// The default value. It is set for resources that were not subject for
    /// migration from Data Catalog service.
    Unspecified,
    /// Indicates that a resource was migrated from Data Catalog service but it
    /// hasn't been transferred yet. In particular the resource cannot be updated
    /// from Dataplex API.
    Migrated,
    /// Indicates that a resource was transferred from Data Catalog service. The
    /// resource can only be updated from Dataplex API.
    Transferred,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransferStatus::value] or
    /// [TransferStatus::name].
    UnknownValue(transfer_status::UnknownValue),
}

#[doc(hidden)]
pub mod transfer_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransferStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Migrated => std::option::Option::Some(1),
            Self::Transferred => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRANSFER_STATUS_UNSPECIFIED"),
            Self::Migrated => std::option::Option::Some("TRANSFER_STATUS_MIGRATED"),
            Self::Transferred => std::option::Option::Some("TRANSFER_STATUS_TRANSFERRED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransferStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransferStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransferStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Migrated,
            2 => Self::Transferred,
            _ => Self::UnknownValue(transfer_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransferStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFER_STATUS_UNSPECIFIED" => Self::Unspecified,
            "TRANSFER_STATUS_MIGRATED" => Self::Migrated,
            "TRANSFER_STATUS_TRANSFERRED" => Self::Transferred,
            _ => Self::UnknownValue(transfer_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransferStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Migrated => serializer.serialize_i32(1),
            Self::Transferred => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransferStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransferStatus>::new(
            ".google.cloud.dataplex.v1.TransferStatus",
        ))
    }
}

/// The type of data scan.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DataScanType {
    /// The data scan type is unspecified.
    Unspecified,
    /// Data quality scan.
    DataQuality,
    /// Data profile scan.
    DataProfile,
    /// Data discovery scan.
    DataDiscovery,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DataScanType::value] or
    /// [DataScanType::name].
    UnknownValue(data_scan_type::UnknownValue),
}

#[doc(hidden)]
pub mod data_scan_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DataScanType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::DataQuality => std::option::Option::Some(1),
            Self::DataProfile => std::option::Option::Some(2),
            Self::DataDiscovery => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATA_SCAN_TYPE_UNSPECIFIED"),
            Self::DataQuality => std::option::Option::Some("DATA_QUALITY"),
            Self::DataProfile => std::option::Option::Some("DATA_PROFILE"),
            Self::DataDiscovery => std::option::Option::Some("DATA_DISCOVERY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DataScanType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DataScanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DataScanType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::DataQuality,
            2 => Self::DataProfile,
            3 => Self::DataDiscovery,
            _ => Self::UnknownValue(data_scan_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DataScanType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATA_SCAN_TYPE_UNSPECIFIED" => Self::Unspecified,
            "DATA_QUALITY" => Self::DataQuality,
            "DATA_PROFILE" => Self::DataProfile,
            "DATA_DISCOVERY" => Self::DataDiscovery,
            _ => Self::UnknownValue(data_scan_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DataScanType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::DataQuality => serializer.serialize_i32(1),
            Self::DataProfile => serializer.serialize_i32(2),
            Self::DataDiscovery => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DataScanType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataScanType>::new(
            ".google.cloud.dataplex.v1.DataScanType",
        ))
    }
}

/// Identifies the cloud system that manages the data storage.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum StorageSystem {
    /// Storage system unspecified.
    Unspecified,
    /// The entity data is contained within a Cloud Storage bucket.
    CloudStorage,
    /// The entity data is contained within a BigQuery dataset.
    Bigquery,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [StorageSystem::value] or
    /// [StorageSystem::name].
    UnknownValue(storage_system::UnknownValue),
}

#[doc(hidden)]
pub mod storage_system {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl StorageSystem {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CloudStorage => std::option::Option::Some(1),
            Self::Bigquery => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STORAGE_SYSTEM_UNSPECIFIED"),
            Self::CloudStorage => std::option::Option::Some("CLOUD_STORAGE"),
            Self::Bigquery => std::option::Option::Some("BIGQUERY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for StorageSystem {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for StorageSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for StorageSystem {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CloudStorage,
            2 => Self::Bigquery,
            _ => Self::UnknownValue(storage_system::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for StorageSystem {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STORAGE_SYSTEM_UNSPECIFIED" => Self::Unspecified,
            "CLOUD_STORAGE" => Self::CloudStorage,
            "BIGQUERY" => Self::Bigquery,
            _ => Self::UnknownValue(storage_system::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for StorageSystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CloudStorage => serializer.serialize_i32(1),
            Self::Bigquery => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for StorageSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageSystem>::new(
            ".google.cloud.dataplex.v1.StorageSystem",
        ))
    }
}

/// State of a resource.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum State {
    /// State is not specified.
    Unspecified,
    /// Resource is active, i.e., ready to use.
    Active,
    /// Resource is under creation.
    Creating,
    /// Resource is under deletion.
    Deleting,
    /// Resource is active but has unresolved actions.
    ActionRequired,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [State::value] or
    /// [State::name].
    UnknownValue(state::UnknownValue),
}

#[doc(hidden)]
pub mod state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl State {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::Creating => std::option::Option::Some(2),
            Self::Deleting => std::option::Option::Some(3),
            Self::ActionRequired => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::Creating => std::option::Option::Some("CREATING"),
            Self::Deleting => std::option::Option::Some("DELETING"),
            Self::ActionRequired => std::option::Option::Some("ACTION_REQUIRED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::Creating,
            3 => Self::Deleting,
            4 => Self::ActionRequired,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for State {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "CREATING" => Self::Creating,
            "DELETING" => Self::Deleting,
            "ACTION_REQUIRED" => Self::ActionRequired,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::Creating => serializer.serialize_i32(2),
            Self::Deleting => serializer.serialize_i32(3),
            Self::ActionRequired => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
            ".google.cloud.dataplex.v1.State",
        ))
    }
}
