// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes an API diff request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeThreatListDiffRequest {
    /// Required. The threat list to update. Only a single ThreatType should be
    /// specified per request. If you want to handle multiple ThreatTypes, you must
    /// make one request per ThreatType.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub threat_type: crate::model::ThreatType,

    /// The current version token of the client for the requested list (the
    /// client version that was received from the last successful diff).
    /// If the client does not have a version token (this is the first time calling
    /// ComputeThreatListDiff), this may be left empty and a full database
    /// snapshot will be returned.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub version_token: ::bytes::Bytes,

    /// Required. The constraints associated with this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub constraints:
        std::option::Option<crate::model::compute_threat_list_diff_request::Constraints>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat_type][crate::model::ComputeThreatListDiffRequest::threat_type].
    pub fn set_threat_type<T: std::convert::Into<crate::model::ThreatType>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_type = v.into();
        self
    }

    /// Sets the value of [version_token][crate::model::ComputeThreatListDiffRequest::version_token].
    pub fn set_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.version_token = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    pub fn set_constraints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_request::Constraints>,
    {
        self.constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    pub fn set_or_clear_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_request::Constraints>,
    {
        self.constraints = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest"
    }
}

/// Defines additional types related to [ComputeThreatListDiffRequest].
pub mod compute_threat_list_diff_request {
    #[allow(unused_imports)]
    use super::*;

    /// The constraints for this diff.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Constraints {
        /// The maximum size in number of entries. The diff will not contain more
        /// entries than this value.  This should be a power of 2 between 2**10 and
        /// 2**20.  If zero, no diff size limit is set.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub max_diff_entries: i32,

        /// Sets the maximum number of entries that the client is willing to have
        /// in the local database. This should be a power of 2 between 2**10 and
        /// 2**20. If zero, no database size limit is set.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub max_database_entries: i32,

        /// The compression types supported by the client.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub supported_compressions: std::vec::Vec<crate::model::CompressionType>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Constraints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_diff_entries][crate::model::compute_threat_list_diff_request::Constraints::max_diff_entries].
        pub fn set_max_diff_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_diff_entries = v.into();
            self
        }

        /// Sets the value of [max_database_entries][crate::model::compute_threat_list_diff_request::Constraints::max_database_entries].
        pub fn set_max_database_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_database_entries = v.into();
            self
        }

        /// Sets the value of [supported_compressions][crate::model::compute_threat_list_diff_request::Constraints::supported_compressions].
        pub fn set_supported_compressions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CompressionType>,
        {
            use std::iter::Iterator;
            self.supported_compressions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Constraints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest.Constraints"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeThreatListDiffResponse {
    /// The type of response. This may indicate that an action must be taken by the
    /// client when the response is received.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub response_type: crate::model::compute_threat_list_diff_response::ResponseType,

    /// A set of entries to add to a local threat type's list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub additions: std::option::Option<crate::model::ThreatEntryAdditions>,

    /// A set of entries to remove from a local threat type's list.
    /// This field may be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub removals: std::option::Option<crate::model::ThreatEntryRemovals>,

    /// The new opaque client version token. This should be retained by the client
    /// and passed into the next call of ComputeThreatListDiff as 'version_token'.
    /// A separate version token should be stored and used for each threatList.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub new_version_token: ::bytes::Bytes,

    /// The expected SHA256 hash of the client state; that is, of the sorted list
    /// of all hashes present in the database after applying the provided diff.
    /// If the client state doesn't match the expected state, the client must
    /// discard this diff and retry later.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub checksum: std::option::Option<crate::model::compute_threat_list_diff_response::Checksum>,

    /// The soonest the client should wait before issuing any diff
    /// request. Querying sooner is unlikely to produce a meaningful diff.
    /// Waiting longer is acceptable considering the use case.
    /// If this field is not set clients may update as soon as they want.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recommended_next_diff: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_type][crate::model::ComputeThreatListDiffResponse::response_type].
    pub fn set_response_type<
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::ResponseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    pub fn set_additions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryAdditions>,
    {
        self.additions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    pub fn set_or_clear_additions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryAdditions>,
    {
        self.additions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    pub fn set_removals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryRemovals>,
    {
        self.removals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    pub fn set_or_clear_removals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryRemovals>,
    {
        self.removals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [new_version_token][crate::model::ComputeThreatListDiffResponse::new_version_token].
    pub fn set_new_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.new_version_token = v.into();
        self
    }

    /// Sets the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    pub fn set_checksum<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::Checksum>,
    {
        self.checksum = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    pub fn set_or_clear_checksum<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::Checksum>,
    {
        self.checksum = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    pub fn set_recommended_next_diff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recommended_next_diff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    pub fn set_or_clear_recommended_next_diff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recommended_next_diff = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse"
    }
}

/// Defines additional types related to [ComputeThreatListDiffResponse].
pub mod compute_threat_list_diff_response {
    #[allow(unused_imports)]
    use super::*;

    /// The expected state of a client's local database.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Checksum {
        /// The SHA256 hash of the client state; that is, of the sorted list of all
        /// hashes present in the database.
        #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub sha256: ::bytes::Bytes,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Checksum {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sha256][crate::model::compute_threat_list_diff_response::Checksum::sha256].
        pub fn set_sha256<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for Checksum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse.Checksum"
        }
    }

    /// The type of response sent to the client.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResponseType {
        /// Unknown.
        Unspecified,
        /// Partial updates are applied to the client's existing local database.
        Diff,
        /// Full updates resets the client's entire local database. This means
        /// that either the client had no state, was seriously out-of-date,
        /// or the client is believed to be corrupt.
        Reset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResponseType::value] or
        /// [ResponseType::name].
        UnknownValue(response_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod response_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResponseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Diff => std::option::Option::Some(1),
                Self::Reset => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESPONSE_TYPE_UNSPECIFIED"),
                Self::Diff => std::option::Option::Some("DIFF"),
                Self::Reset => std::option::Option::Some("RESET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResponseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResponseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResponseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Diff,
                2 => Self::Reset,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResponseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESPONSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DIFF" => Self::Diff,
                "RESET" => Self::Reset,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResponseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Diff => serializer.serialize_i32(1),
                Self::Reset => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResponseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResponseType>::new(
                ".google.cloud.webrisk.v1.ComputeThreatListDiffResponse.ResponseType",
            ))
        }
    }
}

/// Request to check URI entries against threatLists.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchUrisRequest {
    /// Required. The URI to be checked for matches.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::SearchUrisRequest::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchUrisRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchUrisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchUrisResponse {
    /// The threat list matches. This might be empty if the URI is on no list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat: std::option::Option<crate::model::search_uris_response::ThreatUri>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat][crate::model::SearchUrisResponse::threat].
    pub fn set_threat<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_uris_response::ThreatUri>,
    {
        self.threat = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat][crate::model::SearchUrisResponse::threat].
    pub fn set_or_clear_threat<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_uris_response::ThreatUri>,
    {
        self.threat = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchUrisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse"
    }
}

/// Defines additional types related to [SearchUrisResponse].
pub mod search_uris_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching uri.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatUri {
        /// The ThreatList this threat belongs to.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub expire_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatUri {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threat_types][crate::model::search_uris_response::ThreatUri::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        pub fn set_expire_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ThreatUri {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse.ThreatUri"
        }
    }
}

/// Request to return full hashes matched by the provided hash prefixes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchHashesRequest {
    /// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
    /// hash. For JSON requests, this field is base64-encoded.
    /// Note that if this parameter is provided by a URI, it must be encoded using
    /// the web safe base64 variant (RFC 4648).
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub hash_prefix: ::bytes::Bytes,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hash_prefix][crate::model::SearchHashesRequest::hash_prefix].
    pub fn set_hash_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hash_prefix = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchHashesRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchHashesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchHashesResponse {
    /// The full hashes that matched the requested prefixes.
    /// The hash will be populated in the key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threats: std::vec::Vec<crate::model::search_hashes_response::ThreatHash>,

    /// For requested entities that did not match the threat list, how long to
    /// cache the response until.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub negative_expire_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threats][crate::model::SearchHashesResponse::threats].
    pub fn set_threats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_hashes_response::ThreatHash>,
    {
        use std::iter::Iterator;
        self.threats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    pub fn set_negative_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.negative_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    pub fn set_or_clear_negative_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.negative_expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchHashesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse"
    }
}

/// Defines additional types related to [SearchHashesResponse].
pub mod search_hashes_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching hash.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatHash {
        /// The ThreatList this threat belongs to.
        /// This must contain at least one entry.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// A 32 byte SHA256 hash. This field is in binary format. For JSON
        /// requests, hashes are base64-encoded.
        #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub hash: ::bytes::Bytes,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub expire_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatHash {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threat_types][crate::model::search_hashes_response::ThreatHash::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [hash][crate::model::search_hashes_response::ThreatHash::hash].
        pub fn set_hash<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.hash = v.into();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        pub fn set_expire_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ThreatHash {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse.ThreatHash"
        }
    }
}

/// Contains the set of entries to add to a local database.
/// May contain a combination of compressed and raw data in a single response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatEntryAdditions {
    /// The raw SHA256-formatted entries.
    /// Repeated to allow returning sets of hashes with different prefix sizes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub raw_hashes: std::vec::Vec<crate::model::RawHashes>,

    /// The encoded 4-byte prefixes of SHA256-formatted entries, using a
    /// Golomb-Rice encoding. The hashes are converted to uint32, sorted in
    /// ascending order, then delta encoded and stored as encoded_data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rice_hashes: std::option::Option<crate::model::RiceDeltaEncoding>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryAdditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_hashes][crate::model::ThreatEntryAdditions::raw_hashes].
    pub fn set_raw_hashes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RawHashes>,
    {
        use std::iter::Iterator;
        self.raw_hashes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    pub fn set_rice_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    pub fn set_or_clear_rice_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_hashes = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatEntryAdditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryAdditions"
    }
}

/// Contains the set of entries to remove from a local database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatEntryRemovals {
    /// The raw removal indices for a local list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub raw_indices: std::option::Option<crate::model::RawIndices>,

    /// The encoded local, lexicographically-sorted list indices, using a
    /// Golomb-Rice encoding. Used for sending compressed removal indices. The
    /// removal indices (uint32) are sorted in ascending order, then delta encoded
    /// and stored as encoded_data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rice_indices: std::option::Option<crate::model::RiceDeltaEncoding>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryRemovals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    pub fn set_raw_indices<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RawIndices>,
    {
        self.raw_indices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    pub fn set_or_clear_raw_indices<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RawIndices>,
    {
        self.raw_indices = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    pub fn set_rice_indices<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_indices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    pub fn set_or_clear_rice_indices<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_indices = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatEntryRemovals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryRemovals"
    }
}

/// A set of raw indices to remove from a local list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawIndices {
    /// The indices to remove from a lexicographically-sorted local list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<wkt::internal::I32>")]
    pub indices: std::vec::Vec<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawIndices {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indices][crate::model::RawIndices::indices].
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RawIndices {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawIndices"
    }
}

/// The uncompressed threat entries in hash format.
/// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
/// bytes, but some hashes are lengthened if they collide with the hash of a
/// popular URI.
///
/// Used for sending ThreatEntryAdditons to clients that do not support
/// compression, or when sending non-4-byte hashes to clients that do support
/// compression.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawHashes {
    /// The number of bytes for each prefix encoded below.  This field can be
    /// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
    /// In practice this is almost always 4, except in exceptional circumstances.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub prefix_size: i32,

    /// The hashes, in binary format, concatenated into one long string. Hashes are
    /// sorted in lexicographic order. For JSON API users, hashes are
    /// base64-encoded.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub raw_hashes: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prefix_size][crate::model::RawHashes::prefix_size].
    pub fn set_prefix_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.prefix_size = v.into();
        self
    }

    /// Sets the value of [raw_hashes][crate::model::RawHashes::raw_hashes].
    pub fn set_raw_hashes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_hashes = v.into();
        self
    }
}

impl wkt::message::Message for RawHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawHashes"
    }
}

/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
/// compressed removal indices.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RiceDeltaEncoding {
    /// The offset of the first entry in the encoded data, or, if only a single
    /// integer was encoded, that single integer's value. If the field is empty or
    /// missing, assume zero.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub first_value: i64,

    /// The Golomb-Rice parameter, which is a number between 2 and 28. This field
    /// is missing (that is, zero) if `num_entries` is zero.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub rice_parameter: i32,

    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub entry_count: i32,

    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub encoded_data: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiceDeltaEncoding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_value][crate::model::RiceDeltaEncoding::first_value].
    pub fn set_first_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.first_value = v.into();
        self
    }

    /// Sets the value of [rice_parameter][crate::model::RiceDeltaEncoding::rice_parameter].
    pub fn set_rice_parameter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rice_parameter = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::RiceDeltaEncoding::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [encoded_data][crate::model::RiceDeltaEncoding::encoded_data].
    pub fn set_encoded_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.encoded_data = v.into();
        self
    }
}

impl wkt::message::Message for RiceDeltaEncoding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RiceDeltaEncoding"
    }
}

/// Wraps a URI that might be displaying malicious content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Submission {
    /// Required. The URI that is being reported for malicious content to be
    /// analyzed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Output only. ThreatTypes found to be associated with the submitted URI
    /// after reviewing it. This might be empty if the URI was not added to any
    /// list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Submission {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::Submission::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::Submission::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Submission {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.Submission"
    }
}

/// Context about the submission including the type of abuse found on the URI and
/// supporting details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatInfo {
    /// The type of abuse.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub abuse_type: crate::model::threat_info::AbuseType,

    /// Confidence that the URI is unsafe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_confidence: std::option::Option<crate::model::threat_info::Confidence>,

    /// Context about why the URI is unsafe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_justification: std::option::Option<crate::model::threat_info::ThreatJustification>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [abuse_type][crate::model::ThreatInfo::abuse_type].
    pub fn set_abuse_type<T: std::convert::Into<crate::model::threat_info::AbuseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.abuse_type = v.into();
        self
    }

    /// Sets the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    pub fn set_threat_confidence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::Confidence>,
    {
        self.threat_confidence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    pub fn set_or_clear_threat_confidence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::Confidence>,
    {
        self.threat_confidence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    pub fn set_threat_justification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::ThreatJustification>,
    {
        self.threat_justification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    pub fn set_or_clear_threat_justification<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::ThreatJustification>,
    {
        self.threat_justification = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo"
    }
}

/// Defines additional types related to [ThreatInfo].
pub mod threat_info {
    #[allow(unused_imports)]
    use super::*;

    /// Confidence that a URI is unsafe.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Confidence {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::threat_info::confidence::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Confidence {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::threat_info::confidence::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Score`, `None` if the field is not set or
        /// holds a different branch.
        pub fn score(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Score(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Score`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Score(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Level`, `None` if the field is not set or
        /// holds a different branch.
        pub fn level(
            &self,
        ) -> std::option::Option<&crate::model::threat_info::confidence::ConfidenceLevel> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Level(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Level`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_level<
            T: std::convert::Into<crate::model::threat_info::confidence::ConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Level(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Confidence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.Confidence"
        }
    }

    /// Defines additional types related to [Confidence].
    pub mod confidence {
        #[allow(unused_imports)]
        use super::*;

        /// Enum representation of confidence.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ConfidenceLevel {
            /// Default.
            Unspecified,
            /// Less than 60% confidence that the URI is unsafe.
            Low,
            /// Between 60% and 80% confidence that the URI is unsafe.
            Medium,
            /// Greater than 80% confidence that the URI is unsafe.
            High,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ConfidenceLevel::value] or
            /// [ConfidenceLevel::name].
            UnknownValue(confidence_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod confidence_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ConfidenceLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Low => std::option::Option::Some(1),
                    Self::Medium => std::option::Option::Some(2),
                    Self::High => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CONFIDENCE_LEVEL_UNSPECIFIED"),
                    Self::Low => std::option::Option::Some("LOW"),
                    Self::Medium => std::option::Option::Some("MEDIUM"),
                    Self::High => std::option::Option::Some("HIGH"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ConfidenceLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ConfidenceLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ConfidenceLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Low,
                    2 => Self::Medium,
                    3 => Self::High,
                    _ => Self::UnknownValue(confidence_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ConfidenceLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONFIDENCE_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "LOW" => Self::Low,
                    "MEDIUM" => Self::Medium,
                    "HIGH" => Self::High,
                    _ => Self::UnknownValue(confidence_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ConfidenceLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Low => serializer.serialize_i32(1),
                    Self::Medium => serializer.serialize_i32(2),
                    Self::High => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ConfidenceLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConfidenceLevel>::new(
                    ".google.cloud.webrisk.v1.ThreatInfo.Confidence.ConfidenceLevel",
                ))
            }
        }

        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// A decimal representation of confidence in the range of 0
            /// to 1 where 0 indicates no confidence and 1 indicates
            /// complete confidence.
            Score(#[serde_as(as = "wkt::internal::F32")] f32),
            /// Enum representation of confidence.
            Level(crate::model::threat_info::confidence::ConfidenceLevel),
        }
    }

    /// Context about why the URI is unsafe.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatJustification {
        /// Labels associated with this URI that explain how it was classified.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub labels:
            std::vec::Vec<crate::model::threat_info::threat_justification::JustificationLabel>,

        /// Free-form context on why this URI is unsafe.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub comments: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatJustification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::threat_info::ThreatJustification::labels].
        pub fn set_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::threat_info::threat_justification::JustificationLabel,
                >,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [comments][crate::model::threat_info::ThreatJustification::comments].
        pub fn set_comments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.comments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatJustification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.ThreatJustification"
        }
    }

    /// Defines additional types related to [ThreatJustification].
    pub mod threat_justification {
        #[allow(unused_imports)]
        use super::*;

        /// Labels that explain how the URI was classified.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum JustificationLabel {
            /// Default.
            Unspecified,
            /// The submitter manually verified that the submission is unsafe.
            ManualVerification,
            /// The submitter received the submission from an end user.
            UserReport,
            /// The submitter received the submission from an automated system.
            AutomatedReport,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [JustificationLabel::value] or
            /// [JustificationLabel::name].
            UnknownValue(justification_label::UnknownValue),
        }

        #[doc(hidden)]
        pub mod justification_label {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl JustificationLabel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ManualVerification => std::option::Option::Some(1),
                    Self::UserReport => std::option::Option::Some(2),
                    Self::AutomatedReport => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("JUSTIFICATION_LABEL_UNSPECIFIED")
                    }
                    Self::ManualVerification => std::option::Option::Some("MANUAL_VERIFICATION"),
                    Self::UserReport => std::option::Option::Some("USER_REPORT"),
                    Self::AutomatedReport => std::option::Option::Some("AUTOMATED_REPORT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for JustificationLabel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for JustificationLabel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for JustificationLabel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ManualVerification,
                    2 => Self::UserReport,
                    3 => Self::AutomatedReport,
                    _ => Self::UnknownValue(justification_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for JustificationLabel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "JUSTIFICATION_LABEL_UNSPECIFIED" => Self::Unspecified,
                    "MANUAL_VERIFICATION" => Self::ManualVerification,
                    "USER_REPORT" => Self::UserReport,
                    "AUTOMATED_REPORT" => Self::AutomatedReport,
                    _ => Self::UnknownValue(justification_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for JustificationLabel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ManualVerification => serializer.serialize_i32(1),
                    Self::UserReport => serializer.serialize_i32(2),
                    Self::AutomatedReport => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for JustificationLabel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<JustificationLabel>::new(
                    ".google.cloud.webrisk.v1.ThreatInfo.ThreatJustification.JustificationLabel",
                ))
            }
        }
    }

    /// The abuse type found on the URI.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AbuseType {
        /// Default.
        Unspecified,
        /// The URI contains malware.
        Malware,
        /// The URI contains social engineering.
        SocialEngineering,
        /// The URI contains unwanted software.
        UnwantedSoftware,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AbuseType::value] or
        /// [AbuseType::name].
        UnknownValue(abuse_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod abuse_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AbuseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Malware => std::option::Option::Some(1),
                Self::SocialEngineering => std::option::Option::Some(2),
                Self::UnwantedSoftware => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ABUSE_TYPE_UNSPECIFIED"),
                Self::Malware => std::option::Option::Some("MALWARE"),
                Self::SocialEngineering => std::option::Option::Some("SOCIAL_ENGINEERING"),
                Self::UnwantedSoftware => std::option::Option::Some("UNWANTED_SOFTWARE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AbuseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AbuseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AbuseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Malware,
                2 => Self::SocialEngineering,
                3 => Self::UnwantedSoftware,
                _ => Self::UnknownValue(abuse_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AbuseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ABUSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MALWARE" => Self::Malware,
                "SOCIAL_ENGINEERING" => Self::SocialEngineering,
                "UNWANTED_SOFTWARE" => Self::UnwantedSoftware,
                _ => Self::UnknownValue(abuse_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AbuseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Malware => serializer.serialize_i32(1),
                Self::SocialEngineering => serializer.serialize_i32(2),
                Self::UnwantedSoftware => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AbuseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AbuseType>::new(
                ".google.cloud.webrisk.v1.ThreatInfo.AbuseType",
            ))
        }
    }
}

/// Details about how the threat was discovered.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatDiscovery {
    /// Platform on which the threat was discovered.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub platform: crate::model::threat_discovery::Platform,

    /// CLDR region code of the countries/regions the URI poses a threat ordered
    /// from most impact to least impact. Example: "US" for United States.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub region_codes: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatDiscovery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [platform][crate::model::ThreatDiscovery::platform].
    pub fn set_platform<T: std::convert::Into<crate::model::threat_discovery::Platform>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [region_codes][crate::model::ThreatDiscovery::region_codes].
    pub fn set_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ThreatDiscovery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatDiscovery"
    }
}

/// Defines additional types related to [ThreatDiscovery].
pub mod threat_discovery {
    #[allow(unused_imports)]
    use super::*;

    /// Platform types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Platform {
        /// Default.
        Unspecified,
        /// General Android platform.
        Android,
        /// General iOS platform.
        Ios,
        /// General macOS platform.
        Macos,
        /// General Windows platform.
        Windows,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Platform::value] or
        /// [Platform::name].
        UnknownValue(platform::UnknownValue),
    }

    #[doc(hidden)]
    pub mod platform {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Platform {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Android => std::option::Option::Some(1),
                Self::Ios => std::option::Option::Some(2),
                Self::Macos => std::option::Option::Some(3),
                Self::Windows => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PLATFORM_UNSPECIFIED"),
                Self::Android => std::option::Option::Some("ANDROID"),
                Self::Ios => std::option::Option::Some("IOS"),
                Self::Macos => std::option::Option::Some("MACOS"),
                Self::Windows => std::option::Option::Some("WINDOWS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Platform {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Platform {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Platform {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Android,
                2 => Self::Ios,
                3 => Self::Macos,
                4 => Self::Windows,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Platform {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLATFORM_UNSPECIFIED" => Self::Unspecified,
                "ANDROID" => Self::Android,
                "IOS" => Self::Ios,
                "MACOS" => Self::Macos,
                "WINDOWS" => Self::Windows,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Platform {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Android => serializer.serialize_i32(1),
                Self::Ios => serializer.serialize_i32(2),
                Self::Macos => serializer.serialize_i32(3),
                Self::Windows => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Platform {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Platform>::new(
                ".google.cloud.webrisk.v1.ThreatDiscovery.Platform",
            ))
        }
    }
}

/// Request to send a potentially phishy URI to WebRisk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSubmissionRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The submission that contains the content of the phishing report.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submission: std::option::Option<crate::model::Submission>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSubmissionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSubmissionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::CreateSubmissionRequest::submission].
    pub fn set_submission<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submission][crate::model::CreateSubmissionRequest::submission].
    pub fn set_or_clear_submission<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSubmissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.CreateSubmissionRequest"
    }
}

/// Request to send a potentially malicious URI to WebRisk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitUriRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The submission that contains the URI to be scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submission: std::option::Option<crate::model::Submission>,

    /// Provides additional information about the submission.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_info: std::option::Option<crate::model::ThreatInfo>,

    /// Provides additional information about how the submission was discovered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_discovery: std::option::Option<crate::model::ThreatDiscovery>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitUriRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::SubmitUriRequest::submission].
    pub fn set_submission<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submission][crate::model::SubmitUriRequest::submission].
    pub fn set_or_clear_submission<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    pub fn set_threat_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatInfo>,
    {
        self.threat_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    pub fn set_or_clear_threat_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatInfo>,
    {
        self.threat_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    pub fn set_threat_discovery<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatDiscovery>,
    {
        self.threat_discovery = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    pub fn set_or_clear_threat_discovery<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatDiscovery>,
    {
        self.threat_discovery = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitUriRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriRequest"
    }
}

/// Metadata for the Submit URI long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitUriMetadata {
    /// The state of the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::submit_uri_metadata::State,

    /// Creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Latest update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::SubmitUriMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::submit_uri_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitUriMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriMetadata"
    }
}

/// Defines additional types related to [SubmitUriMetadata].
pub mod submit_uri_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the state of the long-running operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified state.
        Unspecified,
        /// The operation is currently running.
        Running,
        /// The operation finished with a success status.
        Succeeded,
        /// The operation was cancelled.
        Cancelled,
        /// The operation finished with a failure status.
        Failed,
        /// The operation was closed with no action taken.
        Closed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Closed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Closed => std::option::Option::Some("CLOSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Cancelled,
                4 => Self::Failed,
                5 => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "CLOSED" => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Closed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.webrisk.v1.SubmitUriMetadata.State",
            ))
        }
    }
}

/// The type of threat. This maps directly to the threat list a threat may
/// belong to.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ThreatType {
    /// No entries should match this threat type. This threat type is unused.
    Unspecified,
    /// Malware targeting any platform.
    Malware,
    /// Social engineering targeting any platform.
    SocialEngineering,
    /// Unwanted software targeting any platform.
    UnwantedSoftware,
    /// A list of extended coverage social engineering URIs targeting any
    /// platform.
    SocialEngineeringExtendedCoverage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ThreatType::value] or
    /// [ThreatType::name].
    UnknownValue(threat_type::UnknownValue),
}

#[doc(hidden)]
pub mod threat_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ThreatType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Malware => std::option::Option::Some(1),
            Self::SocialEngineering => std::option::Option::Some(2),
            Self::UnwantedSoftware => std::option::Option::Some(3),
            Self::SocialEngineeringExtendedCoverage => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("THREAT_TYPE_UNSPECIFIED"),
            Self::Malware => std::option::Option::Some("MALWARE"),
            Self::SocialEngineering => std::option::Option::Some("SOCIAL_ENGINEERING"),
            Self::UnwantedSoftware => std::option::Option::Some("UNWANTED_SOFTWARE"),
            Self::SocialEngineeringExtendedCoverage => {
                std::option::Option::Some("SOCIAL_ENGINEERING_EXTENDED_COVERAGE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ThreatType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ThreatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ThreatType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Malware,
            2 => Self::SocialEngineering,
            3 => Self::UnwantedSoftware,
            4 => Self::SocialEngineeringExtendedCoverage,
            _ => Self::UnknownValue(threat_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ThreatType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "THREAT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "MALWARE" => Self::Malware,
            "SOCIAL_ENGINEERING" => Self::SocialEngineering,
            "UNWANTED_SOFTWARE" => Self::UnwantedSoftware,
            "SOCIAL_ENGINEERING_EXTENDED_COVERAGE" => Self::SocialEngineeringExtendedCoverage,
            _ => Self::UnknownValue(threat_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ThreatType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Malware => serializer.serialize_i32(1),
            Self::SocialEngineering => serializer.serialize_i32(2),
            Self::UnwantedSoftware => serializer.serialize_i32(3),
            Self::SocialEngineeringExtendedCoverage => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ThreatType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ThreatType>::new(
            ".google.cloud.webrisk.v1.ThreatType",
        ))
    }
}

/// The ways in which threat entry sets can be compressed.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CompressionType {
    /// Unknown.
    Unspecified,
    /// Raw, uncompressed data.
    Raw,
    /// Rice-Golomb encoded data.
    Rice,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CompressionType::value] or
    /// [CompressionType::name].
    UnknownValue(compression_type::UnknownValue),
}

#[doc(hidden)]
pub mod compression_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CompressionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Raw => std::option::Option::Some(1),
            Self::Rice => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPRESSION_TYPE_UNSPECIFIED"),
            Self::Raw => std::option::Option::Some("RAW"),
            Self::Rice => std::option::Option::Some("RICE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CompressionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CompressionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CompressionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Raw,
            2 => Self::Rice,
            _ => Self::UnknownValue(compression_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CompressionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPRESSION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RAW" => Self::Raw,
            "RICE" => Self::Rice,
            _ => Self::UnknownValue(compression_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CompressionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Raw => serializer.serialize_i32(1),
            Self::Rice => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CompressionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompressionType>::new(
            ".google.cloud.webrisk.v1.CompressionType",
        ))
    }
}
