// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::invalid_html_tags)]
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes an API diff request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeThreatListDiffRequest {
    /// Required. The threat list to update. Only a single ThreatType should be
    /// specified per request. If you want to handle multiple ThreatTypes, you must
    /// make one request per ThreatType.
    pub threat_type: crate::model::ThreatType,

    /// The current version token of the client for the requested list (the
    /// client version that was received from the last successful diff).
    /// If the client does not have a version token (this is the first time calling
    /// ComputeThreatListDiff), this may be left empty and a full database
    /// snapshot will be returned.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub version_token: bytes::Bytes,

    /// Required. The constraints associated with this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub constraints:
        std::option::Option<crate::model::compute_threat_list_diff_request::Constraints>,
}

impl ComputeThreatListDiffRequest {
    /// Sets the value of [threat_type][crate::model::ComputeThreatListDiffRequest::threat_type].
    pub fn set_threat_type<T: std::convert::Into<crate::model::ThreatType>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_type = v.into();
        self
    }

    /// Sets the value of [version_token][crate::model::ComputeThreatListDiffRequest::version_token].
    pub fn set_version_token<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.version_token = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    pub fn set_constraints<
        T: std::convert::Into<
            std::option::Option<crate::model::compute_threat_list_diff_request::Constraints>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraints = v.into();
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest"
    }
}

/// Defines additional types related to ComputeThreatListDiffRequest
pub mod compute_threat_list_diff_request {
    #[allow(unused_imports)]
    use super::*;

    /// The constraints for this diff.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Constraints {
        /// The maximum size in number of entries. The diff will not contain more
        /// entries than this value.  This should be a power of 2 between 2**10 and
        /// 2**20.  If zero, no diff size limit is set.
        pub max_diff_entries: i32,

        /// Sets the maximum number of entries that the client is willing to have
        /// in the local database. This should be a power of 2 between 2**10 and
        /// 2**20. If zero, no database size limit is set.
        pub max_database_entries: i32,

        /// The compression types supported by the client.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub supported_compressions: std::vec::Vec<crate::model::CompressionType>,
    }

    impl Constraints {
        /// Sets the value of [max_diff_entries][crate::model::compute_threat_list_diff_request::Constraints::max_diff_entries].
        pub fn set_max_diff_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_diff_entries = v.into();
            self
        }

        /// Sets the value of [max_database_entries][crate::model::compute_threat_list_diff_request::Constraints::max_database_entries].
        pub fn set_max_database_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_database_entries = v.into();
            self
        }

        /// Sets the value of [supported_compressions][crate::model::compute_threat_list_diff_request::Constraints::supported_compressions].
        pub fn set_supported_compressions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CompressionType>,
        {
            use std::iter::Iterator;
            self.supported_compressions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Constraints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest.Constraints"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeThreatListDiffResponse {
    /// The type of response. This may indicate that an action must be taken by the
    /// client when the response is received.
    pub response_type: crate::model::compute_threat_list_diff_response::ResponseType,

    /// A set of entries to add to a local threat type's list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub additions: std::option::Option<crate::model::ThreatEntryAdditions>,

    /// A set of entries to remove from a local threat type's list.
    /// This field may be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub removals: std::option::Option<crate::model::ThreatEntryRemovals>,

    /// The new opaque client version token. This should be retained by the client
    /// and passed into the next call of ComputeThreatListDiff as 'version_token'.
    /// A separate version token should be stored and used for each threatList.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub new_version_token: bytes::Bytes,

    /// The expected SHA256 hash of the client state; that is, of the sorted list
    /// of all hashes present in the database after applying the provided diff.
    /// If the client state doesn't match the expected state, the client must
    /// discard this diff and retry later.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub checksum: std::option::Option<crate::model::compute_threat_list_diff_response::Checksum>,

    /// The soonest the client should wait before issuing any diff
    /// request. Querying sooner is unlikely to produce a meaningful diff.
    /// Waiting longer is acceptable considering the use case.
    /// If this field is not set clients may update as soon as they want.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recommended_next_diff: std::option::Option<wkt::Timestamp>,
}

impl ComputeThreatListDiffResponse {
    /// Sets the value of [response_type][crate::model::ComputeThreatListDiffResponse::response_type].
    pub fn set_response_type<
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::ResponseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    pub fn set_additions<
        T: std::convert::Into<std::option::Option<crate::model::ThreatEntryAdditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additions = v.into();
        self
    }

    /// Sets the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    pub fn set_removals<
        T: std::convert::Into<std::option::Option<crate::model::ThreatEntryRemovals>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.removals = v.into();
        self
    }

    /// Sets the value of [new_version_token][crate::model::ComputeThreatListDiffResponse::new_version_token].
    pub fn set_new_version_token<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.new_version_token = v.into();
        self
    }

    /// Sets the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    pub fn set_checksum<
        T: std::convert::Into<
            std::option::Option<crate::model::compute_threat_list_diff_response::Checksum>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.checksum = v.into();
        self
    }

    /// Sets the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    pub fn set_recommended_next_diff<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_next_diff = v.into();
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse"
    }
}

/// Defines additional types related to ComputeThreatListDiffResponse
pub mod compute_threat_list_diff_response {
    #[allow(unused_imports)]
    use super::*;

    /// The expected state of a client's local database.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Checksum {
        /// The SHA256 hash of the client state; that is, of the sorted list of all
        /// hashes present in the database.
        #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub sha256: bytes::Bytes,
    }

    impl Checksum {
        /// Sets the value of [sha256][crate::model::compute_threat_list_diff_response::Checksum::sha256].
        pub fn set_sha256<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
            self.sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for Checksum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse.Checksum"
        }
    }

    /// The type of response sent to the client.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ResponseType(std::string::String);

    impl ResponseType {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ResponseType](ResponseType)
    pub mod response_type {

        /// Unknown.
        pub const RESPONSE_TYPE_UNSPECIFIED: &str = "RESPONSE_TYPE_UNSPECIFIED";

        /// Partial updates are applied to the client's existing local database.
        pub const DIFF: &str = "DIFF";

        /// Full updates resets the client's entire local database. This means
        /// that either the client had no state, was seriously out-of-date,
        /// or the client is believed to be corrupt.
        pub const RESET: &str = "RESET";
    }
}

/// Request to check URI entries against threatLists.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchUrisRequest {
    /// Required. The URI to be checked for matches.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,
}

impl SearchUrisRequest {
    /// Sets the value of [uri][crate::model::SearchUrisRequest::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchUrisRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchUrisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchUrisResponse {
    /// The threat list matches. This might be empty if the URI is on no list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat: std::option::Option<crate::model::search_uris_response::ThreatUri>,
}

impl SearchUrisResponse {
    /// Sets the value of [threat][crate::model::SearchUrisResponse::threat].
    pub fn set_threat<
        T: std::convert::Into<std::option::Option<crate::model::search_uris_response::ThreatUri>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat = v.into();
        self
    }
}

impl wkt::message::Message for SearchUrisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse"
    }
}

/// Defines additional types related to SearchUrisResponse
pub mod search_uris_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching uri.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatUri {
        /// The ThreatList this threat belongs to.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub expire_time: std::option::Option<wkt::Timestamp>,
    }

    impl ThreatUri {
        /// Sets the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.expire_time = v.into();
            self
        }

        /// Sets the value of [threat_types][crate::model::search_uris_response::ThreatUri::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatUri {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse.ThreatUri"
        }
    }
}

/// Request to return full hashes matched by the provided hash prefixes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchHashesRequest {
    /// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
    /// hash. For JSON requests, this field is base64-encoded.
    /// Note that if this parameter is provided by a URI, it must be encoded using
    /// the web safe base64 variant (RFC 4648).
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub hash_prefix: bytes::Bytes,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,
}

impl SearchHashesRequest {
    /// Sets the value of [hash_prefix][crate::model::SearchHashesRequest::hash_prefix].
    pub fn set_hash_prefix<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.hash_prefix = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchHashesRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchHashesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchHashesResponse {
    /// The full hashes that matched the requested prefixes.
    /// The hash will be populated in the key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threats: std::vec::Vec<crate::model::search_hashes_response::ThreatHash>,

    /// For requested entities that did not match the threat list, how long to
    /// cache the response until.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub negative_expire_time: std::option::Option<wkt::Timestamp>,
}

impl SearchHashesResponse {
    /// Sets the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    pub fn set_negative_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.negative_expire_time = v.into();
        self
    }

    /// Sets the value of [threats][crate::model::SearchHashesResponse::threats].
    pub fn set_threats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_hashes_response::ThreatHash>,
    {
        use std::iter::Iterator;
        self.threats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchHashesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse"
    }
}

/// Defines additional types related to SearchHashesResponse
pub mod search_hashes_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching hash.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatHash {
        /// The ThreatList this threat belongs to.
        /// This must contain at least one entry.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// A 32 byte SHA256 hash. This field is in binary format. For JSON
        /// requests, hashes are base64-encoded.
        #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub hash: bytes::Bytes,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub expire_time: std::option::Option<wkt::Timestamp>,
    }

    impl ThreatHash {
        /// Sets the value of [hash][crate::model::search_hashes_response::ThreatHash::hash].
        pub fn set_hash<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
            self.hash = v.into();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.expire_time = v.into();
            self
        }

        /// Sets the value of [threat_types][crate::model::search_hashes_response::ThreatHash::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatHash {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse.ThreatHash"
        }
    }
}

/// Contains the set of entries to add to a local database.
/// May contain a combination of compressed and raw data in a single response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatEntryAdditions {
    /// The raw SHA256-formatted entries.
    /// Repeated to allow returning sets of hashes with different prefix sizes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub raw_hashes: std::vec::Vec<crate::model::RawHashes>,

    /// The encoded 4-byte prefixes of SHA256-formatted entries, using a
    /// Golomb-Rice encoding. The hashes are converted to uint32, sorted in
    /// ascending order, then delta encoded and stored as encoded_data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rice_hashes: std::option::Option<crate::model::RiceDeltaEncoding>,
}

impl ThreatEntryAdditions {
    /// Sets the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    pub fn set_rice_hashes<
        T: std::convert::Into<std::option::Option<crate::model::RiceDeltaEncoding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rice_hashes = v.into();
        self
    }

    /// Sets the value of [raw_hashes][crate::model::ThreatEntryAdditions::raw_hashes].
    pub fn set_raw_hashes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RawHashes>,
    {
        use std::iter::Iterator;
        self.raw_hashes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ThreatEntryAdditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryAdditions"
    }
}

/// Contains the set of entries to remove from a local database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatEntryRemovals {
    /// The raw removal indices for a local list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub raw_indices: std::option::Option<crate::model::RawIndices>,

    /// The encoded local, lexicographically-sorted list indices, using a
    /// Golomb-Rice encoding. Used for sending compressed removal indices. The
    /// removal indices (uint32) are sorted in ascending order, then delta encoded
    /// and stored as encoded_data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rice_indices: std::option::Option<crate::model::RiceDeltaEncoding>,
}

impl ThreatEntryRemovals {
    /// Sets the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    pub fn set_raw_indices<T: std::convert::Into<std::option::Option<crate::model::RawIndices>>>(
        mut self,
        v: T,
    ) -> Self {
        self.raw_indices = v.into();
        self
    }

    /// Sets the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    pub fn set_rice_indices<
        T: std::convert::Into<std::option::Option<crate::model::RiceDeltaEncoding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rice_indices = v.into();
        self
    }
}

impl wkt::message::Message for ThreatEntryRemovals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryRemovals"
    }
}

/// A set of raw indices to remove from a local list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawIndices {
    /// The indices to remove from a lexicographically-sorted local list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indices: std::vec::Vec<i32>,
}

impl RawIndices {
    /// Sets the value of [indices][crate::model::RawIndices::indices].
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RawIndices {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawIndices"
    }
}

/// The uncompressed threat entries in hash format.
/// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
/// bytes, but some hashes are lengthened if they collide with the hash of a
/// popular URI.
///
/// Used for sending ThreatEntryAdditons to clients that do not support
/// compression, or when sending non-4-byte hashes to clients that do support
/// compression.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawHashes {
    /// The number of bytes for each prefix encoded below.  This field can be
    /// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
    /// In practice this is almost always 4, except in exceptional circumstances.
    pub prefix_size: i32,

    /// The hashes, in binary format, concatenated into one long string. Hashes are
    /// sorted in lexicographic order. For JSON API users, hashes are
    /// base64-encoded.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub raw_hashes: bytes::Bytes,
}

impl RawHashes {
    /// Sets the value of [prefix_size][crate::model::RawHashes::prefix_size].
    pub fn set_prefix_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.prefix_size = v.into();
        self
    }

    /// Sets the value of [raw_hashes][crate::model::RawHashes::raw_hashes].
    pub fn set_raw_hashes<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_hashes = v.into();
        self
    }
}

impl wkt::message::Message for RawHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawHashes"
    }
}

/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
/// compressed removal indices.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RiceDeltaEncoding {
    /// The offset of the first entry in the encoded data, or, if only a single
    /// integer was encoded, that single integer's value. If the field is empty or
    /// missing, assume zero.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub first_value: i64,

    /// The Golomb-Rice parameter, which is a number between 2 and 28. This field
    /// is missing (that is, zero) if `num_entries` is zero.
    pub rice_parameter: i32,

    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    pub entry_count: i32,

    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub encoded_data: bytes::Bytes,
}

impl RiceDeltaEncoding {
    /// Sets the value of [first_value][crate::model::RiceDeltaEncoding::first_value].
    pub fn set_first_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.first_value = v.into();
        self
    }

    /// Sets the value of [rice_parameter][crate::model::RiceDeltaEncoding::rice_parameter].
    pub fn set_rice_parameter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rice_parameter = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::RiceDeltaEncoding::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [encoded_data][crate::model::RiceDeltaEncoding::encoded_data].
    pub fn set_encoded_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.encoded_data = v.into();
        self
    }
}

impl wkt::message::Message for RiceDeltaEncoding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RiceDeltaEncoding"
    }
}

/// Wraps a URI that might be displaying malicious content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Submission {
    /// Required. The URI that is being reported for malicious content to be
    /// analyzed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Output only. ThreatTypes found to be associated with the submitted URI
    /// after reviewing it. This might be empty if the URI was not added to any
    /// list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,
}

impl Submission {
    /// Sets the value of [uri][crate::model::Submission::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::Submission::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Submission {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.Submission"
    }
}

/// Context about the submission including the type of abuse found on the URI and
/// supporting details.
/// option (google.api.message_visibility).restriction = "TRUSTED_TESTER";
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatInfo {
    /// The type of abuse.
    pub abuse_type: crate::model::threat_info::AbuseType,

    /// Confidence that the URI is unsafe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_confidence: std::option::Option<crate::model::threat_info::Confidence>,

    /// Context about why the URI is unsafe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_justification: std::option::Option<crate::model::threat_info::ThreatJustification>,
}

impl ThreatInfo {
    /// Sets the value of [abuse_type][crate::model::ThreatInfo::abuse_type].
    pub fn set_abuse_type<T: std::convert::Into<crate::model::threat_info::AbuseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.abuse_type = v.into();
        self
    }

    /// Sets the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    pub fn set_threat_confidence<
        T: std::convert::Into<std::option::Option<crate::model::threat_info::Confidence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat_confidence = v.into();
        self
    }

    /// Sets the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    pub fn set_threat_justification<
        T: std::convert::Into<std::option::Option<crate::model::threat_info::ThreatJustification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat_justification = v.into();
        self
    }
}

impl wkt::message::Message for ThreatInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo"
    }
}

/// Defines additional types related to ThreatInfo
pub mod threat_info {
    #[allow(unused_imports)]
    use super::*;

    /// Confidence that a URI is unsafe.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Confidence {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::threat_info::confidence::Value>,
    }

    impl Confidence {
        /// Sets the value of `value`.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::threat_info::confidence::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Confidence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.Confidence"
        }
    }

    /// Defines additional types related to Confidence
    pub mod confidence {
        #[allow(unused_imports)]
        use super::*;

        /// Enum representation of confidence.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ConfidenceLevel(std::string::String);

        impl ConfidenceLevel {
            /// Sets the enum value.
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.0 = v.into();
                self
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ConfidenceLevel](ConfidenceLevel)
        pub mod confidence_level {

            /// Default.
            pub const CONFIDENCE_LEVEL_UNSPECIFIED: &str = "CONFIDENCE_LEVEL_UNSPECIFIED";

            /// Less than 60% confidence that the URI is unsafe.
            pub const LOW: &str = "LOW";

            /// Between 60% and 80% confidence that the URI is unsafe.
            pub const MEDIUM: &str = "MEDIUM";

            /// Greater than 80% confidence that the URI is unsafe.
            pub const HIGH: &str = "HIGH";
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// A decimal representation of confidence in the range of 0
            /// to 1 where 0 indicates no confidence and 1 indicates
            /// complete confidence.
            Score(f32),
            /// Enum representation of confidence.
            Level(crate::model::threat_info::confidence::ConfidenceLevel),
        }
    }

    /// Context about why the URI is unsafe.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatJustification {
        /// Labels associated with this URI that explain how it was classified.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub labels:
            std::vec::Vec<crate::model::threat_info::threat_justification::JustificationLabel>,

        /// Free-form context on why this URI is unsafe.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub comments: std::vec::Vec<std::string::String>,
    }

    impl ThreatJustification {
        /// Sets the value of [labels][crate::model::threat_info::ThreatJustification::labels].
        pub fn set_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::threat_info::threat_justification::JustificationLabel,
            >,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [comments][crate::model::threat_info::ThreatJustification::comments].
        pub fn set_comments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.comments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatJustification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.ThreatJustification"
        }
    }

    /// Defines additional types related to ThreatJustification
    pub mod threat_justification {
        #[allow(unused_imports)]
        use super::*;

        /// Labels that explain how the URI was classified.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct JustificationLabel(std::string::String);

        impl JustificationLabel {
            /// Sets the enum value.
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.0 = v.into();
                self
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [JustificationLabel](JustificationLabel)
        pub mod justification_label {

            /// Default.
            pub const JUSTIFICATION_LABEL_UNSPECIFIED: &str = "JUSTIFICATION_LABEL_UNSPECIFIED";

            /// The submitter manually verified that the submission is unsafe.
            pub const MANUAL_VERIFICATION: &str = "MANUAL_VERIFICATION";

            /// The submitter received the submission from an end user.
            pub const USER_REPORT: &str = "USER_REPORT";

            /// The submitter received the submission from an automated system.
            pub const AUTOMATED_REPORT: &str = "AUTOMATED_REPORT";
        }
    }

    /// The abuse type found on the URI.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AbuseType(std::string::String);

    impl AbuseType {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [AbuseType](AbuseType)
    pub mod abuse_type {

        /// Default.
        pub const ABUSE_TYPE_UNSPECIFIED: &str = "ABUSE_TYPE_UNSPECIFIED";

        /// The URI contains malware.
        pub const MALWARE: &str = "MALWARE";

        /// The URI contains social engineering.
        pub const SOCIAL_ENGINEERING: &str = "SOCIAL_ENGINEERING";

        /// The URI contains unwanted software.
        pub const UNWANTED_SOFTWARE: &str = "UNWANTED_SOFTWARE";
    }
}

/// Details about how the threat was discovered.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatDiscovery {
    /// Platform on which the threat was discovered.
    pub platform: crate::model::threat_discovery::Platform,

    /// CLDR region code of the countries/regions the URI poses a threat ordered
    /// from most impact to least impact. Example: "US" for United States.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub region_codes: std::vec::Vec<std::string::String>,
}

impl ThreatDiscovery {
    /// Sets the value of [platform][crate::model::ThreatDiscovery::platform].
    pub fn set_platform<T: std::convert::Into<crate::model::threat_discovery::Platform>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [region_codes][crate::model::ThreatDiscovery::region_codes].
    pub fn set_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ThreatDiscovery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatDiscovery"
    }
}

/// Defines additional types related to ThreatDiscovery
pub mod threat_discovery {
    #[allow(unused_imports)]
    use super::*;

    /// Platform types.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Platform(std::string::String);

    impl Platform {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Platform](Platform)
    pub mod platform {

        /// Default.
        pub const PLATFORM_UNSPECIFIED: &str = "PLATFORM_UNSPECIFIED";

        /// General Android platform.
        pub const ANDROID: &str = "ANDROID";

        /// General iOS platform.
        pub const IOS: &str = "IOS";

        /// General macOS platform.
        pub const MACOS: &str = "MACOS";

        /// General Windows platform.
        pub const WINDOWS: &str = "WINDOWS";
    }
}

/// Request to send a potentially phishy URI to WebRisk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSubmissionRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The submission that contains the content of the phishing report.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submission: std::option::Option<crate::model::Submission>,
}

impl CreateSubmissionRequest {
    /// Sets the value of [parent][crate::model::CreateSubmissionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::CreateSubmissionRequest::submission].
    pub fn set_submission<T: std::convert::Into<std::option::Option<crate::model::Submission>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submission = v.into();
        self
    }
}

impl wkt::message::Message for CreateSubmissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.CreateSubmissionRequest"
    }
}

/// Request to send a potentially malicious URI to WebRisk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitUriRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The submission that contains the URI to be scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submission: std::option::Option<crate::model::Submission>,

    /// Provides additional information about the submission.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_info: std::option::Option<crate::model::ThreatInfo>,

    /// Provides additional information about how the submission was discovered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_discovery: std::option::Option<crate::model::ThreatDiscovery>,
}

impl SubmitUriRequest {
    /// Sets the value of [parent][crate::model::SubmitUriRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::SubmitUriRequest::submission].
    pub fn set_submission<T: std::convert::Into<std::option::Option<crate::model::Submission>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submission = v.into();
        self
    }

    /// Sets the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    pub fn set_threat_info<T: std::convert::Into<std::option::Option<crate::model::ThreatInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_info = v.into();
        self
    }

    /// Sets the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    pub fn set_threat_discovery<
        T: std::convert::Into<std::option::Option<crate::model::ThreatDiscovery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat_discovery = v.into();
        self
    }
}

impl wkt::message::Message for SubmitUriRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriRequest"
    }
}

/// Metadata for the Submit URI long-running operation.
/// option (google.api.message_visibility).restriction = "TRUSTED_TESTER";
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitUriMetadata {
    /// The state of the operation.
    pub state: crate::model::submit_uri_metadata::State,

    /// Creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Latest update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl SubmitUriMetadata {
    /// Sets the value of [state][crate::model::SubmitUriMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::submit_uri_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for SubmitUriMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriMetadata"
    }
}

/// Defines additional types related to SubmitUriMetadata
pub mod submit_uri_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the state of the long-running operation.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::string::String);

    impl State {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {

        /// Default unspecified state.
        pub const STATE_UNSPECIFIED: &str = "STATE_UNSPECIFIED";

        /// The operation is currently running.
        pub const RUNNING: &str = "RUNNING";

        /// The operation finished with a success status.
        pub const SUCCEEDED: &str = "SUCCEEDED";

        /// The operation was cancelled.
        pub const CANCELLED: &str = "CANCELLED";

        /// The operation finished with a failure status.
        pub const FAILED: &str = "FAILED";

        /// The operation was closed with no action taken.
        pub const CLOSED: &str = "CLOSED";
    }
}

/// The type of threat. This maps directly to the threat list a threat may
/// belong to.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ThreatType(std::string::String);

impl ThreatType {
    /// Sets the enum value.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.0 = v.into();
        self
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ThreatType](ThreatType)
pub mod threat_type {

    /// No entries should match this threat type. This threat type is unused.
    pub const THREAT_TYPE_UNSPECIFIED: &str = "THREAT_TYPE_UNSPECIFIED";

    /// Malware targeting any platform.
    pub const MALWARE: &str = "MALWARE";

    /// Social engineering targeting any platform.
    pub const SOCIAL_ENGINEERING: &str = "SOCIAL_ENGINEERING";

    /// Unwanted software targeting any platform.
    pub const UNWANTED_SOFTWARE: &str = "UNWANTED_SOFTWARE";

    /// A list of extended coverage social engineering URIs targeting any
    /// platform.
    pub const SOCIAL_ENGINEERING_EXTENDED_COVERAGE: &str = "SOCIAL_ENGINEERING_EXTENDED_COVERAGE";
}

/// The ways in which threat entry sets can be compressed.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct CompressionType(std::string::String);

impl CompressionType {
    /// Sets the enum value.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.0 = v.into();
        self
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [CompressionType](CompressionType)
pub mod compression_type {

    /// Unknown.
    pub const COMPRESSION_TYPE_UNSPECIFIED: &str = "COMPRESSION_TYPE_UNSPECIFIED";

    /// Raw, uncompressed data.
    pub const RAW: &str = "RAW";

    /// Rice-Golomb encoded data.
    pub const RICE: &str = "RICE";
}
