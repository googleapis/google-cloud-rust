// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Describes an API diff request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeThreatListDiffRequest {

    /// Required. The threat list to update. Only a single ThreatType should be
    /// specified per request. If you want to handle multiple ThreatTypes, you must
    /// make one request per ThreatType.
    pub threat_type: crate::model::ThreatType,

    /// The current version token of the client for the requested list (the
    /// client version that was received from the last successful diff).
    /// If the client does not have a version token (this is the first time calling
    /// ComputeThreatListDiff), this may be left empty and a full database
    /// snapshot will be returned.
    pub version_token: ::bytes::Bytes,

    /// Required. The constraints associated with this request.
    pub constraints: std::option::Option<crate::model::compute_threat_list_diff_request::Constraints>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat_type][crate::model::ComputeThreatListDiffRequest::threat_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffRequest;
    /// use google_cloud_webrisk_v1::model::ThreatType;
    /// let x0 = ComputeThreatListDiffRequest::new().set_threat_type(ThreatType::Malware);
    /// let x1 = ComputeThreatListDiffRequest::new().set_threat_type(ThreatType::SocialEngineering);
    /// let x2 = ComputeThreatListDiffRequest::new().set_threat_type(ThreatType::UnwantedSoftware);
    /// ```
    pub fn set_threat_type<T: std::convert::Into<crate::model::ThreatType>>(mut self, v: T) -> Self {
        self.threat_type = v.into();
        self
    }

    /// Sets the value of [version_token][crate::model::ComputeThreatListDiffRequest::version_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffRequest;
    /// let x = ComputeThreatListDiffRequest::new().set_version_token(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.version_token = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffRequest;
    /// use google_cloud_webrisk_v1::model::compute_threat_list_diff_request::Constraints;
    /// let x = ComputeThreatListDiffRequest::new().set_constraints(Constraints::default()/* use setters */);
    /// ```
    pub fn set_constraints<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::compute_threat_list_diff_request::Constraints>
    {
        self.constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffRequest;
    /// use google_cloud_webrisk_v1::model::compute_threat_list_diff_request::Constraints;
    /// let x = ComputeThreatListDiffRequest::new().set_or_clear_constraints(Some(Constraints::default()/* use setters */));
    /// let x = ComputeThreatListDiffRequest::new().set_or_clear_constraints(None::<Constraints>);
    /// ```
    pub fn set_or_clear_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::compute_threat_list_diff_request::Constraints>
    {
        self.constraints = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest"
    }
}

/// Defines additional types related to [ComputeThreatListDiffRequest].
pub mod compute_threat_list_diff_request {
    #[allow(unused_imports)]
    use super::*;


    /// The constraints for this diff.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Constraints {

        /// The maximum size in number of entries. The diff will not contain more
        /// entries than this value.  This should be a power of 2 between 2**10 and
        /// 2**20.  If zero, no diff size limit is set.
        pub max_diff_entries: i32,

        /// Sets the maximum number of entries that the client is willing to have
        /// in the local database. This should be a power of 2 between 2**10 and
        /// 2**20. If zero, no database size limit is set.
        pub max_database_entries: i32,

        /// The compression types supported by the client.
        pub supported_compressions: std::vec::Vec<crate::model::CompressionType>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Constraints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_diff_entries][crate::model::compute_threat_list_diff_request::Constraints::max_diff_entries].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::compute_threat_list_diff_request::Constraints;
        /// let x = Constraints::new().set_max_diff_entries(42);
        /// ```
        pub fn set_max_diff_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_diff_entries = v.into();
            self
        }

        /// Sets the value of [max_database_entries][crate::model::compute_threat_list_diff_request::Constraints::max_database_entries].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::compute_threat_list_diff_request::Constraints;
        /// let x = Constraints::new().set_max_database_entries(42);
        /// ```
        pub fn set_max_database_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_database_entries = v.into();
            self
        }

        /// Sets the value of [supported_compressions][crate::model::compute_threat_list_diff_request::Constraints::supported_compressions].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::compute_threat_list_diff_request::Constraints;
        /// use google_cloud_webrisk_v1::model::CompressionType;
        /// let x = Constraints::new().set_supported_compressions([
        ///     CompressionType::Raw,
        ///     CompressionType::Rice,
        /// ]);
        /// ```
        pub fn set_supported_compressions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CompressionType>
        {
            use std::iter::Iterator;
            self.supported_compressions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Constraints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest.Constraints"
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeThreatListDiffResponse {

    /// The type of response. This may indicate that an action must be taken by the
    /// client when the response is received.
    pub response_type: crate::model::compute_threat_list_diff_response::ResponseType,

    /// A set of entries to add to a local threat type's list.
    pub additions: std::option::Option<crate::model::ThreatEntryAdditions>,

    /// A set of entries to remove from a local threat type's list.
    /// This field may be empty.
    pub removals: std::option::Option<crate::model::ThreatEntryRemovals>,

    /// The new opaque client version token. This should be retained by the client
    /// and passed into the next call of ComputeThreatListDiff as 'version_token'.
    /// A separate version token should be stored and used for each threatList.
    pub new_version_token: ::bytes::Bytes,

    /// The expected SHA256 hash of the client state; that is, of the sorted list
    /// of all hashes present in the database after applying the provided diff.
    /// If the client state doesn't match the expected state, the client must
    /// discard this diff and retry later.
    pub checksum: std::option::Option<crate::model::compute_threat_list_diff_response::Checksum>,

    /// The soonest the client should wait before issuing any diff
    /// request. Querying sooner is unlikely to produce a meaningful diff.
    /// Waiting longer is acceptable considering the use case.
    /// If this field is not set clients may update as soon as they want.
    pub recommended_next_diff: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_type][crate::model::ComputeThreatListDiffResponse::response_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use google_cloud_webrisk_v1::model::compute_threat_list_diff_response::ResponseType;
    /// let x0 = ComputeThreatListDiffResponse::new().set_response_type(ResponseType::Diff);
    /// let x1 = ComputeThreatListDiffResponse::new().set_response_type(ResponseType::Reset);
    /// ```
    pub fn set_response_type<T: std::convert::Into<crate::model::compute_threat_list_diff_response::ResponseType>>(mut self, v: T) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use google_cloud_webrisk_v1::model::ThreatEntryAdditions;
    /// let x = ComputeThreatListDiffResponse::new().set_additions(ThreatEntryAdditions::default()/* use setters */);
    /// ```
    pub fn set_additions<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ThreatEntryAdditions>
    {
        self.additions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use google_cloud_webrisk_v1::model::ThreatEntryAdditions;
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_additions(Some(ThreatEntryAdditions::default()/* use setters */));
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_additions(None::<ThreatEntryAdditions>);
    /// ```
    pub fn set_or_clear_additions<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ThreatEntryAdditions>
    {
        self.additions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use google_cloud_webrisk_v1::model::ThreatEntryRemovals;
    /// let x = ComputeThreatListDiffResponse::new().set_removals(ThreatEntryRemovals::default()/* use setters */);
    /// ```
    pub fn set_removals<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ThreatEntryRemovals>
    {
        self.removals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use google_cloud_webrisk_v1::model::ThreatEntryRemovals;
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_removals(Some(ThreatEntryRemovals::default()/* use setters */));
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_removals(None::<ThreatEntryRemovals>);
    /// ```
    pub fn set_or_clear_removals<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ThreatEntryRemovals>
    {
        self.removals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [new_version_token][crate::model::ComputeThreatListDiffResponse::new_version_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// let x = ComputeThreatListDiffResponse::new().set_new_version_token(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_new_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.new_version_token = v.into();
        self
    }

    /// Sets the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use google_cloud_webrisk_v1::model::compute_threat_list_diff_response::Checksum;
    /// let x = ComputeThreatListDiffResponse::new().set_checksum(Checksum::default()/* use setters */);
    /// ```
    pub fn set_checksum<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::compute_threat_list_diff_response::Checksum>
    {
        self.checksum = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use google_cloud_webrisk_v1::model::compute_threat_list_diff_response::Checksum;
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_checksum(Some(Checksum::default()/* use setters */));
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_checksum(None::<Checksum>);
    /// ```
    pub fn set_or_clear_checksum<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::compute_threat_list_diff_response::Checksum>
    {
        self.checksum = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use wkt::Timestamp;
    /// let x = ComputeThreatListDiffResponse::new().set_recommended_next_diff(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_recommended_next_diff<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.recommended_next_diff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ComputeThreatListDiffResponse;
    /// use wkt::Timestamp;
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_recommended_next_diff(Some(Timestamp::default()/* use setters */));
    /// let x = ComputeThreatListDiffResponse::new().set_or_clear_recommended_next_diff(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_recommended_next_diff<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.recommended_next_diff = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse"
    }
}

/// Defines additional types related to [ComputeThreatListDiffResponse].
pub mod compute_threat_list_diff_response {
    #[allow(unused_imports)]
    use super::*;


    /// The expected state of a client's local database.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Checksum {

        /// The SHA256 hash of the client state; that is, of the sorted list of all
        /// hashes present in the database.
        pub sha256: ::bytes::Bytes,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Checksum {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sha256][crate::model::compute_threat_list_diff_response::Checksum::sha256].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::compute_threat_list_diff_response::Checksum;
        /// let x = Checksum::new().set_sha256(bytes::Bytes::from_static(b"example"));
        /// ```
        pub fn set_sha256<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for Checksum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse.Checksum"
        }
    }

    /// The type of response sent to the client.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResponseType {
        /// Unknown.
        Unspecified,
        /// Partial updates are applied to the client's existing local database.
        Diff,
        /// Full updates resets the client's entire local database. This means
        /// that either the client had no state, was seriously out-of-date,
        /// or the client is believed to be corrupt.
        Reset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResponseType::value] or
        /// [ResponseType::name].
        UnknownValue(response_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod response_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResponseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Diff => std::option::Option::Some(1),
                Self::Reset => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESPONSE_TYPE_UNSPECIFIED"),
                Self::Diff => std::option::Option::Some("DIFF"),
                Self::Reset => std::option::Option::Some("RESET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResponseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResponseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResponseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Diff,
                2 => Self::Reset,
                _ => Self::UnknownValue(response_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ResponseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESPONSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DIFF" => Self::Diff,
                "RESET" => Self::Reset,
                _ => Self::UnknownValue(response_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ResponseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Diff => serializer.serialize_i32(1),
                Self::Reset => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResponseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResponseType>::new(
                ".google.cloud.webrisk.v1.ComputeThreatListDiffResponse.ResponseType"))
        }
    }
}

/// Request to check URI entries against threatLists.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchUrisRequest {

    /// Required. The URI to be checked for matches.
    pub uri: std::string::String,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::SearchUrisRequest::uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchUrisRequest;
    /// let x = SearchUrisRequest::new().set_uri("example");
    /// ```
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchUrisRequest::threat_types].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchUrisRequest;
    /// use google_cloud_webrisk_v1::model::ThreatType;
    /// let x = SearchUrisRequest::new().set_threat_types([
    ///     ThreatType::Malware,
    ///     ThreatType::SocialEngineering,
    ///     ThreatType::UnwantedSoftware,
    /// ]);
    /// ```
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchUrisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisRequest"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchUrisResponse {

    /// The threat list matches. This might be empty if the URI is on no list.
    pub threat: std::option::Option<crate::model::search_uris_response::ThreatUri>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat][crate::model::SearchUrisResponse::threat].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchUrisResponse;
    /// use google_cloud_webrisk_v1::model::search_uris_response::ThreatUri;
    /// let x = SearchUrisResponse::new().set_threat(ThreatUri::default()/* use setters */);
    /// ```
    pub fn set_threat<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::search_uris_response::ThreatUri>
    {
        self.threat = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat][crate::model::SearchUrisResponse::threat].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchUrisResponse;
    /// use google_cloud_webrisk_v1::model::search_uris_response::ThreatUri;
    /// let x = SearchUrisResponse::new().set_or_clear_threat(Some(ThreatUri::default()/* use setters */));
    /// let x = SearchUrisResponse::new().set_or_clear_threat(None::<ThreatUri>);
    /// ```
    pub fn set_or_clear_threat<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::search_uris_response::ThreatUri>
    {
        self.threat = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchUrisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse"
    }
}

/// Defines additional types related to [SearchUrisResponse].
pub mod search_uris_response {
    #[allow(unused_imports)]
    use super::*;


    /// Contains threat information on a matching uri.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThreatUri {

        /// The ThreatList this threat belongs to.
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        pub expire_time: std::option::Option<wkt::Timestamp>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatUri {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threat_types][crate::model::search_uris_response::ThreatUri::threat_types].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::search_uris_response::ThreatUri;
        /// use google_cloud_webrisk_v1::model::ThreatType;
        /// let x = ThreatUri::new().set_threat_types([
        ///     ThreatType::Malware,
        ///     ThreatType::SocialEngineering,
        ///     ThreatType::UnwantedSoftware,
        /// ]);
        /// ```
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::search_uris_response::ThreatUri;
        /// use wkt::Timestamp;
        /// let x = ThreatUri::new().set_expire_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_expire_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.expire_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::search_uris_response::ThreatUri;
        /// use wkt::Timestamp;
        /// let x = ThreatUri::new().set_or_clear_expire_time(Some(Timestamp::default()/* use setters */));
        /// let x = ThreatUri::new().set_or_clear_expire_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.expire_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ThreatUri {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse.ThreatUri"
        }
    }
}

/// Request to return full hashes matched by the provided hash prefixes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchHashesRequest {

    /// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
    /// hash. For JSON requests, this field is base64-encoded.
    /// Note that if this parameter is provided by a URI, it must be encoded using
    /// the web safe base64 variant (RFC 4648).
    pub hash_prefix: ::bytes::Bytes,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hash_prefix][crate::model::SearchHashesRequest::hash_prefix].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchHashesRequest;
    /// let x = SearchHashesRequest::new().set_hash_prefix(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_hash_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hash_prefix = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchHashesRequest::threat_types].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchHashesRequest;
    /// use google_cloud_webrisk_v1::model::ThreatType;
    /// let x = SearchHashesRequest::new().set_threat_types([
    ///     ThreatType::Malware,
    ///     ThreatType::SocialEngineering,
    ///     ThreatType::UnwantedSoftware,
    /// ]);
    /// ```
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchHashesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesRequest"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchHashesResponse {

    /// The full hashes that matched the requested prefixes.
    /// The hash will be populated in the key.
    pub threats: std::vec::Vec<crate::model::search_hashes_response::ThreatHash>,

    /// For requested entities that did not match the threat list, how long to
    /// cache the response until.
    pub negative_expire_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threats][crate::model::SearchHashesResponse::threats].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchHashesResponse;
    /// use google_cloud_webrisk_v1::model::search_hashes_response::ThreatHash;
    /// let x = SearchHashesResponse::new()
    ///     .set_threats([
    ///         ThreatHash::default()/* use setters */,
    ///         ThreatHash::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_threats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_hashes_response::ThreatHash>
    {
        use std::iter::Iterator;
        self.threats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchHashesResponse;
    /// use wkt::Timestamp;
    /// let x = SearchHashesResponse::new().set_negative_expire_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_negative_expire_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.negative_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SearchHashesResponse;
    /// use wkt::Timestamp;
    /// let x = SearchHashesResponse::new().set_or_clear_negative_expire_time(Some(Timestamp::default()/* use setters */));
    /// let x = SearchHashesResponse::new().set_or_clear_negative_expire_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_negative_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.negative_expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchHashesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse"
    }
}

/// Defines additional types related to [SearchHashesResponse].
pub mod search_hashes_response {
    #[allow(unused_imports)]
    use super::*;


    /// Contains threat information on a matching hash.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThreatHash {

        /// The ThreatList this threat belongs to.
        /// This must contain at least one entry.
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// A 32 byte SHA256 hash. This field is in binary format. For JSON
        /// requests, hashes are base64-encoded.
        pub hash: ::bytes::Bytes,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        pub expire_time: std::option::Option<wkt::Timestamp>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatHash {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threat_types][crate::model::search_hashes_response::ThreatHash::threat_types].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::search_hashes_response::ThreatHash;
        /// use google_cloud_webrisk_v1::model::ThreatType;
        /// let x = ThreatHash::new().set_threat_types([
        ///     ThreatType::Malware,
        ///     ThreatType::SocialEngineering,
        ///     ThreatType::UnwantedSoftware,
        /// ]);
        /// ```
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [hash][crate::model::search_hashes_response::ThreatHash::hash].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::search_hashes_response::ThreatHash;
        /// let x = ThreatHash::new().set_hash(bytes::Bytes::from_static(b"example"));
        /// ```
        pub fn set_hash<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.hash = v.into();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::search_hashes_response::ThreatHash;
        /// use wkt::Timestamp;
        /// let x = ThreatHash::new().set_expire_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_expire_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.expire_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::search_hashes_response::ThreatHash;
        /// use wkt::Timestamp;
        /// let x = ThreatHash::new().set_or_clear_expire_time(Some(Timestamp::default()/* use setters */));
        /// let x = ThreatHash::new().set_or_clear_expire_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.expire_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ThreatHash {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse.ThreatHash"
        }
    }
}

/// Contains the set of entries to add to a local database.
/// May contain a combination of compressed and raw data in a single response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatEntryAdditions {

    /// The raw SHA256-formatted entries.
    /// Repeated to allow returning sets of hashes with different prefix sizes.
    pub raw_hashes: std::vec::Vec<crate::model::RawHashes>,

    /// The encoded 4-byte prefixes of SHA256-formatted entries, using a
    /// Golomb-Rice encoding. The hashes are converted to uint32, sorted in
    /// ascending order, then delta encoded and stored as encoded_data.
    pub rice_hashes: std::option::Option<crate::model::RiceDeltaEncoding>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryAdditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_hashes][crate::model::ThreatEntryAdditions::raw_hashes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatEntryAdditions;
    /// use google_cloud_webrisk_v1::model::RawHashes;
    /// let x = ThreatEntryAdditions::new()
    ///     .set_raw_hashes([
    ///         RawHashes::default()/* use setters */,
    ///         RawHashes::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_raw_hashes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RawHashes>
    {
        use std::iter::Iterator;
        self.raw_hashes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatEntryAdditions;
    /// use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = ThreatEntryAdditions::new().set_rice_hashes(RiceDeltaEncoding::default()/* use setters */);
    /// ```
    pub fn set_rice_hashes<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::RiceDeltaEncoding>
    {
        self.rice_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatEntryAdditions;
    /// use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = ThreatEntryAdditions::new().set_or_clear_rice_hashes(Some(RiceDeltaEncoding::default()/* use setters */));
    /// let x = ThreatEntryAdditions::new().set_or_clear_rice_hashes(None::<RiceDeltaEncoding>);
    /// ```
    pub fn set_or_clear_rice_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::RiceDeltaEncoding>
    {
        self.rice_hashes = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatEntryAdditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryAdditions"
    }
}

/// Contains the set of entries to remove from a local database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatEntryRemovals {

    /// The raw removal indices for a local list.
    pub raw_indices: std::option::Option<crate::model::RawIndices>,

    /// The encoded local, lexicographically-sorted list indices, using a
    /// Golomb-Rice encoding. Used for sending compressed removal indices. The
    /// removal indices (uint32) are sorted in ascending order, then delta encoded
    /// and stored as encoded_data.
    pub rice_indices: std::option::Option<crate::model::RiceDeltaEncoding>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryRemovals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatEntryRemovals;
    /// use google_cloud_webrisk_v1::model::RawIndices;
    /// let x = ThreatEntryRemovals::new().set_raw_indices(RawIndices::default()/* use setters */);
    /// ```
    pub fn set_raw_indices<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::RawIndices>
    {
        self.raw_indices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatEntryRemovals;
    /// use google_cloud_webrisk_v1::model::RawIndices;
    /// let x = ThreatEntryRemovals::new().set_or_clear_raw_indices(Some(RawIndices::default()/* use setters */));
    /// let x = ThreatEntryRemovals::new().set_or_clear_raw_indices(None::<RawIndices>);
    /// ```
    pub fn set_or_clear_raw_indices<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::RawIndices>
    {
        self.raw_indices = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatEntryRemovals;
    /// use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = ThreatEntryRemovals::new().set_rice_indices(RiceDeltaEncoding::default()/* use setters */);
    /// ```
    pub fn set_rice_indices<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::RiceDeltaEncoding>
    {
        self.rice_indices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatEntryRemovals;
    /// use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = ThreatEntryRemovals::new().set_or_clear_rice_indices(Some(RiceDeltaEncoding::default()/* use setters */));
    /// let x = ThreatEntryRemovals::new().set_or_clear_rice_indices(None::<RiceDeltaEncoding>);
    /// ```
    pub fn set_or_clear_rice_indices<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::RiceDeltaEncoding>
    {
        self.rice_indices = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatEntryRemovals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryRemovals"
    }
}

/// A set of raw indices to remove from a local list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RawIndices {

    /// The indices to remove from a lexicographically-sorted local list.
    pub indices: std::vec::Vec<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawIndices {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indices][crate::model::RawIndices::indices].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::RawIndices;
    /// let x = RawIndices::new().set_indices([1, 2, 3]);
    /// ```
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RawIndices {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawIndices"
    }
}

/// The uncompressed threat entries in hash format.
/// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
/// bytes, but some hashes are lengthened if they collide with the hash of a
/// popular URI.
///
/// Used for sending ThreatEntryAdditons to clients that do not support
/// compression, or when sending non-4-byte hashes to clients that do support
/// compression.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RawHashes {

    /// The number of bytes for each prefix encoded below.  This field can be
    /// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
    /// In practice this is almost always 4, except in exceptional circumstances.
    pub prefix_size: i32,

    /// The hashes, in binary format, concatenated into one long string. Hashes are
    /// sorted in lexicographic order. For JSON API users, hashes are
    /// base64-encoded.
    pub raw_hashes: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prefix_size][crate::model::RawHashes::prefix_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::RawHashes;
    /// let x = RawHashes::new().set_prefix_size(42);
    /// ```
    pub fn set_prefix_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.prefix_size = v.into();
        self
    }

    /// Sets the value of [raw_hashes][crate::model::RawHashes::raw_hashes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::RawHashes;
    /// let x = RawHashes::new().set_raw_hashes(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_raw_hashes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_hashes = v.into();
        self
    }
}

impl wkt::message::Message for RawHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawHashes"
    }
}

/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
/// compressed removal indices.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RiceDeltaEncoding {

    /// The offset of the first entry in the encoded data, or, if only a single
    /// integer was encoded, that single integer's value. If the field is empty or
    /// missing, assume zero.
    pub first_value: i64,

    /// The Golomb-Rice parameter, which is a number between 2 and 28. This field
    /// is missing (that is, zero) if `num_entries` is zero.
    pub rice_parameter: i32,

    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    pub entry_count: i32,

    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    pub encoded_data: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiceDeltaEncoding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_value][crate::model::RiceDeltaEncoding::first_value].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = RiceDeltaEncoding::new().set_first_value(42);
    /// ```
    pub fn set_first_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.first_value = v.into();
        self
    }

    /// Sets the value of [rice_parameter][crate::model::RiceDeltaEncoding::rice_parameter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = RiceDeltaEncoding::new().set_rice_parameter(42);
    /// ```
    pub fn set_rice_parameter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rice_parameter = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::RiceDeltaEncoding::entry_count].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = RiceDeltaEncoding::new().set_entry_count(42);
    /// ```
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [encoded_data][crate::model::RiceDeltaEncoding::encoded_data].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::RiceDeltaEncoding;
    /// let x = RiceDeltaEncoding::new().set_encoded_data(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_encoded_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.encoded_data = v.into();
        self
    }
}

impl wkt::message::Message for RiceDeltaEncoding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RiceDeltaEncoding"
    }
}

/// Wraps a URI that might be displaying malicious content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Submission {

    /// Required. The URI that is being reported for malicious content to be
    /// analyzed.
    pub uri: std::string::String,

    /// Output only. ThreatTypes found to be associated with the submitted URI
    /// after reviewing it. This might be empty if the URI was not added to any
    /// list.
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Submission {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::Submission::uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::Submission;
    /// let x = Submission::new().set_uri("example");
    /// ```
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::Submission::threat_types].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::Submission;
    /// use google_cloud_webrisk_v1::model::ThreatType;
    /// let x = Submission::new().set_threat_types([
    ///     ThreatType::Malware,
    ///     ThreatType::SocialEngineering,
    ///     ThreatType::UnwantedSoftware,
    /// ]);
    /// ```
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Submission {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.Submission"
    }
}

/// Context about the submission including the type of abuse found on the URI and
/// supporting details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatInfo {

    /// The type of abuse.
    pub abuse_type: crate::model::threat_info::AbuseType,

    /// Confidence that the URI is unsafe.
    pub threat_confidence: std::option::Option<crate::model::threat_info::Confidence>,

    /// Context about why the URI is unsafe.
    pub threat_justification: std::option::Option<crate::model::threat_info::ThreatJustification>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [abuse_type][crate::model::ThreatInfo::abuse_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatInfo;
    /// use google_cloud_webrisk_v1::model::threat_info::AbuseType;
    /// let x0 = ThreatInfo::new().set_abuse_type(AbuseType::Malware);
    /// let x1 = ThreatInfo::new().set_abuse_type(AbuseType::SocialEngineering);
    /// let x2 = ThreatInfo::new().set_abuse_type(AbuseType::UnwantedSoftware);
    /// ```
    pub fn set_abuse_type<T: std::convert::Into<crate::model::threat_info::AbuseType>>(mut self, v: T) -> Self {
        self.abuse_type = v.into();
        self
    }

    /// Sets the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatInfo;
    /// use google_cloud_webrisk_v1::model::threat_info::Confidence;
    /// let x = ThreatInfo::new().set_threat_confidence(Confidence::default()/* use setters */);
    /// ```
    pub fn set_threat_confidence<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::threat_info::Confidence>
    {
        self.threat_confidence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatInfo;
    /// use google_cloud_webrisk_v1::model::threat_info::Confidence;
    /// let x = ThreatInfo::new().set_or_clear_threat_confidence(Some(Confidence::default()/* use setters */));
    /// let x = ThreatInfo::new().set_or_clear_threat_confidence(None::<Confidence>);
    /// ```
    pub fn set_or_clear_threat_confidence<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::threat_info::Confidence>
    {
        self.threat_confidence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatInfo;
    /// use google_cloud_webrisk_v1::model::threat_info::ThreatJustification;
    /// let x = ThreatInfo::new().set_threat_justification(ThreatJustification::default()/* use setters */);
    /// ```
    pub fn set_threat_justification<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::threat_info::ThreatJustification>
    {
        self.threat_justification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatInfo;
    /// use google_cloud_webrisk_v1::model::threat_info::ThreatJustification;
    /// let x = ThreatInfo::new().set_or_clear_threat_justification(Some(ThreatJustification::default()/* use setters */));
    /// let x = ThreatInfo::new().set_or_clear_threat_justification(None::<ThreatJustification>);
    /// ```
    pub fn set_or_clear_threat_justification<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::threat_info::ThreatJustification>
    {
        self.threat_justification = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo"
    }
}

/// Defines additional types related to [ThreatInfo].
pub mod threat_info {
    #[allow(unused_imports)]
    use super::*;


    /// Confidence that a URI is unsafe.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Confidence {

        pub value: std::option::Option<crate::model::threat_info::confidence::Value>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Confidence {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::threat_info::Confidence;
        /// use google_cloud_webrisk_v1::model::threat_info::confidence::Value;
        /// let x = Confidence::new().set_value(Some(Value::Score(42.0)));
        /// ```
        pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::threat_info::confidence::Value>>>(mut self, v: T) -> Self
        {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Score`, `None` if the field is not set or
        /// holds a different branch.
        pub fn score(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Score(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Score`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::threat_info::Confidence;
        /// let x = Confidence::new().set_score(42.0);
        /// assert!(x.score().is_some());
        /// assert!(x.level().is_none());
        /// ```
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Score(
                    v.into()
                )
            );
            self
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Level`, `None` if the field is not set or
        /// holds a different branch.
        pub fn level(&self) -> std::option::Option<&crate::model::threat_info::confidence::ConfidenceLevel> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Level(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Level`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::threat_info::Confidence;
        /// use google_cloud_webrisk_v1::model::threat_info::confidence::ConfidenceLevel;
        /// let x0 = Confidence::new().set_level(ConfidenceLevel::Low);
        /// let x1 = Confidence::new().set_level(ConfidenceLevel::Medium);
        /// let x2 = Confidence::new().set_level(ConfidenceLevel::High);
        /// assert!(x0.level().is_some());
        /// assert!(x0.score().is_none());
        /// assert!(x1.level().is_some());
        /// assert!(x1.score().is_none());
        /// assert!(x2.level().is_some());
        /// assert!(x2.score().is_none());
        /// ```
        pub fn set_level<T: std::convert::Into<crate::model::threat_info::confidence::ConfidenceLevel>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Level(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for Confidence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.Confidence"
        }
    }

    /// Defines additional types related to [Confidence].
    pub mod confidence {
        #[allow(unused_imports)]
        use super::*;


        /// Enum representation of confidence.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ConfidenceLevel {
            /// Default.
            Unspecified,
            /// Less than 60% confidence that the URI is unsafe.
            Low,
            /// Between 60% and 80% confidence that the URI is unsafe.
            Medium,
            /// Greater than 80% confidence that the URI is unsafe.
            High,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ConfidenceLevel::value] or
            /// [ConfidenceLevel::name].
            UnknownValue(confidence_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod confidence_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ConfidenceLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Low => std::option::Option::Some(1),
                    Self::Medium => std::option::Option::Some(2),
                    Self::High => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CONFIDENCE_LEVEL_UNSPECIFIED"),
                    Self::Low => std::option::Option::Some("LOW"),
                    Self::Medium => std::option::Option::Some("MEDIUM"),
                    Self::High => std::option::Option::Some("HIGH"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ConfidenceLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ConfidenceLevel {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ConfidenceLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Low,
                    2 => Self::Medium,
                    3 => Self::High,
                    _ => Self::UnknownValue(confidence_level::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for ConfidenceLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONFIDENCE_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "LOW" => Self::Low,
                    "MEDIUM" => Self::Medium,
                    "HIGH" => Self::High,
                    _ => Self::UnknownValue(confidence_level::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for ConfidenceLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Low => serializer.serialize_i32(1),
                    Self::Medium => serializer.serialize_i32(2),
                    Self::High => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ConfidenceLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConfidenceLevel>::new(
                    ".google.cloud.webrisk.v1.ThreatInfo.Confidence.ConfidenceLevel"))
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// A decimal representation of confidence in the range of 0
            /// to 1 where 0 indicates no confidence and 1 indicates
            /// complete confidence.
            Score(f32),
            /// Enum representation of confidence.
            Level(crate::model::threat_info::confidence::ConfidenceLevel),
        }
    }

    /// Context about why the URI is unsafe.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThreatJustification {

        /// Labels associated with this URI that explain how it was classified.
        pub labels: std::vec::Vec<crate::model::threat_info::threat_justification::JustificationLabel>,

        /// Free-form context on why this URI is unsafe.
        pub comments: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatJustification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::threat_info::ThreatJustification::labels].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::threat_info::ThreatJustification;
        /// use google_cloud_webrisk_v1::model::threat_info::threat_justification::JustificationLabel;
        /// let x = ThreatJustification::new().set_labels([
        ///     JustificationLabel::ManualVerification,
        ///     JustificationLabel::UserReport,
        ///     JustificationLabel::AutomatedReport,
        /// ]);
        /// ```
        pub fn set_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::threat_info::threat_justification::JustificationLabel>
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [comments][crate::model::threat_info::ThreatJustification::comments].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_webrisk_v1::model::threat_info::ThreatJustification;
        /// let x = ThreatJustification::new().set_comments(["a", "b", "c"]);
        /// ```
        pub fn set_comments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.comments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatJustification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.ThreatJustification"
        }
    }

    /// Defines additional types related to [ThreatJustification].
    pub mod threat_justification {
        #[allow(unused_imports)]
        use super::*;


        /// Labels that explain how the URI was classified.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum JustificationLabel {
            /// Default.
            Unspecified,
            /// The submitter manually verified that the submission is unsafe.
            ManualVerification,
            /// The submitter received the submission from an end user.
            UserReport,
            /// The submitter received the submission from an automated system.
            AutomatedReport,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [JustificationLabel::value] or
            /// [JustificationLabel::name].
            UnknownValue(justification_label::UnknownValue),
        }

        #[doc(hidden)]
        pub mod justification_label {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl JustificationLabel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ManualVerification => std::option::Option::Some(1),
                    Self::UserReport => std::option::Option::Some(2),
                    Self::AutomatedReport => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("JUSTIFICATION_LABEL_UNSPECIFIED"),
                    Self::ManualVerification => std::option::Option::Some("MANUAL_VERIFICATION"),
                    Self::UserReport => std::option::Option::Some("USER_REPORT"),
                    Self::AutomatedReport => std::option::Option::Some("AUTOMATED_REPORT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for JustificationLabel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for JustificationLabel {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for JustificationLabel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ManualVerification,
                    2 => Self::UserReport,
                    3 => Self::AutomatedReport,
                    _ => Self::UnknownValue(justification_label::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for JustificationLabel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "JUSTIFICATION_LABEL_UNSPECIFIED" => Self::Unspecified,
                    "MANUAL_VERIFICATION" => Self::ManualVerification,
                    "USER_REPORT" => Self::UserReport,
                    "AUTOMATED_REPORT" => Self::AutomatedReport,
                    _ => Self::UnknownValue(justification_label::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for JustificationLabel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ManualVerification => serializer.serialize_i32(1),
                    Self::UserReport => serializer.serialize_i32(2),
                    Self::AutomatedReport => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for JustificationLabel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<JustificationLabel>::new(
                    ".google.cloud.webrisk.v1.ThreatInfo.ThreatJustification.JustificationLabel"))
            }
        }
    }

    /// The abuse type found on the URI.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AbuseType {
        /// Default.
        Unspecified,
        /// The URI contains malware.
        Malware,
        /// The URI contains social engineering.
        SocialEngineering,
        /// The URI contains unwanted software.
        UnwantedSoftware,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AbuseType::value] or
        /// [AbuseType::name].
        UnknownValue(abuse_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod abuse_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AbuseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Malware => std::option::Option::Some(1),
                Self::SocialEngineering => std::option::Option::Some(2),
                Self::UnwantedSoftware => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ABUSE_TYPE_UNSPECIFIED"),
                Self::Malware => std::option::Option::Some("MALWARE"),
                Self::SocialEngineering => std::option::Option::Some("SOCIAL_ENGINEERING"),
                Self::UnwantedSoftware => std::option::Option::Some("UNWANTED_SOFTWARE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AbuseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AbuseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AbuseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Malware,
                2 => Self::SocialEngineering,
                3 => Self::UnwantedSoftware,
                _ => Self::UnknownValue(abuse_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for AbuseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ABUSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MALWARE" => Self::Malware,
                "SOCIAL_ENGINEERING" => Self::SocialEngineering,
                "UNWANTED_SOFTWARE" => Self::UnwantedSoftware,
                _ => Self::UnknownValue(abuse_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for AbuseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Malware => serializer.serialize_i32(1),
                Self::SocialEngineering => serializer.serialize_i32(2),
                Self::UnwantedSoftware => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AbuseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AbuseType>::new(
                ".google.cloud.webrisk.v1.ThreatInfo.AbuseType"))
        }
    }
}

/// Details about how the threat was discovered.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatDiscovery {

    /// Platform on which the threat was discovered.
    pub platform: crate::model::threat_discovery::Platform,

    /// CLDR region code of the countries/regions the URI poses a threat ordered
    /// from most impact to least impact. Example: "US" for United States.
    pub region_codes: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatDiscovery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [platform][crate::model::ThreatDiscovery::platform].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatDiscovery;
    /// use google_cloud_webrisk_v1::model::threat_discovery::Platform;
    /// let x0 = ThreatDiscovery::new().set_platform(Platform::Android);
    /// let x1 = ThreatDiscovery::new().set_platform(Platform::Ios);
    /// let x2 = ThreatDiscovery::new().set_platform(Platform::Macos);
    /// ```
    pub fn set_platform<T: std::convert::Into<crate::model::threat_discovery::Platform>>(mut self, v: T) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [region_codes][crate::model::ThreatDiscovery::region_codes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::ThreatDiscovery;
    /// let x = ThreatDiscovery::new().set_region_codes(["a", "b", "c"]);
    /// ```
    pub fn set_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ThreatDiscovery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatDiscovery"
    }
}

/// Defines additional types related to [ThreatDiscovery].
pub mod threat_discovery {
    #[allow(unused_imports)]
    use super::*;


    /// Platform types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Platform {
        /// Default.
        Unspecified,
        /// General Android platform.
        Android,
        /// General iOS platform.
        Ios,
        /// General macOS platform.
        Macos,
        /// General Windows platform.
        Windows,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Platform::value] or
        /// [Platform::name].
        UnknownValue(platform::UnknownValue),
    }

    #[doc(hidden)]
    pub mod platform {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Platform {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Android => std::option::Option::Some(1),
                Self::Ios => std::option::Option::Some(2),
                Self::Macos => std::option::Option::Some(3),
                Self::Windows => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PLATFORM_UNSPECIFIED"),
                Self::Android => std::option::Option::Some("ANDROID"),
                Self::Ios => std::option::Option::Some("IOS"),
                Self::Macos => std::option::Option::Some("MACOS"),
                Self::Windows => std::option::Option::Some("WINDOWS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Platform {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Platform {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Platform {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Android,
                2 => Self::Ios,
                3 => Self::Macos,
                4 => Self::Windows,
                _ => Self::UnknownValue(platform::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Platform {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLATFORM_UNSPECIFIED" => Self::Unspecified,
                "ANDROID" => Self::Android,
                "IOS" => Self::Ios,
                "MACOS" => Self::Macos,
                "WINDOWS" => Self::Windows,
                _ => Self::UnknownValue(platform::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Platform {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Android => serializer.serialize_i32(1),
                Self::Ios => serializer.serialize_i32(2),
                Self::Macos => serializer.serialize_i32(3),
                Self::Windows => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Platform {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Platform>::new(
                ".google.cloud.webrisk.v1.ThreatDiscovery.Platform"))
        }
    }
}

/// Request to send a potentially phishy URI to WebRisk.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSubmissionRequest {

    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    pub parent: std::string::String,

    /// Required. The submission that contains the content of the phishing report.
    pub submission: std::option::Option<crate::model::Submission>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSubmissionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSubmissionRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::CreateSubmissionRequest;
    /// let x = CreateSubmissionRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::CreateSubmissionRequest::submission].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::CreateSubmissionRequest;
    /// use google_cloud_webrisk_v1::model::Submission;
    /// let x = CreateSubmissionRequest::new().set_submission(Submission::default()/* use setters */);
    /// ```
    pub fn set_submission<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Submission>
    {
        self.submission = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submission][crate::model::CreateSubmissionRequest::submission].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::CreateSubmissionRequest;
    /// use google_cloud_webrisk_v1::model::Submission;
    /// let x = CreateSubmissionRequest::new().set_or_clear_submission(Some(Submission::default()/* use setters */));
    /// let x = CreateSubmissionRequest::new().set_or_clear_submission(None::<Submission>);
    /// ```
    pub fn set_or_clear_submission<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Submission>
    {
        self.submission = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSubmissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.CreateSubmissionRequest"
    }
}

/// Request to send a potentially malicious URI to WebRisk.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitUriRequest {

    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    pub parent: std::string::String,

    /// Required. The submission that contains the URI to be scanned.
    pub submission: std::option::Option<crate::model::Submission>,

    /// Provides additional information about the submission.
    pub threat_info: std::option::Option<crate::model::ThreatInfo>,

    /// Provides additional information about how the submission was discovered.
    pub threat_discovery: std::option::Option<crate::model::ThreatDiscovery>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitUriRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriRequest;
    /// let x = SubmitUriRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::SubmitUriRequest::submission].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriRequest;
    /// use google_cloud_webrisk_v1::model::Submission;
    /// let x = SubmitUriRequest::new().set_submission(Submission::default()/* use setters */);
    /// ```
    pub fn set_submission<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Submission>
    {
        self.submission = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submission][crate::model::SubmitUriRequest::submission].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriRequest;
    /// use google_cloud_webrisk_v1::model::Submission;
    /// let x = SubmitUriRequest::new().set_or_clear_submission(Some(Submission::default()/* use setters */));
    /// let x = SubmitUriRequest::new().set_or_clear_submission(None::<Submission>);
    /// ```
    pub fn set_or_clear_submission<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Submission>
    {
        self.submission = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriRequest;
    /// use google_cloud_webrisk_v1::model::ThreatInfo;
    /// let x = SubmitUriRequest::new().set_threat_info(ThreatInfo::default()/* use setters */);
    /// ```
    pub fn set_threat_info<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ThreatInfo>
    {
        self.threat_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriRequest;
    /// use google_cloud_webrisk_v1::model::ThreatInfo;
    /// let x = SubmitUriRequest::new().set_or_clear_threat_info(Some(ThreatInfo::default()/* use setters */));
    /// let x = SubmitUriRequest::new().set_or_clear_threat_info(None::<ThreatInfo>);
    /// ```
    pub fn set_or_clear_threat_info<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ThreatInfo>
    {
        self.threat_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriRequest;
    /// use google_cloud_webrisk_v1::model::ThreatDiscovery;
    /// let x = SubmitUriRequest::new().set_threat_discovery(ThreatDiscovery::default()/* use setters */);
    /// ```
    pub fn set_threat_discovery<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ThreatDiscovery>
    {
        self.threat_discovery = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriRequest;
    /// use google_cloud_webrisk_v1::model::ThreatDiscovery;
    /// let x = SubmitUriRequest::new().set_or_clear_threat_discovery(Some(ThreatDiscovery::default()/* use setters */));
    /// let x = SubmitUriRequest::new().set_or_clear_threat_discovery(None::<ThreatDiscovery>);
    /// ```
    pub fn set_or_clear_threat_discovery<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ThreatDiscovery>
    {
        self.threat_discovery = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitUriRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriRequest"
    }
}

/// Metadata for the Submit URI long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitUriMetadata {

    /// The state of the operation.
    pub state: crate::model::submit_uri_metadata::State,

    /// Creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Latest update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::SubmitUriMetadata::state].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriMetadata;
    /// use google_cloud_webrisk_v1::model::submit_uri_metadata::State;
    /// let x0 = SubmitUriMetadata::new().set_state(State::Running);
    /// let x1 = SubmitUriMetadata::new().set_state(State::Succeeded);
    /// let x2 = SubmitUriMetadata::new().set_state(State::Cancelled);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::submit_uri_metadata::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriMetadata;
    /// use wkt::Timestamp;
    /// let x = SubmitUriMetadata::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriMetadata;
    /// use wkt::Timestamp;
    /// let x = SubmitUriMetadata::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = SubmitUriMetadata::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriMetadata;
    /// use wkt::Timestamp;
    /// let x = SubmitUriMetadata::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_webrisk_v1::model::SubmitUriMetadata;
    /// use wkt::Timestamp;
    /// let x = SubmitUriMetadata::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = SubmitUriMetadata::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitUriMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriMetadata"
    }
}

/// Defines additional types related to [SubmitUriMetadata].
pub mod submit_uri_metadata {
    #[allow(unused_imports)]
    use super::*;


    /// Enum that represents the state of the long-running operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified state.
        Unspecified,
        /// The operation is currently running.
        Running,
        /// The operation finished with a success status.
        Succeeded,
        /// The operation was cancelled.
        Cancelled,
        /// The operation finished with a failure status.
        Failed,
        /// The operation was closed with no action taken.
        Closed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Closed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Closed => std::option::Option::Some("CLOSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Cancelled,
                4 => Self::Failed,
                5 => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "CLOSED" => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Closed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.webrisk.v1.SubmitUriMetadata.State"))
        }
    }
}

/// The type of threat. This maps directly to the threat list a threat may
/// belong to.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ThreatType {
    /// No entries should match this threat type. This threat type is unused.
    Unspecified,
    /// Malware targeting any platform.
    Malware,
    /// Social engineering targeting any platform.
    SocialEngineering,
    /// Unwanted software targeting any platform.
    UnwantedSoftware,
    /// A list of extended coverage social engineering URIs targeting any
    /// platform.
    SocialEngineeringExtendedCoverage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ThreatType::value] or
    /// [ThreatType::name].
    UnknownValue(threat_type::UnknownValue),
}

#[doc(hidden)]
pub mod threat_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ThreatType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Malware => std::option::Option::Some(1),
            Self::SocialEngineering => std::option::Option::Some(2),
            Self::UnwantedSoftware => std::option::Option::Some(3),
            Self::SocialEngineeringExtendedCoverage => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("THREAT_TYPE_UNSPECIFIED"),
            Self::Malware => std::option::Option::Some("MALWARE"),
            Self::SocialEngineering => std::option::Option::Some("SOCIAL_ENGINEERING"),
            Self::UnwantedSoftware => std::option::Option::Some("UNWANTED_SOFTWARE"),
            Self::SocialEngineeringExtendedCoverage => std::option::Option::Some("SOCIAL_ENGINEERING_EXTENDED_COVERAGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ThreatType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ThreatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ThreatType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Malware,
            2 => Self::SocialEngineering,
            3 => Self::UnwantedSoftware,
            4 => Self::SocialEngineeringExtendedCoverage,
            _ => Self::UnknownValue(threat_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for ThreatType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "THREAT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "MALWARE" => Self::Malware,
            "SOCIAL_ENGINEERING" => Self::SocialEngineering,
            "UNWANTED_SOFTWARE" => Self::UnwantedSoftware,
            "SOCIAL_ENGINEERING_EXTENDED_COVERAGE" => Self::SocialEngineeringExtendedCoverage,
            _ => Self::UnknownValue(threat_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for ThreatType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Malware => serializer.serialize_i32(1),
            Self::SocialEngineering => serializer.serialize_i32(2),
            Self::UnwantedSoftware => serializer.serialize_i32(3),
            Self::SocialEngineeringExtendedCoverage => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ThreatType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ThreatType>::new(
            ".google.cloud.webrisk.v1.ThreatType"))
    }
}

/// The ways in which threat entry sets can be compressed.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CompressionType {
    /// Unknown.
    Unspecified,
    /// Raw, uncompressed data.
    Raw,
    /// Rice-Golomb encoded data.
    Rice,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CompressionType::value] or
    /// [CompressionType::name].
    UnknownValue(compression_type::UnknownValue),
}

#[doc(hidden)]
pub mod compression_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CompressionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Raw => std::option::Option::Some(1),
            Self::Rice => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPRESSION_TYPE_UNSPECIFIED"),
            Self::Raw => std::option::Option::Some("RAW"),
            Self::Rice => std::option::Option::Some("RICE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CompressionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CompressionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CompressionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Raw,
            2 => Self::Rice,
            _ => Self::UnknownValue(compression_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for CompressionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPRESSION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RAW" => Self::Raw,
            "RICE" => Self::Rice,
            _ => Self::UnknownValue(compression_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for CompressionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Raw => serializer.serialize_i32(1),
            Self::Rice => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CompressionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompressionType>::new(
            ".google.cloud.webrisk.v1.CompressionType"))
    }
}
