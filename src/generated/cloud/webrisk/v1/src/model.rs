// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes an API diff request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeThreatListDiffRequest {
    /// Required. The threat list to update. Only a single ThreatType should be
    /// specified per request. If you want to handle multiple ThreatTypes, you must
    /// make one request per ThreatType.
    pub threat_type: crate::model::ThreatType,

    /// The current version token of the client for the requested list (the
    /// client version that was received from the last successful diff).
    /// If the client does not have a version token (this is the first time calling
    /// ComputeThreatListDiff), this may be left empty and a full database
    /// snapshot will be returned.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub version_token: ::bytes::Bytes,

    /// Required. The constraints associated with this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub constraints:
        std::option::Option<crate::model::compute_threat_list_diff_request::Constraints>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat_type][crate::model::ComputeThreatListDiffRequest::threat_type].
    pub fn set_threat_type<T: std::convert::Into<crate::model::ThreatType>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_type = v.into();
        self
    }

    /// Sets the value of [version_token][crate::model::ComputeThreatListDiffRequest::version_token].
    pub fn set_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.version_token = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    pub fn set_constraints<
        T: std::convert::Into<
                std::option::Option<crate::model::compute_threat_list_diff_request::Constraints>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraints = v.into();
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest"
    }
}

/// Defines additional types related to [ComputeThreatListDiffRequest].
pub mod compute_threat_list_diff_request {
    #[allow(unused_imports)]
    use super::*;

    /// The constraints for this diff.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Constraints {
        /// The maximum size in number of entries. The diff will not contain more
        /// entries than this value.  This should be a power of 2 between 2**10 and
        /// 2**20.  If zero, no diff size limit is set.
        pub max_diff_entries: i32,

        /// Sets the maximum number of entries that the client is willing to have
        /// in the local database. This should be a power of 2 between 2**10 and
        /// 2**20. If zero, no database size limit is set.
        pub max_database_entries: i32,

        /// The compression types supported by the client.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub supported_compressions: std::vec::Vec<crate::model::CompressionType>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Constraints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_diff_entries][crate::model::compute_threat_list_diff_request::Constraints::max_diff_entries].
        pub fn set_max_diff_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_diff_entries = v.into();
            self
        }

        /// Sets the value of [max_database_entries][crate::model::compute_threat_list_diff_request::Constraints::max_database_entries].
        pub fn set_max_database_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_database_entries = v.into();
            self
        }

        /// Sets the value of [supported_compressions][crate::model::compute_threat_list_diff_request::Constraints::supported_compressions].
        pub fn set_supported_compressions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CompressionType>,
        {
            use std::iter::Iterator;
            self.supported_compressions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Constraints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest.Constraints"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeThreatListDiffResponse {
    /// The type of response. This may indicate that an action must be taken by the
    /// client when the response is received.
    pub response_type: crate::model::compute_threat_list_diff_response::ResponseType,

    /// A set of entries to add to a local threat type's list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub additions: std::option::Option<crate::model::ThreatEntryAdditions>,

    /// A set of entries to remove from a local threat type's list.
    /// This field may be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub removals: std::option::Option<crate::model::ThreatEntryRemovals>,

    /// The new opaque client version token. This should be retained by the client
    /// and passed into the next call of ComputeThreatListDiff as 'version_token'.
    /// A separate version token should be stored and used for each threatList.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub new_version_token: ::bytes::Bytes,

    /// The expected SHA256 hash of the client state; that is, of the sorted list
    /// of all hashes present in the database after applying the provided diff.
    /// If the client state doesn't match the expected state, the client must
    /// discard this diff and retry later.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub checksum: std::option::Option<crate::model::compute_threat_list_diff_response::Checksum>,

    /// The soonest the client should wait before issuing any diff
    /// request. Querying sooner is unlikely to produce a meaningful diff.
    /// Waiting longer is acceptable considering the use case.
    /// If this field is not set clients may update as soon as they want.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recommended_next_diff: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_type][crate::model::ComputeThreatListDiffResponse::response_type].
    pub fn set_response_type<
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::ResponseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    pub fn set_additions<
        T: std::convert::Into<std::option::Option<crate::model::ThreatEntryAdditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additions = v.into();
        self
    }

    /// Sets the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    pub fn set_removals<
        T: std::convert::Into<std::option::Option<crate::model::ThreatEntryRemovals>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.removals = v.into();
        self
    }

    /// Sets the value of [new_version_token][crate::model::ComputeThreatListDiffResponse::new_version_token].
    pub fn set_new_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.new_version_token = v.into();
        self
    }

    /// Sets the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    pub fn set_checksum<
        T: std::convert::Into<
                std::option::Option<crate::model::compute_threat_list_diff_response::Checksum>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.checksum = v.into();
        self
    }

    /// Sets the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    pub fn set_recommended_next_diff<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_next_diff = v.into();
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse"
    }
}

/// Defines additional types related to [ComputeThreatListDiffResponse].
pub mod compute_threat_list_diff_response {
    #[allow(unused_imports)]
    use super::*;

    /// The expected state of a client's local database.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Checksum {
        /// The SHA256 hash of the client state; that is, of the sorted list of all
        /// hashes present in the database.
        #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub sha256: ::bytes::Bytes,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Checksum {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sha256][crate::model::compute_threat_list_diff_response::Checksum::sha256].
        pub fn set_sha256<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for Checksum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse.Checksum"
        }
    }

    /// The type of response sent to the client.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ResponseType(i32);

    impl ResponseType {
        /// Unknown.
        pub const RESPONSE_TYPE_UNSPECIFIED: ResponseType = ResponseType::new(0);

        /// Partial updates are applied to the client's existing local database.
        pub const DIFF: ResponseType = ResponseType::new(1);

        /// Full updates resets the client's entire local database. This means
        /// that either the client had no state, was seriously out-of-date,
        /// or the client is believed to be corrupt.
        pub const RESET: ResponseType = ResponseType::new(2);

        /// Creates a new ResponseType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESPONSE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DIFF"),
                2 => std::borrow::Cow::Borrowed("RESET"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESPONSE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RESPONSE_TYPE_UNSPECIFIED)
                }
                "DIFF" => std::option::Option::Some(Self::DIFF),
                "RESET" => std::option::Option::Some(Self::RESET),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ResponseType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ResponseType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request to check URI entries against threatLists.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchUrisRequest {
    /// Required. The URI to be checked for matches.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::SearchUrisRequest::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchUrisRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchUrisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchUrisResponse {
    /// The threat list matches. This might be empty if the URI is on no list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat: std::option::Option<crate::model::search_uris_response::ThreatUri>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat][crate::model::SearchUrisResponse::threat].
    pub fn set_threat<
        T: std::convert::Into<std::option::Option<crate::model::search_uris_response::ThreatUri>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat = v.into();
        self
    }
}

impl wkt::message::Message for SearchUrisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse"
    }
}

/// Defines additional types related to [SearchUrisResponse].
pub mod search_uris_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching uri.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatUri {
        /// The ThreatList this threat belongs to.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub expire_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatUri {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.expire_time = v.into();
            self
        }

        /// Sets the value of [threat_types][crate::model::search_uris_response::ThreatUri::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatUri {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse.ThreatUri"
        }
    }
}

/// Request to return full hashes matched by the provided hash prefixes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchHashesRequest {
    /// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
    /// hash. For JSON requests, this field is base64-encoded.
    /// Note that if this parameter is provided by a URI, it must be encoded using
    /// the web safe base64 variant (RFC 4648).
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub hash_prefix: ::bytes::Bytes,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hash_prefix][crate::model::SearchHashesRequest::hash_prefix].
    pub fn set_hash_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hash_prefix = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchHashesRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchHashesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchHashesResponse {
    /// The full hashes that matched the requested prefixes.
    /// The hash will be populated in the key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threats: std::vec::Vec<crate::model::search_hashes_response::ThreatHash>,

    /// For requested entities that did not match the threat list, how long to
    /// cache the response until.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub negative_expire_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    pub fn set_negative_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.negative_expire_time = v.into();
        self
    }

    /// Sets the value of [threats][crate::model::SearchHashesResponse::threats].
    pub fn set_threats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_hashes_response::ThreatHash>,
    {
        use std::iter::Iterator;
        self.threats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchHashesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse"
    }
}

/// Defines additional types related to [SearchHashesResponse].
pub mod search_hashes_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching hash.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatHash {
        /// The ThreatList this threat belongs to.
        /// This must contain at least one entry.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// A 32 byte SHA256 hash. This field is in binary format. For JSON
        /// requests, hashes are base64-encoded.
        #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub hash: ::bytes::Bytes,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub expire_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatHash {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hash][crate::model::search_hashes_response::ThreatHash::hash].
        pub fn set_hash<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.hash = v.into();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.expire_time = v.into();
            self
        }

        /// Sets the value of [threat_types][crate::model::search_hashes_response::ThreatHash::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatHash {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse.ThreatHash"
        }
    }
}

/// Contains the set of entries to add to a local database.
/// May contain a combination of compressed and raw data in a single response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatEntryAdditions {
    /// The raw SHA256-formatted entries.
    /// Repeated to allow returning sets of hashes with different prefix sizes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub raw_hashes: std::vec::Vec<crate::model::RawHashes>,

    /// The encoded 4-byte prefixes of SHA256-formatted entries, using a
    /// Golomb-Rice encoding. The hashes are converted to uint32, sorted in
    /// ascending order, then delta encoded and stored as encoded_data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rice_hashes: std::option::Option<crate::model::RiceDeltaEncoding>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryAdditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    pub fn set_rice_hashes<
        T: std::convert::Into<std::option::Option<crate::model::RiceDeltaEncoding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rice_hashes = v.into();
        self
    }

    /// Sets the value of [raw_hashes][crate::model::ThreatEntryAdditions::raw_hashes].
    pub fn set_raw_hashes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RawHashes>,
    {
        use std::iter::Iterator;
        self.raw_hashes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ThreatEntryAdditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryAdditions"
    }
}

/// Contains the set of entries to remove from a local database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatEntryRemovals {
    /// The raw removal indices for a local list.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub raw_indices: std::option::Option<crate::model::RawIndices>,

    /// The encoded local, lexicographically-sorted list indices, using a
    /// Golomb-Rice encoding. Used for sending compressed removal indices. The
    /// removal indices (uint32) are sorted in ascending order, then delta encoded
    /// and stored as encoded_data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rice_indices: std::option::Option<crate::model::RiceDeltaEncoding>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryRemovals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    pub fn set_raw_indices<T: std::convert::Into<std::option::Option<crate::model::RawIndices>>>(
        mut self,
        v: T,
    ) -> Self {
        self.raw_indices = v.into();
        self
    }

    /// Sets the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    pub fn set_rice_indices<
        T: std::convert::Into<std::option::Option<crate::model::RiceDeltaEncoding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rice_indices = v.into();
        self
    }
}

impl wkt::message::Message for ThreatEntryRemovals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryRemovals"
    }
}

/// A set of raw indices to remove from a local list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawIndices {
    /// The indices to remove from a lexicographically-sorted local list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indices: std::vec::Vec<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawIndices {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indices][crate::model::RawIndices::indices].
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RawIndices {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawIndices"
    }
}

/// The uncompressed threat entries in hash format.
/// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
/// bytes, but some hashes are lengthened if they collide with the hash of a
/// popular URI.
///
/// Used for sending ThreatEntryAdditons to clients that do not support
/// compression, or when sending non-4-byte hashes to clients that do support
/// compression.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawHashes {
    /// The number of bytes for each prefix encoded below.  This field can be
    /// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
    /// In practice this is almost always 4, except in exceptional circumstances.
    pub prefix_size: i32,

    /// The hashes, in binary format, concatenated into one long string. Hashes are
    /// sorted in lexicographic order. For JSON API users, hashes are
    /// base64-encoded.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub raw_hashes: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prefix_size][crate::model::RawHashes::prefix_size].
    pub fn set_prefix_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.prefix_size = v.into();
        self
    }

    /// Sets the value of [raw_hashes][crate::model::RawHashes::raw_hashes].
    pub fn set_raw_hashes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_hashes = v.into();
        self
    }
}

impl wkt::message::Message for RawHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawHashes"
    }
}

/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
/// compressed removal indices.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RiceDeltaEncoding {
    /// The offset of the first entry in the encoded data, or, if only a single
    /// integer was encoded, that single integer's value. If the field is empty or
    /// missing, assume zero.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub first_value: i64,

    /// The Golomb-Rice parameter, which is a number between 2 and 28. This field
    /// is missing (that is, zero) if `num_entries` is zero.
    pub rice_parameter: i32,

    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    pub entry_count: i32,

    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub encoded_data: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiceDeltaEncoding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_value][crate::model::RiceDeltaEncoding::first_value].
    pub fn set_first_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.first_value = v.into();
        self
    }

    /// Sets the value of [rice_parameter][crate::model::RiceDeltaEncoding::rice_parameter].
    pub fn set_rice_parameter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rice_parameter = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::RiceDeltaEncoding::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [encoded_data][crate::model::RiceDeltaEncoding::encoded_data].
    pub fn set_encoded_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.encoded_data = v.into();
        self
    }
}

impl wkt::message::Message for RiceDeltaEncoding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RiceDeltaEncoding"
    }
}

/// Wraps a URI that might be displaying malicious content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Submission {
    /// Required. The URI that is being reported for malicious content to be
    /// analyzed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Output only. ThreatTypes found to be associated with the submitted URI
    /// after reviewing it. This might be empty if the URI was not added to any
    /// list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Submission {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::Submission::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::Submission::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Submission {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.Submission"
    }
}

/// Context about the submission including the type of abuse found on the URI and
/// supporting details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatInfo {
    /// The type of abuse.
    pub abuse_type: crate::model::threat_info::AbuseType,

    /// Confidence that the URI is unsafe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_confidence: std::option::Option<crate::model::threat_info::Confidence>,

    /// Context about why the URI is unsafe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_justification: std::option::Option<crate::model::threat_info::ThreatJustification>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [abuse_type][crate::model::ThreatInfo::abuse_type].
    pub fn set_abuse_type<T: std::convert::Into<crate::model::threat_info::AbuseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.abuse_type = v.into();
        self
    }

    /// Sets the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    pub fn set_threat_confidence<
        T: std::convert::Into<std::option::Option<crate::model::threat_info::Confidence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat_confidence = v.into();
        self
    }

    /// Sets the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    pub fn set_threat_justification<
        T: std::convert::Into<std::option::Option<crate::model::threat_info::ThreatJustification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat_justification = v.into();
        self
    }
}

impl wkt::message::Message for ThreatInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo"
    }
}

/// Defines additional types related to [ThreatInfo].
pub mod threat_info {
    #[allow(unused_imports)]
    use super::*;

    /// Confidence that a URI is unsafe.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Confidence {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::threat_info::confidence::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Confidence {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::threat_info::confidence::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Score`, `None` if the field is not set or
        /// holds a different branch.
        pub fn score(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Score(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Level`, `None` if the field is not set or
        /// holds a different branch.
        pub fn level(
            &self,
        ) -> std::option::Option<&crate::model::threat_info::confidence::ConfidenceLevel> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Level(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Score`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Score(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Level`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_level<
            T: std::convert::Into<crate::model::threat_info::confidence::ConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Level(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Confidence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.Confidence"
        }
    }

    /// Defines additional types related to [Confidence].
    pub mod confidence {
        #[allow(unused_imports)]
        use super::*;

        /// Enum representation of confidence.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ConfidenceLevel(i32);

        impl ConfidenceLevel {
            /// Default.
            pub const CONFIDENCE_LEVEL_UNSPECIFIED: ConfidenceLevel = ConfidenceLevel::new(0);

            /// Less than 60% confidence that the URI is unsafe.
            pub const LOW: ConfidenceLevel = ConfidenceLevel::new(1);

            /// Between 60% and 80% confidence that the URI is unsafe.
            pub const MEDIUM: ConfidenceLevel = ConfidenceLevel::new(2);

            /// Greater than 80% confidence that the URI is unsafe.
            pub const HIGH: ConfidenceLevel = ConfidenceLevel::new(3);

            /// Creates a new ConfidenceLevel instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("CONFIDENCE_LEVEL_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("LOW"),
                    2 => std::borrow::Cow::Borrowed("MEDIUM"),
                    3 => std::borrow::Cow::Borrowed("HIGH"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "CONFIDENCE_LEVEL_UNSPECIFIED" => {
                        std::option::Option::Some(Self::CONFIDENCE_LEVEL_UNSPECIFIED)
                    }
                    "LOW" => std::option::Option::Some(Self::LOW),
                    "MEDIUM" => std::option::Option::Some(Self::MEDIUM),
                    "HIGH" => std::option::Option::Some(Self::HIGH),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for ConfidenceLevel {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for ConfidenceLevel {
            fn default() -> Self {
                Self::new(0)
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// A decimal representation of confidence in the range of 0
            /// to 1 where 0 indicates no confidence and 1 indicates
            /// complete confidence.
            Score(f32),
            /// Enum representation of confidence.
            Level(crate::model::threat_info::confidence::ConfidenceLevel),
        }
    }

    /// Context about why the URI is unsafe.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThreatJustification {
        /// Labels associated with this URI that explain how it was classified.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub labels:
            std::vec::Vec<crate::model::threat_info::threat_justification::JustificationLabel>,

        /// Free-form context on why this URI is unsafe.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub comments: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatJustification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::threat_info::ThreatJustification::labels].
        pub fn set_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::threat_info::threat_justification::JustificationLabel,
                >,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [comments][crate::model::threat_info::ThreatJustification::comments].
        pub fn set_comments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.comments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatJustification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.ThreatJustification"
        }
    }

    /// Defines additional types related to [ThreatJustification].
    pub mod threat_justification {
        #[allow(unused_imports)]
        use super::*;

        /// Labels that explain how the URI was classified.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct JustificationLabel(i32);

        impl JustificationLabel {
            /// Default.
            pub const JUSTIFICATION_LABEL_UNSPECIFIED: JustificationLabel =
                JustificationLabel::new(0);

            /// The submitter manually verified that the submission is unsafe.
            pub const MANUAL_VERIFICATION: JustificationLabel = JustificationLabel::new(1);

            /// The submitter received the submission from an end user.
            pub const USER_REPORT: JustificationLabel = JustificationLabel::new(2);

            /// The submitter received the submission from an automated system.
            pub const AUTOMATED_REPORT: JustificationLabel = JustificationLabel::new(3);

            /// Creates a new JustificationLabel instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("JUSTIFICATION_LABEL_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("MANUAL_VERIFICATION"),
                    2 => std::borrow::Cow::Borrowed("USER_REPORT"),
                    3 => std::borrow::Cow::Borrowed("AUTOMATED_REPORT"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "JUSTIFICATION_LABEL_UNSPECIFIED" => {
                        std::option::Option::Some(Self::JUSTIFICATION_LABEL_UNSPECIFIED)
                    }
                    "MANUAL_VERIFICATION" => std::option::Option::Some(Self::MANUAL_VERIFICATION),
                    "USER_REPORT" => std::option::Option::Some(Self::USER_REPORT),
                    "AUTOMATED_REPORT" => std::option::Option::Some(Self::AUTOMATED_REPORT),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for JustificationLabel {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for JustificationLabel {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// The abuse type found on the URI.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AbuseType(i32);

    impl AbuseType {
        /// Default.
        pub const ABUSE_TYPE_UNSPECIFIED: AbuseType = AbuseType::new(0);

        /// The URI contains malware.
        pub const MALWARE: AbuseType = AbuseType::new(1);

        /// The URI contains social engineering.
        pub const SOCIAL_ENGINEERING: AbuseType = AbuseType::new(2);

        /// The URI contains unwanted software.
        pub const UNWANTED_SOFTWARE: AbuseType = AbuseType::new(3);

        /// Creates a new AbuseType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ABUSE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("MALWARE"),
                2 => std::borrow::Cow::Borrowed("SOCIAL_ENGINEERING"),
                3 => std::borrow::Cow::Borrowed("UNWANTED_SOFTWARE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ABUSE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::ABUSE_TYPE_UNSPECIFIED),
                "MALWARE" => std::option::Option::Some(Self::MALWARE),
                "SOCIAL_ENGINEERING" => std::option::Option::Some(Self::SOCIAL_ENGINEERING),
                "UNWANTED_SOFTWARE" => std::option::Option::Some(Self::UNWANTED_SOFTWARE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AbuseType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AbuseType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details about how the threat was discovered.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThreatDiscovery {
    /// Platform on which the threat was discovered.
    pub platform: crate::model::threat_discovery::Platform,

    /// CLDR region code of the countries/regions the URI poses a threat ordered
    /// from most impact to least impact. Example: "US" for United States.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub region_codes: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatDiscovery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [platform][crate::model::ThreatDiscovery::platform].
    pub fn set_platform<T: std::convert::Into<crate::model::threat_discovery::Platform>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [region_codes][crate::model::ThreatDiscovery::region_codes].
    pub fn set_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ThreatDiscovery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatDiscovery"
    }
}

/// Defines additional types related to [ThreatDiscovery].
pub mod threat_discovery {
    #[allow(unused_imports)]
    use super::*;

    /// Platform types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Platform(i32);

    impl Platform {
        /// Default.
        pub const PLATFORM_UNSPECIFIED: Platform = Platform::new(0);

        /// General Android platform.
        pub const ANDROID: Platform = Platform::new(1);

        /// General iOS platform.
        pub const IOS: Platform = Platform::new(2);

        /// General macOS platform.
        pub const MACOS: Platform = Platform::new(3);

        /// General Windows platform.
        pub const WINDOWS: Platform = Platform::new(4);

        /// Creates a new Platform instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PLATFORM_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ANDROID"),
                2 => std::borrow::Cow::Borrowed("IOS"),
                3 => std::borrow::Cow::Borrowed("MACOS"),
                4 => std::borrow::Cow::Borrowed("WINDOWS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PLATFORM_UNSPECIFIED" => std::option::Option::Some(Self::PLATFORM_UNSPECIFIED),
                "ANDROID" => std::option::Option::Some(Self::ANDROID),
                "IOS" => std::option::Option::Some(Self::IOS),
                "MACOS" => std::option::Option::Some(Self::MACOS),
                "WINDOWS" => std::option::Option::Some(Self::WINDOWS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Platform {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Platform {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request to send a potentially phishy URI to WebRisk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSubmissionRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The submission that contains the content of the phishing report.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submission: std::option::Option<crate::model::Submission>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSubmissionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSubmissionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::CreateSubmissionRequest::submission].
    pub fn set_submission<T: std::convert::Into<std::option::Option<crate::model::Submission>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submission = v.into();
        self
    }
}

impl wkt::message::Message for CreateSubmissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.CreateSubmissionRequest"
    }
}

/// Request to send a potentially malicious URI to WebRisk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitUriRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The submission that contains the URI to be scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submission: std::option::Option<crate::model::Submission>,

    /// Provides additional information about the submission.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_info: std::option::Option<crate::model::ThreatInfo>,

    /// Provides additional information about how the submission was discovered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threat_discovery: std::option::Option<crate::model::ThreatDiscovery>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitUriRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::SubmitUriRequest::submission].
    pub fn set_submission<T: std::convert::Into<std::option::Option<crate::model::Submission>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submission = v.into();
        self
    }

    /// Sets the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    pub fn set_threat_info<T: std::convert::Into<std::option::Option<crate::model::ThreatInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_info = v.into();
        self
    }

    /// Sets the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    pub fn set_threat_discovery<
        T: std::convert::Into<std::option::Option<crate::model::ThreatDiscovery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threat_discovery = v.into();
        self
    }
}

impl wkt::message::Message for SubmitUriRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriRequest"
    }
}

/// Metadata for the Submit URI long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitUriMetadata {
    /// The state of the operation.
    pub state: crate::model::submit_uri_metadata::State,

    /// Creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Latest update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::SubmitUriMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::submit_uri_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for SubmitUriMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriMetadata"
    }
}

/// Defines additional types related to [SubmitUriMetadata].
pub mod submit_uri_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the state of the long-running operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Default unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The operation is currently running.
        pub const RUNNING: State = State::new(1);

        /// The operation finished with a success status.
        pub const SUCCEEDED: State = State::new(2);

        /// The operation was cancelled.
        pub const CANCELLED: State = State::new(3);

        /// The operation finished with a failure status.
        pub const FAILED: State = State::new(4);

        /// The operation was closed with no action taken.
        pub const CLOSED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                3 => std::borrow::Cow::Borrowed("CANCELLED"),
                4 => std::borrow::Cow::Borrowed("FAILED"),
                5 => std::borrow::Cow::Borrowed("CLOSED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "CLOSED" => std::option::Option::Some(Self::CLOSED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The type of threat. This maps directly to the threat list a threat may
/// belong to.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ThreatType(i32);

impl ThreatType {
    /// No entries should match this threat type. This threat type is unused.
    pub const THREAT_TYPE_UNSPECIFIED: ThreatType = ThreatType::new(0);

    /// Malware targeting any platform.
    pub const MALWARE: ThreatType = ThreatType::new(1);

    /// Social engineering targeting any platform.
    pub const SOCIAL_ENGINEERING: ThreatType = ThreatType::new(2);

    /// Unwanted software targeting any platform.
    pub const UNWANTED_SOFTWARE: ThreatType = ThreatType::new(3);

    /// A list of extended coverage social engineering URIs targeting any
    /// platform.
    pub const SOCIAL_ENGINEERING_EXTENDED_COVERAGE: ThreatType = ThreatType::new(4);

    /// Creates a new ThreatType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("THREAT_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("MALWARE"),
            2 => std::borrow::Cow::Borrowed("SOCIAL_ENGINEERING"),
            3 => std::borrow::Cow::Borrowed("UNWANTED_SOFTWARE"),
            4 => std::borrow::Cow::Borrowed("SOCIAL_ENGINEERING_EXTENDED_COVERAGE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "THREAT_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::THREAT_TYPE_UNSPECIFIED),
            "MALWARE" => std::option::Option::Some(Self::MALWARE),
            "SOCIAL_ENGINEERING" => std::option::Option::Some(Self::SOCIAL_ENGINEERING),
            "UNWANTED_SOFTWARE" => std::option::Option::Some(Self::UNWANTED_SOFTWARE),
            "SOCIAL_ENGINEERING_EXTENDED_COVERAGE" => {
                std::option::Option::Some(Self::SOCIAL_ENGINEERING_EXTENDED_COVERAGE)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ThreatType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ThreatType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The ways in which threat entry sets can be compressed.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct CompressionType(i32);

impl CompressionType {
    /// Unknown.
    pub const COMPRESSION_TYPE_UNSPECIFIED: CompressionType = CompressionType::new(0);

    /// Raw, uncompressed data.
    pub const RAW: CompressionType = CompressionType::new(1);

    /// Rice-Golomb encoded data.
    pub const RICE: CompressionType = CompressionType::new(2);

    /// Creates a new CompressionType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("COMPRESSION_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("RAW"),
            2 => std::borrow::Cow::Borrowed("RICE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "COMPRESSION_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::COMPRESSION_TYPE_UNSPECIFIED)
            }
            "RAW" => std::option::Option::Some(Self::RAW),
            "RICE" => std::option::Option::Some(Self::RICE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for CompressionType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for CompressionType {
    fn default() -> Self {
        Self::new(0)
    }
}
