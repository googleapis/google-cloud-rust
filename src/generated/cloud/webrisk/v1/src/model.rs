// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes an API diff request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeThreatListDiffRequest {
    /// Required. The threat list to update. Only a single ThreatType should be
    /// specified per request. If you want to handle multiple ThreatTypes, you must
    /// make one request per ThreatType.
    pub threat_type: crate::model::ThreatType,

    /// The current version token of the client for the requested list (the
    /// client version that was received from the last successful diff).
    /// If the client does not have a version token (this is the first time calling
    /// ComputeThreatListDiff), this may be left empty and a full database
    /// snapshot will be returned.
    pub version_token: ::bytes::Bytes,

    /// Required. The constraints associated with this request.
    pub constraints:
        std::option::Option<crate::model::compute_threat_list_diff_request::Constraints>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat_type][crate::model::ComputeThreatListDiffRequest::threat_type].
    pub fn set_threat_type<T: std::convert::Into<crate::model::ThreatType>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_type = v.into();
        self
    }

    /// Sets the value of [version_token][crate::model::ComputeThreatListDiffRequest::version_token].
    pub fn set_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.version_token = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    pub fn set_constraints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_request::Constraints>,
    {
        self.constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraints][crate::model::ComputeThreatListDiffRequest::constraints].
    pub fn set_or_clear_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_request::Constraints>,
    {
        self.constraints = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeThreatListDiffRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threat_type,
            __version_token,
            __constraints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeThreatListDiffRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threatType" => Ok(__FieldTag::__threat_type),
                            "threat_type" => Ok(__FieldTag::__threat_type),
                            "versionToken" => Ok(__FieldTag::__version_token),
                            "version_token" => Ok(__FieldTag::__version_token),
                            "constraints" => Ok(__FieldTag::__constraints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeThreatListDiffRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeThreatListDiffRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threat_type => {
                            if !fields.insert(__FieldTag::__threat_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_type",
                                ));
                            }
                            result.threat_type = map
                                .next_value::<std::option::Option<crate::model::ThreatType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_token => {
                            if !fields.insert(__FieldTag::__version_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_token",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version_token =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__constraints => {
                            if !fields.insert(__FieldTag::__constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraints",
                                ));
                            }
                            result.constraints = map.next_value::<std::option::Option<
                                crate::model::compute_threat_list_diff_request::Constraints,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeThreatListDiffRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.threat_type) {
            state.serialize_entry("threatType", &self.threat_type)?;
        }
        if !self.version_token.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("versionToken", &__With(&self.version_token))?;
        }
        if self.constraints.is_some() {
            state.serialize_entry("constraints", &self.constraints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ComputeThreatListDiffRequest].
pub mod compute_threat_list_diff_request {
    #[allow(unused_imports)]
    use super::*;

    /// The constraints for this diff.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Constraints {
        /// The maximum size in number of entries. The diff will not contain more
        /// entries than this value.  This should be a power of 2 between 2**10 and
        /// 2**20.  If zero, no diff size limit is set.
        pub max_diff_entries: i32,

        /// Sets the maximum number of entries that the client is willing to have
        /// in the local database. This should be a power of 2 between 2**10 and
        /// 2**20. If zero, no database size limit is set.
        pub max_database_entries: i32,

        /// The compression types supported by the client.
        pub supported_compressions: std::vec::Vec<crate::model::CompressionType>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Constraints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_diff_entries][crate::model::compute_threat_list_diff_request::Constraints::max_diff_entries].
        pub fn set_max_diff_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_diff_entries = v.into();
            self
        }

        /// Sets the value of [max_database_entries][crate::model::compute_threat_list_diff_request::Constraints::max_database_entries].
        pub fn set_max_database_entries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_database_entries = v.into();
            self
        }

        /// Sets the value of [supported_compressions][crate::model::compute_threat_list_diff_request::Constraints::supported_compressions].
        pub fn set_supported_compressions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CompressionType>,
        {
            use std::iter::Iterator;
            self.supported_compressions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Constraints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffRequest.Constraints"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Constraints {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __max_diff_entries,
                __max_database_entries,
                __supported_compressions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Constraints")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "maxDiffEntries" => Ok(__FieldTag::__max_diff_entries),
                                "max_diff_entries" => Ok(__FieldTag::__max_diff_entries),
                                "maxDatabaseEntries" => Ok(__FieldTag::__max_database_entries),
                                "max_database_entries" => Ok(__FieldTag::__max_database_entries),
                                "supportedCompressions" => Ok(__FieldTag::__supported_compressions),
                                "supported_compressions" => {
                                    Ok(__FieldTag::__supported_compressions)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Constraints;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Constraints")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__max_diff_entries => {
                                if !fields.insert(__FieldTag::__max_diff_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_diff_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_diff_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max_database_entries => {
                                if !fields.insert(__FieldTag::__max_database_entries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_database_entries",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_database_entries =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__supported_compressions => {
                                if !fields.insert(__FieldTag::__supported_compressions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for supported_compressions",
                                    ));
                                }
                                result.supported_compressions = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::CompressionType>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Constraints {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.max_diff_entries) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxDiffEntries", &__With(&self.max_diff_entries))?;
            }
            if !wkt::internal::is_default(&self.max_database_entries) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxDatabaseEntries", &__With(&self.max_database_entries))?;
            }
            if !self.supported_compressions.is_empty() {
                state.serialize_entry("supportedCompressions", &self.supported_compressions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeThreatListDiffResponse {
    /// The type of response. This may indicate that an action must be taken by the
    /// client when the response is received.
    pub response_type: crate::model::compute_threat_list_diff_response::ResponseType,

    /// A set of entries to add to a local threat type's list.
    pub additions: std::option::Option<crate::model::ThreatEntryAdditions>,

    /// A set of entries to remove from a local threat type's list.
    /// This field may be empty.
    pub removals: std::option::Option<crate::model::ThreatEntryRemovals>,

    /// The new opaque client version token. This should be retained by the client
    /// and passed into the next call of ComputeThreatListDiff as 'version_token'.
    /// A separate version token should be stored and used for each threatList.
    pub new_version_token: ::bytes::Bytes,

    /// The expected SHA256 hash of the client state; that is, of the sorted list
    /// of all hashes present in the database after applying the provided diff.
    /// If the client state doesn't match the expected state, the client must
    /// discard this diff and retry later.
    pub checksum: std::option::Option<crate::model::compute_threat_list_diff_response::Checksum>,

    /// The soonest the client should wait before issuing any diff
    /// request. Querying sooner is unlikely to produce a meaningful diff.
    /// Waiting longer is acceptable considering the use case.
    /// If this field is not set clients may update as soon as they want.
    pub recommended_next_diff: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeThreatListDiffResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_type][crate::model::ComputeThreatListDiffResponse::response_type].
    pub fn set_response_type<
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::ResponseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    pub fn set_additions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryAdditions>,
    {
        self.additions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additions][crate::model::ComputeThreatListDiffResponse::additions].
    pub fn set_or_clear_additions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryAdditions>,
    {
        self.additions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    pub fn set_removals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryRemovals>,
    {
        self.removals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [removals][crate::model::ComputeThreatListDiffResponse::removals].
    pub fn set_or_clear_removals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatEntryRemovals>,
    {
        self.removals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [new_version_token][crate::model::ComputeThreatListDiffResponse::new_version_token].
    pub fn set_new_version_token<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.new_version_token = v.into();
        self
    }

    /// Sets the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    pub fn set_checksum<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::Checksum>,
    {
        self.checksum = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [checksum][crate::model::ComputeThreatListDiffResponse::checksum].
    pub fn set_or_clear_checksum<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::compute_threat_list_diff_response::Checksum>,
    {
        self.checksum = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    pub fn set_recommended_next_diff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recommended_next_diff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recommended_next_diff][crate::model::ComputeThreatListDiffResponse::recommended_next_diff].
    pub fn set_or_clear_recommended_next_diff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recommended_next_diff = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComputeThreatListDiffResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeThreatListDiffResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_type,
            __additions,
            __removals,
            __new_version_token,
            __checksum,
            __recommended_next_diff,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeThreatListDiffResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseType" => Ok(__FieldTag::__response_type),
                            "response_type" => Ok(__FieldTag::__response_type),
                            "additions" => Ok(__FieldTag::__additions),
                            "removals" => Ok(__FieldTag::__removals),
                            "newVersionToken" => Ok(__FieldTag::__new_version_token),
                            "new_version_token" => Ok(__FieldTag::__new_version_token),
                            "checksum" => Ok(__FieldTag::__checksum),
                            "recommendedNextDiff" => Ok(__FieldTag::__recommended_next_diff),
                            "recommended_next_diff" => Ok(__FieldTag::__recommended_next_diff),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeThreatListDiffResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeThreatListDiffResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_type => {
                            if !fields.insert(__FieldTag::__response_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_type",
                                ));
                            }
                            result.response_type = map
                                .next_value::<std::option::Option<
                                    crate::model::compute_threat_list_diff_response::ResponseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additions => {
                            if !fields.insert(__FieldTag::__additions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additions",
                                ));
                            }
                            result.additions = map.next_value::<std::option::Option<crate::model::ThreatEntryAdditions>>()?
                                ;
                        }
                        __FieldTag::__removals => {
                            if !fields.insert(__FieldTag::__removals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for removals",
                                ));
                            }
                            result.removals = map.next_value::<std::option::Option<crate::model::ThreatEntryRemovals>>()?
                                ;
                        }
                        __FieldTag::__new_version_token => {
                            if !fields.insert(__FieldTag::__new_version_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_version_token",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_version_token =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__checksum => {
                            if !fields.insert(__FieldTag::__checksum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for checksum",
                                ));
                            }
                            result.checksum = map.next_value::<std::option::Option<
                                crate::model::compute_threat_list_diff_response::Checksum,
                            >>()?;
                        }
                        __FieldTag::__recommended_next_diff => {
                            if !fields.insert(__FieldTag::__recommended_next_diff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recommended_next_diff",
                                ));
                            }
                            result.recommended_next_diff =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeThreatListDiffResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.response_type) {
            state.serialize_entry("responseType", &self.response_type)?;
        }
        if self.additions.is_some() {
            state.serialize_entry("additions", &self.additions)?;
        }
        if self.removals.is_some() {
            state.serialize_entry("removals", &self.removals)?;
        }
        if !self.new_version_token.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newVersionToken", &__With(&self.new_version_token))?;
        }
        if self.checksum.is_some() {
            state.serialize_entry("checksum", &self.checksum)?;
        }
        if self.recommended_next_diff.is_some() {
            state.serialize_entry("recommendedNextDiff", &self.recommended_next_diff)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ComputeThreatListDiffResponse].
pub mod compute_threat_list_diff_response {
    #[allow(unused_imports)]
    use super::*;

    /// The expected state of a client's local database.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Checksum {
        /// The SHA256 hash of the client state; that is, of the sorted list of all
        /// hashes present in the database.
        pub sha256: ::bytes::Bytes,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Checksum {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sha256][crate::model::compute_threat_list_diff_response::Checksum::sha256].
        pub fn set_sha256<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for Checksum {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ComputeThreatListDiffResponse.Checksum"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Checksum {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sha256,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Checksum")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sha256" => Ok(__FieldTag::__sha256),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Checksum;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Checksum")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sha256 => {
                                if !fields.insert(__FieldTag::__sha256) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sha256",
                                    ));
                                }
                                struct __With(std::option::Option<::bytes::Bytes>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<serde_with::base64::Base64>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.sha256 = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Checksum {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sha256.is_empty() {
                struct __With<'a>(&'a ::bytes::Bytes);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sha256", &__With(&self.sha256))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The type of response sent to the client.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResponseType {
        /// Unknown.
        Unspecified,
        /// Partial updates are applied to the client's existing local database.
        Diff,
        /// Full updates resets the client's entire local database. This means
        /// that either the client had no state, was seriously out-of-date,
        /// or the client is believed to be corrupt.
        Reset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResponseType::value] or
        /// [ResponseType::name].
        UnknownValue(response_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod response_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResponseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Diff => std::option::Option::Some(1),
                Self::Reset => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESPONSE_TYPE_UNSPECIFIED"),
                Self::Diff => std::option::Option::Some("DIFF"),
                Self::Reset => std::option::Option::Some("RESET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResponseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResponseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResponseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Diff,
                2 => Self::Reset,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResponseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESPONSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DIFF" => Self::Diff,
                "RESET" => Self::Reset,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResponseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Diff => serializer.serialize_i32(1),
                Self::Reset => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResponseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResponseType>::new(
                ".google.cloud.webrisk.v1.ComputeThreatListDiffResponse.ResponseType",
            ))
        }
    }
}

/// Request to check URI entries against threatLists.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchUrisRequest {
    /// Required. The URI to be checked for matches.
    pub uri: std::string::String,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::SearchUrisRequest::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchUrisRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchUrisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchUrisRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __threat_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchUrisRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "threatTypes" => Ok(__FieldTag::__threat_types),
                            "threat_types" => Ok(__FieldTag::__threat_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchUrisRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchUrisRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__threat_types => {
                            if !fields.insert(__FieldTag::__threat_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_types",
                                ));
                            }
                            result.threat_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ThreatType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchUrisRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.threat_types.is_empty() {
            state.serialize_entry("threatTypes", &self.threat_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchUrisResponse {
    /// The threat list matches. This might be empty if the URI is on no list.
    pub threat: std::option::Option<crate::model::search_uris_response::ThreatUri>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchUrisResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threat][crate::model::SearchUrisResponse::threat].
    pub fn set_threat<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_uris_response::ThreatUri>,
    {
        self.threat = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat][crate::model::SearchUrisResponse::threat].
    pub fn set_or_clear_threat<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_uris_response::ThreatUri>,
    {
        self.threat = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchUrisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchUrisResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threat,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchUrisResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threat" => Ok(__FieldTag::__threat),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchUrisResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchUrisResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threat => {
                            if !fields.insert(__FieldTag::__threat) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat",
                                ));
                            }
                            result.threat = map.next_value::<std::option::Option<
                                crate::model::search_uris_response::ThreatUri,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchUrisResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.threat.is_some() {
            state.serialize_entry("threat", &self.threat)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchUrisResponse].
pub mod search_uris_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching uri.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThreatUri {
        /// The ThreatList this threat belongs to.
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        pub expire_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatUri {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threat_types][crate::model::search_uris_response::ThreatUri::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        pub fn set_expire_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expire_time][crate::model::search_uris_response::ThreatUri::expire_time].
        pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ThreatUri {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchUrisResponse.ThreatUri"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ThreatUri {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __threat_types,
                __expire_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ThreatUri")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "threatTypes" => Ok(__FieldTag::__threat_types),
                                "threat_types" => Ok(__FieldTag::__threat_types),
                                "expireTime" => Ok(__FieldTag::__expire_time),
                                "expire_time" => Ok(__FieldTag::__expire_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ThreatUri;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ThreatUri")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__threat_types => {
                                if !fields.insert(__FieldTag::__threat_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for threat_types",
                                    ));
                                }
                                result.threat_types =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ThreatType>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__expire_time => {
                                if !fields.insert(__FieldTag::__expire_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expire_time",
                                    ));
                                }
                                result.expire_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ThreatUri {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.threat_types.is_empty() {
                state.serialize_entry("threatTypes", &self.threat_types)?;
            }
            if self.expire_time.is_some() {
                state.serialize_entry("expireTime", &self.expire_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Request to return full hashes matched by the provided hash prefixes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchHashesRequest {
    /// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
    /// hash. For JSON requests, this field is base64-encoded.
    /// Note that if this parameter is provided by a URI, it must be encoded using
    /// the web safe base64 variant (RFC 4648).
    pub hash_prefix: ::bytes::Bytes,

    /// Required. The ThreatLists to search in. Multiple ThreatLists may be
    /// specified.
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hash_prefix][crate::model::SearchHashesRequest::hash_prefix].
    pub fn set_hash_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hash_prefix = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::SearchHashesRequest::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchHashesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchHashesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hash_prefix,
            __threat_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchHashesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hashPrefix" => Ok(__FieldTag::__hash_prefix),
                            "hash_prefix" => Ok(__FieldTag::__hash_prefix),
                            "threatTypes" => Ok(__FieldTag::__threat_types),
                            "threat_types" => Ok(__FieldTag::__threat_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchHashesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchHashesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hash_prefix => {
                            if !fields.insert(__FieldTag::__hash_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hash_prefix",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hash_prefix = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__threat_types => {
                            if !fields.insert(__FieldTag::__threat_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_types",
                                ));
                            }
                            result.threat_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ThreatType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchHashesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hash_prefix.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hashPrefix", &__With(&self.hash_prefix))?;
        }
        if !self.threat_types.is_empty() {
            state.serialize_entry("threatTypes", &self.threat_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchHashesResponse {
    /// The full hashes that matched the requested prefixes.
    /// The hash will be populated in the key.
    pub threats: std::vec::Vec<crate::model::search_hashes_response::ThreatHash>,

    /// For requested entities that did not match the threat list, how long to
    /// cache the response until.
    pub negative_expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchHashesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threats][crate::model::SearchHashesResponse::threats].
    pub fn set_threats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_hashes_response::ThreatHash>,
    {
        use std::iter::Iterator;
        self.threats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    pub fn set_negative_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.negative_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [negative_expire_time][crate::model::SearchHashesResponse::negative_expire_time].
    pub fn set_or_clear_negative_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.negative_expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchHashesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchHashesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threats,
            __negative_expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchHashesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threats" => Ok(__FieldTag::__threats),
                            "negativeExpireTime" => Ok(__FieldTag::__negative_expire_time),
                            "negative_expire_time" => Ok(__FieldTag::__negative_expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchHashesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchHashesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threats => {
                            if !fields.insert(__FieldTag::__threats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threats",
                                ));
                            }
                            result.threats = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::search_hashes_response::ThreatHash>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__negative_expire_time => {
                            if !fields.insert(__FieldTag::__negative_expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for negative_expire_time",
                                ));
                            }
                            result.negative_expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchHashesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.threats.is_empty() {
            state.serialize_entry("threats", &self.threats)?;
        }
        if self.negative_expire_time.is_some() {
            state.serialize_entry("negativeExpireTime", &self.negative_expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchHashesResponse].
pub mod search_hashes_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains threat information on a matching hash.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThreatHash {
        /// The ThreatList this threat belongs to.
        /// This must contain at least one entry.
        pub threat_types: std::vec::Vec<crate::model::ThreatType>,

        /// A 32 byte SHA256 hash. This field is in binary format. For JSON
        /// requests, hashes are base64-encoded.
        pub hash: ::bytes::Bytes,

        /// The cache lifetime for the returned match. Clients must not cache this
        /// response past this timestamp to avoid false positives.
        pub expire_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatHash {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threat_types][crate::model::search_hashes_response::ThreatHash::threat_types].
        pub fn set_threat_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ThreatType>,
        {
            use std::iter::Iterator;
            self.threat_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [hash][crate::model::search_hashes_response::ThreatHash::hash].
        pub fn set_hash<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.hash = v.into();
            self
        }

        /// Sets the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        pub fn set_expire_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expire_time][crate::model::search_hashes_response::ThreatHash::expire_time].
        pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ThreatHash {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.SearchHashesResponse.ThreatHash"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ThreatHash {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __threat_types,
                __hash,
                __expire_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ThreatHash")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "threatTypes" => Ok(__FieldTag::__threat_types),
                                "threat_types" => Ok(__FieldTag::__threat_types),
                                "hash" => Ok(__FieldTag::__hash),
                                "expireTime" => Ok(__FieldTag::__expire_time),
                                "expire_time" => Ok(__FieldTag::__expire_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ThreatHash;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ThreatHash")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__threat_types => {
                                if !fields.insert(__FieldTag::__threat_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for threat_types",
                                    ));
                                }
                                result.threat_types =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ThreatType>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__hash => {
                                if !fields.insert(__FieldTag::__hash) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hash",
                                    ));
                                }
                                struct __With(std::option::Option<::bytes::Bytes>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<serde_with::base64::Base64>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.hash = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__expire_time => {
                                if !fields.insert(__FieldTag::__expire_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expire_time",
                                    ));
                                }
                                result.expire_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ThreatHash {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.threat_types.is_empty() {
                state.serialize_entry("threatTypes", &self.threat_types)?;
            }
            if !self.hash.is_empty() {
                struct __With<'a>(&'a ::bytes::Bytes);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("hash", &__With(&self.hash))?;
            }
            if self.expire_time.is_some() {
                state.serialize_entry("expireTime", &self.expire_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Contains the set of entries to add to a local database.
/// May contain a combination of compressed and raw data in a single response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatEntryAdditions {
    /// The raw SHA256-formatted entries.
    /// Repeated to allow returning sets of hashes with different prefix sizes.
    pub raw_hashes: std::vec::Vec<crate::model::RawHashes>,

    /// The encoded 4-byte prefixes of SHA256-formatted entries, using a
    /// Golomb-Rice encoding. The hashes are converted to uint32, sorted in
    /// ascending order, then delta encoded and stored as encoded_data.
    pub rice_hashes: std::option::Option<crate::model::RiceDeltaEncoding>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryAdditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_hashes][crate::model::ThreatEntryAdditions::raw_hashes].
    pub fn set_raw_hashes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RawHashes>,
    {
        use std::iter::Iterator;
        self.raw_hashes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    pub fn set_rice_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rice_hashes][crate::model::ThreatEntryAdditions::rice_hashes].
    pub fn set_or_clear_rice_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_hashes = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatEntryAdditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryAdditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ThreatEntryAdditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __raw_hashes,
            __rice_hashes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ThreatEntryAdditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rawHashes" => Ok(__FieldTag::__raw_hashes),
                            "raw_hashes" => Ok(__FieldTag::__raw_hashes),
                            "riceHashes" => Ok(__FieldTag::__rice_hashes),
                            "rice_hashes" => Ok(__FieldTag::__rice_hashes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ThreatEntryAdditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ThreatEntryAdditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__raw_hashes => {
                            if !fields.insert(__FieldTag::__raw_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_hashes",
                                ));
                            }
                            result.raw_hashes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RawHashes>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rice_hashes => {
                            if !fields.insert(__FieldTag::__rice_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rice_hashes",
                                ));
                            }
                            result.rice_hashes = map
                                .next_value::<std::option::Option<crate::model::RiceDeltaEncoding>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ThreatEntryAdditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.raw_hashes.is_empty() {
            state.serialize_entry("rawHashes", &self.raw_hashes)?;
        }
        if self.rice_hashes.is_some() {
            state.serialize_entry("riceHashes", &self.rice_hashes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains the set of entries to remove from a local database.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatEntryRemovals {
    /// The raw removal indices for a local list.
    pub raw_indices: std::option::Option<crate::model::RawIndices>,

    /// The encoded local, lexicographically-sorted list indices, using a
    /// Golomb-Rice encoding. Used for sending compressed removal indices. The
    /// removal indices (uint32) are sorted in ascending order, then delta encoded
    /// and stored as encoded_data.
    pub rice_indices: std::option::Option<crate::model::RiceDeltaEncoding>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatEntryRemovals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    pub fn set_raw_indices<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RawIndices>,
    {
        self.raw_indices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [raw_indices][crate::model::ThreatEntryRemovals::raw_indices].
    pub fn set_or_clear_raw_indices<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RawIndices>,
    {
        self.raw_indices = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    pub fn set_rice_indices<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_indices = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rice_indices][crate::model::ThreatEntryRemovals::rice_indices].
    pub fn set_or_clear_rice_indices<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RiceDeltaEncoding>,
    {
        self.rice_indices = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatEntryRemovals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatEntryRemovals"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ThreatEntryRemovals {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __raw_indices,
            __rice_indices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ThreatEntryRemovals")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rawIndices" => Ok(__FieldTag::__raw_indices),
                            "raw_indices" => Ok(__FieldTag::__raw_indices),
                            "riceIndices" => Ok(__FieldTag::__rice_indices),
                            "rice_indices" => Ok(__FieldTag::__rice_indices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ThreatEntryRemovals;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ThreatEntryRemovals")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__raw_indices => {
                            if !fields.insert(__FieldTag::__raw_indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_indices",
                                ));
                            }
                            result.raw_indices =
                                map.next_value::<std::option::Option<crate::model::RawIndices>>()?;
                        }
                        __FieldTag::__rice_indices => {
                            if !fields.insert(__FieldTag::__rice_indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rice_indices",
                                ));
                            }
                            result.rice_indices = map
                                .next_value::<std::option::Option<crate::model::RiceDeltaEncoding>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ThreatEntryRemovals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.raw_indices.is_some() {
            state.serialize_entry("rawIndices", &self.raw_indices)?;
        }
        if self.rice_indices.is_some() {
            state.serialize_entry("riceIndices", &self.rice_indices)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A set of raw indices to remove from a local list.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RawIndices {
    /// The indices to remove from a lexicographically-sorted local list.
    pub indices: std::vec::Vec<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawIndices {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indices][crate::model::RawIndices::indices].
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RawIndices {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawIndices"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RawIndices {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __indices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RawIndices")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "indices" => Ok(__FieldTag::__indices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RawIndices;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RawIndices")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__indices => {
                            if !fields.insert(__FieldTag::__indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indices",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.indices = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RawIndices {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("indices", &__With(&self.indices))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The uncompressed threat entries in hash format.
/// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
/// bytes, but some hashes are lengthened if they collide with the hash of a
/// popular URI.
///
/// Used for sending ThreatEntryAdditons to clients that do not support
/// compression, or when sending non-4-byte hashes to clients that do support
/// compression.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RawHashes {
    /// The number of bytes for each prefix encoded below.  This field can be
    /// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
    /// In practice this is almost always 4, except in exceptional circumstances.
    pub prefix_size: i32,

    /// The hashes, in binary format, concatenated into one long string. Hashes are
    /// sorted in lexicographic order. For JSON API users, hashes are
    /// base64-encoded.
    pub raw_hashes: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prefix_size][crate::model::RawHashes::prefix_size].
    pub fn set_prefix_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.prefix_size = v.into();
        self
    }

    /// Sets the value of [raw_hashes][crate::model::RawHashes::raw_hashes].
    pub fn set_raw_hashes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_hashes = v.into();
        self
    }
}

impl wkt::message::Message for RawHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RawHashes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RawHashes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __prefix_size,
            __raw_hashes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RawHashes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "prefixSize" => Ok(__FieldTag::__prefix_size),
                            "prefix_size" => Ok(__FieldTag::__prefix_size),
                            "rawHashes" => Ok(__FieldTag::__raw_hashes),
                            "raw_hashes" => Ok(__FieldTag::__raw_hashes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RawHashes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RawHashes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__prefix_size => {
                            if !fields.insert(__FieldTag::__prefix_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prefix_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.prefix_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__raw_hashes => {
                            if !fields.insert(__FieldTag::__raw_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_hashes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.raw_hashes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RawHashes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.prefix_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("prefixSize", &__With(&self.prefix_size))?;
        }
        if !self.raw_hashes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rawHashes", &__With(&self.raw_hashes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
/// compressed removal indices.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RiceDeltaEncoding {
    /// The offset of the first entry in the encoded data, or, if only a single
    /// integer was encoded, that single integer's value. If the field is empty or
    /// missing, assume zero.
    pub first_value: i64,

    /// The Golomb-Rice parameter, which is a number between 2 and 28. This field
    /// is missing (that is, zero) if `num_entries` is zero.
    pub rice_parameter: i32,

    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    pub entry_count: i32,

    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    pub encoded_data: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiceDeltaEncoding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_value][crate::model::RiceDeltaEncoding::first_value].
    pub fn set_first_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.first_value = v.into();
        self
    }

    /// Sets the value of [rice_parameter][crate::model::RiceDeltaEncoding::rice_parameter].
    pub fn set_rice_parameter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rice_parameter = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::RiceDeltaEncoding::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [encoded_data][crate::model::RiceDeltaEncoding::encoded_data].
    pub fn set_encoded_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.encoded_data = v.into();
        self
    }
}

impl wkt::message::Message for RiceDeltaEncoding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.RiceDeltaEncoding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RiceDeltaEncoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __first_value,
            __rice_parameter,
            __entry_count,
            __encoded_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RiceDeltaEncoding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firstValue" => Ok(__FieldTag::__first_value),
                            "first_value" => Ok(__FieldTag::__first_value),
                            "riceParameter" => Ok(__FieldTag::__rice_parameter),
                            "rice_parameter" => Ok(__FieldTag::__rice_parameter),
                            "entryCount" => Ok(__FieldTag::__entry_count),
                            "entry_count" => Ok(__FieldTag::__entry_count),
                            "encodedData" => Ok(__FieldTag::__encoded_data),
                            "encoded_data" => Ok(__FieldTag::__encoded_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RiceDeltaEncoding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RiceDeltaEncoding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__first_value => {
                            if !fields.insert(__FieldTag::__first_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.first_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rice_parameter => {
                            if !fields.insert(__FieldTag::__rice_parameter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rice_parameter",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rice_parameter =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__entry_count => {
                            if !fields.insert(__FieldTag::__entry_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.entry_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encoded_data => {
                            if !fields.insert(__FieldTag::__encoded_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoded_data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.encoded_data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RiceDeltaEncoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.first_value) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("firstValue", &__With(&self.first_value))?;
        }
        if !wkt::internal::is_default(&self.rice_parameter) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("riceParameter", &__With(&self.rice_parameter))?;
        }
        if !wkt::internal::is_default(&self.entry_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("entryCount", &__With(&self.entry_count))?;
        }
        if !self.encoded_data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("encodedData", &__With(&self.encoded_data))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Wraps a URI that might be displaying malicious content.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Submission {
    /// Required. The URI that is being reported for malicious content to be
    /// analyzed.
    pub uri: std::string::String,

    /// Output only. ThreatTypes found to be associated with the submitted URI
    /// after reviewing it. This might be empty if the URI was not added to any
    /// list.
    pub threat_types: std::vec::Vec<crate::model::ThreatType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Submission {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::Submission::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [threat_types][crate::model::Submission::threat_types].
    pub fn set_threat_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ThreatType>,
    {
        use std::iter::Iterator;
        self.threat_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Submission {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.Submission"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Submission {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __threat_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Submission")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "threatTypes" => Ok(__FieldTag::__threat_types),
                            "threat_types" => Ok(__FieldTag::__threat_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Submission;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Submission")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__threat_types => {
                            if !fields.insert(__FieldTag::__threat_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_types",
                                ));
                            }
                            result.threat_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ThreatType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Submission {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.threat_types.is_empty() {
            state.serialize_entry("threatTypes", &self.threat_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Context about the submission including the type of abuse found on the URI and
/// supporting details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatInfo {
    /// The type of abuse.
    pub abuse_type: crate::model::threat_info::AbuseType,

    /// Confidence that the URI is unsafe.
    pub threat_confidence: std::option::Option<crate::model::threat_info::Confidence>,

    /// Context about why the URI is unsafe.
    pub threat_justification: std::option::Option<crate::model::threat_info::ThreatJustification>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [abuse_type][crate::model::ThreatInfo::abuse_type].
    pub fn set_abuse_type<T: std::convert::Into<crate::model::threat_info::AbuseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.abuse_type = v.into();
        self
    }

    /// Sets the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    pub fn set_threat_confidence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::Confidence>,
    {
        self.threat_confidence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_confidence][crate::model::ThreatInfo::threat_confidence].
    pub fn set_or_clear_threat_confidence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::Confidence>,
    {
        self.threat_confidence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    pub fn set_threat_justification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::ThreatJustification>,
    {
        self.threat_justification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_justification][crate::model::ThreatInfo::threat_justification].
    pub fn set_or_clear_threat_justification<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::threat_info::ThreatJustification>,
    {
        self.threat_justification = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ThreatInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ThreatInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __abuse_type,
            __threat_confidence,
            __threat_justification,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ThreatInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "abuseType" => Ok(__FieldTag::__abuse_type),
                            "abuse_type" => Ok(__FieldTag::__abuse_type),
                            "threatConfidence" => Ok(__FieldTag::__threat_confidence),
                            "threat_confidence" => Ok(__FieldTag::__threat_confidence),
                            "threatJustification" => Ok(__FieldTag::__threat_justification),
                            "threat_justification" => Ok(__FieldTag::__threat_justification),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ThreatInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ThreatInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__abuse_type => {
                            if !fields.insert(__FieldTag::__abuse_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for abuse_type",
                                ));
                            }
                            result.abuse_type = map.next_value::<std::option::Option<crate::model::threat_info::AbuseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__threat_confidence => {
                            if !fields.insert(__FieldTag::__threat_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_confidence",
                                ));
                            }
                            result.threat_confidence = map.next_value::<std::option::Option<crate::model::threat_info::Confidence>>()?
                                ;
                        }
                        __FieldTag::__threat_justification => {
                            if !fields.insert(__FieldTag::__threat_justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_justification",
                                ));
                            }
                            result.threat_justification = map.next_value::<std::option::Option<
                                crate::model::threat_info::ThreatJustification,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ThreatInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.abuse_type) {
            state.serialize_entry("abuseType", &self.abuse_type)?;
        }
        if self.threat_confidence.is_some() {
            state.serialize_entry("threatConfidence", &self.threat_confidence)?;
        }
        if self.threat_justification.is_some() {
            state.serialize_entry("threatJustification", &self.threat_justification)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ThreatInfo].
pub mod threat_info {
    #[allow(unused_imports)]
    use super::*;

    /// Confidence that a URI is unsafe.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Confidence {
        pub value: std::option::Option<crate::model::threat_info::confidence::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Confidence {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::threat_info::confidence::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Score`, `None` if the field is not set or
        /// holds a different branch.
        pub fn score(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Score(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Score`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Score(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::threat_info::Confidence::value]
        /// if it holds a `Level`, `None` if the field is not set or
        /// holds a different branch.
        pub fn level(
            &self,
        ) -> std::option::Option<&crate::model::threat_info::confidence::ConfidenceLevel> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::threat_info::confidence::Value::Level(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::threat_info::Confidence::value]
        /// to hold a `Level`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_level<
            T: std::convert::Into<crate::model::threat_info::confidence::ConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::threat_info::confidence::Value::Level(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Confidence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.Confidence"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Confidence {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __score,
                __level,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Confidence")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "score" => Ok(__FieldTag::__score),
                                "level" => Ok(__FieldTag::__level),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Confidence;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Confidence")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.webrisk.v1.ThreatInfo.Confidence.score, latest field was score",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::threat_info::confidence::Value::Score(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__level => {
                                if !fields.insert(__FieldTag::__level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for level",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.webrisk.v1.ThreatInfo.Confidence.level, latest field was level",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::threat_info::confidence::Value::Level(
                                        map.next_value::<std::option::Option<
                                            crate::model::threat_info::confidence::ConfidenceLevel,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Confidence {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.score() {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(value))?;
            }
            if let Some(value) = self.level() {
                state.serialize_entry("level", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Confidence].
    pub mod confidence {
        #[allow(unused_imports)]
        use super::*;

        /// Enum representation of confidence.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ConfidenceLevel {
            /// Default.
            Unspecified,
            /// Less than 60% confidence that the URI is unsafe.
            Low,
            /// Between 60% and 80% confidence that the URI is unsafe.
            Medium,
            /// Greater than 80% confidence that the URI is unsafe.
            High,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ConfidenceLevel::value] or
            /// [ConfidenceLevel::name].
            UnknownValue(confidence_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod confidence_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ConfidenceLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Low => std::option::Option::Some(1),
                    Self::Medium => std::option::Option::Some(2),
                    Self::High => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CONFIDENCE_LEVEL_UNSPECIFIED"),
                    Self::Low => std::option::Option::Some("LOW"),
                    Self::Medium => std::option::Option::Some("MEDIUM"),
                    Self::High => std::option::Option::Some("HIGH"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ConfidenceLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ConfidenceLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ConfidenceLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Low,
                    2 => Self::Medium,
                    3 => Self::High,
                    _ => Self::UnknownValue(confidence_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ConfidenceLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONFIDENCE_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "LOW" => Self::Low,
                    "MEDIUM" => Self::Medium,
                    "HIGH" => Self::High,
                    _ => Self::UnknownValue(confidence_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ConfidenceLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Low => serializer.serialize_i32(1),
                    Self::Medium => serializer.serialize_i32(2),
                    Self::High => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ConfidenceLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConfidenceLevel>::new(
                    ".google.cloud.webrisk.v1.ThreatInfo.Confidence.ConfidenceLevel",
                ))
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// A decimal representation of confidence in the range of 0
            /// to 1 where 0 indicates no confidence and 1 indicates
            /// complete confidence.
            Score(f32),
            /// Enum representation of confidence.
            Level(crate::model::threat_info::confidence::ConfidenceLevel),
        }
    }

    /// Context about why the URI is unsafe.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThreatJustification {
        /// Labels associated with this URI that explain how it was classified.
        pub labels:
            std::vec::Vec<crate::model::threat_info::threat_justification::JustificationLabel>,

        /// Free-form context on why this URI is unsafe.
        pub comments: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThreatJustification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::threat_info::ThreatJustification::labels].
        pub fn set_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::threat_info::threat_justification::JustificationLabel,
                >,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [comments][crate::model::threat_info::ThreatJustification::comments].
        pub fn set_comments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.comments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ThreatJustification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.webrisk.v1.ThreatInfo.ThreatJustification"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ThreatJustification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __labels,
                __comments,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ThreatJustification")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "labels" => Ok(__FieldTag::__labels),
                                "comments" => Ok(__FieldTag::__comments),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ThreatJustification;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ThreatJustification")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::threat_info::threat_justification::JustificationLabel>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__comments => {
                                if !fields.insert(__FieldTag::__comments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for comments",
                                    ));
                                }
                                result.comments = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ThreatJustification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self.comments.is_empty() {
                state.serialize_entry("comments", &self.comments)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ThreatJustification].
    pub mod threat_justification {
        #[allow(unused_imports)]
        use super::*;

        /// Labels that explain how the URI was classified.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum JustificationLabel {
            /// Default.
            Unspecified,
            /// The submitter manually verified that the submission is unsafe.
            ManualVerification,
            /// The submitter received the submission from an end user.
            UserReport,
            /// The submitter received the submission from an automated system.
            AutomatedReport,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [JustificationLabel::value] or
            /// [JustificationLabel::name].
            UnknownValue(justification_label::UnknownValue),
        }

        #[doc(hidden)]
        pub mod justification_label {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl JustificationLabel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ManualVerification => std::option::Option::Some(1),
                    Self::UserReport => std::option::Option::Some(2),
                    Self::AutomatedReport => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("JUSTIFICATION_LABEL_UNSPECIFIED")
                    }
                    Self::ManualVerification => std::option::Option::Some("MANUAL_VERIFICATION"),
                    Self::UserReport => std::option::Option::Some("USER_REPORT"),
                    Self::AutomatedReport => std::option::Option::Some("AUTOMATED_REPORT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for JustificationLabel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for JustificationLabel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for JustificationLabel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ManualVerification,
                    2 => Self::UserReport,
                    3 => Self::AutomatedReport,
                    _ => Self::UnknownValue(justification_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for JustificationLabel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "JUSTIFICATION_LABEL_UNSPECIFIED" => Self::Unspecified,
                    "MANUAL_VERIFICATION" => Self::ManualVerification,
                    "USER_REPORT" => Self::UserReport,
                    "AUTOMATED_REPORT" => Self::AutomatedReport,
                    _ => Self::UnknownValue(justification_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for JustificationLabel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ManualVerification => serializer.serialize_i32(1),
                    Self::UserReport => serializer.serialize_i32(2),
                    Self::AutomatedReport => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for JustificationLabel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<JustificationLabel>::new(
                    ".google.cloud.webrisk.v1.ThreatInfo.ThreatJustification.JustificationLabel",
                ))
            }
        }
    }

    /// The abuse type found on the URI.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AbuseType {
        /// Default.
        Unspecified,
        /// The URI contains malware.
        Malware,
        /// The URI contains social engineering.
        SocialEngineering,
        /// The URI contains unwanted software.
        UnwantedSoftware,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AbuseType::value] or
        /// [AbuseType::name].
        UnknownValue(abuse_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod abuse_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AbuseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Malware => std::option::Option::Some(1),
                Self::SocialEngineering => std::option::Option::Some(2),
                Self::UnwantedSoftware => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ABUSE_TYPE_UNSPECIFIED"),
                Self::Malware => std::option::Option::Some("MALWARE"),
                Self::SocialEngineering => std::option::Option::Some("SOCIAL_ENGINEERING"),
                Self::UnwantedSoftware => std::option::Option::Some("UNWANTED_SOFTWARE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AbuseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AbuseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AbuseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Malware,
                2 => Self::SocialEngineering,
                3 => Self::UnwantedSoftware,
                _ => Self::UnknownValue(abuse_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AbuseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ABUSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MALWARE" => Self::Malware,
                "SOCIAL_ENGINEERING" => Self::SocialEngineering,
                "UNWANTED_SOFTWARE" => Self::UnwantedSoftware,
                _ => Self::UnknownValue(abuse_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AbuseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Malware => serializer.serialize_i32(1),
                Self::SocialEngineering => serializer.serialize_i32(2),
                Self::UnwantedSoftware => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AbuseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AbuseType>::new(
                ".google.cloud.webrisk.v1.ThreatInfo.AbuseType",
            ))
        }
    }
}

/// Details about how the threat was discovered.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ThreatDiscovery {
    /// Platform on which the threat was discovered.
    pub platform: crate::model::threat_discovery::Platform,

    /// CLDR region code of the countries/regions the URI poses a threat ordered
    /// from most impact to least impact. Example: "US" for United States.
    pub region_codes: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ThreatDiscovery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [platform][crate::model::ThreatDiscovery::platform].
    pub fn set_platform<T: std::convert::Into<crate::model::threat_discovery::Platform>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [region_codes][crate::model::ThreatDiscovery::region_codes].
    pub fn set_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ThreatDiscovery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.ThreatDiscovery"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ThreatDiscovery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __platform,
            __region_codes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ThreatDiscovery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "platform" => Ok(__FieldTag::__platform),
                            "regionCodes" => Ok(__FieldTag::__region_codes),
                            "region_codes" => Ok(__FieldTag::__region_codes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ThreatDiscovery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ThreatDiscovery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform",
                                ));
                            }
                            result.platform = map.next_value::<std::option::Option<crate::model::threat_discovery::Platform>>()?.unwrap_or_default();
                        }
                        __FieldTag::__region_codes => {
                            if !fields.insert(__FieldTag::__region_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region_codes",
                                ));
                            }
                            result.region_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ThreatDiscovery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.platform) {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self.region_codes.is_empty() {
            state.serialize_entry("regionCodes", &self.region_codes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ThreatDiscovery].
pub mod threat_discovery {
    #[allow(unused_imports)]
    use super::*;

    /// Platform types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Platform {
        /// Default.
        Unspecified,
        /// General Android platform.
        Android,
        /// General iOS platform.
        Ios,
        /// General macOS platform.
        Macos,
        /// General Windows platform.
        Windows,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Platform::value] or
        /// [Platform::name].
        UnknownValue(platform::UnknownValue),
    }

    #[doc(hidden)]
    pub mod platform {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Platform {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Android => std::option::Option::Some(1),
                Self::Ios => std::option::Option::Some(2),
                Self::Macos => std::option::Option::Some(3),
                Self::Windows => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PLATFORM_UNSPECIFIED"),
                Self::Android => std::option::Option::Some("ANDROID"),
                Self::Ios => std::option::Option::Some("IOS"),
                Self::Macos => std::option::Option::Some("MACOS"),
                Self::Windows => std::option::Option::Some("WINDOWS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Platform {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Platform {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Platform {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Android,
                2 => Self::Ios,
                3 => Self::Macos,
                4 => Self::Windows,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Platform {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLATFORM_UNSPECIFIED" => Self::Unspecified,
                "ANDROID" => Self::Android,
                "IOS" => Self::Ios,
                "MACOS" => Self::Macos,
                "WINDOWS" => Self::Windows,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Platform {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Android => serializer.serialize_i32(1),
                Self::Ios => serializer.serialize_i32(2),
                Self::Macos => serializer.serialize_i32(3),
                Self::Windows => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Platform {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Platform>::new(
                ".google.cloud.webrisk.v1.ThreatDiscovery.Platform",
            ))
        }
    }
}

/// Request to send a potentially phishy URI to WebRisk.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSubmissionRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    pub parent: std::string::String,

    /// Required. The submission that contains the content of the phishing report.
    pub submission: std::option::Option<crate::model::Submission>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSubmissionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSubmissionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::CreateSubmissionRequest::submission].
    pub fn set_submission<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submission][crate::model::CreateSubmissionRequest::submission].
    pub fn set_or_clear_submission<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSubmissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.CreateSubmissionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSubmissionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __submission,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSubmissionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "submission" => Ok(__FieldTag::__submission),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSubmissionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSubmissionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submission => {
                            if !fields.insert(__FieldTag::__submission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submission",
                                ));
                            }
                            result.submission =
                                map.next_value::<std::option::Option<crate::model::Submission>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSubmissionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.submission.is_some() {
            state.serialize_entry("submission", &self.submission)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to send a potentially malicious URI to WebRisk.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitUriRequest {
    /// Required. The name of the project that is making the submission. This
    /// string is in the format "projects/{project_number}".
    pub parent: std::string::String,

    /// Required. The submission that contains the URI to be scanned.
    pub submission: std::option::Option<crate::model::Submission>,

    /// Provides additional information about the submission.
    pub threat_info: std::option::Option<crate::model::ThreatInfo>,

    /// Provides additional information about how the submission was discovered.
    pub threat_discovery: std::option::Option<crate::model::ThreatDiscovery>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitUriRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [submission][crate::model::SubmitUriRequest::submission].
    pub fn set_submission<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submission][crate::model::SubmitUriRequest::submission].
    pub fn set_or_clear_submission<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Submission>,
    {
        self.submission = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    pub fn set_threat_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatInfo>,
    {
        self.threat_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_info][crate::model::SubmitUriRequest::threat_info].
    pub fn set_or_clear_threat_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatInfo>,
    {
        self.threat_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    pub fn set_threat_discovery<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ThreatDiscovery>,
    {
        self.threat_discovery = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threat_discovery][crate::model::SubmitUriRequest::threat_discovery].
    pub fn set_or_clear_threat_discovery<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ThreatDiscovery>,
    {
        self.threat_discovery = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitUriRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitUriRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __submission,
            __threat_info,
            __threat_discovery,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitUriRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "submission" => Ok(__FieldTag::__submission),
                            "threatInfo" => Ok(__FieldTag::__threat_info),
                            "threat_info" => Ok(__FieldTag::__threat_info),
                            "threatDiscovery" => Ok(__FieldTag::__threat_discovery),
                            "threat_discovery" => Ok(__FieldTag::__threat_discovery),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitUriRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitUriRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submission => {
                            if !fields.insert(__FieldTag::__submission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submission",
                                ));
                            }
                            result.submission =
                                map.next_value::<std::option::Option<crate::model::Submission>>()?;
                        }
                        __FieldTag::__threat_info => {
                            if !fields.insert(__FieldTag::__threat_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_info",
                                ));
                            }
                            result.threat_info =
                                map.next_value::<std::option::Option<crate::model::ThreatInfo>>()?;
                        }
                        __FieldTag::__threat_discovery => {
                            if !fields.insert(__FieldTag::__threat_discovery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_discovery",
                                ));
                            }
                            result.threat_discovery = map
                                .next_value::<std::option::Option<crate::model::ThreatDiscovery>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitUriRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.submission.is_some() {
            state.serialize_entry("submission", &self.submission)?;
        }
        if self.threat_info.is_some() {
            state.serialize_entry("threatInfo", &self.threat_info)?;
        }
        if self.threat_discovery.is_some() {
            state.serialize_entry("threatDiscovery", &self.threat_discovery)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for the Submit URI long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitUriMetadata {
    /// The state of the operation.
    pub state: crate::model::submit_uri_metadata::State,

    /// Creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Latest update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitUriMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::SubmitUriMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::submit_uri_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SubmitUriMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SubmitUriMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitUriMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.webrisk.v1.SubmitUriMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitUriMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitUriMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitUriMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitUriMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::submit_uri_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitUriMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SubmitUriMetadata].
pub mod submit_uri_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the state of the long-running operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified state.
        Unspecified,
        /// The operation is currently running.
        Running,
        /// The operation finished with a success status.
        Succeeded,
        /// The operation was cancelled.
        Cancelled,
        /// The operation finished with a failure status.
        Failed,
        /// The operation was closed with no action taken.
        Closed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Closed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Closed => std::option::Option::Some("CLOSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Cancelled,
                4 => Self::Failed,
                5 => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "CLOSED" => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Closed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.webrisk.v1.SubmitUriMetadata.State",
            ))
        }
    }
}

/// The type of threat. This maps directly to the threat list a threat may
/// belong to.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ThreatType {
    /// No entries should match this threat type. This threat type is unused.
    Unspecified,
    /// Malware targeting any platform.
    Malware,
    /// Social engineering targeting any platform.
    SocialEngineering,
    /// Unwanted software targeting any platform.
    UnwantedSoftware,
    /// A list of extended coverage social engineering URIs targeting any
    /// platform.
    SocialEngineeringExtendedCoverage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ThreatType::value] or
    /// [ThreatType::name].
    UnknownValue(threat_type::UnknownValue),
}

#[doc(hidden)]
pub mod threat_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ThreatType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Malware => std::option::Option::Some(1),
            Self::SocialEngineering => std::option::Option::Some(2),
            Self::UnwantedSoftware => std::option::Option::Some(3),
            Self::SocialEngineeringExtendedCoverage => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("THREAT_TYPE_UNSPECIFIED"),
            Self::Malware => std::option::Option::Some("MALWARE"),
            Self::SocialEngineering => std::option::Option::Some("SOCIAL_ENGINEERING"),
            Self::UnwantedSoftware => std::option::Option::Some("UNWANTED_SOFTWARE"),
            Self::SocialEngineeringExtendedCoverage => {
                std::option::Option::Some("SOCIAL_ENGINEERING_EXTENDED_COVERAGE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ThreatType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ThreatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ThreatType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Malware,
            2 => Self::SocialEngineering,
            3 => Self::UnwantedSoftware,
            4 => Self::SocialEngineeringExtendedCoverage,
            _ => Self::UnknownValue(threat_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ThreatType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "THREAT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "MALWARE" => Self::Malware,
            "SOCIAL_ENGINEERING" => Self::SocialEngineering,
            "UNWANTED_SOFTWARE" => Self::UnwantedSoftware,
            "SOCIAL_ENGINEERING_EXTENDED_COVERAGE" => Self::SocialEngineeringExtendedCoverage,
            _ => Self::UnknownValue(threat_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ThreatType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Malware => serializer.serialize_i32(1),
            Self::SocialEngineering => serializer.serialize_i32(2),
            Self::UnwantedSoftware => serializer.serialize_i32(3),
            Self::SocialEngineeringExtendedCoverage => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ThreatType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ThreatType>::new(
            ".google.cloud.webrisk.v1.ThreatType",
        ))
    }
}

/// The ways in which threat entry sets can be compressed.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CompressionType {
    /// Unknown.
    Unspecified,
    /// Raw, uncompressed data.
    Raw,
    /// Rice-Golomb encoded data.
    Rice,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CompressionType::value] or
    /// [CompressionType::name].
    UnknownValue(compression_type::UnknownValue),
}

#[doc(hidden)]
pub mod compression_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CompressionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Raw => std::option::Option::Some(1),
            Self::Rice => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPRESSION_TYPE_UNSPECIFIED"),
            Self::Raw => std::option::Option::Some("RAW"),
            Self::Rice => std::option::Option::Some("RICE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CompressionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CompressionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CompressionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Raw,
            2 => Self::Rice,
            _ => Self::UnknownValue(compression_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CompressionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPRESSION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RAW" => Self::Raw,
            "RICE" => Self::Rice,
            _ => Self::UnknownValue(compression_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CompressionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Raw => serializer.serialize_i32(1),
            Self::Rice => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CompressionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompressionType>::new(
            ".google.cloud.webrisk.v1.CompressionType",
        ))
    }
}
