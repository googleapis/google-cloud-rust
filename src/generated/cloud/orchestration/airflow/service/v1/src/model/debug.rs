// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::CreateEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateEnvironmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEnvironmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListEnvironmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEnvironmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListEnvironmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEnvironmentsResponse");
        debug_struct.field("environments", &self.environments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteEnvironmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateEnvironmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExecuteAirflowCommandRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecuteAirflowCommandRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("command", &self.command);
        debug_struct.field("subcommand", &self.subcommand);
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExecuteAirflowCommandResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecuteAirflowCommandResponse");
        debug_struct.field("execution_id", &self.execution_id);
        debug_struct.field("pod", &self.pod);
        debug_struct.field("pod_namespace", &self.pod_namespace);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StopAirflowCommandRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopAirflowCommandRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("execution_id", &self.execution_id);
        debug_struct.field("pod", &self.pod);
        debug_struct.field("pod_namespace", &self.pod_namespace);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StopAirflowCommandResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopAirflowCommandResponse");
        debug_struct.field("is_done", &self.is_done);
        debug_struct.field("output", &self.output);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PollAirflowCommandRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PollAirflowCommandRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("execution_id", &self.execution_id);
        debug_struct.field("pod", &self.pod);
        debug_struct.field("pod_namespace", &self.pod_namespace);
        debug_struct.field("next_line_number", &self.next_line_number);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PollAirflowCommandResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PollAirflowCommandResponse");
        debug_struct.field("output", &self.output);
        debug_struct.field("output_end", &self.output_end);
        debug_struct.field("exit_info", &self.exit_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::poll_airflow_command_response::Line {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Line");
        debug_struct.field("line_number", &self.line_number);
        debug_struct.field("content", &self.content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::poll_airflow_command_response::ExitInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExitInfo");
        debug_struct.field("exit_code", &self.exit_code);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateUserWorkloadsSecretRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("user_workloads_secret", &self.user_workloads_secret);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetUserWorkloadsSecretRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListUserWorkloadsSecretsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsSecretsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateUserWorkloadsSecretRequest");
        debug_struct.field("user_workloads_secret", &self.user_workloads_secret);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteUserWorkloadsSecretRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateUserWorkloadsConfigMapRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("user_workloads_config_map", &self.user_workloads_config_map);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetUserWorkloadsConfigMapRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListUserWorkloadsConfigMapsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsConfigMapsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateUserWorkloadsConfigMapRequest");
        debug_struct.field("user_workloads_config_map", &self.user_workloads_config_map);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteUserWorkloadsConfigMapRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UserWorkloadsSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserWorkloadsSecret");
        debug_struct.field("name", &self.name);
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListUserWorkloadsSecretsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsSecretsResponse");
        debug_struct.field("user_workloads_secrets", &self.user_workloads_secrets);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UserWorkloadsConfigMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserWorkloadsConfigMap");
        debug_struct.field("name", &self.name);
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListUserWorkloadsConfigMapsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsConfigMapsResponse");
        debug_struct.field(
            "user_workloads_config_maps",
            &self.user_workloads_config_maps,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkloadsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkloadsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkloadsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkloadsResponse");
        debug_struct.field("workloads", &self.workloads);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::list_workloads_response::ComposerWorkload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComposerWorkload");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::list_workloads_response::ComposerWorkloadStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComposerWorkloadStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("detailed_status_message", &self.detailed_status_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SaveSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SaveSnapshotRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("snapshot_location", &self.snapshot_location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SaveSnapshotResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SaveSnapshotResponse");
        debug_struct.field("snapshot_path", &self.snapshot_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoadSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadSnapshotRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("snapshot_path", &self.snapshot_path);
        debug_struct.field(
            "skip_pypi_packages_installation",
            &self.skip_pypi_packages_installation,
        );
        debug_struct.field(
            "skip_environment_variables_setting",
            &self.skip_environment_variables_setting,
        );
        debug_struct.field(
            "skip_airflow_overrides_setting",
            &self.skip_airflow_overrides_setting,
        );
        debug_struct.field("skip_gcs_data_copying", &self.skip_gcs_data_copying);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoadSnapshotResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadSnapshotResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseFailoverRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseFailoverRequest");
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseFailoverResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseFailoverResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchDatabasePropertiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchDatabasePropertiesRequest");
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchDatabasePropertiesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchDatabasePropertiesResponse");
        debug_struct.field("primary_gce_zone", &self.primary_gce_zone);
        debug_struct.field("secondary_gce_zone", &self.secondary_gce_zone);
        debug_struct.field(
            "is_failover_replica_available",
            &self.is_failover_replica_available,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageConfig");
        debug_struct.field("bucket", &self.bucket);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnvironmentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnvironmentConfig");
        debug_struct.field("gke_cluster", &self.gke_cluster);
        debug_struct.field("dag_gcs_prefix", &self.dag_gcs_prefix);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("software_config", &self.software_config);
        debug_struct.field("node_config", &self.node_config);
        debug_struct.field(
            "private_environment_config",
            &self.private_environment_config,
        );
        debug_struct.field(
            "web_server_network_access_control",
            &self.web_server_network_access_control,
        );
        debug_struct.field("database_config", &self.database_config);
        debug_struct.field("web_server_config", &self.web_server_config);
        debug_struct.field("encryption_config", &self.encryption_config);
        debug_struct.field("maintenance_window", &self.maintenance_window);
        debug_struct.field("workloads_config", &self.workloads_config);
        debug_struct.field("environment_size", &self.environment_size);
        debug_struct.field("airflow_uri", &self.airflow_uri);
        debug_struct.field("airflow_byoid_uri", &self.airflow_byoid_uri);
        debug_struct.field(
            "master_authorized_networks_config",
            &self.master_authorized_networks_config,
        );
        debug_struct.field("recovery_config", &self.recovery_config);
        debug_struct.field("resilience_mode", &self.resilience_mode);
        debug_struct.field("data_retention_config", &self.data_retention_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WebServerNetworkAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebServerNetworkAccessControl");
        debug_struct.field("allowed_ip_ranges", &self.allowed_ip_ranges);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::web_server_network_access_control::AllowedIpRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AllowedIpRange");
        debug_struct.field("value", &self.value);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseConfig");
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("zone", &self.zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WebServerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebServerConfig");
        debug_struct.field("machine_type", &self.machine_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfig");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("recurrence", &self.recurrence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SoftwareConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoftwareConfig");
        debug_struct.field("image_version", &self.image_version);
        debug_struct.field("airflow_config_overrides", &self.airflow_config_overrides);
        debug_struct.field("pypi_packages", &self.pypi_packages);
        debug_struct.field("env_variables", &self.env_variables);
        debug_struct.field("python_version", &self.python_version);
        debug_struct.field("scheduler_count", &self.scheduler_count);
        debug_struct.field(
            "cloud_data_lineage_integration",
            &self.cloud_data_lineage_integration,
        );
        debug_struct.field("web_server_plugins_mode", &self.web_server_plugins_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IPAllocationPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IPAllocationPolicy");
        debug_struct.field("use_ip_aliases", &self.use_ip_aliases);
        debug_struct.field("cluster_ip_allocation", &self.cluster_ip_allocation);
        debug_struct.field("services_ip_allocation", &self.services_ip_allocation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfig");
        debug_struct.field("location", &self.location);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("oauth_scopes", &self.oauth_scopes);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("ip_allocation_policy", &self.ip_allocation_policy);
        debug_struct.field("enable_ip_masq_agent", &self.enable_ip_masq_agent);
        debug_struct.field(
            "composer_network_attachment",
            &self.composer_network_attachment,
        );
        debug_struct.field(
            "composer_internal_ipv4_cidr_block",
            &self.composer_internal_ipv4_cidr_block,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivateClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateClusterConfig");
        debug_struct.field("enable_private_endpoint", &self.enable_private_endpoint);
        debug_struct.field("master_ipv4_cidr_block", &self.master_ipv4_cidr_block);
        debug_struct.field(
            "master_ipv4_reserved_range",
            &self.master_ipv4_reserved_range,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkingConfig");
        debug_struct.field("connection_type", &self.connection_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivateEnvironmentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateEnvironmentConfig");
        debug_struct.field(
            "enable_private_environment",
            &self.enable_private_environment,
        );
        debug_struct.field(
            "enable_private_builds_only",
            &self.enable_private_builds_only,
        );
        debug_struct.field("private_cluster_config", &self.private_cluster_config);
        debug_struct.field(
            "web_server_ipv4_cidr_block",
            &self.web_server_ipv4_cidr_block,
        );
        debug_struct.field("cloud_sql_ipv4_cidr_block", &self.cloud_sql_ipv4_cidr_block);
        debug_struct.field(
            "web_server_ipv4_reserved_range",
            &self.web_server_ipv4_reserved_range,
        );
        debug_struct.field(
            "cloud_composer_network_ipv4_cidr_block",
            &self.cloud_composer_network_ipv4_cidr_block,
        );
        debug_struct.field(
            "cloud_composer_network_ipv4_reserved_range",
            &self.cloud_composer_network_ipv4_reserved_range,
        );
        debug_struct.field(
            "enable_privately_used_public_ips",
            &self.enable_privately_used_public_ips,
        );
        debug_struct.field(
            "cloud_composer_connection_subnetwork",
            &self.cloud_composer_connection_subnetwork,
        );
        debug_struct.field("networking_config", &self.networking_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkloadsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadsConfig");
        debug_struct.field("scheduler", &self.scheduler);
        debug_struct.field("web_server", &self.web_server);
        debug_struct.field("worker", &self.worker);
        debug_struct.field("triggerer", &self.triggerer);
        debug_struct.field("dag_processor", &self.dag_processor);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::workloads_config::SchedulerResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchedulerResource");
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("memory_gb", &self.memory_gb);
        debug_struct.field("storage_gb", &self.storage_gb);
        debug_struct.field("count", &self.count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::workloads_config::WebServerResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebServerResource");
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("memory_gb", &self.memory_gb);
        debug_struct.field("storage_gb", &self.storage_gb);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::workloads_config::WorkerResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkerResource");
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("memory_gb", &self.memory_gb);
        debug_struct.field("storage_gb", &self.storage_gb);
        debug_struct.field("min_count", &self.min_count);
        debug_struct.field("max_count", &self.max_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::workloads_config::TriggererResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TriggererResource");
        debug_struct.field("count", &self.count);
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("memory_gb", &self.memory_gb);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::workloads_config::DagProcessorResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DagProcessorResource");
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("memory_gb", &self.memory_gb);
        debug_struct.field("storage_gb", &self.storage_gb);
        debug_struct.field("count", &self.count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RecoveryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecoveryConfig");
        debug_struct.field(
            "scheduled_snapshots_config",
            &self.scheduled_snapshots_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ScheduledSnapshotsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScheduledSnapshotsConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("snapshot_location", &self.snapshot_location);
        debug_struct.field(
            "snapshot_creation_schedule",
            &self.snapshot_creation_schedule,
        );
        debug_struct.field("time_zone", &self.time_zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MasterAuthorizedNetworksConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MasterAuthorizedNetworksConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("cidr_blocks", &self.cidr_blocks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::master_authorized_networks_config::CidrBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CidrBlock");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("cidr_block", &self.cidr_block);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudDataLineageIntegration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudDataLineageIntegration");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Environment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Environment");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("storage_config", &self.storage_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CheckUpgradeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckUpgradeRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("image_version", &self.image_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CheckUpgradeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckUpgradeResponse");
        debug_struct.field("build_log_uri", &self.build_log_uri);
        debug_struct.field(
            "contains_pypi_modules_conflict",
            &self.contains_pypi_modules_conflict,
        );
        debug_struct.field(
            "pypi_conflict_build_log_extract",
            &self.pypi_conflict_build_log_extract,
        );
        debug_struct.field("image_version", &self.image_version);
        debug_struct.field("pypi_dependencies", &self.pypi_dependencies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataRetentionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataRetentionConfig");
        debug_struct.field(
            "airflow_metadata_retention_config",
            &self.airflow_metadata_retention_config,
        );
        debug_struct.field(
            "task_logs_retention_config",
            &self.task_logs_retention_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TaskLogsRetentionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TaskLogsRetentionConfig");
        debug_struct.field("storage_mode", &self.storage_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AirflowMetadataRetentionPolicyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AirflowMetadataRetentionPolicyConfig");
        debug_struct.field("retention_mode", &self.retention_mode);
        debug_struct.field("retention_days", &self.retention_days);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListImageVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("include_past_releases", &self.include_past_releases);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListImageVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageVersionsResponse");
        debug_struct.field("image_versions", &self.image_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ImageVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageVersion");
        debug_struct.field("image_version_id", &self.image_version_id);
        debug_struct.field("is_default", &self.is_default);
        debug_struct.field("supported_python_versions", &self.supported_python_versions);
        debug_struct.field("release_date", &self.release_date);
        debug_struct.field("creation_disabled", &self.creation_disabled);
        debug_struct.field("upgrade_disabled", &self.upgrade_disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("resource_uuid", &self.resource_uuid);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
