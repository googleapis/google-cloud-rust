// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gclient;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Create a new environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEnvironmentRequest {
    /// The parent must be of the form
    /// "projects/{projectId}/locations/{locationId}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The environment to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub environment: std::option::Option<crate::model::Environment>,
}

impl CreateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnvironmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_environment<
        T: std::convert::Into<std::option::Option<crate::model::Environment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for CreateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CreateEnvironmentRequest"
    }
}

/// Get an environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEnvironmentRequest {
    /// The resource name of the environment to get, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.GetEnvironmentRequest"
    }
}

/// List environments in a project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnvironmentsRequest {
    /// List environments in the given project and location, in the form:
    /// "projects/{projectId}/locations/{locationId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of environments to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListEnvironmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnvironmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnvironmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnvironmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListEnvironmentsRequest"
    }
}

/// The environments in a project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnvironmentsResponse {
    /// The list of environments returned by a ListEnvironmentsRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub environments: std::vec::Vec<crate::model::Environment>,

    /// The page token used to query for the next page if one exists.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListEnvironmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEnvironmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [environments][crate::model::ListEnvironmentsResponse::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListEnvironmentsResponse"
    }
}

impl gax::paginator::PageableResponse for ListEnvironmentsResponse {
    type PageItem = crate::model::Environment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.environments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Delete an environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEnvironmentRequest {
    /// The environment to delete, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DeleteEnvironmentRequest"
    }
}

/// Update an environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEnvironmentRequest {
    /// The relative resource name of the environment to update, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A patch environment. Fields specified by the `updateMask` will be copied
    /// from the patch environment into the environment under update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub environment: std::option::Option<crate::model::Environment>,

    /// Required. A comma-separated list of paths, relative to `Environment`, of
    /// fields to update.
    /// For example, to set the version of scikit-learn to install in the
    /// environment to 0.19.0 and to remove an existing installation of
    /// numpy, the `updateMask` parameter would include the following two
    /// `paths` values: "config.softwareConfig.pypiPackages.scikit-learn" and
    /// "config.softwareConfig.pypiPackages.numpy". The included patch
    /// environment would specify the scikit-learn version as follows:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "softwareConfig":{
    ///       "pypiPackages":{
    ///         "scikit-learn":"==0.19.0"
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Note that in the above example, any existing PyPI packages
    /// other than scikit-learn and numpy will be unaffected.
    ///
    /// Only one update type may be included in a single request's `updateMask`.
    /// For example, one cannot update both the PyPI packages and
    /// labels in the same request. However, it is possible to update multiple
    /// members of a map field simultaneously in the same request. For example,
    /// to set the labels "label1" and "label2" while clearing "label3" (assuming
    /// it already exists), one can
    /// provide the paths "labels.label1", "labels.label2", and "labels.label3"
    /// and populate the patch environment as follows:
    ///
    /// ```norust
    /// {
    ///   "labels":{
    ///     "label1":"new-label1-value"
    ///     "label2":"new-label2-value"
    ///   }
    /// }
    /// ```
    ///
    /// Note that in the above example, any existing labels that are not
    /// included in the `updateMask` will be unaffected.
    ///
    /// It is also possible to replace an entire map field by providing the
    /// map field's path in the `updateMask`. The new value of the field will
    /// be that which is provided in the patch environment. For example, to
    /// delete all pre-existing user-specified PyPI packages and
    /// install botocore at version 1.7.14, the `updateMask` would contain
    /// the path "config.softwareConfig.pypiPackages", and
    /// the patch environment would be the following:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "softwareConfig":{
    ///       "pypiPackages":{
    ///         "botocore":"==1.7.14"
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// **Note:** Only the following fields can be updated:
    ///
    /// * `config.softwareConfig.pypiPackages`
    ///   * Replace all custom custom PyPI packages. If a replacement
    ///     package map is not included in `environment`, all custom
    ///     PyPI packages are cleared. It is an error to provide both
    ///     this mask and a mask specifying an individual package.
    /// * `config.softwareConfig.pypiPackages.`packagename
    ///   * Update the custom PyPI package *packagename*,
    ///     preserving other packages. To delete the package, include it in
    ///     `updateMask`, and omit the mapping for it in
    ///     `environment.config.softwareConfig.pypiPackages`. It is an error
    ///     to provide both a mask of this form and the
    ///     `config.softwareConfig.pypiPackages` mask.
    /// * `labels`
    ///   * Replace all environment labels. If a replacement labels map is not
    ///     included in `environment`, all labels are cleared. It is an error to
    ///     provide both this mask and a mask specifying one or more individual
    ///     labels.
    /// * `labels.`labelName
    ///   * Set the label named *labelName*, while preserving other
    ///     labels. To delete the label, include it in `updateMask` and omit its
    ///     mapping in `environment.labels`. It is an error to provide both a
    ///     mask of this form and the `labels` mask.
    /// * `config.nodeCount`
    ///   * Horizontally scale the number of nodes in the environment. An integer
    ///     greater than or equal to 3 must be provided in the `config.nodeCount`
    ///     field. Supported for Cloud Composer environments in versions
    ///     composer-1.*.*-airflow-*.*.*.
    /// * `config.webServerNetworkAccessControl`
    ///   * Replace the environment's current `WebServerNetworkAccessControl`.
    /// * `config.softwareConfig.airflowConfigOverrides`
    ///   * Replace all Apache Airflow config overrides. If a replacement config
    ///     overrides map is not included in `environment`, all config overrides
    ///     are cleared.
    ///     It is an error to provide both this mask and a mask specifying one or
    ///     more individual config overrides.
    /// * `config.softwareConfig.airflowConfigOverrides.`section-name
    ///   * Override the Apache Airflow config property *name* in the
    ///     section named *section*, preserving other properties. To
    ///     delete the property override, include it in `updateMask` and omit its
    ///     mapping in
    ///     `environment.config.softwareConfig.airflowConfigOverrides`.
    ///     It is an error to provide both a mask of this form and the
    ///     `config.softwareConfig.airflowConfigOverrides` mask.
    /// * `config.softwareConfig.envVariables`
    ///   * Replace all environment variables. If a replacement environment
    ///     variable map is not included in `environment`, all custom environment
    ///     variables are cleared.
    /// * `config.softwareConfig.schedulerCount`
    ///   * Horizontally scale the number of schedulers in Airflow. A positive
    ///     integer not greater than the number of nodes must be provided in the
    ///     `config.softwareConfig.schedulerCount` field. Supported for Cloud
    ///     Composer environments in versions composer-1.*.*-airflow-2.*.*.
    /// * `config.databaseConfig.machineType`
    ///   * Cloud SQL machine type used by Airflow database.
    ///     It has to be one of: db-n1-standard-2, db-n1-standard-4,
    ///     db-n1-standard-8 or db-n1-standard-16. Supported for Cloud Composer
    ///     environments in versions composer-1.*.*-airflow-*.*.*.
    /// * `config.webServerConfig.machineType`
    ///   * Machine type on which Airflow web server is running.
    ///     It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4
    ///     or composer-n1-webserver-8. Supported for Cloud Composer environments
    ///     in versions composer-1.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_environment<
        T: std::convert::Into<std::option::Option<crate::model::Environment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UpdateEnvironmentRequest"
    }
}

/// Execute Airflow Command request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecuteAirflowCommandRequest {
    /// The resource name of the environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,

    /// Airflow command.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub command: std::string::String,

    /// Airflow subcommand.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subcommand: std::string::String,

    /// Parameters for the Airflow command/subcommand as an array of arguments.
    /// It may contain positional arguments like `["my-dag-id"]`, key-value
    /// parameters like `["--foo=bar"]` or `["--foo","bar"]`,
    /// or other flags like `["-f"]`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<std::string::String>,
}

impl ExecuteAirflowCommandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::ExecuteAirflowCommandRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [command][crate::model::ExecuteAirflowCommandRequest::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [subcommand][crate::model::ExecuteAirflowCommandRequest::subcommand].
    pub fn set_subcommand<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subcommand = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::ExecuteAirflowCommandRequest::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExecuteAirflowCommandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ExecuteAirflowCommandRequest"
    }
}

/// Response to ExecuteAirflowCommandRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecuteAirflowCommandResponse {
    /// The unique ID of the command execution for polling.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution_id: std::string::String,

    /// The name of the pod where the command is executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod: std::string::String,

    /// The namespace of the pod where the command is executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod_namespace: std::string::String,

    /// Error message. Empty if there was no error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error: std::string::String,
}

impl ExecuteAirflowCommandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_id][crate::model::ExecuteAirflowCommandResponse::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::ExecuteAirflowCommandResponse::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [pod_namespace][crate::model::ExecuteAirflowCommandResponse::pod_namespace].
    pub fn set_pod_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_namespace = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ExecuteAirflowCommandResponse::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for ExecuteAirflowCommandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ExecuteAirflowCommandResponse"
    }
}

/// Stop Airflow Command request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopAirflowCommandRequest {
    /// The resource name of the environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,

    /// The unique ID of the command execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution_id: std::string::String,

    /// The name of the pod where the command is executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod: std::string::String,

    /// The namespace of the pod where the command is executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod_namespace: std::string::String,

    /// If true, the execution is terminated forcefully (SIGKILL). If false, the
    /// execution is stopped gracefully, giving it time for cleanup.
    pub force: bool,
}

impl StopAirflowCommandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::StopAirflowCommandRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [execution_id][crate::model::StopAirflowCommandRequest::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::StopAirflowCommandRequest::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [pod_namespace][crate::model::StopAirflowCommandRequest::pod_namespace].
    pub fn set_pod_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_namespace = v.into();
        self
    }

    /// Sets the value of [force][crate::model::StopAirflowCommandRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for StopAirflowCommandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.StopAirflowCommandRequest"
    }
}

/// Response to StopAirflowCommandRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopAirflowCommandResponse {
    /// Whether the execution is still running.
    pub is_done: bool,

    /// Output message from stopping execution request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub output: std::vec::Vec<std::string::String>,
}

impl StopAirflowCommandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_done][crate::model::StopAirflowCommandResponse::is_done].
    pub fn set_is_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_done = v.into();
        self
    }

    /// Sets the value of [output][crate::model::StopAirflowCommandResponse::output].
    pub fn set_output<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.output = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StopAirflowCommandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.StopAirflowCommandResponse"
    }
}

/// Poll Airflow Command request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PollAirflowCommandRequest {
    /// The resource name of the environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,

    /// The unique ID of the command execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution_id: std::string::String,

    /// The name of the pod where the command is executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod: std::string::String,

    /// The namespace of the pod where the command is executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod_namespace: std::string::String,

    /// Line number from which new logs should be fetched.
    pub next_line_number: i32,
}

impl PollAirflowCommandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::PollAirflowCommandRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [execution_id][crate::model::PollAirflowCommandRequest::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::PollAirflowCommandRequest::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [pod_namespace][crate::model::PollAirflowCommandRequest::pod_namespace].
    pub fn set_pod_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_namespace = v.into();
        self
    }

    /// Sets the value of [next_line_number][crate::model::PollAirflowCommandRequest::next_line_number].
    pub fn set_next_line_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.next_line_number = v.into();
        self
    }
}

impl wkt::message::Message for PollAirflowCommandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandRequest"
    }
}

/// Response to PollAirflowCommandRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PollAirflowCommandResponse {
    /// Output from the command execution. It may not contain the full output
    /// and the caller may need to poll for more lines.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub output: std::vec::Vec<crate::model::poll_airflow_command_response::Line>,

    /// Whether the command execution has finished and there is no more output.
    pub output_end: bool,

    /// The result exit status of the command.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exit_info: std::option::Option<crate::model::poll_airflow_command_response::ExitInfo>,
}

impl PollAirflowCommandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_end][crate::model::PollAirflowCommandResponse::output_end].
    pub fn set_output_end<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.output_end = v.into();
        self
    }

    /// Sets the value of [exit_info][crate::model::PollAirflowCommandResponse::exit_info].
    pub fn set_exit_info<
        T: std::convert::Into<
            std::option::Option<crate::model::poll_airflow_command_response::ExitInfo>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exit_info = v.into();
        self
    }

    /// Sets the value of [output][crate::model::PollAirflowCommandResponse::output].
    pub fn set_output<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::poll_airflow_command_response::Line>,
    {
        use std::iter::Iterator;
        self.output = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PollAirflowCommandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandResponse"
    }
}

/// Defines additional types related to PollAirflowCommandResponse
pub mod poll_airflow_command_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains information about a single line from logs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Line {
        /// Number of the line.
        pub line_number: i32,

        /// Text content of the log line.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub content: std::string::String,
    }

    impl Line {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line_number][crate::model::poll_airflow_command_response::Line::line_number].
        pub fn set_line_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.line_number = v.into();
            self
        }

        /// Sets the value of [content][crate::model::poll_airflow_command_response::Line::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }
    }

    impl wkt::message::Message for Line {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandResponse.Line"
        }
    }

    /// Information about how a command ended.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExitInfo {
        /// The exit code from the command execution.
        pub exit_code: i32,

        /// Error message. Empty if there was no error.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error: std::string::String,
    }

    impl ExitInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [exit_code][crate::model::poll_airflow_command_response::ExitInfo::exit_code].
        pub fn set_exit_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.exit_code = v.into();
            self
        }

        /// Sets the value of [error][crate::model::poll_airflow_command_response::ExitInfo::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for ExitInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandResponse.ExitInfo"
        }
    }
}

/// Create user workloads Secret request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateUserWorkloadsSecretRequest {
    /// Required. The environment name to create a Secret for, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User workloads Secret to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_workloads_secret: std::option::Option<crate::model::UserWorkloadsSecret>,
}

impl CreateUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserWorkloadsSecretRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_workloads_secret][crate::model::CreateUserWorkloadsSecretRequest::user_workloads_secret].
    pub fn set_user_workloads_secret<
        T: std::convert::Into<std::option::Option<crate::model::UserWorkloadsSecret>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_workloads_secret = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CreateUserWorkloadsSecretRequest"
    }
}

/// Get user workloads Secret request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetUserWorkloadsSecretRequest {
    /// Required. The resource name of the Secret to get, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserWorkloadsSecretRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.GetUserWorkloadsSecretRequest"
    }
}

/// List user workloads Secrets request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUserWorkloadsSecretsRequest {
    /// Required. List Secrets in the given environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of Secrets to return.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListUserWorkloadsSecretsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUserWorkloadsSecretsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUserWorkloadsSecretsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUserWorkloadsSecretsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsSecretsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsSecretsRequest"
    }
}

/// Update user workloads Secret request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateUserWorkloadsSecretRequest {
    /// Optional. User workloads Secret to override.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_workloads_secret: std::option::Option<crate::model::UserWorkloadsSecret>,
}

impl UpdateUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workloads_secret][crate::model::UpdateUserWorkloadsSecretRequest::user_workloads_secret].
    pub fn set_user_workloads_secret<
        T: std::convert::Into<std::option::Option<crate::model::UserWorkloadsSecret>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_workloads_secret = v.into();
        self
    }
}

impl wkt::message::Message for UpdateUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UpdateUserWorkloadsSecretRequest"
    }
}

/// Delete user workloads Secret request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteUserWorkloadsSecretRequest {
    /// Required. The Secret to delete, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserWorkloadsSecretRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DeleteUserWorkloadsSecretRequest"
    }
}

/// Create user workloads ConfigMap request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateUserWorkloadsConfigMapRequest {
    /// Required. The environment name to create a ConfigMap for, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User workloads ConfigMap to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_workloads_config_map: std::option::Option<crate::model::UserWorkloadsConfigMap>,
}

impl CreateUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserWorkloadsConfigMapRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_workloads_config_map][crate::model::CreateUserWorkloadsConfigMapRequest::user_workloads_config_map].
    pub fn set_user_workloads_config_map<
        T: std::convert::Into<std::option::Option<crate::model::UserWorkloadsConfigMap>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_workloads_config_map = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CreateUserWorkloadsConfigMapRequest"
    }
}

/// Get user workloads ConfigMap request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetUserWorkloadsConfigMapRequest {
    /// Required. The resource name of the ConfigMap to get, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserWorkloadsConfigMapRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.GetUserWorkloadsConfigMapRequest"
    }
}

/// List user workloads ConfigMaps request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUserWorkloadsConfigMapsRequest {
    /// Required. List ConfigMaps in the given environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of ConfigMaps to return.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListUserWorkloadsConfigMapsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUserWorkloadsConfigMapsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUserWorkloadsConfigMapsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUserWorkloadsConfigMapsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsConfigMapsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsConfigMapsRequest"
    }
}

/// Update user workloads ConfigMap request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateUserWorkloadsConfigMapRequest {
    /// Optional. User workloads ConfigMap to override.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_workloads_config_map: std::option::Option<crate::model::UserWorkloadsConfigMap>,
}

impl UpdateUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workloads_config_map][crate::model::UpdateUserWorkloadsConfigMapRequest::user_workloads_config_map].
    pub fn set_user_workloads_config_map<
        T: std::convert::Into<std::option::Option<crate::model::UserWorkloadsConfigMap>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_workloads_config_map = v.into();
        self
    }
}

impl wkt::message::Message for UpdateUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UpdateUserWorkloadsConfigMapRequest"
    }
}

/// Delete user workloads ConfigMap request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteUserWorkloadsConfigMapRequest {
    /// Required. The ConfigMap to delete, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserWorkloadsConfigMapRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DeleteUserWorkloadsConfigMapRequest"
    }
}

/// User workloads Secret used by Airflow tasks that run with Kubernetes executor
/// or KubernetesPodOperator.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserWorkloadsSecret {
    /// Identifier. The resource name of the Secret, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The "data" field of Kubernetes Secret, organized in key-value
    /// pairs, which can contain sensitive values such as a password, a token, or a
    /// key. The values for all keys have to be base64-encoded strings. For details
    /// see: <https://kubernetes.io/docs/concepts/configuration/secret/>
    ///
    /// Example:
    ///
    /// {
    /// "example": "ZXhhbXBsZV92YWx1ZQ==",
    /// "another-example": "YW5vdGhlcl9leGFtcGxlX3ZhbHVl"
    /// }
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub data: std::collections::HashMap<std::string::String, std::string::String>,
}

impl UserWorkloadsSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UserWorkloadsSecret::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::UserWorkloadsSecret::data].
    pub fn set_data<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for UserWorkloadsSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UserWorkloadsSecret"
    }
}

/// The user workloads Secrets for a given environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUserWorkloadsSecretsResponse {
    /// The list of Secrets returned by a ListUserWorkloadsSecretsRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_workloads_secrets: std::vec::Vec<crate::model::UserWorkloadsSecret>,

    /// The page token used to query for the next page if one exists.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListUserWorkloadsSecretsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListUserWorkloadsSecretsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [user_workloads_secrets][crate::model::ListUserWorkloadsSecretsResponse::user_workloads_secrets].
    pub fn set_user_workloads_secrets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserWorkloadsSecret>,
    {
        use std::iter::Iterator;
        self.user_workloads_secrets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsSecretsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsSecretsResponse"
    }
}

impl gax::paginator::PageableResponse for ListUserWorkloadsSecretsResponse {
    type PageItem = crate::model::UserWorkloadsSecret;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.user_workloads_secrets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// User workloads ConfigMap used by Airflow tasks that run with Kubernetes
/// executor or KubernetesPodOperator.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserWorkloadsConfigMap {
    /// Identifier. The resource name of the ConfigMap, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The "data" field of Kubernetes ConfigMap, organized in key-value
    /// pairs. For details see:
    /// <https://kubernetes.io/docs/concepts/configuration/configmap/>
    ///
    /// Example:
    ///
    /// {
    /// "example_key": "example_value",
    /// "another_key": "another_value"
    /// }
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub data: std::collections::HashMap<std::string::String, std::string::String>,
}

impl UserWorkloadsConfigMap {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UserWorkloadsConfigMap::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::UserWorkloadsConfigMap::data].
    pub fn set_data<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for UserWorkloadsConfigMap {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UserWorkloadsConfigMap"
    }
}

/// The user workloads ConfigMaps for a given environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUserWorkloadsConfigMapsResponse {
    /// The list of ConfigMaps returned by a ListUserWorkloadsConfigMapsRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_workloads_config_maps: std::vec::Vec<crate::model::UserWorkloadsConfigMap>,

    /// The page token used to query for the next page if one exists.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListUserWorkloadsConfigMapsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListUserWorkloadsConfigMapsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [user_workloads_config_maps][crate::model::ListUserWorkloadsConfigMapsResponse::user_workloads_config_maps].
    pub fn set_user_workloads_config_maps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserWorkloadsConfigMap>,
    {
        use std::iter::Iterator;
        self.user_workloads_config_maps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsConfigMapsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsConfigMapsResponse"
    }
}

impl gax::paginator::PageableResponse for ListUserWorkloadsConfigMapsResponse {
    type PageItem = crate::model::UserWorkloadsConfigMap;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.user_workloads_config_maps
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for listing workloads in a Cloud Composer environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsRequest {
    /// Required. The environment name to get workloads for, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of environments to return.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The list filter.
    /// Currently only supports equality on the type field. The value of a field
    /// specified in the filter expression must be one ComposerWorkloadType enum
    /// option. It's possible to get multiple types using "OR" operator, e.g.:
    /// "type=SCHEDULER OR type=CELERY_WORKER". If not specified, all items are
    /// returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListWorkloadsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkloadsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkloadsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkloadsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkloadsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkloadsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsRequest"
    }
}

/// Response to ListWorkloadsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsResponse {
    /// The list of environment workloads.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workloads: std::vec::Vec<crate::model::list_workloads_response::ComposerWorkload>,

    /// The page token used to query for the next page if one exists.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListWorkloadsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkloadsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workloads][crate::model::ListWorkloadsResponse::workloads].
    pub fn set_workloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::list_workloads_response::ComposerWorkload>,
    {
        use std::iter::Iterator;
        self.workloads = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkloadsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse"
    }
}

impl gax::paginator::PageableResponse for ListWorkloadsResponse {
    type PageItem = crate::model::list_workloads_response::ComposerWorkload;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workloads
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Defines additional types related to ListWorkloadsResponse
pub mod list_workloads_response {
    #[allow(unused_imports)]
    use super::*;

    /// Information about a single workload.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ComposerWorkload {
        /// Name of a workload.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Type of a workload.
        #[serde(rename = "type")]
        pub r#type: crate::model::list_workloads_response::ComposerWorkloadType,

        /// Output only. Status of a workload.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status:
            std::option::Option<crate::model::list_workloads_response::ComposerWorkloadStatus>,
    }

    impl ComposerWorkload {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::list_workloads_response::ComposerWorkload::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::list_workloads_response::ComposerWorkload::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::list_workloads_response::ComposerWorkloadType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [status][crate::model::list_workloads_response::ComposerWorkload::status].
        pub fn set_status<
            T: std::convert::Into<
                std::option::Option<crate::model::list_workloads_response::ComposerWorkloadStatus>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for ComposerWorkload {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse.ComposerWorkload"
        }
    }

    /// Workload status.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ComposerWorkloadStatus {
        /// Output only. Workload state.
        pub state: crate::model::list_workloads_response::ComposerWorkloadState,

        /// Output only. Text to provide more descriptive status.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub status_message: std::string::String,

        /// Output only. Detailed message of the status.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub detailed_status_message: std::string::String,
    }

    impl ComposerWorkloadStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::list_workloads_response::ComposerWorkloadStatus::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::list_workloads_response::ComposerWorkloadState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [status_message][crate::model::list_workloads_response::ComposerWorkloadStatus::status_message].
        pub fn set_status_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.status_message = v.into();
            self
        }

        /// Sets the value of [detailed_status_message][crate::model::list_workloads_response::ComposerWorkloadStatus::detailed_status_message].
        pub fn set_detailed_status_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.detailed_status_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ComposerWorkloadStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse.ComposerWorkloadStatus"
        }
    }

    /// Supported workload types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ComposerWorkloadType(i32);

    impl ComposerWorkloadType {
        /// Not able to determine the type of the workload.
        pub const COMPOSER_WORKLOAD_TYPE_UNSPECIFIED: ComposerWorkloadType =
            ComposerWorkloadType::new(0);

        /// Celery worker.
        pub const CELERY_WORKER: ComposerWorkloadType = ComposerWorkloadType::new(1);

        /// Kubernetes worker.
        pub const KUBERNETES_WORKER: ComposerWorkloadType = ComposerWorkloadType::new(2);

        /// Workload created by Kubernetes Pod Operator.
        pub const KUBERNETES_OPERATOR_POD: ComposerWorkloadType = ComposerWorkloadType::new(3);

        /// Airflow scheduler.
        pub const SCHEDULER: ComposerWorkloadType = ComposerWorkloadType::new(4);

        /// Airflow Dag processor.
        pub const DAG_PROCESSOR: ComposerWorkloadType = ComposerWorkloadType::new(5);

        /// Airflow triggerer.
        pub const TRIGGERER: ComposerWorkloadType = ComposerWorkloadType::new(6);

        /// Airflow web server UI.
        pub const WEB_SERVER: ComposerWorkloadType = ComposerWorkloadType::new(7);

        /// Redis.
        pub const REDIS: ComposerWorkloadType = ComposerWorkloadType::new(8);

        /// Creates a new ComposerWorkloadType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COMPOSER_WORKLOAD_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CELERY_WORKER"),
                2 => std::borrow::Cow::Borrowed("KUBERNETES_WORKER"),
                3 => std::borrow::Cow::Borrowed("KUBERNETES_OPERATOR_POD"),
                4 => std::borrow::Cow::Borrowed("SCHEDULER"),
                5 => std::borrow::Cow::Borrowed("DAG_PROCESSOR"),
                6 => std::borrow::Cow::Borrowed("TRIGGERER"),
                7 => std::borrow::Cow::Borrowed("WEB_SERVER"),
                8 => std::borrow::Cow::Borrowed("REDIS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COMPOSER_WORKLOAD_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COMPOSER_WORKLOAD_TYPE_UNSPECIFIED)
                }
                "CELERY_WORKER" => std::option::Option::Some(Self::CELERY_WORKER),
                "KUBERNETES_WORKER" => std::option::Option::Some(Self::KUBERNETES_WORKER),
                "KUBERNETES_OPERATOR_POD" => {
                    std::option::Option::Some(Self::KUBERNETES_OPERATOR_POD)
                }
                "SCHEDULER" => std::option::Option::Some(Self::SCHEDULER),
                "DAG_PROCESSOR" => std::option::Option::Some(Self::DAG_PROCESSOR),
                "TRIGGERER" => std::option::Option::Some(Self::TRIGGERER),
                "WEB_SERVER" => std::option::Option::Some(Self::WEB_SERVER),
                "REDIS" => std::option::Option::Some(Self::REDIS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ComposerWorkloadType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ComposerWorkloadType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Workload states.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ComposerWorkloadState(i32);

    impl ComposerWorkloadState {
        /// Not able to determine the status of the workload.
        pub const COMPOSER_WORKLOAD_STATE_UNSPECIFIED: ComposerWorkloadState =
            ComposerWorkloadState::new(0);

        /// Workload is in pending state and has not yet started.
        pub const PENDING: ComposerWorkloadState = ComposerWorkloadState::new(1);

        /// Workload is running fine.
        pub const OK: ComposerWorkloadState = ComposerWorkloadState::new(2);

        /// Workload is running but there are some non-critical problems.
        pub const WARNING: ComposerWorkloadState = ComposerWorkloadState::new(3);

        /// Workload is not running due to an error.
        pub const ERROR: ComposerWorkloadState = ComposerWorkloadState::new(4);

        /// Workload has finished execution with success.
        pub const SUCCEEDED: ComposerWorkloadState = ComposerWorkloadState::new(5);

        /// Workload has finished execution with failure.
        pub const FAILED: ComposerWorkloadState = ComposerWorkloadState::new(6);

        /// Creates a new ComposerWorkloadState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COMPOSER_WORKLOAD_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING"),
                2 => std::borrow::Cow::Borrowed("OK"),
                3 => std::borrow::Cow::Borrowed("WARNING"),
                4 => std::borrow::Cow::Borrowed("ERROR"),
                5 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                6 => std::borrow::Cow::Borrowed("FAILED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COMPOSER_WORKLOAD_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COMPOSER_WORKLOAD_STATE_UNSPECIFIED)
                }
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "OK" => std::option::Option::Some(Self::OK),
                "WARNING" => std::option::Option::Some(Self::WARNING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ComposerWorkloadState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ComposerWorkloadState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request to create a snapshot of a Cloud Composer environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SaveSnapshotRequest {
    /// The resource name of the source environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,

    /// Location in a Cloud Storage where the snapshot is going to be stored, e.g.:
    /// "gs://my-bucket/snapshots".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_location: std::string::String,
}

impl SaveSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::SaveSnapshotRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [snapshot_location][crate::model::SaveSnapshotRequest::snapshot_location].
    pub fn set_snapshot_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_location = v.into();
        self
    }
}

impl wkt::message::Message for SaveSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.SaveSnapshotRequest"
    }
}

/// Response to SaveSnapshotRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SaveSnapshotResponse {
    /// The fully-resolved Cloud Storage path of the created snapshot,
    /// e.g.:
    /// "gs://my-bucket/snapshots/project_location_environment_timestamp".
    /// This field is populated only if the snapshot creation was successful.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_path: std::string::String,
}

impl SaveSnapshotResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot_path][crate::model::SaveSnapshotResponse::snapshot_path].
    pub fn set_snapshot_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_path = v.into();
        self
    }
}

impl wkt::message::Message for SaveSnapshotResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.SaveSnapshotResponse"
    }
}

/// Request to load a snapshot into a Cloud Composer environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoadSnapshotRequest {
    /// The resource name of the target environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,

    /// A Cloud Storage path to a snapshot to load, e.g.:
    /// "gs://my-bucket/snapshots/project_location_environment_timestamp".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_path: std::string::String,

    /// Whether or not to skip installing Pypi packages when loading the
    /// environment's state.
    pub skip_pypi_packages_installation: bool,

    /// Whether or not to skip setting environment variables when loading the
    /// environment's state.
    pub skip_environment_variables_setting: bool,

    /// Whether or not to skip setting Airflow overrides when loading the
    /// environment's state.
    pub skip_airflow_overrides_setting: bool,

    /// Whether or not to skip copying Cloud Storage data when loading the
    /// environment's state.
    pub skip_gcs_data_copying: bool,
}

impl LoadSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::LoadSnapshotRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [snapshot_path][crate::model::LoadSnapshotRequest::snapshot_path].
    pub fn set_snapshot_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_path = v.into();
        self
    }

    /// Sets the value of [skip_pypi_packages_installation][crate::model::LoadSnapshotRequest::skip_pypi_packages_installation].
    pub fn set_skip_pypi_packages_installation<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.skip_pypi_packages_installation = v.into();
        self
    }

    /// Sets the value of [skip_environment_variables_setting][crate::model::LoadSnapshotRequest::skip_environment_variables_setting].
    pub fn set_skip_environment_variables_setting<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.skip_environment_variables_setting = v.into();
        self
    }

    /// Sets the value of [skip_airflow_overrides_setting][crate::model::LoadSnapshotRequest::skip_airflow_overrides_setting].
    pub fn set_skip_airflow_overrides_setting<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_airflow_overrides_setting = v.into();
        self
    }

    /// Sets the value of [skip_gcs_data_copying][crate::model::LoadSnapshotRequest::skip_gcs_data_copying].
    pub fn set_skip_gcs_data_copying<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_gcs_data_copying = v.into();
        self
    }
}

impl wkt::message::Message for LoadSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.LoadSnapshotRequest"
    }
}

/// Response to LoadSnapshotRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoadSnapshotResponse {}

impl LoadSnapshotResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for LoadSnapshotResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.LoadSnapshotResponse"
    }
}

/// Request to trigger database failover (only for highly resilient
/// environments).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseFailoverRequest {
    /// Target environment:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,
}

impl DatabaseFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::DatabaseFailoverRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DatabaseFailoverRequest"
    }
}

/// Response for DatabaseFailoverRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseFailoverResponse {}

impl DatabaseFailoverResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DatabaseFailoverResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DatabaseFailoverResponse"
    }
}

/// Request to fetch properties of environment's database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchDatabasePropertiesRequest {
    /// Required. The resource name of the environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,
}

impl FetchDatabasePropertiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::FetchDatabasePropertiesRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for FetchDatabasePropertiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.FetchDatabasePropertiesRequest"
    }
}

/// Response for FetchDatabasePropertiesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchDatabasePropertiesResponse {
    /// The Compute Engine zone that the instance is currently serving from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub primary_gce_zone: std::string::String,

    /// The Compute Engine zone that the failover instance is currently serving
    /// from for a regional Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_gce_zone: std::string::String,

    /// The availability status of the failover replica. A false status indicates
    /// that the failover replica is out of sync. The primary instance can only
    /// fail over to the failover replica when the status is true.
    pub is_failover_replica_available: bool,
}

impl FetchDatabasePropertiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_gce_zone][crate::model::FetchDatabasePropertiesResponse::primary_gce_zone].
    pub fn set_primary_gce_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_gce_zone = v.into();
        self
    }

    /// Sets the value of [secondary_gce_zone][crate::model::FetchDatabasePropertiesResponse::secondary_gce_zone].
    pub fn set_secondary_gce_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_gce_zone = v.into();
        self
    }

    /// Sets the value of [is_failover_replica_available][crate::model::FetchDatabasePropertiesResponse::is_failover_replica_available].
    pub fn set_is_failover_replica_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_failover_replica_available = v.into();
        self
    }
}

impl wkt::message::Message for FetchDatabasePropertiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.FetchDatabasePropertiesResponse"
    }
}

/// The configuration for data storage in the environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageConfig {
    /// Optional. The name of the Cloud Storage bucket used by the environment. No
    /// `gs://` prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,
}

impl StorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageConfig::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }
}

impl wkt::message::Message for StorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.StorageConfig"
    }
}

/// Configuration information for an environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnvironmentConfig {
    /// Output only. The Kubernetes Engine cluster used to run this environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gke_cluster: std::string::String,

    /// Output only. The Cloud Storage prefix of the DAGs for this environment.
    /// Although Cloud Storage objects reside in a flat namespace, a hierarchical
    /// file tree can be simulated using "/"-delimited object name prefixes. DAG
    /// objects for this environment reside in a simulated directory with the given
    /// prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dag_gcs_prefix: std::string::String,

    /// The number of nodes in the Kubernetes Engine cluster that will be
    /// used to run this environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub node_count: i32,

    /// Optional. The configuration settings for software inside the environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub software_config: std::option::Option<crate::model::SoftwareConfig>,

    /// Optional. The configuration used for the Kubernetes Engine cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// Optional. The configuration used for the Private IP Cloud Composer
    /// environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_environment_config: std::option::Option<crate::model::PrivateEnvironmentConfig>,

    /// Optional. The network-level access control policy for the Airflow web
    /// server. If unspecified, no network-level access restrictions will be
    /// applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub web_server_network_access_control:
        std::option::Option<crate::model::WebServerNetworkAccessControl>,

    /// Optional. The configuration settings for Cloud SQL instance used internally
    /// by Apache Airflow software.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database_config: std::option::Option<crate::model::DatabaseConfig>,

    /// Optional. The configuration settings for the Airflow web server App Engine
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub web_server_config: std::option::Option<crate::model::WebServerConfig>,

    /// Optional. The encryption options for the Cloud Composer environment
    /// and its dependencies. Cannot be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Optional. The maintenance window is the period when Cloud Composer
    /// components may undergo maintenance. It is defined so that maintenance is
    /// not executed during peak hours or critical time periods.
    ///
    /// The system will not be under maintenance for every occurrence of this
    /// window, but when maintenance is planned, it will be scheduled
    /// during the window.
    ///
    /// The maintenance window period must encompass at least 12 hours per week.
    /// This may be split into multiple chunks, each with a size of
    /// at least 4 hours.
    ///
    /// If this value is omitted, the default value for maintenance window is
    /// applied. By default, maintenance windows are from 00:00:00 to 04:00:00
    /// (GMT) on Friday, Saturday, and Sunday every week.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Optional. The workloads configuration settings for the GKE cluster
    /// associated with the Cloud Composer environment. The GKE cluster runs
    /// Airflow scheduler, web server and workers workloads.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workloads_config: std::option::Option<crate::model::WorkloadsConfig>,

    /// Optional. The size of the Cloud Composer environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    pub environment_size: crate::model::environment_config::EnvironmentSize,

    /// Output only. The URI of the Apache Airflow Web UI hosted within this
    /// environment (see [Airflow web
    /// interface](/composer/docs/how-to/accessing/airflow-web-interface)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub airflow_uri: std::string::String,

    /// Output only. The 'bring your own identity' variant of the URI of the Apache
    /// Airflow Web UI hosted within this environment, to be accessed with external
    /// identities using workforce identity federation (see [Access environments
    /// with workforce identity
    /// federation](/composer/docs/composer-2/access-environments-with-workforce-identity-federation)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub airflow_byoid_uri: std::string::String,

    /// Optional. The configuration options for GKE cluster master authorized
    /// networks. By default master authorized networks feature is:
    ///
    /// - in case of private environment: enabled with no external networks
    ///   allowlisted.
    /// - in case of public environment: disabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    /// Optional. The Recovery settings configuration of an environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recovery_config: std::option::Option<crate::model::RecoveryConfig>,

    /// Optional. Resilience mode of the Cloud Composer Environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.2.0-airflow-*.*.* and newer.
    pub resilience_mode: crate::model::environment_config::ResilienceMode,

    /// Optional. The configuration setting for Airflow database data retention
    /// mechanism.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_retention_config: std::option::Option<crate::model::DataRetentionConfig>,
}

impl EnvironmentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gke_cluster][crate::model::EnvironmentConfig::gke_cluster].
    pub fn set_gke_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gke_cluster = v.into();
        self
    }

    /// Sets the value of [dag_gcs_prefix][crate::model::EnvironmentConfig::dag_gcs_prefix].
    pub fn set_dag_gcs_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dag_gcs_prefix = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::EnvironmentConfig::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [software_config][crate::model::EnvironmentConfig::software_config].
    pub fn set_software_config<
        T: std::convert::Into<std::option::Option<crate::model::SoftwareConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.software_config = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::EnvironmentConfig::node_config].
    pub fn set_node_config<T: std::convert::Into<std::option::Option<crate::model::NodeConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_config = v.into();
        self
    }

    /// Sets the value of [private_environment_config][crate::model::EnvironmentConfig::private_environment_config].
    pub fn set_private_environment_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateEnvironmentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_environment_config = v.into();
        self
    }

    /// Sets the value of [web_server_network_access_control][crate::model::EnvironmentConfig::web_server_network_access_control].
    pub fn set_web_server_network_access_control<
        T: std::convert::Into<std::option::Option<crate::model::WebServerNetworkAccessControl>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_network_access_control = v.into();
        self
    }

    /// Sets the value of [database_config][crate::model::EnvironmentConfig::database_config].
    pub fn set_database_config<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_config = v.into();
        self
    }

    /// Sets the value of [web_server_config][crate::model::EnvironmentConfig::web_server_config].
    pub fn set_web_server_config<
        T: std::convert::Into<std::option::Option<crate::model::WebServerConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_config = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::EnvironmentConfig::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::EnvironmentConfig::maintenance_window].
    pub fn set_maintenance_window<
        T: std::convert::Into<std::option::Option<crate::model::MaintenanceWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_window = v.into();
        self
    }

    /// Sets the value of [workloads_config][crate::model::EnvironmentConfig::workloads_config].
    pub fn set_workloads_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workloads_config = v.into();
        self
    }

    /// Sets the value of [environment_size][crate::model::EnvironmentConfig::environment_size].
    pub fn set_environment_size<
        T: std::convert::Into<crate::model::environment_config::EnvironmentSize>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_size = v.into();
        self
    }

    /// Sets the value of [airflow_uri][crate::model::EnvironmentConfig::airflow_uri].
    pub fn set_airflow_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.airflow_uri = v.into();
        self
    }

    /// Sets the value of [airflow_byoid_uri][crate::model::EnvironmentConfig::airflow_byoid_uri].
    pub fn set_airflow_byoid_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.airflow_byoid_uri = v.into();
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::EnvironmentConfig::master_authorized_networks_config].
    pub fn set_master_authorized_networks_config<
        T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_authorized_networks_config = v.into();
        self
    }

    /// Sets the value of [recovery_config][crate::model::EnvironmentConfig::recovery_config].
    pub fn set_recovery_config<
        T: std::convert::Into<std::option::Option<crate::model::RecoveryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recovery_config = v.into();
        self
    }

    /// Sets the value of [resilience_mode][crate::model::EnvironmentConfig::resilience_mode].
    pub fn set_resilience_mode<
        T: std::convert::Into<crate::model::environment_config::ResilienceMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resilience_mode = v.into();
        self
    }

    /// Sets the value of [data_retention_config][crate::model::EnvironmentConfig::data_retention_config].
    pub fn set_data_retention_config<
        T: std::convert::Into<std::option::Option<crate::model::DataRetentionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_retention_config = v.into();
        self
    }
}

impl wkt::message::Message for EnvironmentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.EnvironmentConfig"
    }
}

/// Defines additional types related to EnvironmentConfig
pub mod environment_config {
    #[allow(unused_imports)]
    use super::*;

    /// The size of the Cloud Composer environment.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EnvironmentSize(i32);

    impl EnvironmentSize {
        /// The size of the environment is unspecified.
        pub const ENVIRONMENT_SIZE_UNSPECIFIED: EnvironmentSize = EnvironmentSize::new(0);

        /// The environment size is small.
        pub const ENVIRONMENT_SIZE_SMALL: EnvironmentSize = EnvironmentSize::new(1);

        /// The environment size is medium.
        pub const ENVIRONMENT_SIZE_MEDIUM: EnvironmentSize = EnvironmentSize::new(2);

        /// The environment size is large.
        pub const ENVIRONMENT_SIZE_LARGE: EnvironmentSize = EnvironmentSize::new(3);

        /// Creates a new EnvironmentSize instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ENVIRONMENT_SIZE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENVIRONMENT_SIZE_SMALL"),
                2 => std::borrow::Cow::Borrowed("ENVIRONMENT_SIZE_MEDIUM"),
                3 => std::borrow::Cow::Borrowed("ENVIRONMENT_SIZE_LARGE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ENVIRONMENT_SIZE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ENVIRONMENT_SIZE_UNSPECIFIED)
                }
                "ENVIRONMENT_SIZE_SMALL" => std::option::Option::Some(Self::ENVIRONMENT_SIZE_SMALL),
                "ENVIRONMENT_SIZE_MEDIUM" => {
                    std::option::Option::Some(Self::ENVIRONMENT_SIZE_MEDIUM)
                }
                "ENVIRONMENT_SIZE_LARGE" => std::option::Option::Some(Self::ENVIRONMENT_SIZE_LARGE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EnvironmentSize {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EnvironmentSize {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Resilience mode of the Cloud Composer Environment.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ResilienceMode(i32);

    impl ResilienceMode {
        /// Default mode doesn't change environment parameters.
        pub const RESILIENCE_MODE_UNSPECIFIED: ResilienceMode = ResilienceMode::new(0);

        /// Enabled High Resilience mode, including Cloud SQL HA.
        pub const HIGH_RESILIENCE: ResilienceMode = ResilienceMode::new(1);

        /// Creates a new ResilienceMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESILIENCE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("HIGH_RESILIENCE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESILIENCE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RESILIENCE_MODE_UNSPECIFIED)
                }
                "HIGH_RESILIENCE" => std::option::Option::Some(Self::HIGH_RESILIENCE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ResilienceMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ResilienceMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Network-level access control policy for the Airflow web server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WebServerNetworkAccessControl {
    /// A collection of allowed IP ranges with descriptions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_ip_ranges:
        std::vec::Vec<crate::model::web_server_network_access_control::AllowedIpRange>,
}

impl WebServerNetworkAccessControl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_ip_ranges][crate::model::WebServerNetworkAccessControl::allowed_ip_ranges].
    pub fn set_allowed_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_server_network_access_control::AllowedIpRange>,
    {
        use std::iter::Iterator;
        self.allowed_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WebServerNetworkAccessControl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WebServerNetworkAccessControl"
    }
}

/// Defines additional types related to WebServerNetworkAccessControl
pub mod web_server_network_access_control {
    #[allow(unused_imports)]
    use super::*;

    /// Allowed IP range with user-provided description.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AllowedIpRange {
        /// IP address or range, defined using CIDR notation, of requests that this
        /// rule applies to.
        /// Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32`
        /// or `2001:0db8:0000:0042:0000:8a2e:0370:7334`.
        ///
        /// IP range prefixes should be properly truncated. For example,
        /// `1.2.3.4/24` should be truncated to `1.2.3.0/24`. Similarly, for IPv6,
        /// `2001:db8::1/32` should be truncated to `2001:db8::/32`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        /// Optional. User-provided description. It must contain at most 300
        /// characters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,
    }

    impl AllowedIpRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::web_server_network_access_control::AllowedIpRange::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [description][crate::model::web_server_network_access_control::AllowedIpRange::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }
    }

    impl wkt::message::Message for AllowedIpRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WebServerNetworkAccessControl.AllowedIpRange"
        }
    }
}

/// The configuration of Cloud SQL instance that is used by the Apache Airflow
/// software.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseConfig {
    /// Optional. Cloud SQL machine type used by Airflow database.
    /// It has to be one of: db-n1-standard-2, db-n1-standard-4, db-n1-standard-8
    /// or db-n1-standard-16. If not specified, db-n1-standard-2 will be used.
    /// Supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Optional. The Compute Engine zone where the Airflow database is created. If
    /// zone is provided, it must be in the region selected for the environment. If
    /// zone is not provided, a zone is automatically selected. The zone can only
    /// be set during environment creation. Supported for Cloud Composer
    /// environments in versions composer-2.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,
}

impl DatabaseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::DatabaseConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::DatabaseConfig::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DatabaseConfig"
    }
}

/// The configuration settings for the Airflow web server App Engine instance.
/// Supported for Cloud Composer environments in versions
/// composer-1.*.*-airflow-*.*.*
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WebServerConfig {
    /// Optional. Machine type on which Airflow web server is running.
    /// It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or
    /// composer-n1-webserver-8.
    /// If not specified, composer-n1-webserver-2 will be used.
    /// Value custom is returned only in response, if Airflow web server parameters
    /// were manually changed to a non-standard values.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,
}

impl WebServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::WebServerConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }
}

impl wkt::message::Message for WebServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WebServerConfig"
    }
}

/// The encryption options for the Cloud Composer environment
/// and its dependencies.Supported for Cloud Composer environments in versions
/// composer-1.*.*-airflow-*.*.*.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// Optional. Customer-managed Encryption Key available through Google's Key
    /// Management Service. Cannot be updated. If not specified, Google-managed key
    /// will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfig::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.EncryptionConfig"
    }
}

/// The configuration settings for Cloud Composer maintenance window.
/// The following example:
///
/// ```norust
///    {
///      "startTime":"2019-08-01T01:00:00Z"
///      "endTime":"2019-08-01T07:00:00Z"
///      "recurrence":"FREQ=WEEKLY;BYDAY=TU,WE"
///    }
/// ```
///
/// would define a maintenance window between 01 and 07 hours UTC during
/// each Tuesday and Wednesday.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Required. Start time of the first recurrence of the maintenance window.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Required. Maintenance window end time. It is used only to calculate the
    /// duration of the maintenance window. The value for end-time must be in the
    /// future, relative to `start_time`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Required. Maintenance window recurrence. Format is a subset of
    /// [RFC-5545](https://tools.ietf.org/html/rfc5545) `RRULE`. The only allowed
    /// values for `FREQ` field are `FREQ=DAILY` and `FREQ=WEEKLY;BYDAY=...`
    /// Example values: `FREQ=WEEKLY;BYDAY=TU,WE`, `FREQ=DAILY`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recurrence: std::string::String,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::MaintenanceWindow::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::MaintenanceWindow::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [recurrence][crate::model::MaintenanceWindow::recurrence].
    pub fn set_recurrence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recurrence = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.MaintenanceWindow"
    }
}

/// Specifies the selection and configuration of software inside the environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SoftwareConfig {
    /// Optional. The version of the software running in the environment.
    /// This encapsulates both the version of Cloud Composer functionality and the
    /// version of Apache Airflow. It must match the regular expression
    /// `composer-([0-9]+(\.[0-9]+\.[0-9]+(-preview\.[0-9]+)?)?|latest)-airflow-([0-9]+(\.[0-9]+(\.[0-9]+)?)?)`.
    /// When used as input, the server also checks if the provided version is
    /// supported and denies the request for an unsupported version.
    ///
    /// The Cloud Composer portion of the image version is a full
    /// [semantic version](https://semver.org), or an alias in the form of major
    /// version number or `latest`. When an alias is provided, the server replaces
    /// it with the current Cloud Composer version that satisfies the alias.
    ///
    /// The Apache Airflow portion of the image version is a full semantic version
    /// that points to one of the supported Apache Airflow versions, or an alias in
    /// the form of only major or major.minor versions specified. When an alias is
    /// provided, the server replaces it with the latest Apache Airflow version
    /// that satisfies the alias and is supported in the given Cloud Composer
    /// version.
    ///
    /// In all cases, the resolved image version is stored in the same field.
    ///
    /// See also [version
    /// list](/composer/docs/concepts/versioning/composer-versions) and [versioning
    /// overview](/composer/docs/concepts/versioning/composer-versioning-overview).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_version: std::string::String,

    /// Optional. Apache Airflow configuration properties to override.
    ///
    /// Property keys contain the section and property names, separated by a
    /// hyphen, for example "core-dags_are_paused_at_creation". Section names must
    /// not contain hyphens ("-"), opening square brackets ("["),  or closing
    /// square brackets ("]"). The property name must not be empty and must not
    /// contain an equals sign ("=") or semicolon (";"). Section and property names
    /// must not contain a period ("."). Apache Airflow configuration property
    /// names must be written in
    /// [snake_case](https://en.wikipedia.org/wiki/Snake_case). Property values can
    /// contain any character, and can be written in any lower/upper case format.
    ///
    /// Certain Apache Airflow configuration property values are
    /// [blocked](/composer/docs/concepts/airflow-configurations),
    /// and cannot be overridden.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub airflow_config_overrides:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Custom Python Package Index (PyPI) packages to be installed in
    /// the environment.
    ///
    /// Keys refer to the lowercase package name such as "numpy"
    /// and values are the lowercase extras and version specifier such as
    /// "==1.12.0", "[devel,gcp_api]", or "[devel]>=1.8.2, <1.9.2". To specify a
    /// package without pinning it to a version specifier, use the empty string as
    /// the value.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub pypi_packages: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Additional environment variables to provide to the Apache Airflow
    /// scheduler, worker, and webserver processes.
    ///
    /// Environment variable names must match the regular expression
    /// `[a-zA-Z_][a-zA-Z0-9_]*`. They cannot specify Apache Airflow
    /// software configuration overrides (they cannot match the regular expression
    /// `AIRFLOW__[A-Z0-9_]+__[A-Z0-9_]+`), and they cannot match any of the
    /// following reserved names:
    ///
    /// * `AIRFLOW_HOME`
    /// * `C_FORCE_ROOT`
    /// * `CONTAINER_NAME`
    /// * `DAGS_FOLDER`
    /// * `GCP_PROJECT`
    /// * `GCS_BUCKET`
    /// * `GKE_CLUSTER_NAME`
    /// * `SQL_DATABASE`
    /// * `SQL_INSTANCE`
    /// * `SQL_PASSWORD`
    /// * `SQL_PROJECT`
    /// * `SQL_REGION`
    /// * `SQL_USER`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The major version of Python used to run the Apache Airflow
    /// scheduler, worker, and webserver processes.
    ///
    /// Can be set to '2' or '3'. If not specified, the default is '3'. Cannot be
    /// updated.
    ///
    /// This field is only supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*. Environments in newer versions always use
    /// Python major version 3.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub python_version: std::string::String,

    /// Optional. The number of schedulers for Airflow.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-2.*.*.
    pub scheduler_count: i32,

    /// Optional. The configuration for Cloud Data Lineage integration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_data_lineage_integration:
        std::option::Option<crate::model::CloudDataLineageIntegration>,

    /// Optional. Whether or not the web server uses custom plugins.
    /// If unspecified, the field defaults to `PLUGINS_ENABLED`.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    pub web_server_plugins_mode: crate::model::software_config::WebServerPluginsMode,
}

impl SoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_version][crate::model::SoftwareConfig::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }

    /// Sets the value of [python_version][crate::model::SoftwareConfig::python_version].
    pub fn set_python_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.python_version = v.into();
        self
    }

    /// Sets the value of [scheduler_count][crate::model::SoftwareConfig::scheduler_count].
    pub fn set_scheduler_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scheduler_count = v.into();
        self
    }

    /// Sets the value of [cloud_data_lineage_integration][crate::model::SoftwareConfig::cloud_data_lineage_integration].
    pub fn set_cloud_data_lineage_integration<
        T: std::convert::Into<std::option::Option<crate::model::CloudDataLineageIntegration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_data_lineage_integration = v.into();
        self
    }

    /// Sets the value of [web_server_plugins_mode][crate::model::SoftwareConfig::web_server_plugins_mode].
    pub fn set_web_server_plugins_mode<
        T: std::convert::Into<crate::model::software_config::WebServerPluginsMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_plugins_mode = v.into();
        self
    }

    /// Sets the value of [airflow_config_overrides][crate::model::SoftwareConfig::airflow_config_overrides].
    pub fn set_airflow_config_overrides<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.airflow_config_overrides = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [pypi_packages][crate::model::SoftwareConfig::pypi_packages].
    pub fn set_pypi_packages<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pypi_packages = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [env_variables][crate::model::SoftwareConfig::env_variables].
    pub fn set_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.SoftwareConfig"
    }
}

/// Defines additional types related to SoftwareConfig
pub mod software_config {
    #[allow(unused_imports)]
    use super::*;

    /// Web server plugins mode of the Cloud Composer environment.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct WebServerPluginsMode(i32);

    impl WebServerPluginsMode {
        /// Default mode.
        pub const WEB_SERVER_PLUGINS_MODE_UNSPECIFIED: WebServerPluginsMode =
            WebServerPluginsMode::new(0);

        /// Web server plugins are not supported.
        pub const PLUGINS_DISABLED: WebServerPluginsMode = WebServerPluginsMode::new(1);

        /// Web server plugins are supported.
        pub const PLUGINS_ENABLED: WebServerPluginsMode = WebServerPluginsMode::new(2);

        /// Creates a new WebServerPluginsMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("WEB_SERVER_PLUGINS_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PLUGINS_DISABLED"),
                2 => std::borrow::Cow::Borrowed("PLUGINS_ENABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "WEB_SERVER_PLUGINS_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::WEB_SERVER_PLUGINS_MODE_UNSPECIFIED)
                }
                "PLUGINS_DISABLED" => std::option::Option::Some(Self::PLUGINS_DISABLED),
                "PLUGINS_ENABLED" => std::option::Option::Some(Self::PLUGINS_ENABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for WebServerPluginsMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for WebServerPluginsMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configuration for controlling how IPs are allocated in the
/// GKE cluster running the Apache Airflow software.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IPAllocationPolicy {
    /// Optional. Whether or not to enable Alias IPs in the GKE cluster.
    /// If `true`, a VPC-native cluster is created.
    ///
    /// This field is only supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*. Environments in newer versions always use
    /// VPC-native GKE clusters.
    pub use_ip_aliases: bool,

    /// Configuration of allocating IP addresses for pods in the GKE cluster.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cluster_ip_allocation:
        std::option::Option<crate::model::ip_allocation_policy::ClusterIpAllocation>,

    /// Configuration of allocating IP addresses for services in the GKE cluster.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub services_ip_allocation:
        std::option::Option<crate::model::ip_allocation_policy::ServicesIpAllocation>,
}

impl IPAllocationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_ip_aliases][crate::model::IPAllocationPolicy::use_ip_aliases].
    pub fn set_use_ip_aliases<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_ip_aliases = v.into();
        self
    }

    /// Sets the value of `cluster_ip_allocation`.
    pub fn set_cluster_ip_allocation<
        T: std::convert::Into<
            std::option::Option<crate::model::ip_allocation_policy::ClusterIpAllocation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ip_allocation = v.into();
        self
    }

    /// The value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// if it holds a `ClusterSecondaryRangeName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cluster_secondary_range_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.cluster_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterSecondaryRangeName(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// if it holds a `ClusterIpv4CidrBlock`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cluster_ipv4_cidr_block(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.cluster_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterIpv4CidrBlock(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// to hold a `ClusterSecondaryRangeName`.
    ///
    /// Note that all the setters affecting `cluster_ip_allocation` are
    /// mutually exclusive.
    pub fn set_cluster_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterSecondaryRangeName(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// to hold a `ClusterIpv4CidrBlock`.
    ///
    /// Note that all the setters affecting `cluster_ip_allocation` are
    /// mutually exclusive.
    pub fn set_cluster_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterIpv4CidrBlock(v.into()),
        );
        self
    }

    /// Sets the value of `services_ip_allocation`.
    pub fn set_services_ip_allocation<
        T: std::convert::Into<
            std::option::Option<crate::model::ip_allocation_policy::ServicesIpAllocation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.services_ip_allocation = v.into();
        self
    }

    /// The value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// if it holds a `ServicesSecondaryRangeName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_services_secondary_range_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.services_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesSecondaryRangeName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// if it holds a `ServicesIpv4CidrBlock`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_services_ipv4_cidr_block(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.services_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesIpv4CidrBlock(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// to hold a `ServicesSecondaryRangeName`.
    ///
    /// Note that all the setters affecting `services_ip_allocation` are
    /// mutually exclusive.
    pub fn set_services_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesSecondaryRangeName(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// to hold a `ServicesIpv4CidrBlock`.
    ///
    /// Note that all the setters affecting `services_ip_allocation` are
    /// mutually exclusive.
    pub fn set_services_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesIpv4CidrBlock(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for IPAllocationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.IPAllocationPolicy"
    }
}

/// Defines additional types related to IPAllocationPolicy
pub mod ip_allocation_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of allocating IP addresses for pods in the GKE cluster.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ClusterIpAllocation {
        /// Optional. The name of the GKE cluster's secondary range used to allocate
        /// IP addresses to pods.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ClusterSecondaryRangeName(std::string::String),
        /// Optional. The IP address range used to allocate IP addresses to pods in
        /// the GKE cluster.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ///
        /// Set to blank to have GKE choose a range with the default size.
        ///
        /// Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
        /// netmask.
        ///
        /// Set to a
        /// [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
        /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
        /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
        /// to use.
        ClusterIpv4CidrBlock(std::string::String),
    }

    /// Configuration of allocating IP addresses for services in the GKE cluster.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ServicesIpAllocation {
        /// Optional. The name of the services' secondary range used to allocate
        /// IP addresses to the GKE cluster.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ServicesSecondaryRangeName(std::string::String),
        /// Optional. The IP address range of the services IP addresses in this
        /// GKE cluster.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ///
        /// Set to blank to have GKE choose a range with the default size.
        ///
        /// Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
        /// netmask.
        ///
        /// Set to a
        /// [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
        /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
        /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
        /// to use.
        ServicesIpv4CidrBlock(std::string::String),
    }
}

/// The configuration information for the Kubernetes Engine nodes running
/// the Apache Airflow software.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeConfig {
    /// Optional. The Compute Engine [zone](/compute/docs/regions-zones) in which
    /// to deploy the VMs used to run the Apache Airflow software, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/zones/{zoneId}".
    ///
    /// This `location` must belong to the enclosing environment's project and
    /// location. If both this field and `nodeConfig.machineType` are specified,
    /// `nodeConfig.machineType` must belong to this `location`; if both are
    /// unspecified, the service will pick a zone in the Compute Engine region
    /// corresponding to the Cloud Composer location, and propagate that choice to
    /// both fields. If only one field (`location` or `nodeConfig.machineType`) is
    /// specified, the location information from the specified field will be
    /// propagated to the unspecified field.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Optional. The Compute Engine
    /// [machine type](/compute/docs/machine-types) used for cluster instances,
    /// specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/zones/{zoneId}/machineTypes/{machineTypeId}".
    ///
    /// The `machineType` must belong to the enclosing environment's project and
    /// location. If both this field and `nodeConfig.location` are specified,
    /// this `machineType` must belong to the `nodeConfig.location`; if both are
    /// unspecified, the service will pick a zone in the Compute Engine region
    /// corresponding to the Cloud Composer location, and propagate that choice to
    /// both fields. If exactly one of this field and `nodeConfig.location` is
    /// specified, the location information from the specified field will be
    /// propagated to the unspecified field.
    ///
    /// The `machineTypeId` must not be a [shared-core machine
    /// type](/compute/docs/machine-types#sharedcore).
    ///
    /// If this field is unspecified, the `machineTypeId` defaults
    /// to "n1-standard-1".
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Optional. The Compute Engine network to be used for machine
    /// communications, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/global/networks/{networkId}".
    ///
    /// If unspecified, the "default" network ID in the environment's project is
    /// used. If a [Custom Subnet Network](/vpc/docs/vpc#vpc_networks_and_subnets)
    /// is provided, `nodeConfig.subnetwork` must also be provided. For
    /// [Shared VPC](/vpc/docs/shared-vpc) subnetwork requirements, see
    /// `nodeConfig.subnetwork`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. The Compute Engine subnetwork to be used for machine
    /// communications, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/regions/{regionId}/subnetworks/{subnetworkId}"
    ///
    /// If a subnetwork is provided, `nodeConfig.network` must also be provided,
    /// and the subnetwork must belong to the enclosing environment's project and
    /// location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    /// Optional. The disk size in GB used for node VMs. Minimum size is 30GB.
    /// If unspecified, defaults to 100GB. Cannot be updated.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub disk_size_gb: i32,

    /// Optional. The set of Google API scopes to be made available on all
    /// node VMs. If `oauth_scopes` is empty, defaults to
    /// [`https://www.googleapis.com/auth/cloud-platform`]. Cannot be updated.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub oauth_scopes: std::vec::Vec<std::string::String>,

    /// Optional. The Google Cloud Platform Service Account to be used by the node
    /// VMs. If a service account is not specified, the "default" Compute Engine
    /// service account is used. Cannot be updated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. The list of instance tags applied to all node VMs. Tags are used
    /// to identify valid sources or targets for network firewalls. Each tag within
    /// the list must comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Cannot be updated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Optional. The configuration for controlling how IPs are allocated in the
    /// GKE cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_allocation_policy: std::option::Option<crate::model::IPAllocationPolicy>,

    /// Optional. Deploys 'ip-masq-agent' daemon set in the GKE cluster and defines
    /// nonMasqueradeCIDRs equals to pod IP range so IP masquerading is used for
    /// all destination addresses, except between pods traffic.
    ///
    /// See:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent>
    pub enable_ip_masq_agent: bool,

    /// Optional. Network Attachment that Cloud Composer environment is connected
    /// to, which provides connectivity with a user's VPC network. Takes precedence
    /// over network and subnetwork settings. If not provided, but network and
    /// subnetwork are defined during environment, it will be provisioned. If not
    /// provided and network and subnetwork are also empty, then connectivity to
    /// user's VPC network is disabled. Network attachment must be provided in
    /// format
    /// projects/{project}/regions/{region}/networkAttachments/{networkAttachment}.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub composer_network_attachment: std::string::String,

    /// Optional. The IP range in CIDR notation to use internally by Cloud
    /// Composer. IP addresses are not reserved - and the same range can be used by
    /// multiple Cloud Composer environments. In case of overlap, IPs from this
    /// range will not be accessible in the user's VPC network. Cannot be updated.
    /// If not specified, the default value of '100.64.128.0/20' is used.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub composer_internal_ipv4_cidr_block: std::string::String,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::NodeConfig::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::NodeConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network][crate::model::NodeConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NodeConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::NodeConfig::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::NodeConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [ip_allocation_policy][crate::model::NodeConfig::ip_allocation_policy].
    pub fn set_ip_allocation_policy<
        T: std::convert::Into<std::option::Option<crate::model::IPAllocationPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ip_allocation_policy = v.into();
        self
    }

    /// Sets the value of [enable_ip_masq_agent][crate::model::NodeConfig::enable_ip_masq_agent].
    pub fn set_enable_ip_masq_agent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_ip_masq_agent = v.into();
        self
    }

    /// Sets the value of [composer_network_attachment][crate::model::NodeConfig::composer_network_attachment].
    pub fn set_composer_network_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.composer_network_attachment = v.into();
        self
    }

    /// Sets the value of [composer_internal_ipv4_cidr_block][crate::model::NodeConfig::composer_internal_ipv4_cidr_block].
    pub fn set_composer_internal_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.composer_internal_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [oauth_scopes][crate::model::NodeConfig::oauth_scopes].
    pub fn set_oauth_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oauth_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::NodeConfig::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.NodeConfig"
    }
}

/// Configuration options for the private GKE cluster in a Cloud Composer
/// environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateClusterConfig {
    /// Optional. If `true`, access to the public endpoint of the GKE cluster is
    /// denied.
    pub enable_private_endpoint: bool,

    /// Optional. The CIDR block from which IPv4 range for GKE master will be
    /// reserved. If left blank, the default value of '172.16.0.0/23' is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_ipv4_cidr_block: std::string::String,

    /// Output only. The IP range in CIDR notation to use for the hosted master
    /// network. This range is used for assigning internal IP addresses to the GKE
    /// cluster master or set of masters and to the internal load balancer virtual
    /// IP. This range must not overlap with any other ranges in use within the
    /// cluster's network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_ipv4_reserved_range: std::string::String,
}

impl PrivateClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_endpoint][crate::model::PrivateClusterConfig::enable_private_endpoint].
    pub fn set_enable_private_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_endpoint = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::PrivateClusterConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [master_ipv4_reserved_range][crate::model::PrivateClusterConfig::master_ipv4_reserved_range].
    pub fn set_master_ipv4_reserved_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_reserved_range = v.into();
        self
    }
}

impl wkt::message::Message for PrivateClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PrivateClusterConfig"
    }
}

/// Configuration options for networking connections in the Composer 2
/// environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkingConfig {
    /// Optional. Indicates the user requested specifc connection type between
    /// Tenant and Customer projects. You cannot set networking connection type in
    /// public IP environment.
    pub connection_type: crate::model::networking_config::ConnectionType,
}

impl NetworkingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_type][crate::model::NetworkingConfig::connection_type].
    pub fn set_connection_type<
        T: std::convert::Into<crate::model::networking_config::ConnectionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for NetworkingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.NetworkingConfig"
    }
}

/// Defines additional types related to NetworkingConfig
pub mod networking_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents connection type between Composer environment in Customer
    /// Project and the corresponding Tenant project, from a predefined list
    /// of available connection modes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConnectionType(i32);

    impl ConnectionType {
        /// No specific connection type was requested, so the environment uses
        /// the default value corresponding to the rest of its configuration.
        pub const CONNECTION_TYPE_UNSPECIFIED: ConnectionType = ConnectionType::new(0);

        /// Requests the use of VPC peerings for connecting the Customer and Tenant
        /// projects.
        pub const VPC_PEERING: ConnectionType = ConnectionType::new(1);

        /// Requests the use of Private Service Connect for connecting the Customer
        /// and Tenant projects.
        pub const PRIVATE_SERVICE_CONNECT: ConnectionType = ConnectionType::new(2);

        /// Creates a new ConnectionType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONNECTION_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("VPC_PEERING"),
                2 => std::borrow::Cow::Borrowed("PRIVATE_SERVICE_CONNECT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONNECTION_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONNECTION_TYPE_UNSPECIFIED)
                }
                "VPC_PEERING" => std::option::Option::Some(Self::VPC_PEERING),
                "PRIVATE_SERVICE_CONNECT" => {
                    std::option::Option::Some(Self::PRIVATE_SERVICE_CONNECT)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConnectionType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConnectionType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The configuration information for configuring a Private IP Cloud Composer
/// environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateEnvironmentConfig {
    /// Optional. If `true`, a Private IP Cloud Composer environment is created.
    /// If this field is set to true, `IPAllocationPolicy.use_ip_aliases` must be
    /// set to true for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub enable_private_environment: bool,

    /// Optional. If `true`, builds performed during operations that install Python
    /// packages have only private connectivity to Google services (including
    /// Artifact Registry) and VPC network (if either `NodeConfig.network` and
    /// `NodeConfig.subnetwork` fields or `NodeConfig.composer_network_attachment`
    /// field are specified). If `false`, the builds also have access to the
    /// internet.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    pub enable_private_builds_only: bool,

    /// Optional. Configuration for the private GKE cluster for a Private IP
    /// Cloud Composer environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_cluster_config: std::option::Option<crate::model::PrivateClusterConfig>,

    /// Optional. The CIDR block from which IP range for web server will be
    /// reserved. Needs to be disjoint from
    /// `private_cluster_config.master_ipv4_cidr_block` and
    /// `cloud_sql_ipv4_cidr_block`.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub web_server_ipv4_cidr_block: std::string::String,

    /// Optional. The CIDR block from which IP range in tenant project will be
    /// reserved for Cloud SQL. Needs to be disjoint from
    /// `web_server_ipv4_cidr_block`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_ipv4_cidr_block: std::string::String,

    /// Output only. The IP range reserved for the tenant project's App Engine VMs.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub web_server_ipv4_reserved_range: std::string::String,

    /// Optional. The CIDR block from which IP range for Cloud Composer Network in
    /// tenant project will be reserved. Needs to be disjoint from
    /// private_cluster_config.master_ipv4_cidr_block and
    /// cloud_sql_ipv4_cidr_block.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_composer_network_ipv4_cidr_block: std::string::String,

    /// Output only. The IP range reserved for the tenant project's Cloud Composer
    /// network.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_composer_network_ipv4_reserved_range: std::string::String,

    /// Optional. When enabled, IPs from public (non-RFC1918) ranges can be used
    /// for `IPAllocationPolicy.cluster_ipv4_cidr_block` and
    /// `IPAllocationPolicy.service_ipv4_cidr_block`.
    pub enable_privately_used_public_ips: bool,

    /// Optional. When specified, the environment will use Private Service Connect
    /// instead of VPC peerings to connect to Cloud SQL in the Tenant Project,
    /// and the PSC endpoint in the Customer Project will use an IP address from
    /// this subnetwork.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_composer_connection_subnetwork: std::string::String,

    /// Optional. Configuration for the network connections configuration in the
    /// environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub networking_config: std::option::Option<crate::model::NetworkingConfig>,
}

impl PrivateEnvironmentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_environment][crate::model::PrivateEnvironmentConfig::enable_private_environment].
    pub fn set_enable_private_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_environment = v.into();
        self
    }

    /// Sets the value of [enable_private_builds_only][crate::model::PrivateEnvironmentConfig::enable_private_builds_only].
    pub fn set_enable_private_builds_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_builds_only = v.into();
        self
    }

    /// Sets the value of [private_cluster_config][crate::model::PrivateEnvironmentConfig::private_cluster_config].
    pub fn set_private_cluster_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_cluster_config = v.into();
        self
    }

    /// Sets the value of [web_server_ipv4_cidr_block][crate::model::PrivateEnvironmentConfig::web_server_ipv4_cidr_block].
    pub fn set_web_server_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cloud_sql_ipv4_cidr_block][crate::model::PrivateEnvironmentConfig::cloud_sql_ipv4_cidr_block].
    pub fn set_cloud_sql_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_sql_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [web_server_ipv4_reserved_range][crate::model::PrivateEnvironmentConfig::web_server_ipv4_reserved_range].
    pub fn set_web_server_ipv4_reserved_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_ipv4_reserved_range = v.into();
        self
    }

    /// Sets the value of [cloud_composer_network_ipv4_cidr_block][crate::model::PrivateEnvironmentConfig::cloud_composer_network_ipv4_cidr_block].
    pub fn set_cloud_composer_network_ipv4_cidr_block<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_composer_network_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cloud_composer_network_ipv4_reserved_range][crate::model::PrivateEnvironmentConfig::cloud_composer_network_ipv4_reserved_range].
    pub fn set_cloud_composer_network_ipv4_reserved_range<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_composer_network_ipv4_reserved_range = v.into();
        self
    }

    /// Sets the value of [enable_privately_used_public_ips][crate::model::PrivateEnvironmentConfig::enable_privately_used_public_ips].
    pub fn set_enable_privately_used_public_ips<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_privately_used_public_ips = v.into();
        self
    }

    /// Sets the value of [cloud_composer_connection_subnetwork][crate::model::PrivateEnvironmentConfig::cloud_composer_connection_subnetwork].
    pub fn set_cloud_composer_connection_subnetwork<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_composer_connection_subnetwork = v.into();
        self
    }

    /// Sets the value of [networking_config][crate::model::PrivateEnvironmentConfig::networking_config].
    pub fn set_networking_config<
        T: std::convert::Into<std::option::Option<crate::model::NetworkingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.networking_config = v.into();
        self
    }
}

impl wkt::message::Message for PrivateEnvironmentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PrivateEnvironmentConfig"
    }
}

/// The Kubernetes workloads configuration for GKE cluster associated with the
/// Cloud Composer environment. Supported for Cloud Composer environments in
/// versions composer-2.*.*-airflow-*.*.* and newer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadsConfig {
    /// Optional. Resources used by Airflow schedulers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduler: std::option::Option<crate::model::workloads_config::SchedulerResource>,

    /// Optional. Resources used by Airflow web server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub web_server: std::option::Option<crate::model::workloads_config::WebServerResource>,

    /// Optional. Resources used by Airflow workers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker: std::option::Option<crate::model::workloads_config::WorkerResource>,

    /// Optional. Resources used by Airflow triggerers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub triggerer: std::option::Option<crate::model::workloads_config::TriggererResource>,

    /// Optional. Resources used by Airflow DAG processors.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dag_processor: std::option::Option<crate::model::workloads_config::DagProcessorResource>,
}

impl WorkloadsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scheduler][crate::model::WorkloadsConfig::scheduler].
    pub fn set_scheduler<
        T: std::convert::Into<std::option::Option<crate::model::workloads_config::SchedulerResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scheduler = v.into();
        self
    }

    /// Sets the value of [web_server][crate::model::WorkloadsConfig::web_server].
    pub fn set_web_server<
        T: std::convert::Into<std::option::Option<crate::model::workloads_config::WebServerResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.web_server = v.into();
        self
    }

    /// Sets the value of [worker][crate::model::WorkloadsConfig::worker].
    pub fn set_worker<
        T: std::convert::Into<std::option::Option<crate::model::workloads_config::WorkerResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.worker = v.into();
        self
    }

    /// Sets the value of [triggerer][crate::model::WorkloadsConfig::triggerer].
    pub fn set_triggerer<
        T: std::convert::Into<std::option::Option<crate::model::workloads_config::TriggererResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.triggerer = v.into();
        self
    }

    /// Sets the value of [dag_processor][crate::model::WorkloadsConfig::dag_processor].
    pub fn set_dag_processor<
        T: std::convert::Into<
            std::option::Option<crate::model::workloads_config::DagProcessorResource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dag_processor = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig"
    }
}

/// Defines additional types related to WorkloadsConfig
pub mod workloads_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for resources used by Airflow schedulers.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SchedulerResource {
        /// Optional. CPU request and limit for a single Airflow scheduler replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow scheduler
        /// replica.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for a single Airflow scheduler
        /// replica.
        pub storage_gb: f32,

        /// Optional. The number of schedulers.
        pub count: i32,
    }

    impl SchedulerResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::SchedulerResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::SchedulerResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::SchedulerResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }

        /// Sets the value of [count][crate::model::workloads_config::SchedulerResource::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for SchedulerResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.SchedulerResource"
        }
    }

    /// Configuration for resources used by Airflow web server.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WebServerResource {
        /// Optional. CPU request and limit for Airflow web server.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for Airflow web server.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for Airflow web server.
        pub storage_gb: f32,
    }

    impl WebServerResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::WebServerResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::WebServerResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::WebServerResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for WebServerResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.WebServerResource"
        }
    }

    /// Configuration for resources used by Airflow workers.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WorkerResource {
        /// Optional. CPU request and limit for a single Airflow worker replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow worker
        /// replica.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for a single Airflow worker
        /// replica.
        pub storage_gb: f32,

        /// Optional. Minimum number of workers for autoscaling.
        pub min_count: i32,

        /// Optional. Maximum number of workers for autoscaling.
        pub max_count: i32,
    }

    impl WorkerResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::WorkerResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::WorkerResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::WorkerResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }

        /// Sets the value of [min_count][crate::model::workloads_config::WorkerResource::min_count].
        pub fn set_min_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_count = v.into();
            self
        }

        /// Sets the value of [max_count][crate::model::workloads_config::WorkerResource::max_count].
        pub fn set_max_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_count = v.into();
            self
        }
    }

    impl wkt::message::Message for WorkerResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.WorkerResource"
        }
    }

    /// Configuration for resources used by Airflow triggerers.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TriggererResource {
        /// Optional. The number of triggerers.
        pub count: i32,

        /// Optional. CPU request and limit for a single Airflow triggerer replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow triggerer
        /// replica.
        pub memory_gb: f32,
    }

    impl TriggererResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::workloads_config::TriggererResource::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [cpu][crate::model::workloads_config::TriggererResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::TriggererResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for TriggererResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.TriggererResource"
        }
    }

    /// Configuration for resources used by Airflow DAG processors.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DagProcessorResource {
        /// Optional. CPU request and limit for a single Airflow DAG processor
        /// replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow DAG
        /// processor replica.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for a single Airflow DAG
        /// processor replica.
        pub storage_gb: f32,

        /// Optional. The number of DAG processors. If not provided or set to 0, a
        /// single DAG processor instance will be created.
        pub count: i32,
    }

    impl DagProcessorResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::DagProcessorResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::DagProcessorResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::DagProcessorResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }

        /// Sets the value of [count][crate::model::workloads_config::DagProcessorResource::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for DagProcessorResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.DagProcessorResource"
        }
    }
}

/// The Recovery settings of an environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecoveryConfig {
    /// Optional. The configuration for scheduled snapshot creation mechanism.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduled_snapshots_config: std::option::Option<crate::model::ScheduledSnapshotsConfig>,
}

impl RecoveryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scheduled_snapshots_config][crate::model::RecoveryConfig::scheduled_snapshots_config].
    pub fn set_scheduled_snapshots_config<
        T: std::convert::Into<std::option::Option<crate::model::ScheduledSnapshotsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scheduled_snapshots_config = v.into();
        self
    }
}

impl wkt::message::Message for RecoveryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.RecoveryConfig"
    }
}

/// The configuration for scheduled snapshot creation mechanism.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScheduledSnapshotsConfig {
    /// Optional. Whether scheduled snapshots creation is enabled.
    pub enabled: bool,

    /// Optional. The Cloud Storage location for storing automatically created
    /// snapshots.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_location: std::string::String,

    /// Optional. The cron expression representing the time when snapshots creation
    /// mechanism runs. This field is subject to additional validation around
    /// frequency of execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_creation_schedule: std::string::String,

    /// Optional. Time zone that sets the context to interpret
    /// snapshot_creation_schedule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_zone: std::string::String,
}

impl ScheduledSnapshotsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ScheduledSnapshotsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [snapshot_location][crate::model::ScheduledSnapshotsConfig::snapshot_location].
    pub fn set_snapshot_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_location = v.into();
        self
    }

    /// Sets the value of [snapshot_creation_schedule][crate::model::ScheduledSnapshotsConfig::snapshot_creation_schedule].
    pub fn set_snapshot_creation_schedule<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_creation_schedule = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::ScheduledSnapshotsConfig::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }
}

impl wkt::message::Message for ScheduledSnapshotsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ScheduledSnapshotsConfig"
    }
}

/// Configuration options for the master authorized networks feature. Enabled
/// master authorized networks will disallow all external traffic to access
/// Kubernetes master through HTTPS except traffic from the given CIDR blocks,
/// Google Compute Engine Public IPs and Google Prod IPs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MasterAuthorizedNetworksConfig {
    /// Whether or not master authorized networks feature is enabled.
    pub enabled: bool,

    /// Up to 50 external networks that could access Kubernetes master through
    /// HTTPS.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cidr_blocks: std::vec::Vec<crate::model::master_authorized_networks_config::CidrBlock>,
}

impl MasterAuthorizedNetworksConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::MasterAuthorizedNetworksConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [cidr_blocks][crate::model::MasterAuthorizedNetworksConfig::cidr_blocks].
    pub fn set_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::master_authorized_networks_config::CidrBlock>,
    {
        use std::iter::Iterator;
        self.cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MasterAuthorizedNetworksConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.MasterAuthorizedNetworksConfig"
    }
}

/// Defines additional types related to MasterAuthorizedNetworksConfig
pub mod master_authorized_networks_config {
    #[allow(unused_imports)]
    use super::*;

    /// CIDR block with an optional name.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CidrBlock {
        /// User-defined name that identifies the CIDR block.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// CIDR block that must be specified in CIDR notation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cidr_block: std::string::String,
    }

    impl CidrBlock {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::master_authorized_networks_config::CidrBlock::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [cidr_block][crate::model::master_authorized_networks_config::CidrBlock::cidr_block].
        pub fn set_cidr_block<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cidr_block = v.into();
            self
        }
    }

    impl wkt::message::Message for CidrBlock {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.MasterAuthorizedNetworksConfig.CidrBlock"
        }
    }
}

/// Configuration for Cloud Data Lineage integration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudDataLineageIntegration {
    /// Optional. Whether or not Cloud Data Lineage integration is enabled.
    pub enabled: bool,
}

impl CloudDataLineageIntegration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::CloudDataLineageIntegration::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for CloudDataLineageIntegration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CloudDataLineageIntegration"
    }
}

/// An environment for running orchestration tasks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Environment {
    /// Identifier. The resource name of the environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    ///
    /// EnvironmentId must start with a lowercase letter followed by up to 63
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Configuration parameters for this environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Output only. The UUID (Universally Unique IDentifier) associated with this
    /// environment. This value is generated when the environment is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uuid: std::string::String,

    /// The current state of the environment.
    pub state: crate::model::environment::State,

    /// Output only. The time at which this environment was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this environment was last modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-defined labels for this environment.
    /// The labels map can contain no more than 64 entries. Entries of the labels
    /// map are UTF8 strings that comply with the following restrictions:
    ///
    /// * Keys must conform to regexp: [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
    /// * Values must conform to regexp:  [\p{Ll}\p{Lo}\p{N}_-]{0,63}
    /// * Both keys and values are additionally constrained to be <= 128 bytes in
    ///   size.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// Optional. Storage configuration for this environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_config: std::option::Option<crate::model::StorageConfig>,
}

impl Environment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Environment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Environment::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::EnvironmentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::Environment::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Environment::state].
    pub fn set_state<T: std::convert::Into<crate::model::environment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Environment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Environment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Environment::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Environment::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [storage_config][crate::model::Environment::storage_config].
    pub fn set_storage_config<
        T: std::convert::Into<std::option::Option<crate::model::StorageConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Environment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Environment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.Environment"
    }
}

/// Defines additional types related to Environment
pub mod environment {
    #[allow(unused_imports)]
    use super::*;

    /// State of the environment.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The state of the environment is unknown.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The environment is in the process of being created.
        pub const CREATING: State = State::new(1);

        /// The environment is currently running and healthy. It is ready for use.
        pub const RUNNING: State = State::new(2);

        /// The environment is being updated. It remains usable but cannot receive
        /// additional update requests or be deleted at this time.
        pub const UPDATING: State = State::new(3);

        /// The environment is undergoing deletion. It cannot be used.
        pub const DELETING: State = State::new(4);

        /// The environment has encountered an error and cannot be used.
        pub const ERROR: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                5 => std::borrow::Cow::Borrowed("ERROR"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request to check whether image upgrade will succeed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckUpgradeRequest {
    /// Required. The resource name of the environment to check upgrade for, in the
    /// form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,

    /// Optional. The version of the software running in the environment.
    /// This encapsulates both the version of Cloud Composer functionality and the
    /// version of Apache Airflow. It must match the regular expression
    /// `composer-([0-9]+(\.[0-9]+\.[0-9]+(-preview\.[0-9]+)?)?|latest)-airflow-([0-9]+(\.[0-9]+(\.[0-9]+)?)?)`.
    /// When used as input, the server also checks if the provided version is
    /// supported and denies the request for an unsupported version.
    ///
    /// The Cloud Composer portion of the image version is a full
    /// [semantic version](https://semver.org), or an alias in the form of major
    /// version number or `latest`. When an alias is provided, the server replaces
    /// it with the current Cloud Composer version that satisfies the alias.
    ///
    /// The Apache Airflow portion of the image version is a full semantic version
    /// that points to one of the supported Apache Airflow versions, or an alias in
    /// the form of only major or major.minor versions specified. When an alias is
    /// provided, the server replaces it with the latest Apache Airflow version
    /// that satisfies the alias and is supported in the given Cloud Composer
    /// version.
    ///
    /// In all cases, the resolved image version is stored in the same field.
    ///
    /// See also [version
    /// list](/composer/docs/concepts/versioning/composer-versions) and [versioning
    /// overview](/composer/docs/concepts/versioning/composer-versioning-overview).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_version: std::string::String,
}

impl CheckUpgradeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::CheckUpgradeRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [image_version][crate::model::CheckUpgradeRequest::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }
}

impl wkt::message::Message for CheckUpgradeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CheckUpgradeRequest"
    }
}

/// Message containing information about the result of an upgrade check
/// operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckUpgradeResponse {
    /// Output only. Url for a docker build log of an upgraded image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub build_log_uri: std::string::String,

    /// Output only. Whether build has succeeded or failed on modules conflicts.
    pub contains_pypi_modules_conflict: crate::model::check_upgrade_response::ConflictResult,

    /// Output only. Extract from a docker image build log containing information
    /// about pypi modules conflicts.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pypi_conflict_build_log_extract: std::string::String,

    /// Composer image for which the build was happening.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_version: std::string::String,

    /// Pypi dependencies specified in the environment configuration, at the time
    /// when the build was triggered.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub pypi_dependencies: std::collections::HashMap<std::string::String, std::string::String>,
}

impl CheckUpgradeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build_log_uri][crate::model::CheckUpgradeResponse::build_log_uri].
    pub fn set_build_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_log_uri = v.into();
        self
    }

    /// Sets the value of [contains_pypi_modules_conflict][crate::model::CheckUpgradeResponse::contains_pypi_modules_conflict].
    pub fn set_contains_pypi_modules_conflict<
        T: std::convert::Into<crate::model::check_upgrade_response::ConflictResult>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.contains_pypi_modules_conflict = v.into();
        self
    }

    /// Sets the value of [pypi_conflict_build_log_extract][crate::model::CheckUpgradeResponse::pypi_conflict_build_log_extract].
    pub fn set_pypi_conflict_build_log_extract<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pypi_conflict_build_log_extract = v.into();
        self
    }

    /// Sets the value of [image_version][crate::model::CheckUpgradeResponse::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }

    /// Sets the value of [pypi_dependencies][crate::model::CheckUpgradeResponse::pypi_dependencies].
    pub fn set_pypi_dependencies<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pypi_dependencies = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CheckUpgradeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CheckUpgradeResponse"
    }
}

/// Defines additional types related to CheckUpgradeResponse
pub mod check_upgrade_response {
    #[allow(unused_imports)]
    use super::*;

    /// Whether there were python modules conflict during image build.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConflictResult(i32);

    impl ConflictResult {
        /// It is unknown whether build had conflicts or not.
        pub const CONFLICT_RESULT_UNSPECIFIED: ConflictResult = ConflictResult::new(0);

        /// There were python packages conflicts.
        pub const CONFLICT: ConflictResult = ConflictResult::new(1);

        /// There were no python packages conflicts.
        pub const NO_CONFLICT: ConflictResult = ConflictResult::new(2);

        /// Creates a new ConflictResult instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONFLICT_RESULT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CONFLICT"),
                2 => std::borrow::Cow::Borrowed("NO_CONFLICT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONFLICT_RESULT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONFLICT_RESULT_UNSPECIFIED)
                }
                "CONFLICT" => std::option::Option::Some(Self::CONFLICT),
                "NO_CONFLICT" => std::option::Option::Some(Self::NO_CONFLICT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConflictResult {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConflictResult {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The configuration setting for Airflow database data retention mechanism.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataRetentionConfig {
    /// Optional. The retention policy for airflow metadata database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub airflow_metadata_retention_config:
        std::option::Option<crate::model::AirflowMetadataRetentionPolicyConfig>,

    /// Optional. The configuration settings for task logs retention
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub task_logs_retention_config: std::option::Option<crate::model::TaskLogsRetentionConfig>,
}

impl DataRetentionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [airflow_metadata_retention_config][crate::model::DataRetentionConfig::airflow_metadata_retention_config].
    pub fn set_airflow_metadata_retention_config<
        T: std::convert::Into<std::option::Option<crate::model::AirflowMetadataRetentionPolicyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.airflow_metadata_retention_config = v.into();
        self
    }

    /// Sets the value of [task_logs_retention_config][crate::model::DataRetentionConfig::task_logs_retention_config].
    pub fn set_task_logs_retention_config<
        T: std::convert::Into<std::option::Option<crate::model::TaskLogsRetentionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task_logs_retention_config = v.into();
        self
    }
}

impl wkt::message::Message for DataRetentionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DataRetentionConfig"
    }
}

/// The configuration setting for Task Logs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TaskLogsRetentionConfig {
    /// Optional. The mode of storage for Airflow workers task logs.
    pub storage_mode: crate::model::task_logs_retention_config::TaskLogsStorageMode,
}

impl TaskLogsRetentionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_mode][crate::model::TaskLogsRetentionConfig::storage_mode].
    pub fn set_storage_mode<
        T: std::convert::Into<crate::model::task_logs_retention_config::TaskLogsStorageMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_mode = v.into();
        self
    }
}

impl wkt::message::Message for TaskLogsRetentionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.TaskLogsRetentionConfig"
    }
}

/// Defines additional types related to TaskLogsRetentionConfig
pub mod task_logs_retention_config {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of task_logs_storage_mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TaskLogsStorageMode(i32);

    impl TaskLogsStorageMode {
        /// This configuration is not specified by the user.
        pub const TASK_LOGS_STORAGE_MODE_UNSPECIFIED: TaskLogsStorageMode =
            TaskLogsStorageMode::new(0);

        /// Store task logs in Cloud Logging and in the environment's Cloud Storage
        /// bucket.
        pub const CLOUD_LOGGING_AND_CLOUD_STORAGE: TaskLogsStorageMode =
            TaskLogsStorageMode::new(1);

        /// Store task logs in Cloud Logging only.
        pub const CLOUD_LOGGING_ONLY: TaskLogsStorageMode = TaskLogsStorageMode::new(2);

        /// Creates a new TaskLogsStorageMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TASK_LOGS_STORAGE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLOUD_LOGGING_AND_CLOUD_STORAGE"),
                2 => std::borrow::Cow::Borrowed("CLOUD_LOGGING_ONLY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TASK_LOGS_STORAGE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TASK_LOGS_STORAGE_MODE_UNSPECIFIED)
                }
                "CLOUD_LOGGING_AND_CLOUD_STORAGE" => {
                    std::option::Option::Some(Self::CLOUD_LOGGING_AND_CLOUD_STORAGE)
                }
                "CLOUD_LOGGING_ONLY" => std::option::Option::Some(Self::CLOUD_LOGGING_ONLY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TaskLogsStorageMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TaskLogsStorageMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The policy for airflow metadata database retention.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AirflowMetadataRetentionPolicyConfig {
    /// Optional. Retention can be either enabled or disabled.
    pub retention_mode: crate::model::airflow_metadata_retention_policy_config::RetentionMode,

    /// Optional. How many days data should be retained for.
    pub retention_days: i32,
}

impl AirflowMetadataRetentionPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retention_mode][crate::model::AirflowMetadataRetentionPolicyConfig::retention_mode].
    pub fn set_retention_mode<
        T: std::convert::Into<crate::model::airflow_metadata_retention_policy_config::RetentionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention_mode = v.into();
        self
    }

    /// Sets the value of [retention_days][crate::model::AirflowMetadataRetentionPolicyConfig::retention_days].
    pub fn set_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_days = v.into();
        self
    }
}

impl wkt::message::Message for AirflowMetadataRetentionPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.AirflowMetadataRetentionPolicyConfig"
    }
}

/// Defines additional types related to AirflowMetadataRetentionPolicyConfig
pub mod airflow_metadata_retention_policy_config {
    #[allow(unused_imports)]
    use super::*;

    /// Describes retention policy.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RetentionMode(i32);

    impl RetentionMode {
        /// Default mode doesn't change environment parameters.
        pub const RETENTION_MODE_UNSPECIFIED: RetentionMode = RetentionMode::new(0);

        /// Retention policy is enabled.
        pub const RETENTION_MODE_ENABLED: RetentionMode = RetentionMode::new(1);

        /// Retention policy is disabled.
        pub const RETENTION_MODE_DISABLED: RetentionMode = RetentionMode::new(2);

        /// Creates a new RetentionMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RETENTION_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RETENTION_MODE_ENABLED"),
                2 => std::borrow::Cow::Borrowed("RETENTION_MODE_DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RETENTION_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RETENTION_MODE_UNSPECIFIED)
                }
                "RETENTION_MODE_ENABLED" => std::option::Option::Some(Self::RETENTION_MODE_ENABLED),
                "RETENTION_MODE_DISABLED" => {
                    std::option::Option::Some(Self::RETENTION_MODE_DISABLED)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RetentionMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RetentionMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// List ImageVersions in a project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImageVersionsRequest {
    /// List ImageVersions in the given project and location, in the form:
    /// "projects/{projectId}/locations/{locationId}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of image_versions to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Whether or not image versions from old releases should be included.
    pub include_past_releases: bool,
}

impl ListImageVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImageVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImageVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImageVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [include_past_releases][crate::model::ListImageVersionsRequest::include_past_releases].
    pub fn set_include_past_releases<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_past_releases = v.into();
        self
    }
}

impl wkt::message::Message for ListImageVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListImageVersionsRequest"
    }
}

/// The ImageVersions in a project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImageVersionsResponse {
    /// The list of supported ImageVersions in a location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub image_versions: std::vec::Vec<crate::model::ImageVersion>,

    /// The page token used to query for the next page if one exists.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListImageVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListImageVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [image_versions][crate::model::ListImageVersionsResponse::image_versions].
    pub fn set_image_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImageVersion>,
    {
        use std::iter::Iterator;
        self.image_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImageVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListImageVersionsResponse"
    }
}

impl gax::paginator::PageableResponse for ListImageVersionsResponse {
    type PageItem = crate::model::ImageVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.image_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// ImageVersion information
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageVersion {
    /// The string identifier of the ImageVersion, in the form:
    /// "composer-x.y.z-airflow-a.b.c"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_version_id: std::string::String,

    /// Whether this is the default ImageVersion used by Composer during
    /// environment creation if no input ImageVersion is specified.
    pub is_default: bool,

    /// supported python versions
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_python_versions: std::vec::Vec<std::string::String>,

    /// The date of the version release.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub release_date: std::option::Option<gtype::model::Date>,

    /// Whether it is impossible to create an environment with the image version.
    pub creation_disabled: bool,

    /// Whether it is impossible to upgrade an environment running with the image
    /// version.
    pub upgrade_disabled: bool,
}

impl ImageVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_version_id][crate::model::ImageVersion::image_version_id].
    pub fn set_image_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.image_version_id = v.into();
        self
    }

    /// Sets the value of [is_default][crate::model::ImageVersion::is_default].
    pub fn set_is_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_default = v.into();
        self
    }

    /// Sets the value of [release_date][crate::model::ImageVersion::release_date].
    pub fn set_release_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_date = v.into();
        self
    }

    /// Sets the value of [creation_disabled][crate::model::ImageVersion::creation_disabled].
    pub fn set_creation_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.creation_disabled = v.into();
        self
    }

    /// Sets the value of [upgrade_disabled][crate::model::ImageVersion::upgrade_disabled].
    pub fn set_upgrade_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.upgrade_disabled = v.into();
        self
    }

    /// Sets the value of [supported_python_versions][crate::model::ImageVersion::supported_python_versions].
    pub fn set_supported_python_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_python_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ImageVersion"
    }
}

/// Metadata describing an operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The current operation state.
    pub state: crate::model::operation_metadata::State,

    /// Output only. The type of operation being performed.
    pub operation_type: crate::model::operation_metadata::Type,

    /// Output only. The resource being operated on, as a [relative resource name](
    /// /apis/design/resource_names#relative_resource_name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// Output only. The UUID of the resource being operated on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uuid: std::string::String,

    /// Output only. The time the operation was submitted to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the operation terminated, regardless of its
    /// success. This field is unset if the operation is still ongoing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::OperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::OperationMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation_metadata::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::OperationMetadata::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [resource_uuid][crate::model::OperationMetadata::resource_uuid].
    pub fn set_resource_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.OperationMetadata"
    }
}

/// Defines additional types related to OperationMetadata
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// An enum describing the overall state of an operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unused.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The operation has been created but is not yet started.
        pub const PENDING: State = State::new(1);

        /// The operation is underway.
        pub const RUNNING: State = State::new(2);

        /// The operation completed successfully.
        pub const SUCCEEDED: State = State::new(3);

        pub const SUCCESSFUL: State = State::new(3);

        /// The operation is no longer running but did not succeed.
        pub const FAILED: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                4 => std::borrow::Cow::Borrowed("FAILED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "SUCCESSFUL" => std::option::Option::Some(Self::SUCCESSFUL),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of longrunning operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Unused.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// A resource creation operation.
        pub const CREATE: Type = Type::new(1);

        /// A resource deletion operation.
        pub const DELETE: Type = Type::new(2);

        /// A resource update operation.
        pub const UPDATE: Type = Type::new(3);

        /// A resource check operation.
        pub const CHECK: Type = Type::new(4);

        /// Saves snapshot of the resource operation.
        pub const SAVE_SNAPSHOT: Type = Type::new(5);

        /// Loads snapshot of the resource operation.
        pub const LOAD_SNAPSHOT: Type = Type::new(6);

        /// Triggers failover of environment's Cloud SQL instance (only for highly
        /// resilient environments).
        pub const DATABASE_FAILOVER: Type = Type::new(7);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATE"),
                2 => std::borrow::Cow::Borrowed("DELETE"),
                3 => std::borrow::Cow::Borrowed("UPDATE"),
                4 => std::borrow::Cow::Borrowed("CHECK"),
                5 => std::borrow::Cow::Borrowed("SAVE_SNAPSHOT"),
                6 => std::borrow::Cow::Borrowed("LOAD_SNAPSHOT"),
                7 => std::borrow::Cow::Borrowed("DATABASE_FAILOVER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "CREATE" => std::option::Option::Some(Self::CREATE),
                "DELETE" => std::option::Option::Some(Self::DELETE),
                "UPDATE" => std::option::Option::Some(Self::UPDATE),
                "CHECK" => std::option::Option::Some(Self::CHECK),
                "SAVE_SNAPSHOT" => std::option::Option::Some(Self::SAVE_SNAPSHOT),
                "LOAD_SNAPSHOT" => std::option::Option::Some(Self::LOAD_SNAPSHOT),
                "DATABASE_FAILOVER" => std::option::Option::Some(Self::DATABASE_FAILOVER),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }
}
