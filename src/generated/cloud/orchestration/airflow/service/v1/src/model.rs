// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Create a new environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEnvironmentRequest {
    /// The parent must be of the form
    /// "projects/{projectId}/locations/{locationId}".
    pub parent: std::string::String,

    /// The environment to create.
    pub environment: std::option::Option<crate::model::Environment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnvironmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CreateEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateEnvironmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Get an environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEnvironmentRequest {
    /// The resource name of the environment to get, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.GetEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEnvironmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List environments in a project and location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsRequest {
    /// List environments in the given project and location, in the form:
    /// "projects/{projectId}/locations/{locationId}"
    pub parent: std::string::String,

    /// The maximum number of environments to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnvironmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnvironmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnvironmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnvironmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListEnvironmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEnvironmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEnvironmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The environments in a project and location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsResponse {
    /// The list of environments returned by a ListEnvironmentsRequest.
    pub environments: std::vec::Vec<crate::model::Environment>,

    /// The page token used to query for the next page if one exists.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnvironmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environments][crate::model::ListEnvironmentsResponse::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEnvironmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListEnvironmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnvironmentsResponse {
    type PageItem = crate::model::Environment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.environments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environments" => Ok(__FieldTag::__environments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environments => {
                            if !fields.insert(__FieldTag::__environments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environments",
                                ));
                            }
                            result.environments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Environment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEnvironmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEnvironmentsResponse");
        debug_struct.field("environments", &self.environments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Delete an environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEnvironmentRequest {
    /// The environment to delete, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DeleteEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteEnvironmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update an environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEnvironmentRequest {
    /// The relative resource name of the environment to update, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub name: std::string::String,

    /// A patch environment. Fields specified by the `updateMask` will be copied
    /// from the patch environment into the environment under update.
    pub environment: std::option::Option<crate::model::Environment>,

    /// Required. A comma-separated list of paths, relative to `Environment`, of
    /// fields to update.
    /// For example, to set the version of scikit-learn to install in the
    /// environment to 0.19.0 and to remove an existing installation of
    /// numpy, the `updateMask` parameter would include the following two
    /// `paths` values: "config.softwareConfig.pypiPackages.scikit-learn" and
    /// "config.softwareConfig.pypiPackages.numpy". The included patch
    /// environment would specify the scikit-learn version as follows:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "softwareConfig":{
    ///       "pypiPackages":{
    ///         "scikit-learn":"==0.19.0"
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Note that in the above example, any existing PyPI packages
    /// other than scikit-learn and numpy will be unaffected.
    ///
    /// Only one update type may be included in a single request's `updateMask`.
    /// For example, one cannot update both the PyPI packages and
    /// labels in the same request. However, it is possible to update multiple
    /// members of a map field simultaneously in the same request. For example,
    /// to set the labels "label1" and "label2" while clearing "label3" (assuming
    /// it already exists), one can
    /// provide the paths "labels.label1", "labels.label2", and "labels.label3"
    /// and populate the patch environment as follows:
    ///
    /// ```norust
    /// {
    ///   "labels":{
    ///     "label1":"new-label1-value"
    ///     "label2":"new-label2-value"
    ///   }
    /// }
    /// ```
    ///
    /// Note that in the above example, any existing labels that are not
    /// included in the `updateMask` will be unaffected.
    ///
    /// It is also possible to replace an entire map field by providing the
    /// map field's path in the `updateMask`. The new value of the field will
    /// be that which is provided in the patch environment. For example, to
    /// delete all pre-existing user-specified PyPI packages and
    /// install botocore at version 1.7.14, the `updateMask` would contain
    /// the path "config.softwareConfig.pypiPackages", and
    /// the patch environment would be the following:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "softwareConfig":{
    ///       "pypiPackages":{
    ///         "botocore":"==1.7.14"
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// **Note:** Only the following fields can be updated:
    ///
    /// * `config.softwareConfig.pypiPackages`
    ///   * Replace all custom custom PyPI packages. If a replacement
    ///     package map is not included in `environment`, all custom
    ///     PyPI packages are cleared. It is an error to provide both
    ///     this mask and a mask specifying an individual package.
    /// * `config.softwareConfig.pypiPackages.`packagename
    ///   * Update the custom PyPI package *packagename*,
    ///     preserving other packages. To delete the package, include it in
    ///     `updateMask`, and omit the mapping for it in
    ///     `environment.config.softwareConfig.pypiPackages`. It is an error
    ///     to provide both a mask of this form and the
    ///     `config.softwareConfig.pypiPackages` mask.
    /// * `labels`
    ///   * Replace all environment labels. If a replacement labels map is not
    ///     included in `environment`, all labels are cleared. It is an error to
    ///     provide both this mask and a mask specifying one or more individual
    ///     labels.
    /// * `labels.`labelName
    ///   * Set the label named *labelName*, while preserving other
    ///     labels. To delete the label, include it in `updateMask` and omit its
    ///     mapping in `environment.labels`. It is an error to provide both a
    ///     mask of this form and the `labels` mask.
    /// * `config.nodeCount`
    ///   * Horizontally scale the number of nodes in the environment. An integer
    ///     greater than or equal to 3 must be provided in the `config.nodeCount`
    ///     field. Supported for Cloud Composer environments in versions
    ///     composer-1.*.*-airflow-*.*.*.
    /// * `config.webServerNetworkAccessControl`
    ///   * Replace the environment's current `WebServerNetworkAccessControl`.
    /// * `config.softwareConfig.airflowConfigOverrides`
    ///   * Replace all Apache Airflow config overrides. If a replacement config
    ///     overrides map is not included in `environment`, all config overrides
    ///     are cleared.
    ///     It is an error to provide both this mask and a mask specifying one or
    ///     more individual config overrides.
    /// * `config.softwareConfig.airflowConfigOverrides.`section-name
    ///   * Override the Apache Airflow config property *name* in the
    ///     section named *section*, preserving other properties. To
    ///     delete the property override, include it in `updateMask` and omit its
    ///     mapping in
    ///     `environment.config.softwareConfig.airflowConfigOverrides`.
    ///     It is an error to provide both a mask of this form and the
    ///     `config.softwareConfig.airflowConfigOverrides` mask.
    /// * `config.softwareConfig.envVariables`
    ///   * Replace all environment variables. If a replacement environment
    ///     variable map is not included in `environment`, all custom environment
    ///     variables are cleared.
    /// * `config.softwareConfig.schedulerCount`
    ///   * Horizontally scale the number of schedulers in Airflow. A positive
    ///     integer not greater than the number of nodes must be provided in the
    ///     `config.softwareConfig.schedulerCount` field. Supported for Cloud
    ///     Composer environments in versions composer-1.*.*-airflow-2.*.*.
    /// * `config.databaseConfig.machineType`
    ///   * Cloud SQL machine type used by Airflow database.
    ///     It has to be one of: db-n1-standard-2, db-n1-standard-4,
    ///     db-n1-standard-8 or db-n1-standard-16. Supported for Cloud Composer
    ///     environments in versions composer-1.*.*-airflow-*.*.*.
    /// * `config.webServerConfig.machineType`
    ///   * Machine type on which Airflow web server is running.
    ///     It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4
    ///     or composer-n1-webserver-8. Supported for Cloud Composer environments
    ///     in versions composer-1.*.*-airflow-*.*.*.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UpdateEnvironmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __environment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "environment" => Ok(__FieldTag::__environment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateEnvironmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateEnvironmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Execute Airflow Command request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteAirflowCommandRequest {
    /// The resource name of the environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}".
    pub environment: std::string::String,

    /// Airflow command.
    pub command: std::string::String,

    /// Airflow subcommand.
    pub subcommand: std::string::String,

    /// Parameters for the Airflow command/subcommand as an array of arguments.
    /// It may contain positional arguments like `["my-dag-id"]`, key-value
    /// parameters like `["--foo=bar"]` or `["--foo","bar"]`,
    /// or other flags like `["-f"]`.
    pub parameters: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteAirflowCommandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::ExecuteAirflowCommandRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [command][crate::model::ExecuteAirflowCommandRequest::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [subcommand][crate::model::ExecuteAirflowCommandRequest::subcommand].
    pub fn set_subcommand<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subcommand = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::ExecuteAirflowCommandRequest::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExecuteAirflowCommandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ExecuteAirflowCommandRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecuteAirflowCommandRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __command,
            __subcommand,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecuteAirflowCommandRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "command" => Ok(__FieldTag::__command),
                            "subcommand" => Ok(__FieldTag::__subcommand),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecuteAirflowCommandRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecuteAirflowCommandRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__command => {
                            if !fields.insert(__FieldTag::__command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for command",
                                ));
                            }
                            result.command = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subcommand => {
                            if !fields.insert(__FieldTag::__subcommand) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subcommand",
                                ));
                            }
                            result.subcommand = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecuteAirflowCommandRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.command.is_empty() {
            state.serialize_entry("command", &self.command)?;
        }
        if !self.subcommand.is_empty() {
            state.serialize_entry("subcommand", &self.subcommand)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecuteAirflowCommandRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecuteAirflowCommandRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("command", &self.command);
        debug_struct.field("subcommand", &self.subcommand);
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to ExecuteAirflowCommandRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteAirflowCommandResponse {
    /// The unique ID of the command execution for polling.
    pub execution_id: std::string::String,

    /// The name of the pod where the command is executed.
    pub pod: std::string::String,

    /// The namespace of the pod where the command is executed.
    pub pod_namespace: std::string::String,

    /// Error message. Empty if there was no error.
    pub error: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteAirflowCommandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_id][crate::model::ExecuteAirflowCommandResponse::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::ExecuteAirflowCommandResponse::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [pod_namespace][crate::model::ExecuteAirflowCommandResponse::pod_namespace].
    pub fn set_pod_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_namespace = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ExecuteAirflowCommandResponse::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for ExecuteAirflowCommandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ExecuteAirflowCommandResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecuteAirflowCommandResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_id,
            __pod,
            __pod_namespace,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecuteAirflowCommandResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionId" => Ok(__FieldTag::__execution_id),
                            "execution_id" => Ok(__FieldTag::__execution_id),
                            "pod" => Ok(__FieldTag::__pod),
                            "podNamespace" => Ok(__FieldTag::__pod_namespace),
                            "pod_namespace" => Ok(__FieldTag::__pod_namespace),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecuteAirflowCommandResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecuteAirflowCommandResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_id => {
                            if !fields.insert(__FieldTag::__execution_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_id",
                                ));
                            }
                            result.execution_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod => {
                            if !fields.insert(__FieldTag::__pod) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod",
                                ));
                            }
                            result.pod = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_namespace => {
                            if !fields.insert(__FieldTag::__pod_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_namespace",
                                ));
                            }
                            result.pod_namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecuteAirflowCommandResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.execution_id.is_empty() {
            state.serialize_entry("executionId", &self.execution_id)?;
        }
        if !self.pod.is_empty() {
            state.serialize_entry("pod", &self.pod)?;
        }
        if !self.pod_namespace.is_empty() {
            state.serialize_entry("podNamespace", &self.pod_namespace)?;
        }
        if !self.error.is_empty() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecuteAirflowCommandResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecuteAirflowCommandResponse");
        debug_struct.field("execution_id", &self.execution_id);
        debug_struct.field("pod", &self.pod);
        debug_struct.field("pod_namespace", &self.pod_namespace);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Stop Airflow Command request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopAirflowCommandRequest {
    /// The resource name of the environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}".
    pub environment: std::string::String,

    /// The unique ID of the command execution.
    pub execution_id: std::string::String,

    /// The name of the pod where the command is executed.
    pub pod: std::string::String,

    /// The namespace of the pod where the command is executed.
    pub pod_namespace: std::string::String,

    /// If true, the execution is terminated forcefully (SIGKILL). If false, the
    /// execution is stopped gracefully, giving it time for cleanup.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopAirflowCommandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::StopAirflowCommandRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [execution_id][crate::model::StopAirflowCommandRequest::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::StopAirflowCommandRequest::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [pod_namespace][crate::model::StopAirflowCommandRequest::pod_namespace].
    pub fn set_pod_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_namespace = v.into();
        self
    }

    /// Sets the value of [force][crate::model::StopAirflowCommandRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for StopAirflowCommandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.StopAirflowCommandRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopAirflowCommandRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __execution_id,
            __pod,
            __pod_namespace,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopAirflowCommandRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "executionId" => Ok(__FieldTag::__execution_id),
                            "execution_id" => Ok(__FieldTag::__execution_id),
                            "pod" => Ok(__FieldTag::__pod),
                            "podNamespace" => Ok(__FieldTag::__pod_namespace),
                            "pod_namespace" => Ok(__FieldTag::__pod_namespace),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopAirflowCommandRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopAirflowCommandRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_id => {
                            if !fields.insert(__FieldTag::__execution_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_id",
                                ));
                            }
                            result.execution_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod => {
                            if !fields.insert(__FieldTag::__pod) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod",
                                ));
                            }
                            result.pod = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_namespace => {
                            if !fields.insert(__FieldTag::__pod_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_namespace",
                                ));
                            }
                            result.pod_namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopAirflowCommandRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.execution_id.is_empty() {
            state.serialize_entry("executionId", &self.execution_id)?;
        }
        if !self.pod.is_empty() {
            state.serialize_entry("pod", &self.pod)?;
        }
        if !self.pod_namespace.is_empty() {
            state.serialize_entry("podNamespace", &self.pod_namespace)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StopAirflowCommandRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopAirflowCommandRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("execution_id", &self.execution_id);
        debug_struct.field("pod", &self.pod);
        debug_struct.field("pod_namespace", &self.pod_namespace);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to StopAirflowCommandRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopAirflowCommandResponse {
    /// Whether the execution is still running.
    pub is_done: bool,

    /// Output message from stopping execution request.
    pub output: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopAirflowCommandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_done][crate::model::StopAirflowCommandResponse::is_done].
    pub fn set_is_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_done = v.into();
        self
    }

    /// Sets the value of [output][crate::model::StopAirflowCommandResponse::output].
    pub fn set_output<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.output = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StopAirflowCommandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.StopAirflowCommandResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopAirflowCommandResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __is_done,
            __output,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopAirflowCommandResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "isDone" => Ok(__FieldTag::__is_done),
                            "is_done" => Ok(__FieldTag::__is_done),
                            "output" => Ok(__FieldTag::__output),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopAirflowCommandResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopAirflowCommandResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__is_done => {
                            if !fields.insert(__FieldTag::__is_done) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_done",
                                ));
                            }
                            result.is_done = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output => {
                            if !fields.insert(__FieldTag::__output) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output",
                                ));
                            }
                            result.output = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopAirflowCommandResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.is_done) {
            state.serialize_entry("isDone", &self.is_done)?;
        }
        if !self.output.is_empty() {
            state.serialize_entry("output", &self.output)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StopAirflowCommandResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopAirflowCommandResponse");
        debug_struct.field("is_done", &self.is_done);
        debug_struct.field("output", &self.output);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Poll Airflow Command request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PollAirflowCommandRequest {
    /// The resource name of the environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub environment: std::string::String,

    /// The unique ID of the command execution.
    pub execution_id: std::string::String,

    /// The name of the pod where the command is executed.
    pub pod: std::string::String,

    /// The namespace of the pod where the command is executed.
    pub pod_namespace: std::string::String,

    /// Line number from which new logs should be fetched.
    pub next_line_number: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PollAirflowCommandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::PollAirflowCommandRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [execution_id][crate::model::PollAirflowCommandRequest::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::PollAirflowCommandRequest::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [pod_namespace][crate::model::PollAirflowCommandRequest::pod_namespace].
    pub fn set_pod_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_namespace = v.into();
        self
    }

    /// Sets the value of [next_line_number][crate::model::PollAirflowCommandRequest::next_line_number].
    pub fn set_next_line_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.next_line_number = v.into();
        self
    }
}

impl wkt::message::Message for PollAirflowCommandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PollAirflowCommandRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __execution_id,
            __pod,
            __pod_namespace,
            __next_line_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PollAirflowCommandRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "executionId" => Ok(__FieldTag::__execution_id),
                            "execution_id" => Ok(__FieldTag::__execution_id),
                            "pod" => Ok(__FieldTag::__pod),
                            "podNamespace" => Ok(__FieldTag::__pod_namespace),
                            "pod_namespace" => Ok(__FieldTag::__pod_namespace),
                            "nextLineNumber" => Ok(__FieldTag::__next_line_number),
                            "next_line_number" => Ok(__FieldTag::__next_line_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PollAirflowCommandRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PollAirflowCommandRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_id => {
                            if !fields.insert(__FieldTag::__execution_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_id",
                                ));
                            }
                            result.execution_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod => {
                            if !fields.insert(__FieldTag::__pod) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod",
                                ));
                            }
                            result.pod = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_namespace => {
                            if !fields.insert(__FieldTag::__pod_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_namespace",
                                ));
                            }
                            result.pod_namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_line_number => {
                            if !fields.insert(__FieldTag::__next_line_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_line_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.next_line_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PollAirflowCommandRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.execution_id.is_empty() {
            state.serialize_entry("executionId", &self.execution_id)?;
        }
        if !self.pod.is_empty() {
            state.serialize_entry("pod", &self.pod)?;
        }
        if !self.pod_namespace.is_empty() {
            state.serialize_entry("podNamespace", &self.pod_namespace)?;
        }
        if !wkt::internal::is_default(&self.next_line_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nextLineNumber", &__With(&self.next_line_number))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PollAirflowCommandRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PollAirflowCommandRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("execution_id", &self.execution_id);
        debug_struct.field("pod", &self.pod);
        debug_struct.field("pod_namespace", &self.pod_namespace);
        debug_struct.field("next_line_number", &self.next_line_number);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to PollAirflowCommandRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PollAirflowCommandResponse {
    /// Output from the command execution. It may not contain the full output
    /// and the caller may need to poll for more lines.
    pub output: std::vec::Vec<crate::model::poll_airflow_command_response::Line>,

    /// Whether the command execution has finished and there is no more output.
    pub output_end: bool,

    /// The result exit status of the command.
    pub exit_info: std::option::Option<crate::model::poll_airflow_command_response::ExitInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PollAirflowCommandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::PollAirflowCommandResponse::output].
    pub fn set_output<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::poll_airflow_command_response::Line>,
    {
        use std::iter::Iterator;
        self.output = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_end][crate::model::PollAirflowCommandResponse::output_end].
    pub fn set_output_end<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.output_end = v.into();
        self
    }

    /// Sets the value of [exit_info][crate::model::PollAirflowCommandResponse::exit_info].
    pub fn set_exit_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::poll_airflow_command_response::ExitInfo>,
    {
        self.exit_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exit_info][crate::model::PollAirflowCommandResponse::exit_info].
    pub fn set_or_clear_exit_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::poll_airflow_command_response::ExitInfo>,
    {
        self.exit_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PollAirflowCommandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PollAirflowCommandResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output,
            __output_end,
            __exit_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PollAirflowCommandResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "output" => Ok(__FieldTag::__output),
                            "outputEnd" => Ok(__FieldTag::__output_end),
                            "output_end" => Ok(__FieldTag::__output_end),
                            "exitInfo" => Ok(__FieldTag::__exit_info),
                            "exit_info" => Ok(__FieldTag::__exit_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PollAirflowCommandResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PollAirflowCommandResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output => {
                            if !fields.insert(__FieldTag::__output) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output",
                                ));
                            }
                            result.output = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::poll_airflow_command_response::Line,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_end => {
                            if !fields.insert(__FieldTag::__output_end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_end",
                                ));
                            }
                            result.output_end = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exit_info => {
                            if !fields.insert(__FieldTag::__exit_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exit_info",
                                ));
                            }
                            result.exit_info = map.next_value::<std::option::Option<
                                crate::model::poll_airflow_command_response::ExitInfo,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PollAirflowCommandResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.output.is_empty() {
            state.serialize_entry("output", &self.output)?;
        }
        if !wkt::internal::is_default(&self.output_end) {
            state.serialize_entry("outputEnd", &self.output_end)?;
        }
        if self.exit_info.is_some() {
            state.serialize_entry("exitInfo", &self.exit_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PollAirflowCommandResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PollAirflowCommandResponse");
        debug_struct.field("output", &self.output);
        debug_struct.field("output_end", &self.output_end);
        debug_struct.field("exit_info", &self.exit_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PollAirflowCommandResponse].
pub mod poll_airflow_command_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains information about a single line from logs.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Line {
        /// Number of the line.
        pub line_number: i32,

        /// Text content of the log line.
        pub content: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Line {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line_number][crate::model::poll_airflow_command_response::Line::line_number].
        pub fn set_line_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.line_number = v.into();
            self
        }

        /// Sets the value of [content][crate::model::poll_airflow_command_response::Line::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }
    }

    impl wkt::message::Message for Line {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandResponse.Line"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Line {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __line_number,
                __content,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Line")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lineNumber" => Ok(__FieldTag::__line_number),
                                "line_number" => Ok(__FieldTag::__line_number),
                                "content" => Ok(__FieldTag::__content),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Line;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Line")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__line_number => {
                                if !fields.insert(__FieldTag::__line_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for line_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.line_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__content => {
                                if !fields.insert(__FieldTag::__content) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for content",
                                    ));
                                }
                                result.content = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Line {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.line_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("lineNumber", &__With(&self.line_number))?;
            }
            if !self.content.is_empty() {
                state.serialize_entry("content", &self.content)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Line {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Line");
            debug_struct.field("line_number", &self.line_number);
            debug_struct.field("content", &self.content);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Information about how a command ended.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExitInfo {
        /// The exit code from the command execution.
        pub exit_code: i32,

        /// Error message. Empty if there was no error.
        pub error: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExitInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [exit_code][crate::model::poll_airflow_command_response::ExitInfo::exit_code].
        pub fn set_exit_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.exit_code = v.into();
            self
        }

        /// Sets the value of [error][crate::model::poll_airflow_command_response::ExitInfo::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for ExitInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PollAirflowCommandResponse.ExitInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExitInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __exit_code,
                __error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExitInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "exitCode" => Ok(__FieldTag::__exit_code),
                                "exit_code" => Ok(__FieldTag::__exit_code),
                                "error" => Ok(__FieldTag::__error),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExitInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExitInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__exit_code => {
                                if !fields.insert(__FieldTag::__exit_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exit_code",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.exit_code =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExitInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.exit_code) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("exitCode", &__With(&self.exit_code))?;
            }
            if !self.error.is_empty() {
                state.serialize_entry("error", &self.error)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ExitInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ExitInfo");
            debug_struct.field("exit_code", &self.exit_code);
            debug_struct.field("error", &self.error);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Create user workloads Secret request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUserWorkloadsSecretRequest {
    /// Required. The environment name to create a Secret for, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub parent: std::string::String,

    /// Required. User workloads Secret to create.
    pub user_workloads_secret: std::option::Option<crate::model::UserWorkloadsSecret>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserWorkloadsSecretRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_workloads_secret][crate::model::CreateUserWorkloadsSecretRequest::user_workloads_secret].
    pub fn set_user_workloads_secret<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsSecret>,
    {
        self.user_workloads_secret = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_workloads_secret][crate::model::CreateUserWorkloadsSecretRequest::user_workloads_secret].
    pub fn set_or_clear_user_workloads_secret<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsSecret>,
    {
        self.user_workloads_secret = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CreateUserWorkloadsSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUserWorkloadsSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __user_workloads_secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUserWorkloadsSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "userWorkloadsSecret" => Ok(__FieldTag::__user_workloads_secret),
                            "user_workloads_secret" => Ok(__FieldTag::__user_workloads_secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUserWorkloadsSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUserWorkloadsSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_workloads_secret => {
                            if !fields.insert(__FieldTag::__user_workloads_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_workloads_secret",
                                ));
                            }
                            result.user_workloads_secret = map.next_value::<std::option::Option<crate::model::UserWorkloadsSecret>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUserWorkloadsSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.user_workloads_secret.is_some() {
            state.serialize_entry("userWorkloadsSecret", &self.user_workloads_secret)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateUserWorkloadsSecretRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("user_workloads_secret", &self.user_workloads_secret);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Get user workloads Secret request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUserWorkloadsSecretRequest {
    /// Required. The resource name of the Secret to get, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserWorkloadsSecretRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.GetUserWorkloadsSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUserWorkloadsSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUserWorkloadsSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUserWorkloadsSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUserWorkloadsSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUserWorkloadsSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetUserWorkloadsSecretRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List user workloads Secrets request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUserWorkloadsSecretsRequest {
    /// Required. List Secrets in the given environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub parent: std::string::String,

    /// Optional. The maximum number of Secrets to return.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserWorkloadsSecretsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUserWorkloadsSecretsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUserWorkloadsSecretsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUserWorkloadsSecretsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsSecretsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsSecretsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUserWorkloadsSecretsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUserWorkloadsSecretsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUserWorkloadsSecretsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUserWorkloadsSecretsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUserWorkloadsSecretsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUserWorkloadsSecretsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsSecretsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update user workloads Secret request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateUserWorkloadsSecretRequest {
    /// Optional. User workloads Secret to override.
    pub user_workloads_secret: std::option::Option<crate::model::UserWorkloadsSecret>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workloads_secret][crate::model::UpdateUserWorkloadsSecretRequest::user_workloads_secret].
    pub fn set_user_workloads_secret<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsSecret>,
    {
        self.user_workloads_secret = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_workloads_secret][crate::model::UpdateUserWorkloadsSecretRequest::user_workloads_secret].
    pub fn set_or_clear_user_workloads_secret<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsSecret>,
    {
        self.user_workloads_secret = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UpdateUserWorkloadsSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateUserWorkloadsSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_workloads_secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateUserWorkloadsSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userWorkloadsSecret" => Ok(__FieldTag::__user_workloads_secret),
                            "user_workloads_secret" => Ok(__FieldTag::__user_workloads_secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateUserWorkloadsSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateUserWorkloadsSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_workloads_secret => {
                            if !fields.insert(__FieldTag::__user_workloads_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_workloads_secret",
                                ));
                            }
                            result.user_workloads_secret = map.next_value::<std::option::Option<crate::model::UserWorkloadsSecret>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateUserWorkloadsSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.user_workloads_secret.is_some() {
            state.serialize_entry("userWorkloadsSecret", &self.user_workloads_secret)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateUserWorkloadsSecretRequest");
        debug_struct.field("user_workloads_secret", &self.user_workloads_secret);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Delete user workloads Secret request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUserWorkloadsSecretRequest {
    /// Required. The Secret to delete, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserWorkloadsSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserWorkloadsSecretRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserWorkloadsSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DeleteUserWorkloadsSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUserWorkloadsSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUserWorkloadsSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUserWorkloadsSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUserWorkloadsSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUserWorkloadsSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteUserWorkloadsSecretRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteUserWorkloadsSecretRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Create user workloads ConfigMap request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUserWorkloadsConfigMapRequest {
    /// Required. The environment name to create a ConfigMap for, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub parent: std::string::String,

    /// Required. User workloads ConfigMap to create.
    pub user_workloads_config_map: std::option::Option<crate::model::UserWorkloadsConfigMap>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserWorkloadsConfigMapRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_workloads_config_map][crate::model::CreateUserWorkloadsConfigMapRequest::user_workloads_config_map].
    pub fn set_user_workloads_config_map<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsConfigMap>,
    {
        self.user_workloads_config_map = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_workloads_config_map][crate::model::CreateUserWorkloadsConfigMapRequest::user_workloads_config_map].
    pub fn set_or_clear_user_workloads_config_map<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsConfigMap>,
    {
        self.user_workloads_config_map = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CreateUserWorkloadsConfigMapRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUserWorkloadsConfigMapRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __user_workloads_config_map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUserWorkloadsConfigMapRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "userWorkloadsConfigMap" => Ok(__FieldTag::__user_workloads_config_map),
                            "user_workloads_config_map" => {
                                Ok(__FieldTag::__user_workloads_config_map)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUserWorkloadsConfigMapRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUserWorkloadsConfigMapRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_workloads_config_map => {
                            if !fields.insert(__FieldTag::__user_workloads_config_map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_workloads_config_map",
                                ));
                            }
                            result.user_workloads_config_map = map.next_value::<std::option::Option<crate::model::UserWorkloadsConfigMap>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUserWorkloadsConfigMapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.user_workloads_config_map.is_some() {
            state.serialize_entry("userWorkloadsConfigMap", &self.user_workloads_config_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateUserWorkloadsConfigMapRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("user_workloads_config_map", &self.user_workloads_config_map);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Get user workloads ConfigMap request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUserWorkloadsConfigMapRequest {
    /// Required. The resource name of the ConfigMap to get, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserWorkloadsConfigMapRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.GetUserWorkloadsConfigMapRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUserWorkloadsConfigMapRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUserWorkloadsConfigMapRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUserWorkloadsConfigMapRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUserWorkloadsConfigMapRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUserWorkloadsConfigMapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetUserWorkloadsConfigMapRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List user workloads ConfigMaps request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUserWorkloadsConfigMapsRequest {
    /// Required. List ConfigMaps in the given environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub parent: std::string::String,

    /// Optional. The maximum number of ConfigMaps to return.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserWorkloadsConfigMapsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUserWorkloadsConfigMapsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUserWorkloadsConfigMapsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUserWorkloadsConfigMapsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsConfigMapsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsConfigMapsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUserWorkloadsConfigMapsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUserWorkloadsConfigMapsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUserWorkloadsConfigMapsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUserWorkloadsConfigMapsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUserWorkloadsConfigMapsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUserWorkloadsConfigMapsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsConfigMapsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update user workloads ConfigMap request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateUserWorkloadsConfigMapRequest {
    /// Optional. User workloads ConfigMap to override.
    pub user_workloads_config_map: std::option::Option<crate::model::UserWorkloadsConfigMap>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workloads_config_map][crate::model::UpdateUserWorkloadsConfigMapRequest::user_workloads_config_map].
    pub fn set_user_workloads_config_map<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsConfigMap>,
    {
        self.user_workloads_config_map = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_workloads_config_map][crate::model::UpdateUserWorkloadsConfigMapRequest::user_workloads_config_map].
    pub fn set_or_clear_user_workloads_config_map<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserWorkloadsConfigMap>,
    {
        self.user_workloads_config_map = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UpdateUserWorkloadsConfigMapRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateUserWorkloadsConfigMapRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_workloads_config_map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateUserWorkloadsConfigMapRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userWorkloadsConfigMap" => Ok(__FieldTag::__user_workloads_config_map),
                            "user_workloads_config_map" => {
                                Ok(__FieldTag::__user_workloads_config_map)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateUserWorkloadsConfigMapRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateUserWorkloadsConfigMapRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_workloads_config_map => {
                            if !fields.insert(__FieldTag::__user_workloads_config_map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_workloads_config_map",
                                ));
                            }
                            result.user_workloads_config_map = map.next_value::<std::option::Option<crate::model::UserWorkloadsConfigMap>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateUserWorkloadsConfigMapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.user_workloads_config_map.is_some() {
            state.serialize_entry("userWorkloadsConfigMap", &self.user_workloads_config_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateUserWorkloadsConfigMapRequest");
        debug_struct.field("user_workloads_config_map", &self.user_workloads_config_map);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Delete user workloads ConfigMap request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUserWorkloadsConfigMapRequest {
    /// Required. The ConfigMap to delete, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserWorkloadsConfigMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserWorkloadsConfigMapRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserWorkloadsConfigMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DeleteUserWorkloadsConfigMapRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUserWorkloadsConfigMapRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUserWorkloadsConfigMapRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUserWorkloadsConfigMapRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUserWorkloadsConfigMapRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUserWorkloadsConfigMapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteUserWorkloadsConfigMapRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteUserWorkloadsConfigMapRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// User workloads Secret used by Airflow tasks that run with Kubernetes executor
/// or KubernetesPodOperator.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserWorkloadsSecret {
    /// Identifier. The resource name of the Secret, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
    pub name: std::string::String,

    /// Optional. The "data" field of Kubernetes Secret, organized in key-value
    /// pairs, which can contain sensitive values such as a password, a token, or a
    /// key. The values for all keys have to be base64-encoded strings. For details
    /// see: <https://kubernetes.io/docs/concepts/configuration/secret/>
    ///
    /// Example:
    ///
    /// {
    /// "example": "ZXhhbXBsZV92YWx1ZQ==",
    /// "another-example": "YW5vdGhlcl9leGFtcGxlX3ZhbHVl"
    /// }
    pub data: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserWorkloadsSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UserWorkloadsSecret::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::UserWorkloadsSecret::data].
    pub fn set_data<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for UserWorkloadsSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UserWorkloadsSecret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserWorkloadsSecret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserWorkloadsSecret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "data" => Ok(__FieldTag::__data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserWorkloadsSecret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserWorkloadsSecret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            result.data = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserWorkloadsSecret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserWorkloadsSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserWorkloadsSecret");
        debug_struct.field("name", &self.name);
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The user workloads Secrets for a given environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUserWorkloadsSecretsResponse {
    /// The list of Secrets returned by a ListUserWorkloadsSecretsRequest.
    pub user_workloads_secrets: std::vec::Vec<crate::model::UserWorkloadsSecret>,

    /// The page token used to query for the next page if one exists.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserWorkloadsSecretsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workloads_secrets][crate::model::ListUserWorkloadsSecretsResponse::user_workloads_secrets].
    pub fn set_user_workloads_secrets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserWorkloadsSecret>,
    {
        use std::iter::Iterator;
        self.user_workloads_secrets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUserWorkloadsSecretsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsSecretsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsSecretsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUserWorkloadsSecretsResponse {
    type PageItem = crate::model::UserWorkloadsSecret;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.user_workloads_secrets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUserWorkloadsSecretsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_workloads_secrets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUserWorkloadsSecretsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userWorkloadsSecrets" => Ok(__FieldTag::__user_workloads_secrets),
                            "user_workloads_secrets" => Ok(__FieldTag::__user_workloads_secrets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUserWorkloadsSecretsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUserWorkloadsSecretsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_workloads_secrets => {
                            if !fields.insert(__FieldTag::__user_workloads_secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_workloads_secrets",
                                ));
                            }
                            result.user_workloads_secrets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UserWorkloadsSecret>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUserWorkloadsSecretsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_workloads_secrets.is_empty() {
            state.serialize_entry("userWorkloadsSecrets", &self.user_workloads_secrets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUserWorkloadsSecretsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsSecretsResponse");
        debug_struct.field("user_workloads_secrets", &self.user_workloads_secrets);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// User workloads ConfigMap used by Airflow tasks that run with Kubernetes
/// executor or KubernetesPodOperator.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserWorkloadsConfigMap {
    /// Identifier. The resource name of the ConfigMap, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
    pub name: std::string::String,

    /// Optional. The "data" field of Kubernetes ConfigMap, organized in key-value
    /// pairs. For details see:
    /// <https://kubernetes.io/docs/concepts/configuration/configmap/>
    ///
    /// Example:
    ///
    /// {
    /// "example_key": "example_value",
    /// "another_key": "another_value"
    /// }
    pub data: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserWorkloadsConfigMap {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UserWorkloadsConfigMap::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::UserWorkloadsConfigMap::data].
    pub fn set_data<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for UserWorkloadsConfigMap {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.UserWorkloadsConfigMap"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserWorkloadsConfigMap {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserWorkloadsConfigMap")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "data" => Ok(__FieldTag::__data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserWorkloadsConfigMap;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserWorkloadsConfigMap")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            result.data = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserWorkloadsConfigMap {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserWorkloadsConfigMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserWorkloadsConfigMap");
        debug_struct.field("name", &self.name);
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The user workloads ConfigMaps for a given environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUserWorkloadsConfigMapsResponse {
    /// The list of ConfigMaps returned by a ListUserWorkloadsConfigMapsRequest.
    pub user_workloads_config_maps: std::vec::Vec<crate::model::UserWorkloadsConfigMap>,

    /// The page token used to query for the next page if one exists.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserWorkloadsConfigMapsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workloads_config_maps][crate::model::ListUserWorkloadsConfigMapsResponse::user_workloads_config_maps].
    pub fn set_user_workloads_config_maps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserWorkloadsConfigMap>,
    {
        use std::iter::Iterator;
        self.user_workloads_config_maps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUserWorkloadsConfigMapsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUserWorkloadsConfigMapsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListUserWorkloadsConfigMapsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUserWorkloadsConfigMapsResponse {
    type PageItem = crate::model::UserWorkloadsConfigMap;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.user_workloads_config_maps
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUserWorkloadsConfigMapsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_workloads_config_maps,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUserWorkloadsConfigMapsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userWorkloadsConfigMaps" => {
                                Ok(__FieldTag::__user_workloads_config_maps)
                            }
                            "user_workloads_config_maps" => {
                                Ok(__FieldTag::__user_workloads_config_maps)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUserWorkloadsConfigMapsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUserWorkloadsConfigMapsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_workloads_config_maps => {
                            if !fields.insert(__FieldTag::__user_workloads_config_maps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_workloads_config_maps",
                                ));
                            }
                            result.user_workloads_config_maps = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UserWorkloadsConfigMap>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUserWorkloadsConfigMapsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_workloads_config_maps.is_empty() {
            state.serialize_entry("userWorkloadsConfigMaps", &self.user_workloads_config_maps)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUserWorkloadsConfigMapsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUserWorkloadsConfigMapsResponse");
        debug_struct.field(
            "user_workloads_config_maps",
            &self.user_workloads_config_maps,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for listing workloads in a Cloud Composer environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkloadsRequest {
    /// Required. The environment name to get workloads for, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub parent: std::string::String,

    /// Optional. The maximum number of environments to return.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    pub page_token: std::string::String,

    /// Optional. The list filter.
    /// Currently only supports equality on the type field. The value of a field
    /// specified in the filter expression must be one ComposerWorkloadType enum
    /// option. It's possible to get multiple types using "OR" operator, e.g.:
    /// "type=SCHEDULER OR type=CELERY_WORKER". If not specified, all items are
    /// returned.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkloadsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkloadsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkloadsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkloadsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkloadsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkloadsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkloadsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkloadsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkloadsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkloadsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkloadsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListWorkloadsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkloadsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to ListWorkloadsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkloadsResponse {
    /// The list of environment workloads.
    pub workloads: std::vec::Vec<crate::model::list_workloads_response::ComposerWorkload>,

    /// The page token used to query for the next page if one exists.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkloadsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workloads][crate::model::ListWorkloadsResponse::workloads].
    pub fn set_workloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::list_workloads_response::ComposerWorkload>,
    {
        use std::iter::Iterator;
        self.workloads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkloadsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkloadsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkloadsResponse {
    type PageItem = crate::model::list_workloads_response::ComposerWorkload;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workloads
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkloadsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workloads,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkloadsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workloads" => Ok(__FieldTag::__workloads),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkloadsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkloadsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workloads => {
                            if !fields.insert(__FieldTag::__workloads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workloads",
                                ));
                            }
                            result.workloads = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::list_workloads_response::ComposerWorkload,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkloadsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workloads.is_empty() {
            state.serialize_entry("workloads", &self.workloads)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListWorkloadsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkloadsResponse");
        debug_struct.field("workloads", &self.workloads);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ListWorkloadsResponse].
pub mod list_workloads_response {
    #[allow(unused_imports)]
    use super::*;

    /// Information about a single workload.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ComposerWorkload {
        /// Name of a workload.
        pub name: std::string::String,

        /// Type of a workload.
        pub r#type: crate::model::list_workloads_response::ComposerWorkloadType,

        /// Output only. Status of a workload.
        pub status:
            std::option::Option<crate::model::list_workloads_response::ComposerWorkloadStatus>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ComposerWorkload {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::list_workloads_response::ComposerWorkload::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::list_workloads_response::ComposerWorkload::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::list_workloads_response::ComposerWorkloadType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [status][crate::model::list_workloads_response::ComposerWorkload::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::list_workloads_response::ComposerWorkloadStatus>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::list_workloads_response::ComposerWorkload::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::list_workloads_response::ComposerWorkloadStatus>,
        {
            self.status = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ComposerWorkload {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse.ComposerWorkload"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ComposerWorkload {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __type,
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ComposerWorkload")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ComposerWorkload;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ComposerWorkload")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::list_workloads_response::ComposerWorkloadType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map.next_value::<std::option::Option<
                                    crate::model::list_workloads_response::ComposerWorkloadStatus,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ComposerWorkload {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ComposerWorkload {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ComposerWorkload");
            debug_struct.field("name", &self.name);
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("status", &self.status);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Workload status.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ComposerWorkloadStatus {
        /// Output only. Workload state.
        pub state: crate::model::list_workloads_response::ComposerWorkloadState,

        /// Output only. Text to provide more descriptive status.
        pub status_message: std::string::String,

        /// Output only. Detailed message of the status.
        pub detailed_status_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ComposerWorkloadStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::list_workloads_response::ComposerWorkloadStatus::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::list_workloads_response::ComposerWorkloadState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [status_message][crate::model::list_workloads_response::ComposerWorkloadStatus::status_message].
        pub fn set_status_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.status_message = v.into();
            self
        }

        /// Sets the value of [detailed_status_message][crate::model::list_workloads_response::ComposerWorkloadStatus::detailed_status_message].
        pub fn set_detailed_status_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.detailed_status_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ComposerWorkloadStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse.ComposerWorkloadStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ComposerWorkloadStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __status_message,
                __detailed_status_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ComposerWorkloadStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "statusMessage" => Ok(__FieldTag::__status_message),
                                "status_message" => Ok(__FieldTag::__status_message),
                                "detailedStatusMessage" => {
                                    Ok(__FieldTag::__detailed_status_message)
                                }
                                "detailed_status_message" => {
                                    Ok(__FieldTag::__detailed_status_message)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ComposerWorkloadStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ComposerWorkloadStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::list_workloads_response::ComposerWorkloadState>>()?.unwrap_or_default();
                            }
                            __FieldTag::__status_message => {
                                if !fields.insert(__FieldTag::__status_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status_message",
                                    ));
                                }
                                result.status_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__detailed_status_message => {
                                if !fields.insert(__FieldTag::__detailed_status_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detailed_status_message",
                                    ));
                                }
                                result.detailed_status_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ComposerWorkloadStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.status_message.is_empty() {
                state.serialize_entry("statusMessage", &self.status_message)?;
            }
            if !self.detailed_status_message.is_empty() {
                state.serialize_entry("detailedStatusMessage", &self.detailed_status_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ComposerWorkloadStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ComposerWorkloadStatus");
            debug_struct.field("state", &self.state);
            debug_struct.field("status_message", &self.status_message);
            debug_struct.field("detailed_status_message", &self.detailed_status_message);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Supported workload types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComposerWorkloadType {
        /// Not able to determine the type of the workload.
        Unspecified,
        /// Celery worker.
        CeleryWorker,
        /// Kubernetes worker.
        KubernetesWorker,
        /// Workload created by Kubernetes Pod Operator.
        KubernetesOperatorPod,
        /// Airflow scheduler.
        Scheduler,
        /// Airflow Dag processor.
        DagProcessor,
        /// Airflow triggerer.
        Triggerer,
        /// Airflow web server UI.
        WebServer,
        /// Redis.
        Redis,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ComposerWorkloadType::value] or
        /// [ComposerWorkloadType::name].
        UnknownValue(composer_workload_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod composer_workload_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ComposerWorkloadType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CeleryWorker => std::option::Option::Some(1),
                Self::KubernetesWorker => std::option::Option::Some(2),
                Self::KubernetesOperatorPod => std::option::Option::Some(3),
                Self::Scheduler => std::option::Option::Some(4),
                Self::DagProcessor => std::option::Option::Some(5),
                Self::Triggerer => std::option::Option::Some(6),
                Self::WebServer => std::option::Option::Some(7),
                Self::Redis => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("COMPOSER_WORKLOAD_TYPE_UNSPECIFIED")
                }
                Self::CeleryWorker => std::option::Option::Some("CELERY_WORKER"),
                Self::KubernetesWorker => std::option::Option::Some("KUBERNETES_WORKER"),
                Self::KubernetesOperatorPod => std::option::Option::Some("KUBERNETES_OPERATOR_POD"),
                Self::Scheduler => std::option::Option::Some("SCHEDULER"),
                Self::DagProcessor => std::option::Option::Some("DAG_PROCESSOR"),
                Self::Triggerer => std::option::Option::Some("TRIGGERER"),
                Self::WebServer => std::option::Option::Some("WEB_SERVER"),
                Self::Redis => std::option::Option::Some("REDIS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ComposerWorkloadType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ComposerWorkloadType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ComposerWorkloadType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CeleryWorker,
                2 => Self::KubernetesWorker,
                3 => Self::KubernetesOperatorPod,
                4 => Self::Scheduler,
                5 => Self::DagProcessor,
                6 => Self::Triggerer,
                7 => Self::WebServer,
                8 => Self::Redis,
                _ => Self::UnknownValue(composer_workload_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ComposerWorkloadType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPOSER_WORKLOAD_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CELERY_WORKER" => Self::CeleryWorker,
                "KUBERNETES_WORKER" => Self::KubernetesWorker,
                "KUBERNETES_OPERATOR_POD" => Self::KubernetesOperatorPod,
                "SCHEDULER" => Self::Scheduler,
                "DAG_PROCESSOR" => Self::DagProcessor,
                "TRIGGERER" => Self::Triggerer,
                "WEB_SERVER" => Self::WebServer,
                "REDIS" => Self::Redis,
                _ => Self::UnknownValue(composer_workload_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ComposerWorkloadType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CeleryWorker => serializer.serialize_i32(1),
                Self::KubernetesWorker => serializer.serialize_i32(2),
                Self::KubernetesOperatorPod => serializer.serialize_i32(3),
                Self::Scheduler => serializer.serialize_i32(4),
                Self::DagProcessor => serializer.serialize_i32(5),
                Self::Triggerer => serializer.serialize_i32(6),
                Self::WebServer => serializer.serialize_i32(7),
                Self::Redis => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ComposerWorkloadType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComposerWorkloadType>::new(
                ".google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse.ComposerWorkloadType"))
        }
    }

    /// Workload states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComposerWorkloadState {
        /// Not able to determine the status of the workload.
        Unspecified,
        /// Workload is in pending state and has not yet started.
        Pending,
        /// Workload is running fine.
        Ok,
        /// Workload is running but there are some non-critical problems.
        Warning,
        /// Workload is not running due to an error.
        Error,
        /// Workload has finished execution with success.
        Succeeded,
        /// Workload has finished execution with failure.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ComposerWorkloadState::value] or
        /// [ComposerWorkloadState::name].
        UnknownValue(composer_workload_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod composer_workload_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ComposerWorkloadState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Ok => std::option::Option::Some(2),
                Self::Warning => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Succeeded => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("COMPOSER_WORKLOAD_STATE_UNSPECIFIED")
                }
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ComposerWorkloadState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ComposerWorkloadState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ComposerWorkloadState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Ok,
                3 => Self::Warning,
                4 => Self::Error,
                5 => Self::Succeeded,
                6 => Self::Failed,
                _ => Self::UnknownValue(composer_workload_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ComposerWorkloadState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPOSER_WORKLOAD_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "OK" => Self::Ok,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(composer_workload_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ComposerWorkloadState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Ok => serializer.serialize_i32(2),
                Self::Warning => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Succeeded => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ComposerWorkloadState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComposerWorkloadState>::new(
                ".google.cloud.orchestration.airflow.service.v1.ListWorkloadsResponse.ComposerWorkloadState"))
        }
    }
}

/// Request to create a snapshot of a Cloud Composer environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SaveSnapshotRequest {
    /// The resource name of the source environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub environment: std::string::String,

    /// Location in a Cloud Storage where the snapshot is going to be stored, e.g.:
    /// "gs://my-bucket/snapshots".
    pub snapshot_location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SaveSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::SaveSnapshotRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [snapshot_location][crate::model::SaveSnapshotRequest::snapshot_location].
    pub fn set_snapshot_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_location = v.into();
        self
    }
}

impl wkt::message::Message for SaveSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.SaveSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SaveSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __snapshot_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SaveSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "snapshotLocation" => Ok(__FieldTag::__snapshot_location),
                            "snapshot_location" => Ok(__FieldTag::__snapshot_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SaveSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SaveSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_location => {
                            if !fields.insert(__FieldTag::__snapshot_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_location",
                                ));
                            }
                            result.snapshot_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SaveSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.snapshot_location.is_empty() {
            state.serialize_entry("snapshotLocation", &self.snapshot_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SaveSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SaveSnapshotRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("snapshot_location", &self.snapshot_location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to SaveSnapshotRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SaveSnapshotResponse {
    /// The fully-resolved Cloud Storage path of the created snapshot,
    /// e.g.:
    /// "gs://my-bucket/snapshots/project_location_environment_timestamp".
    /// This field is populated only if the snapshot creation was successful.
    pub snapshot_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SaveSnapshotResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot_path][crate::model::SaveSnapshotResponse::snapshot_path].
    pub fn set_snapshot_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_path = v.into();
        self
    }
}

impl wkt::message::Message for SaveSnapshotResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.SaveSnapshotResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SaveSnapshotResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshot_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SaveSnapshotResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshotPath" => Ok(__FieldTag::__snapshot_path),
                            "snapshot_path" => Ok(__FieldTag::__snapshot_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SaveSnapshotResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SaveSnapshotResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshot_path => {
                            if !fields.insert(__FieldTag::__snapshot_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_path",
                                ));
                            }
                            result.snapshot_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SaveSnapshotResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshot_path.is_empty() {
            state.serialize_entry("snapshotPath", &self.snapshot_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SaveSnapshotResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SaveSnapshotResponse");
        debug_struct.field("snapshot_path", &self.snapshot_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to load a snapshot into a Cloud Composer environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadSnapshotRequest {
    /// The resource name of the target environment in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub environment: std::string::String,

    /// A Cloud Storage path to a snapshot to load, e.g.:
    /// "gs://my-bucket/snapshots/project_location_environment_timestamp".
    pub snapshot_path: std::string::String,

    /// Whether or not to skip installing Pypi packages when loading the
    /// environment's state.
    pub skip_pypi_packages_installation: bool,

    /// Whether or not to skip setting environment variables when loading the
    /// environment's state.
    pub skip_environment_variables_setting: bool,

    /// Whether or not to skip setting Airflow overrides when loading the
    /// environment's state.
    pub skip_airflow_overrides_setting: bool,

    /// Whether or not to skip copying Cloud Storage data when loading the
    /// environment's state.
    pub skip_gcs_data_copying: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoadSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::LoadSnapshotRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [snapshot_path][crate::model::LoadSnapshotRequest::snapshot_path].
    pub fn set_snapshot_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_path = v.into();
        self
    }

    /// Sets the value of [skip_pypi_packages_installation][crate::model::LoadSnapshotRequest::skip_pypi_packages_installation].
    pub fn set_skip_pypi_packages_installation<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.skip_pypi_packages_installation = v.into();
        self
    }

    /// Sets the value of [skip_environment_variables_setting][crate::model::LoadSnapshotRequest::skip_environment_variables_setting].
    pub fn set_skip_environment_variables_setting<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.skip_environment_variables_setting = v.into();
        self
    }

    /// Sets the value of [skip_airflow_overrides_setting][crate::model::LoadSnapshotRequest::skip_airflow_overrides_setting].
    pub fn set_skip_airflow_overrides_setting<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_airflow_overrides_setting = v.into();
        self
    }

    /// Sets the value of [skip_gcs_data_copying][crate::model::LoadSnapshotRequest::skip_gcs_data_copying].
    pub fn set_skip_gcs_data_copying<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_gcs_data_copying = v.into();
        self
    }
}

impl wkt::message::Message for LoadSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.LoadSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __snapshot_path,
            __skip_pypi_packages_installation,
            __skip_environment_variables_setting,
            __skip_airflow_overrides_setting,
            __skip_gcs_data_copying,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "snapshotPath" => Ok(__FieldTag::__snapshot_path),
                            "snapshot_path" => Ok(__FieldTag::__snapshot_path),
                            "skipPypiPackagesInstallation" => {
                                Ok(__FieldTag::__skip_pypi_packages_installation)
                            }
                            "skip_pypi_packages_installation" => {
                                Ok(__FieldTag::__skip_pypi_packages_installation)
                            }
                            "skipEnvironmentVariablesSetting" => {
                                Ok(__FieldTag::__skip_environment_variables_setting)
                            }
                            "skip_environment_variables_setting" => {
                                Ok(__FieldTag::__skip_environment_variables_setting)
                            }
                            "skipAirflowOverridesSetting" => {
                                Ok(__FieldTag::__skip_airflow_overrides_setting)
                            }
                            "skip_airflow_overrides_setting" => {
                                Ok(__FieldTag::__skip_airflow_overrides_setting)
                            }
                            "skipGcsDataCopying" => Ok(__FieldTag::__skip_gcs_data_copying),
                            "skip_gcs_data_copying" => Ok(__FieldTag::__skip_gcs_data_copying),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_path => {
                            if !fields.insert(__FieldTag::__snapshot_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_path",
                                ));
                            }
                            result.snapshot_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_pypi_packages_installation => {
                            if !fields.insert(__FieldTag::__skip_pypi_packages_installation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_pypi_packages_installation",
                                ));
                            }
                            result.skip_pypi_packages_installation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_environment_variables_setting => {
                            if !fields.insert(__FieldTag::__skip_environment_variables_setting) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_environment_variables_setting",
                                ));
                            }
                            result.skip_environment_variables_setting = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_airflow_overrides_setting => {
                            if !fields.insert(__FieldTag::__skip_airflow_overrides_setting) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_airflow_overrides_setting",
                                ));
                            }
                            result.skip_airflow_overrides_setting = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_gcs_data_copying => {
                            if !fields.insert(__FieldTag::__skip_gcs_data_copying) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_gcs_data_copying",
                                ));
                            }
                            result.skip_gcs_data_copying = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoadSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.snapshot_path.is_empty() {
            state.serialize_entry("snapshotPath", &self.snapshot_path)?;
        }
        if !wkt::internal::is_default(&self.skip_pypi_packages_installation) {
            state.serialize_entry(
                "skipPypiPackagesInstallation",
                &self.skip_pypi_packages_installation,
            )?;
        }
        if !wkt::internal::is_default(&self.skip_environment_variables_setting) {
            state.serialize_entry(
                "skipEnvironmentVariablesSetting",
                &self.skip_environment_variables_setting,
            )?;
        }
        if !wkt::internal::is_default(&self.skip_airflow_overrides_setting) {
            state.serialize_entry(
                "skipAirflowOverridesSetting",
                &self.skip_airflow_overrides_setting,
            )?;
        }
        if !wkt::internal::is_default(&self.skip_gcs_data_copying) {
            state.serialize_entry("skipGcsDataCopying", &self.skip_gcs_data_copying)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoadSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadSnapshotRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("snapshot_path", &self.snapshot_path);
        debug_struct.field(
            "skip_pypi_packages_installation",
            &self.skip_pypi_packages_installation,
        );
        debug_struct.field(
            "skip_environment_variables_setting",
            &self.skip_environment_variables_setting,
        );
        debug_struct.field(
            "skip_airflow_overrides_setting",
            &self.skip_airflow_overrides_setting,
        );
        debug_struct.field("skip_gcs_data_copying", &self.skip_gcs_data_copying);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to LoadSnapshotRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadSnapshotResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoadSnapshotResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for LoadSnapshotResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.LoadSnapshotResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadSnapshotResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadSnapshotResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadSnapshotResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadSnapshotResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoadSnapshotResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoadSnapshotResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadSnapshotResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to trigger database failover (only for highly resilient
/// environments).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseFailoverRequest {
    /// Target environment:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub environment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::DatabaseFailoverRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DatabaseFailoverRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseFailoverRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseFailoverRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseFailoverRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseFailoverRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseFailoverRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseFailoverRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseFailoverRequest");
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for DatabaseFailoverRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseFailoverResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseFailoverResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DatabaseFailoverResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DatabaseFailoverResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseFailoverResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseFailoverResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseFailoverResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseFailoverResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseFailoverResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseFailoverResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseFailoverResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to fetch properties of environment's database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchDatabasePropertiesRequest {
    /// Required. The resource name of the environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub environment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchDatabasePropertiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::FetchDatabasePropertiesRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for FetchDatabasePropertiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.FetchDatabasePropertiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchDatabasePropertiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchDatabasePropertiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchDatabasePropertiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchDatabasePropertiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchDatabasePropertiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchDatabasePropertiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchDatabasePropertiesRequest");
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for FetchDatabasePropertiesRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchDatabasePropertiesResponse {
    /// The Compute Engine zone that the instance is currently serving from.
    pub primary_gce_zone: std::string::String,

    /// The Compute Engine zone that the failover instance is currently serving
    /// from for a regional Cloud SQL instance.
    pub secondary_gce_zone: std::string::String,

    /// The availability status of the failover replica. A false status indicates
    /// that the failover replica is out of sync. The primary instance can only
    /// fail over to the failover replica when the status is true.
    pub is_failover_replica_available: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchDatabasePropertiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_gce_zone][crate::model::FetchDatabasePropertiesResponse::primary_gce_zone].
    pub fn set_primary_gce_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_gce_zone = v.into();
        self
    }

    /// Sets the value of [secondary_gce_zone][crate::model::FetchDatabasePropertiesResponse::secondary_gce_zone].
    pub fn set_secondary_gce_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_gce_zone = v.into();
        self
    }

    /// Sets the value of [is_failover_replica_available][crate::model::FetchDatabasePropertiesResponse::is_failover_replica_available].
    pub fn set_is_failover_replica_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_failover_replica_available = v.into();
        self
    }
}

impl wkt::message::Message for FetchDatabasePropertiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.FetchDatabasePropertiesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchDatabasePropertiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __primary_gce_zone,
            __secondary_gce_zone,
            __is_failover_replica_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchDatabasePropertiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "primaryGceZone" => Ok(__FieldTag::__primary_gce_zone),
                            "primary_gce_zone" => Ok(__FieldTag::__primary_gce_zone),
                            "secondaryGceZone" => Ok(__FieldTag::__secondary_gce_zone),
                            "secondary_gce_zone" => Ok(__FieldTag::__secondary_gce_zone),
                            "isFailoverReplicaAvailable" => {
                                Ok(__FieldTag::__is_failover_replica_available)
                            }
                            "is_failover_replica_available" => {
                                Ok(__FieldTag::__is_failover_replica_available)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchDatabasePropertiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchDatabasePropertiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__primary_gce_zone => {
                            if !fields.insert(__FieldTag::__primary_gce_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_gce_zone",
                                ));
                            }
                            result.primary_gce_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_gce_zone => {
                            if !fields.insert(__FieldTag::__secondary_gce_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_gce_zone",
                                ));
                            }
                            result.secondary_gce_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_failover_replica_available => {
                            if !fields.insert(__FieldTag::__is_failover_replica_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_failover_replica_available",
                                ));
                            }
                            result.is_failover_replica_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchDatabasePropertiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.primary_gce_zone.is_empty() {
            state.serialize_entry("primaryGceZone", &self.primary_gce_zone)?;
        }
        if !self.secondary_gce_zone.is_empty() {
            state.serialize_entry("secondaryGceZone", &self.secondary_gce_zone)?;
        }
        if !wkt::internal::is_default(&self.is_failover_replica_available) {
            state.serialize_entry(
                "isFailoverReplicaAvailable",
                &self.is_failover_replica_available,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchDatabasePropertiesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchDatabasePropertiesResponse");
        debug_struct.field("primary_gce_zone", &self.primary_gce_zone);
        debug_struct.field("secondary_gce_zone", &self.secondary_gce_zone);
        debug_struct.field(
            "is_failover_replica_available",
            &self.is_failover_replica_available,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The configuration for data storage in the environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageConfig {
    /// Optional. The name of the Cloud Storage bucket used by the environment. No
    /// `gs://` prefix.
    pub bucket: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageConfig::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }
}

impl wkt::message::Message for StorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.StorageConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageConfig");
        debug_struct.field("bucket", &self.bucket);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration information for an environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvironmentConfig {
    /// Output only. The Kubernetes Engine cluster used to run this environment.
    pub gke_cluster: std::string::String,

    /// Output only. The Cloud Storage prefix of the DAGs for this environment.
    /// Although Cloud Storage objects reside in a flat namespace, a hierarchical
    /// file tree can be simulated using "/"-delimited object name prefixes. DAG
    /// objects for this environment reside in a simulated directory with the given
    /// prefix.
    pub dag_gcs_prefix: std::string::String,

    /// The number of nodes in the Kubernetes Engine cluster that will be
    /// used to run this environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub node_count: i32,

    /// Optional. The configuration settings for software inside the environment.
    pub software_config: std::option::Option<crate::model::SoftwareConfig>,

    /// Optional. The configuration used for the Kubernetes Engine cluster.
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// Optional. The configuration used for the Private IP Cloud Composer
    /// environment.
    pub private_environment_config: std::option::Option<crate::model::PrivateEnvironmentConfig>,

    /// Optional. The network-level access control policy for the Airflow web
    /// server. If unspecified, no network-level access restrictions will be
    /// applied.
    pub web_server_network_access_control:
        std::option::Option<crate::model::WebServerNetworkAccessControl>,

    /// Optional. The configuration settings for Cloud SQL instance used internally
    /// by Apache Airflow software.
    pub database_config: std::option::Option<crate::model::DatabaseConfig>,

    /// Optional. The configuration settings for the Airflow web server App Engine
    /// instance.
    pub web_server_config: std::option::Option<crate::model::WebServerConfig>,

    /// Optional. The encryption options for the Cloud Composer environment
    /// and its dependencies. Cannot be updated.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Optional. The maintenance window is the period when Cloud Composer
    /// components may undergo maintenance. It is defined so that maintenance is
    /// not executed during peak hours or critical time periods.
    ///
    /// The system will not be under maintenance for every occurrence of this
    /// window, but when maintenance is planned, it will be scheduled
    /// during the window.
    ///
    /// The maintenance window period must encompass at least 12 hours per week.
    /// This may be split into multiple chunks, each with a size of
    /// at least 4 hours.
    ///
    /// If this value is omitted, the default value for maintenance window is
    /// applied. By default, maintenance windows are from 00:00:00 to 04:00:00
    /// (GMT) on Friday, Saturday, and Sunday every week.
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Optional. The workloads configuration settings for the GKE cluster
    /// associated with the Cloud Composer environment. The GKE cluster runs
    /// Airflow scheduler, web server and workers workloads.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    pub workloads_config: std::option::Option<crate::model::WorkloadsConfig>,

    /// Optional. The size of the Cloud Composer environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    pub environment_size: crate::model::environment_config::EnvironmentSize,

    /// Output only. The URI of the Apache Airflow Web UI hosted within this
    /// environment (see [Airflow web
    /// interface](/composer/docs/how-to/accessing/airflow-web-interface)).
    pub airflow_uri: std::string::String,

    /// Output only. The 'bring your own identity' variant of the URI of the Apache
    /// Airflow Web UI hosted within this environment, to be accessed with external
    /// identities using workforce identity federation (see [Access environments
    /// with workforce identity
    /// federation](/composer/docs/composer-2/access-environments-with-workforce-identity-federation)).
    pub airflow_byoid_uri: std::string::String,

    /// Optional. The configuration options for GKE cluster master authorized
    /// networks. By default master authorized networks feature is:
    ///
    /// - in case of private environment: enabled with no external networks
    ///   allowlisted.
    /// - in case of public environment: disabled.
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    /// Optional. The Recovery settings configuration of an environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    pub recovery_config: std::option::Option<crate::model::RecoveryConfig>,

    /// Optional. Resilience mode of the Cloud Composer Environment.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.2.0-airflow-*.*.* and newer.
    pub resilience_mode: crate::model::environment_config::ResilienceMode,

    /// Optional. The configuration setting for Airflow database data retention
    /// mechanism.
    pub data_retention_config: std::option::Option<crate::model::DataRetentionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvironmentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gke_cluster][crate::model::EnvironmentConfig::gke_cluster].
    pub fn set_gke_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gke_cluster = v.into();
        self
    }

    /// Sets the value of [dag_gcs_prefix][crate::model::EnvironmentConfig::dag_gcs_prefix].
    pub fn set_dag_gcs_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dag_gcs_prefix = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::EnvironmentConfig::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [software_config][crate::model::EnvironmentConfig::software_config].
    pub fn set_software_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SoftwareConfig>,
    {
        self.software_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [software_config][crate::model::EnvironmentConfig::software_config].
    pub fn set_or_clear_software_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SoftwareConfig>,
    {
        self.software_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_config][crate::model::EnvironmentConfig::node_config].
    pub fn set_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config][crate::model::EnvironmentConfig::node_config].
    pub fn set_or_clear_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_environment_config][crate::model::EnvironmentConfig::private_environment_config].
    pub fn set_private_environment_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateEnvironmentConfig>,
    {
        self.private_environment_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_environment_config][crate::model::EnvironmentConfig::private_environment_config].
    pub fn set_or_clear_private_environment_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateEnvironmentConfig>,
    {
        self.private_environment_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [web_server_network_access_control][crate::model::EnvironmentConfig::web_server_network_access_control].
    pub fn set_web_server_network_access_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WebServerNetworkAccessControl>,
    {
        self.web_server_network_access_control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [web_server_network_access_control][crate::model::EnvironmentConfig::web_server_network_access_control].
    pub fn set_or_clear_web_server_network_access_control<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::WebServerNetworkAccessControl>,
    {
        self.web_server_network_access_control = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_config][crate::model::EnvironmentConfig::database_config].
    pub fn set_database_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseConfig>,
    {
        self.database_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_config][crate::model::EnvironmentConfig::database_config].
    pub fn set_or_clear_database_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseConfig>,
    {
        self.database_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [web_server_config][crate::model::EnvironmentConfig::web_server_config].
    pub fn set_web_server_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WebServerConfig>,
    {
        self.web_server_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [web_server_config][crate::model::EnvironmentConfig::web_server_config].
    pub fn set_or_clear_web_server_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WebServerConfig>,
    {
        self.web_server_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_config][crate::model::EnvironmentConfig::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::EnvironmentConfig::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_window][crate::model::EnvironmentConfig::maintenance_window].
    pub fn set_maintenance_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_window][crate::model::EnvironmentConfig::maintenance_window].
    pub fn set_or_clear_maintenance_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workloads_config][crate::model::EnvironmentConfig::workloads_config].
    pub fn set_workloads_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadsConfig>,
    {
        self.workloads_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workloads_config][crate::model::EnvironmentConfig::workloads_config].
    pub fn set_or_clear_workloads_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadsConfig>,
    {
        self.workloads_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [environment_size][crate::model::EnvironmentConfig::environment_size].
    pub fn set_environment_size<
        T: std::convert::Into<crate::model::environment_config::EnvironmentSize>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_size = v.into();
        self
    }

    /// Sets the value of [airflow_uri][crate::model::EnvironmentConfig::airflow_uri].
    pub fn set_airflow_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.airflow_uri = v.into();
        self
    }

    /// Sets the value of [airflow_byoid_uri][crate::model::EnvironmentConfig::airflow_byoid_uri].
    pub fn set_airflow_byoid_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.airflow_byoid_uri = v.into();
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::EnvironmentConfig::master_authorized_networks_config].
    pub fn set_master_authorized_networks_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
    {
        self.master_authorized_networks_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [master_authorized_networks_config][crate::model::EnvironmentConfig::master_authorized_networks_config].
    pub fn set_or_clear_master_authorized_networks_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
    {
        self.master_authorized_networks_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recovery_config][crate::model::EnvironmentConfig::recovery_config].
    pub fn set_recovery_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecoveryConfig>,
    {
        self.recovery_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recovery_config][crate::model::EnvironmentConfig::recovery_config].
    pub fn set_or_clear_recovery_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecoveryConfig>,
    {
        self.recovery_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resilience_mode][crate::model::EnvironmentConfig::resilience_mode].
    pub fn set_resilience_mode<
        T: std::convert::Into<crate::model::environment_config::ResilienceMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resilience_mode = v.into();
        self
    }

    /// Sets the value of [data_retention_config][crate::model::EnvironmentConfig::data_retention_config].
    pub fn set_data_retention_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataRetentionConfig>,
    {
        self.data_retention_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_retention_config][crate::model::EnvironmentConfig::data_retention_config].
    pub fn set_or_clear_data_retention_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataRetentionConfig>,
    {
        self.data_retention_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EnvironmentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.EnvironmentConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnvironmentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gke_cluster,
            __dag_gcs_prefix,
            __node_count,
            __software_config,
            __node_config,
            __private_environment_config,
            __web_server_network_access_control,
            __database_config,
            __web_server_config,
            __encryption_config,
            __maintenance_window,
            __workloads_config,
            __environment_size,
            __airflow_uri,
            __airflow_byoid_uri,
            __master_authorized_networks_config,
            __recovery_config,
            __resilience_mode,
            __data_retention_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvironmentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gkeCluster" => Ok(__FieldTag::__gke_cluster),
                            "gke_cluster" => Ok(__FieldTag::__gke_cluster),
                            "dagGcsPrefix" => Ok(__FieldTag::__dag_gcs_prefix),
                            "dag_gcs_prefix" => Ok(__FieldTag::__dag_gcs_prefix),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "softwareConfig" => Ok(__FieldTag::__software_config),
                            "software_config" => Ok(__FieldTag::__software_config),
                            "nodeConfig" => Ok(__FieldTag::__node_config),
                            "node_config" => Ok(__FieldTag::__node_config),
                            "privateEnvironmentConfig" => {
                                Ok(__FieldTag::__private_environment_config)
                            }
                            "private_environment_config" => {
                                Ok(__FieldTag::__private_environment_config)
                            }
                            "webServerNetworkAccessControl" => {
                                Ok(__FieldTag::__web_server_network_access_control)
                            }
                            "web_server_network_access_control" => {
                                Ok(__FieldTag::__web_server_network_access_control)
                            }
                            "databaseConfig" => Ok(__FieldTag::__database_config),
                            "database_config" => Ok(__FieldTag::__database_config),
                            "webServerConfig" => Ok(__FieldTag::__web_server_config),
                            "web_server_config" => Ok(__FieldTag::__web_server_config),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            "maintenanceWindow" => Ok(__FieldTag::__maintenance_window),
                            "maintenance_window" => Ok(__FieldTag::__maintenance_window),
                            "workloadsConfig" => Ok(__FieldTag::__workloads_config),
                            "workloads_config" => Ok(__FieldTag::__workloads_config),
                            "environmentSize" => Ok(__FieldTag::__environment_size),
                            "environment_size" => Ok(__FieldTag::__environment_size),
                            "airflowUri" => Ok(__FieldTag::__airflow_uri),
                            "airflow_uri" => Ok(__FieldTag::__airflow_uri),
                            "airflowByoidUri" => Ok(__FieldTag::__airflow_byoid_uri),
                            "airflow_byoid_uri" => Ok(__FieldTag::__airflow_byoid_uri),
                            "masterAuthorizedNetworksConfig" => {
                                Ok(__FieldTag::__master_authorized_networks_config)
                            }
                            "master_authorized_networks_config" => {
                                Ok(__FieldTag::__master_authorized_networks_config)
                            }
                            "recoveryConfig" => Ok(__FieldTag::__recovery_config),
                            "recovery_config" => Ok(__FieldTag::__recovery_config),
                            "resilienceMode" => Ok(__FieldTag::__resilience_mode),
                            "resilience_mode" => Ok(__FieldTag::__resilience_mode),
                            "dataRetentionConfig" => Ok(__FieldTag::__data_retention_config),
                            "data_retention_config" => Ok(__FieldTag::__data_retention_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnvironmentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvironmentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gke_cluster => {
                            if !fields.insert(__FieldTag::__gke_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_cluster",
                                ));
                            }
                            result.gke_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dag_gcs_prefix => {
                            if !fields.insert(__FieldTag::__dag_gcs_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dag_gcs_prefix",
                                ));
                            }
                            result.dag_gcs_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__software_config => {
                            if !fields.insert(__FieldTag::__software_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for software_config",
                                ));
                            }
                            result.software_config = map
                                .next_value::<std::option::Option<crate::model::SoftwareConfig>>(
                                )?;
                        }
                        __FieldTag::__node_config => {
                            if !fields.insert(__FieldTag::__node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_config",
                                ));
                            }
                            result.node_config =
                                map.next_value::<std::option::Option<crate::model::NodeConfig>>()?;
                        }
                        __FieldTag::__private_environment_config => {
                            if !fields.insert(__FieldTag::__private_environment_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_environment_config",
                                ));
                            }
                            result.private_environment_config = map.next_value::<std::option::Option<crate::model::PrivateEnvironmentConfig>>()?
                                ;
                        }
                        __FieldTag::__web_server_network_access_control => {
                            if !fields.insert(__FieldTag::__web_server_network_access_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_server_network_access_control",
                                ));
                            }
                            result.web_server_network_access_control =
                                map.next_value::<std::option::Option<
                                    crate::model::WebServerNetworkAccessControl,
                                >>()?;
                        }
                        __FieldTag::__database_config => {
                            if !fields.insert(__FieldTag::__database_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_config",
                                ));
                            }
                            result.database_config = map
                                .next_value::<std::option::Option<crate::model::DatabaseConfig>>(
                                )?;
                        }
                        __FieldTag::__web_server_config => {
                            if !fields.insert(__FieldTag::__web_server_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_server_config",
                                ));
                            }
                            result.web_server_config = map
                                .next_value::<std::option::Option<crate::model::WebServerConfig>>(
                                )?;
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::__maintenance_window => {
                            if !fields.insert(__FieldTag::__maintenance_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_window",
                                ));
                            }
                            result.maintenance_window = map
                                .next_value::<std::option::Option<crate::model::MaintenanceWindow>>(
                                )?;
                        }
                        __FieldTag::__workloads_config => {
                            if !fields.insert(__FieldTag::__workloads_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workloads_config",
                                ));
                            }
                            result.workloads_config = map
                                .next_value::<std::option::Option<crate::model::WorkloadsConfig>>(
                                )?;
                        }
                        __FieldTag::__environment_size => {
                            if !fields.insert(__FieldTag::__environment_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment_size",
                                ));
                            }
                            result.environment_size = map
                                .next_value::<std::option::Option<
                                    crate::model::environment_config::EnvironmentSize,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__airflow_uri => {
                            if !fields.insert(__FieldTag::__airflow_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for airflow_uri",
                                ));
                            }
                            result.airflow_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__airflow_byoid_uri => {
                            if !fields.insert(__FieldTag::__airflow_byoid_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for airflow_byoid_uri",
                                ));
                            }
                            result.airflow_byoid_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_authorized_networks_config => {
                            if !fields.insert(__FieldTag::__master_authorized_networks_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_authorized_networks_config",
                                ));
                            }
                            result.master_authorized_networks_config =
                                map.next_value::<std::option::Option<
                                    crate::model::MasterAuthorizedNetworksConfig,
                                >>()?;
                        }
                        __FieldTag::__recovery_config => {
                            if !fields.insert(__FieldTag::__recovery_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recovery_config",
                                ));
                            }
                            result.recovery_config = map
                                .next_value::<std::option::Option<crate::model::RecoveryConfig>>(
                                )?;
                        }
                        __FieldTag::__resilience_mode => {
                            if !fields.insert(__FieldTag::__resilience_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resilience_mode",
                                ));
                            }
                            result.resilience_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::environment_config::ResilienceMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_retention_config => {
                            if !fields.insert(__FieldTag::__data_retention_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_retention_config",
                                ));
                            }
                            result.data_retention_config = map.next_value::<std::option::Option<crate::model::DataRetentionConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnvironmentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gke_cluster.is_empty() {
            state.serialize_entry("gkeCluster", &self.gke_cluster)?;
        }
        if !self.dag_gcs_prefix.is_empty() {
            state.serialize_entry("dagGcsPrefix", &self.dag_gcs_prefix)?;
        }
        if !wkt::internal::is_default(&self.node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(&self.node_count))?;
        }
        if self.software_config.is_some() {
            state.serialize_entry("softwareConfig", &self.software_config)?;
        }
        if self.node_config.is_some() {
            state.serialize_entry("nodeConfig", &self.node_config)?;
        }
        if self.private_environment_config.is_some() {
            state.serialize_entry("privateEnvironmentConfig", &self.private_environment_config)?;
        }
        if self.web_server_network_access_control.is_some() {
            state.serialize_entry(
                "webServerNetworkAccessControl",
                &self.web_server_network_access_control,
            )?;
        }
        if self.database_config.is_some() {
            state.serialize_entry("databaseConfig", &self.database_config)?;
        }
        if self.web_server_config.is_some() {
            state.serialize_entry("webServerConfig", &self.web_server_config)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if self.maintenance_window.is_some() {
            state.serialize_entry("maintenanceWindow", &self.maintenance_window)?;
        }
        if self.workloads_config.is_some() {
            state.serialize_entry("workloadsConfig", &self.workloads_config)?;
        }
        if !wkt::internal::is_default(&self.environment_size) {
            state.serialize_entry("environmentSize", &self.environment_size)?;
        }
        if !self.airflow_uri.is_empty() {
            state.serialize_entry("airflowUri", &self.airflow_uri)?;
        }
        if !self.airflow_byoid_uri.is_empty() {
            state.serialize_entry("airflowByoidUri", &self.airflow_byoid_uri)?;
        }
        if self.master_authorized_networks_config.is_some() {
            state.serialize_entry(
                "masterAuthorizedNetworksConfig",
                &self.master_authorized_networks_config,
            )?;
        }
        if self.recovery_config.is_some() {
            state.serialize_entry("recoveryConfig", &self.recovery_config)?;
        }
        if !wkt::internal::is_default(&self.resilience_mode) {
            state.serialize_entry("resilienceMode", &self.resilience_mode)?;
        }
        if self.data_retention_config.is_some() {
            state.serialize_entry("dataRetentionConfig", &self.data_retention_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnvironmentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnvironmentConfig");
        debug_struct.field("gke_cluster", &self.gke_cluster);
        debug_struct.field("dag_gcs_prefix", &self.dag_gcs_prefix);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("software_config", &self.software_config);
        debug_struct.field("node_config", &self.node_config);
        debug_struct.field(
            "private_environment_config",
            &self.private_environment_config,
        );
        debug_struct.field(
            "web_server_network_access_control",
            &self.web_server_network_access_control,
        );
        debug_struct.field("database_config", &self.database_config);
        debug_struct.field("web_server_config", &self.web_server_config);
        debug_struct.field("encryption_config", &self.encryption_config);
        debug_struct.field("maintenance_window", &self.maintenance_window);
        debug_struct.field("workloads_config", &self.workloads_config);
        debug_struct.field("environment_size", &self.environment_size);
        debug_struct.field("airflow_uri", &self.airflow_uri);
        debug_struct.field("airflow_byoid_uri", &self.airflow_byoid_uri);
        debug_struct.field(
            "master_authorized_networks_config",
            &self.master_authorized_networks_config,
        );
        debug_struct.field("recovery_config", &self.recovery_config);
        debug_struct.field("resilience_mode", &self.resilience_mode);
        debug_struct.field("data_retention_config", &self.data_retention_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EnvironmentConfig].
pub mod environment_config {
    #[allow(unused_imports)]
    use super::*;

    /// The size of the Cloud Composer environment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EnvironmentSize {
        /// The size of the environment is unspecified.
        Unspecified,
        /// The environment size is small.
        Small,
        /// The environment size is medium.
        Medium,
        /// The environment size is large.
        Large,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EnvironmentSize::value] or
        /// [EnvironmentSize::name].
        UnknownValue(environment_size::UnknownValue),
    }

    #[doc(hidden)]
    pub mod environment_size {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EnvironmentSize {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Small => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::Large => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENVIRONMENT_SIZE_UNSPECIFIED"),
                Self::Small => std::option::Option::Some("ENVIRONMENT_SIZE_SMALL"),
                Self::Medium => std::option::Option::Some("ENVIRONMENT_SIZE_MEDIUM"),
                Self::Large => std::option::Option::Some("ENVIRONMENT_SIZE_LARGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EnvironmentSize {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EnvironmentSize {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EnvironmentSize {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Small,
                2 => Self::Medium,
                3 => Self::Large,
                _ => Self::UnknownValue(environment_size::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EnvironmentSize {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENVIRONMENT_SIZE_UNSPECIFIED" => Self::Unspecified,
                "ENVIRONMENT_SIZE_SMALL" => Self::Small,
                "ENVIRONMENT_SIZE_MEDIUM" => Self::Medium,
                "ENVIRONMENT_SIZE_LARGE" => Self::Large,
                _ => Self::UnknownValue(environment_size::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EnvironmentSize {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Small => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::Large => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EnvironmentSize {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EnvironmentSize>::new(
                ".google.cloud.orchestration.airflow.service.v1.EnvironmentConfig.EnvironmentSize",
            ))
        }
    }

    /// Resilience mode of the Cloud Composer Environment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResilienceMode {
        /// Default mode doesn't change environment parameters.
        Unspecified,
        /// Enabled High Resilience mode, including Cloud SQL HA.
        HighResilience,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResilienceMode::value] or
        /// [ResilienceMode::name].
        UnknownValue(resilience_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod resilience_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResilienceMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HighResilience => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESILIENCE_MODE_UNSPECIFIED"),
                Self::HighResilience => std::option::Option::Some("HIGH_RESILIENCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResilienceMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResilienceMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResilienceMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HighResilience,
                _ => Self::UnknownValue(resilience_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResilienceMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESILIENCE_MODE_UNSPECIFIED" => Self::Unspecified,
                "HIGH_RESILIENCE" => Self::HighResilience,
                _ => Self::UnknownValue(resilience_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResilienceMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HighResilience => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResilienceMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResilienceMode>::new(
                ".google.cloud.orchestration.airflow.service.v1.EnvironmentConfig.ResilienceMode",
            ))
        }
    }
}

/// Network-level access control policy for the Airflow web server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WebServerNetworkAccessControl {
    /// A collection of allowed IP ranges with descriptions.
    pub allowed_ip_ranges:
        std::vec::Vec<crate::model::web_server_network_access_control::AllowedIpRange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebServerNetworkAccessControl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_ip_ranges][crate::model::WebServerNetworkAccessControl::allowed_ip_ranges].
    pub fn set_allowed_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_server_network_access_control::AllowedIpRange>,
    {
        use std::iter::Iterator;
        self.allowed_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WebServerNetworkAccessControl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WebServerNetworkAccessControl"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebServerNetworkAccessControl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_ip_ranges,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebServerNetworkAccessControl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedIpRanges" => Ok(__FieldTag::__allowed_ip_ranges),
                            "allowed_ip_ranges" => Ok(__FieldTag::__allowed_ip_ranges),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebServerNetworkAccessControl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebServerNetworkAccessControl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_ip_ranges => {
                            if !fields.insert(__FieldTag::__allowed_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_ip_ranges",
                                ));
                            }
                            result.allowed_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<crate::model::web_server_network_access_control::AllowedIpRange>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WebServerNetworkAccessControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowed_ip_ranges.is_empty() {
            state.serialize_entry("allowedIpRanges", &self.allowed_ip_ranges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WebServerNetworkAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebServerNetworkAccessControl");
        debug_struct.field("allowed_ip_ranges", &self.allowed_ip_ranges);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WebServerNetworkAccessControl].
pub mod web_server_network_access_control {
    #[allow(unused_imports)]
    use super::*;

    /// Allowed IP range with user-provided description.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllowedIpRange {
        /// IP address or range, defined using CIDR notation, of requests that this
        /// rule applies to.
        /// Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32`
        /// or `2001:0db8:0000:0042:0000:8a2e:0370:7334`.
        ///
        /// IP range prefixes should be properly truncated. For example,
        /// `1.2.3.4/24` should be truncated to `1.2.3.0/24`. Similarly, for IPv6,
        /// `2001:db8::1/32` should be truncated to `2001:db8::/32`.
        pub value: std::string::String,

        /// Optional. User-provided description. It must contain at most 300
        /// characters.
        pub description: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowedIpRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::web_server_network_access_control::AllowedIpRange::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [description][crate::model::web_server_network_access_control::AllowedIpRange::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }
    }

    impl wkt::message::Message for AllowedIpRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WebServerNetworkAccessControl.AllowedIpRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AllowedIpRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                __description,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AllowedIpRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                "description" => Ok(__FieldTag::__description),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AllowedIpRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AllowedIpRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AllowedIpRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AllowedIpRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AllowedIpRange");
            debug_struct.field("value", &self.value);
            debug_struct.field("description", &self.description);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The configuration of Cloud SQL instance that is used by the Apache Airflow
/// software.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseConfig {
    /// Optional. Cloud SQL machine type used by Airflow database.
    /// It has to be one of: db-n1-standard-2, db-n1-standard-4, db-n1-standard-8
    /// or db-n1-standard-16. If not specified, db-n1-standard-2 will be used.
    /// Supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub machine_type: std::string::String,

    /// Optional. The Compute Engine zone where the Airflow database is created. If
    /// zone is provided, it must be in the region selected for the environment. If
    /// zone is not provided, a zone is automatically selected. The zone can only
    /// be set during environment creation. Supported for Cloud Composer
    /// environments in versions composer-2.*.*-airflow-*.*.*.
    pub zone: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::DatabaseConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::DatabaseConfig::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DatabaseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type,
            __zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "zone" => Ok(__FieldTag::__zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseConfig");
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("zone", &self.zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The configuration settings for the Airflow web server App Engine instance.
/// Supported for Cloud Composer environments in versions
/// composer-1.*.*-airflow-*.*.*
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WebServerConfig {
    /// Optional. Machine type on which Airflow web server is running.
    /// It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or
    /// composer-n1-webserver-8.
    /// If not specified, composer-n1-webserver-2 will be used.
    /// Value custom is returned only in response, if Airflow web server parameters
    /// were manually changed to a non-standard values.
    pub machine_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::WebServerConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }
}

impl wkt::message::Message for WebServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WebServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WebServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WebServerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebServerConfig");
        debug_struct.field("machine_type", &self.machine_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The encryption options for the Cloud Composer environment
/// and its dependencies.Supported for Cloud Composer environments in versions
/// composer-1.*.*-airflow-*.*.*.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// Optional. Customer-managed Encryption Key available through Google's Key
    /// Management Service. Cannot be updated. If not specified, Google-managed key
    /// will be used.
    pub kms_key_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfig::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.EncryptionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfig");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The configuration settings for Cloud Composer maintenance window.
/// The following example:
///
/// ```norust
///    {
///      "startTime":"2019-08-01T01:00:00Z"
///      "endTime":"2019-08-01T07:00:00Z"
///      "recurrence":"FREQ=WEEKLY;BYDAY=TU,WE"
///    }
/// ```
///
/// would define a maintenance window between 01 and 07 hours UTC during
/// each Tuesday and Wednesday.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Required. Start time of the first recurrence of the maintenance window.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Required. Maintenance window end time. It is used only to calculate the
    /// duration of the maintenance window. The value for end-time must be in the
    /// future, relative to `start_time`.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Required. Maintenance window recurrence. Format is a subset of
    /// [RFC-5545](https://tools.ietf.org/html/rfc5545) `RRULE`. The only allowed
    /// values for `FREQ` field are `FREQ=DAILY` and `FREQ=WEEKLY;BYDAY=...`
    /// Example values: `FREQ=WEEKLY;BYDAY=TU,WE`, `FREQ=DAILY`.
    pub recurrence: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::MaintenanceWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::MaintenanceWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::MaintenanceWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::MaintenanceWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recurrence][crate::model::MaintenanceWindow::recurrence].
    pub fn set_recurrence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recurrence = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.MaintenanceWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __recurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "recurrence" => Ok(__FieldTag::__recurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__recurrence => {
                            if !fields.insert(__FieldTag::__recurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurrence",
                                ));
                            }
                            result.recurrence = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.recurrence.is_empty() {
            state.serialize_entry("recurrence", &self.recurrence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("recurrence", &self.recurrence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies the selection and configuration of software inside the environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SoftwareConfig {
    /// Optional. The version of the software running in the environment.
    /// This encapsulates both the version of Cloud Composer functionality and the
    /// version of Apache Airflow. It must match the regular expression
    /// `composer-([0-9]+(\.[0-9]+\.[0-9]+(-preview\.[0-9]+)?)?|latest)-airflow-([0-9]+(\.[0-9]+(\.[0-9]+)?)?)`.
    /// When used as input, the server also checks if the provided version is
    /// supported and denies the request for an unsupported version.
    ///
    /// The Cloud Composer portion of the image version is a full
    /// [semantic version](https://semver.org), or an alias in the form of major
    /// version number or `latest`. When an alias is provided, the server replaces
    /// it with the current Cloud Composer version that satisfies the alias.
    ///
    /// The Apache Airflow portion of the image version is a full semantic version
    /// that points to one of the supported Apache Airflow versions, or an alias in
    /// the form of only major or major.minor versions specified. When an alias is
    /// provided, the server replaces it with the latest Apache Airflow version
    /// that satisfies the alias and is supported in the given Cloud Composer
    /// version.
    ///
    /// In all cases, the resolved image version is stored in the same field.
    ///
    /// See also [version
    /// list](/composer/docs/concepts/versioning/composer-versions) and [versioning
    /// overview](/composer/docs/concepts/versioning/composer-versioning-overview).
    pub image_version: std::string::String,

    /// Optional. Apache Airflow configuration properties to override.
    ///
    /// Property keys contain the section and property names, separated by a
    /// hyphen, for example "core-dags_are_paused_at_creation". Section names must
    /// not contain hyphens ("-"), opening square brackets ("["),  or closing
    /// square brackets ("]"). The property name must not be empty and must not
    /// contain an equals sign ("=") or semicolon (";"). Section and property names
    /// must not contain a period ("."). Apache Airflow configuration property
    /// names must be written in
    /// [snake_case](https://en.wikipedia.org/wiki/Snake_case). Property values can
    /// contain any character, and can be written in any lower/upper case format.
    ///
    /// Certain Apache Airflow configuration property values are
    /// [blocked](/composer/docs/concepts/airflow-configurations),
    /// and cannot be overridden.
    pub airflow_config_overrides:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Custom Python Package Index (PyPI) packages to be installed in
    /// the environment.
    ///
    /// Keys refer to the lowercase package name such as "numpy"
    /// and values are the lowercase extras and version specifier such as
    /// "==1.12.0", "[devel,gcp_api]", or "[devel]>=1.8.2, <1.9.2". To specify a
    /// package without pinning it to a version specifier, use the empty string as
    /// the value.
    pub pypi_packages: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Additional environment variables to provide to the Apache Airflow
    /// scheduler, worker, and webserver processes.
    ///
    /// Environment variable names must match the regular expression
    /// `[a-zA-Z_][a-zA-Z0-9_]*`. They cannot specify Apache Airflow
    /// software configuration overrides (they cannot match the regular expression
    /// `AIRFLOW__[A-Z0-9_]+__[A-Z0-9_]+`), and they cannot match any of the
    /// following reserved names:
    ///
    /// * `AIRFLOW_HOME`
    /// * `C_FORCE_ROOT`
    /// * `CONTAINER_NAME`
    /// * `DAGS_FOLDER`
    /// * `GCP_PROJECT`
    /// * `GCS_BUCKET`
    /// * `GKE_CLUSTER_NAME`
    /// * `SQL_DATABASE`
    /// * `SQL_INSTANCE`
    /// * `SQL_PASSWORD`
    /// * `SQL_PROJECT`
    /// * `SQL_REGION`
    /// * `SQL_USER`
    pub env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The major version of Python used to run the Apache Airflow
    /// scheduler, worker, and webserver processes.
    ///
    /// Can be set to '2' or '3'. If not specified, the default is '3'. Cannot be
    /// updated.
    ///
    /// This field is only supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*. Environments in newer versions always use
    /// Python major version 3.
    pub python_version: std::string::String,

    /// Optional. The number of schedulers for Airflow.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-2.*.*.
    pub scheduler_count: i32,

    /// Optional. The configuration for Cloud Data Lineage integration.
    pub cloud_data_lineage_integration:
        std::option::Option<crate::model::CloudDataLineageIntegration>,

    /// Optional. Whether or not the web server uses custom plugins.
    /// If unspecified, the field defaults to `PLUGINS_ENABLED`.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    pub web_server_plugins_mode: crate::model::software_config::WebServerPluginsMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_version][crate::model::SoftwareConfig::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }

    /// Sets the value of [airflow_config_overrides][crate::model::SoftwareConfig::airflow_config_overrides].
    pub fn set_airflow_config_overrides<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.airflow_config_overrides = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [pypi_packages][crate::model::SoftwareConfig::pypi_packages].
    pub fn set_pypi_packages<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pypi_packages = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [env_variables][crate::model::SoftwareConfig::env_variables].
    pub fn set_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [python_version][crate::model::SoftwareConfig::python_version].
    pub fn set_python_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.python_version = v.into();
        self
    }

    /// Sets the value of [scheduler_count][crate::model::SoftwareConfig::scheduler_count].
    pub fn set_scheduler_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scheduler_count = v.into();
        self
    }

    /// Sets the value of [cloud_data_lineage_integration][crate::model::SoftwareConfig::cloud_data_lineage_integration].
    pub fn set_cloud_data_lineage_integration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudDataLineageIntegration>,
    {
        self.cloud_data_lineage_integration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_data_lineage_integration][crate::model::SoftwareConfig::cloud_data_lineage_integration].
    pub fn set_or_clear_cloud_data_lineage_integration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CloudDataLineageIntegration>,
    {
        self.cloud_data_lineage_integration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [web_server_plugins_mode][crate::model::SoftwareConfig::web_server_plugins_mode].
    pub fn set_web_server_plugins_mode<
        T: std::convert::Into<crate::model::software_config::WebServerPluginsMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_plugins_mode = v.into();
        self
    }
}

impl wkt::message::Message for SoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.SoftwareConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SoftwareConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_version,
            __airflow_config_overrides,
            __pypi_packages,
            __env_variables,
            __python_version,
            __scheduler_count,
            __cloud_data_lineage_integration,
            __web_server_plugins_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoftwareConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageVersion" => Ok(__FieldTag::__image_version),
                            "image_version" => Ok(__FieldTag::__image_version),
                            "airflowConfigOverrides" => Ok(__FieldTag::__airflow_config_overrides),
                            "airflow_config_overrides" => {
                                Ok(__FieldTag::__airflow_config_overrides)
                            }
                            "pypiPackages" => Ok(__FieldTag::__pypi_packages),
                            "pypi_packages" => Ok(__FieldTag::__pypi_packages),
                            "envVariables" => Ok(__FieldTag::__env_variables),
                            "env_variables" => Ok(__FieldTag::__env_variables),
                            "pythonVersion" => Ok(__FieldTag::__python_version),
                            "python_version" => Ok(__FieldTag::__python_version),
                            "schedulerCount" => Ok(__FieldTag::__scheduler_count),
                            "scheduler_count" => Ok(__FieldTag::__scheduler_count),
                            "cloudDataLineageIntegration" => {
                                Ok(__FieldTag::__cloud_data_lineage_integration)
                            }
                            "cloud_data_lineage_integration" => {
                                Ok(__FieldTag::__cloud_data_lineage_integration)
                            }
                            "webServerPluginsMode" => Ok(__FieldTag::__web_server_plugins_mode),
                            "web_server_plugins_mode" => Ok(__FieldTag::__web_server_plugins_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SoftwareConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoftwareConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_version => {
                            if !fields.insert(__FieldTag::__image_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_version",
                                ));
                            }
                            result.image_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__airflow_config_overrides => {
                            if !fields.insert(__FieldTag::__airflow_config_overrides) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for airflow_config_overrides",
                                ));
                            }
                            result.airflow_config_overrides = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pypi_packages => {
                            if !fields.insert(__FieldTag::__pypi_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pypi_packages",
                                ));
                            }
                            result.pypi_packages = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env_variables => {
                            if !fields.insert(__FieldTag::__env_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env_variables",
                                ));
                            }
                            result.env_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__python_version => {
                            if !fields.insert(__FieldTag::__python_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_version",
                                ));
                            }
                            result.python_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduler_count => {
                            if !fields.insert(__FieldTag::__scheduler_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduler_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scheduler_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cloud_data_lineage_integration => {
                            if !fields.insert(__FieldTag::__cloud_data_lineage_integration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_data_lineage_integration",
                                ));
                            }
                            result.cloud_data_lineage_integration = map.next_value::<std::option::Option<crate::model::CloudDataLineageIntegration>>()?
                                ;
                        }
                        __FieldTag::__web_server_plugins_mode => {
                            if !fields.insert(__FieldTag::__web_server_plugins_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_server_plugins_mode",
                                ));
                            }
                            result.web_server_plugins_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::software_config::WebServerPluginsMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SoftwareConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image_version.is_empty() {
            state.serialize_entry("imageVersion", &self.image_version)?;
        }
        if !self.airflow_config_overrides.is_empty() {
            state.serialize_entry("airflowConfigOverrides", &self.airflow_config_overrides)?;
        }
        if !self.pypi_packages.is_empty() {
            state.serialize_entry("pypiPackages", &self.pypi_packages)?;
        }
        if !self.env_variables.is_empty() {
            state.serialize_entry("envVariables", &self.env_variables)?;
        }
        if !self.python_version.is_empty() {
            state.serialize_entry("pythonVersion", &self.python_version)?;
        }
        if !wkt::internal::is_default(&self.scheduler_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("schedulerCount", &__With(&self.scheduler_count))?;
        }
        if self.cloud_data_lineage_integration.is_some() {
            state.serialize_entry(
                "cloudDataLineageIntegration",
                &self.cloud_data_lineage_integration,
            )?;
        }
        if !wkt::internal::is_default(&self.web_server_plugins_mode) {
            state.serialize_entry("webServerPluginsMode", &self.web_server_plugins_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SoftwareConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoftwareConfig");
        debug_struct.field("image_version", &self.image_version);
        debug_struct.field("airflow_config_overrides", &self.airflow_config_overrides);
        debug_struct.field("pypi_packages", &self.pypi_packages);
        debug_struct.field("env_variables", &self.env_variables);
        debug_struct.field("python_version", &self.python_version);
        debug_struct.field("scheduler_count", &self.scheduler_count);
        debug_struct.field(
            "cloud_data_lineage_integration",
            &self.cloud_data_lineage_integration,
        );
        debug_struct.field("web_server_plugins_mode", &self.web_server_plugins_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SoftwareConfig].
pub mod software_config {
    #[allow(unused_imports)]
    use super::*;

    /// Web server plugins mode of the Cloud Composer environment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WebServerPluginsMode {
        /// Default mode.
        Unspecified,
        /// Web server plugins are not supported.
        PluginsDisabled,
        /// Web server plugins are supported.
        PluginsEnabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WebServerPluginsMode::value] or
        /// [WebServerPluginsMode::name].
        UnknownValue(web_server_plugins_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod web_server_plugins_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WebServerPluginsMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PluginsDisabled => std::option::Option::Some(1),
                Self::PluginsEnabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("WEB_SERVER_PLUGINS_MODE_UNSPECIFIED")
                }
                Self::PluginsDisabled => std::option::Option::Some("PLUGINS_DISABLED"),
                Self::PluginsEnabled => std::option::Option::Some("PLUGINS_ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WebServerPluginsMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WebServerPluginsMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WebServerPluginsMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PluginsDisabled,
                2 => Self::PluginsEnabled,
                _ => Self::UnknownValue(web_server_plugins_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WebServerPluginsMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WEB_SERVER_PLUGINS_MODE_UNSPECIFIED" => Self::Unspecified,
                "PLUGINS_DISABLED" => Self::PluginsDisabled,
                "PLUGINS_ENABLED" => Self::PluginsEnabled,
                _ => Self::UnknownValue(web_server_plugins_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WebServerPluginsMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PluginsDisabled => serializer.serialize_i32(1),
                Self::PluginsEnabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WebServerPluginsMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WebServerPluginsMode>::new(
                ".google.cloud.orchestration.airflow.service.v1.SoftwareConfig.WebServerPluginsMode"))
        }
    }
}

/// Configuration for controlling how IPs are allocated in the
/// GKE cluster running the Apache Airflow software.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IPAllocationPolicy {
    /// Optional. Whether or not to enable Alias IPs in the GKE cluster.
    /// If `true`, a VPC-native cluster is created.
    ///
    /// This field is only supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*. Environments in newer versions always use
    /// VPC-native GKE clusters.
    pub use_ip_aliases: bool,

    /// Configuration of allocating IP addresses for pods in the GKE cluster.
    pub cluster_ip_allocation:
        std::option::Option<crate::model::ip_allocation_policy::ClusterIpAllocation>,

    /// Configuration of allocating IP addresses for services in the GKE cluster.
    pub services_ip_allocation:
        std::option::Option<crate::model::ip_allocation_policy::ServicesIpAllocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IPAllocationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_ip_aliases][crate::model::IPAllocationPolicy::use_ip_aliases].
    pub fn set_use_ip_aliases<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_ip_aliases = v.into();
        self
    }

    /// Sets the value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation].
    ///
    /// Note that all the setters affecting `cluster_ip_allocation` are mutually
    /// exclusive.
    pub fn set_cluster_ip_allocation<
        T: std::convert::Into<
                std::option::Option<crate::model::ip_allocation_policy::ClusterIpAllocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ip_allocation = v.into();
        self
    }

    /// The value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// if it holds a `ClusterSecondaryRangeName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster_secondary_range_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.cluster_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterSecondaryRangeName(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// to hold a `ClusterSecondaryRangeName`.
    ///
    /// Note that all the setters affecting `cluster_ip_allocation` are
    /// mutually exclusive.
    pub fn set_cluster_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterSecondaryRangeName(
                v.into(),
            ),
        );
        self
    }

    /// The value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// if it holds a `ClusterIpv4CidrBlock`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster_ipv4_cidr_block(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.cluster_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterIpv4CidrBlock(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cluster_ip_allocation][crate::model::IPAllocationPolicy::cluster_ip_allocation]
    /// to hold a `ClusterIpv4CidrBlock`.
    ///
    /// Note that all the setters affecting `cluster_ip_allocation` are
    /// mutually exclusive.
    pub fn set_cluster_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterIpv4CidrBlock(v.into()),
        );
        self
    }

    /// Sets the value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation].
    ///
    /// Note that all the setters affecting `services_ip_allocation` are mutually
    /// exclusive.
    pub fn set_services_ip_allocation<
        T: std::convert::Into<
                std::option::Option<crate::model::ip_allocation_policy::ServicesIpAllocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.services_ip_allocation = v.into();
        self
    }

    /// The value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// if it holds a `ServicesSecondaryRangeName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn services_secondary_range_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.services_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesSecondaryRangeName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// to hold a `ServicesSecondaryRangeName`.
    ///
    /// Note that all the setters affecting `services_ip_allocation` are
    /// mutually exclusive.
    pub fn set_services_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesSecondaryRangeName(
                v.into(),
            ),
        );
        self
    }

    /// The value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// if it holds a `ServicesIpv4CidrBlock`, `None` if the field is not set or
    /// holds a different branch.
    pub fn services_ipv4_cidr_block(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.services_ip_allocation.as_ref().and_then(|v| match v {
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesIpv4CidrBlock(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [services_ip_allocation][crate::model::IPAllocationPolicy::services_ip_allocation]
    /// to hold a `ServicesIpv4CidrBlock`.
    ///
    /// Note that all the setters affecting `services_ip_allocation` are
    /// mutually exclusive.
    pub fn set_services_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ip_allocation = std::option::Option::Some(
            crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesIpv4CidrBlock(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for IPAllocationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.IPAllocationPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IPAllocationPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_ip_aliases,
            __cluster_secondary_range_name,
            __cluster_ipv4_cidr_block,
            __services_secondary_range_name,
            __services_ipv4_cidr_block,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IPAllocationPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useIpAliases" => Ok(__FieldTag::__use_ip_aliases),
                            "use_ip_aliases" => Ok(__FieldTag::__use_ip_aliases),
                            "clusterSecondaryRangeName" => {
                                Ok(__FieldTag::__cluster_secondary_range_name)
                            }
                            "cluster_secondary_range_name" => {
                                Ok(__FieldTag::__cluster_secondary_range_name)
                            }
                            "clusterIpv4CidrBlock" => Ok(__FieldTag::__cluster_ipv4_cidr_block),
                            "cluster_ipv4_cidr_block" => Ok(__FieldTag::__cluster_ipv4_cidr_block),
                            "servicesSecondaryRangeName" => {
                                Ok(__FieldTag::__services_secondary_range_name)
                            }
                            "services_secondary_range_name" => {
                                Ok(__FieldTag::__services_secondary_range_name)
                            }
                            "servicesIpv4CidrBlock" => Ok(__FieldTag::__services_ipv4_cidr_block),
                            "services_ipv4_cidr_block" => {
                                Ok(__FieldTag::__services_ipv4_cidr_block)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IPAllocationPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IPAllocationPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_ip_aliases => {
                            if !fields.insert(__FieldTag::__use_ip_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_ip_aliases",
                                ));
                            }
                            result.use_ip_aliases = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_secondary_range_name => {
                            if !fields.insert(__FieldTag::__cluster_secondary_range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_secondary_range_name",
                                ));
                            }
                            if result.cluster_ip_allocation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cluster_ip_allocation`, a oneof with full ID .google.cloud.orchestration.airflow.service.v1.IPAllocationPolicy.cluster_secondary_range_name, latest field was clusterSecondaryRangeName",
                                ));
                            }
                            result.cluster_ip_allocation = std::option::Option::Some(
                                crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterSecondaryRangeName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__cluster_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr_block",
                                ));
                            }
                            if result.cluster_ip_allocation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cluster_ip_allocation`, a oneof with full ID .google.cloud.orchestration.airflow.service.v1.IPAllocationPolicy.cluster_ipv4_cidr_block, latest field was clusterIpv4CidrBlock",
                                ));
                            }
                            result.cluster_ip_allocation = std::option::Option::Some(
                                crate::model::ip_allocation_policy::ClusterIpAllocation::ClusterIpv4CidrBlock(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__services_secondary_range_name => {
                            if !fields.insert(__FieldTag::__services_secondary_range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_secondary_range_name",
                                ));
                            }
                            if result.services_ip_allocation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `services_ip_allocation`, a oneof with full ID .google.cloud.orchestration.airflow.service.v1.IPAllocationPolicy.services_secondary_range_name, latest field was servicesSecondaryRangeName",
                                ));
                            }
                            result.services_ip_allocation = std::option::Option::Some(
                                crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesSecondaryRangeName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__services_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr_block",
                                ));
                            }
                            if result.services_ip_allocation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `services_ip_allocation`, a oneof with full ID .google.cloud.orchestration.airflow.service.v1.IPAllocationPolicy.services_ipv4_cidr_block, latest field was servicesIpv4CidrBlock",
                                ));
                            }
                            result.services_ip_allocation = std::option::Option::Some(
                                crate::model::ip_allocation_policy::ServicesIpAllocation::ServicesIpv4CidrBlock(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IPAllocationPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.use_ip_aliases) {
            state.serialize_entry("useIpAliases", &self.use_ip_aliases)?;
        }
        if let Some(value) = self.cluster_secondary_range_name() {
            state.serialize_entry("clusterSecondaryRangeName", value)?;
        }
        if let Some(value) = self.cluster_ipv4_cidr_block() {
            state.serialize_entry("clusterIpv4CidrBlock", value)?;
        }
        if let Some(value) = self.services_secondary_range_name() {
            state.serialize_entry("servicesSecondaryRangeName", value)?;
        }
        if let Some(value) = self.services_ipv4_cidr_block() {
            state.serialize_entry("servicesIpv4CidrBlock", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IPAllocationPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IPAllocationPolicy");
        debug_struct.field("use_ip_aliases", &self.use_ip_aliases);
        debug_struct.field("cluster_ip_allocation", &self.cluster_ip_allocation);
        debug_struct.field("services_ip_allocation", &self.services_ip_allocation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IPAllocationPolicy].
pub mod ip_allocation_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of allocating IP addresses for pods in the GKE cluster.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterIpAllocation {
        /// Optional. The name of the GKE cluster's secondary range used to allocate
        /// IP addresses to pods.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ClusterSecondaryRangeName(std::string::String),
        /// Optional. The IP address range used to allocate IP addresses to pods in
        /// the GKE cluster.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ///
        /// Set to blank to have GKE choose a range with the default size.
        ///
        /// Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
        /// netmask.
        ///
        /// Set to a
        /// [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
        /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
        /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
        /// to use.
        ClusterIpv4CidrBlock(std::string::String),
    }

    /// Configuration of allocating IP addresses for services in the GKE cluster.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServicesIpAllocation {
        /// Optional. The name of the services' secondary range used to allocate
        /// IP addresses to the GKE cluster.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ServicesSecondaryRangeName(std::string::String),
        /// Optional. The IP address range of the services IP addresses in this
        /// GKE cluster.
        ///
        /// For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
        /// this field is applicable only when `use_ip_aliases` is true.
        ///
        /// Set to blank to have GKE choose a range with the default size.
        ///
        /// Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
        /// netmask.
        ///
        /// Set to a
        /// [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
        /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
        /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
        /// to use.
        ServicesIpv4CidrBlock(std::string::String),
    }
}

/// The configuration information for the Kubernetes Engine nodes running
/// the Apache Airflow software.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeConfig {
    /// Optional. The Compute Engine [zone](/compute/docs/regions-zones) in which
    /// to deploy the VMs used to run the Apache Airflow software, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/zones/{zoneId}".
    ///
    /// This `location` must belong to the enclosing environment's project and
    /// location. If both this field and `nodeConfig.machineType` are specified,
    /// `nodeConfig.machineType` must belong to this `location`; if both are
    /// unspecified, the service will pick a zone in the Compute Engine region
    /// corresponding to the Cloud Composer location, and propagate that choice to
    /// both fields. If only one field (`location` or `nodeConfig.machineType`) is
    /// specified, the location information from the specified field will be
    /// propagated to the unspecified field.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub location: std::string::String,

    /// Optional. The Compute Engine
    /// [machine type](/compute/docs/machine-types) used for cluster instances,
    /// specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/zones/{zoneId}/machineTypes/{machineTypeId}".
    ///
    /// The `machineType` must belong to the enclosing environment's project and
    /// location. If both this field and `nodeConfig.location` are specified,
    /// this `machineType` must belong to the `nodeConfig.location`; if both are
    /// unspecified, the service will pick a zone in the Compute Engine region
    /// corresponding to the Cloud Composer location, and propagate that choice to
    /// both fields. If exactly one of this field and `nodeConfig.location` is
    /// specified, the location information from the specified field will be
    /// propagated to the unspecified field.
    ///
    /// The `machineTypeId` must not be a [shared-core machine
    /// type](/compute/docs/machine-types#sharedcore).
    ///
    /// If this field is unspecified, the `machineTypeId` defaults
    /// to "n1-standard-1".
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub machine_type: std::string::String,

    /// Optional. The Compute Engine network to be used for machine
    /// communications, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/global/networks/{networkId}".
    ///
    /// If unspecified, the "default" network ID in the environment's project is
    /// used. If a [Custom Subnet Network](/vpc/docs/vpc#vpc_networks_and_subnets)
    /// is provided, `nodeConfig.subnetwork` must also be provided. For
    /// [Shared VPC](/vpc/docs/shared-vpc) subnetwork requirements, see
    /// `nodeConfig.subnetwork`.
    pub network: std::string::String,

    /// Optional. The Compute Engine subnetwork to be used for machine
    /// communications, specified as a
    /// [relative resource
    /// name](/apis/design/resource_names#relative_resource_name). For example:
    /// "projects/{projectId}/regions/{regionId}/subnetworks/{subnetworkId}"
    ///
    /// If a subnetwork is provided, `nodeConfig.network` must also be provided,
    /// and the subnetwork must belong to the enclosing environment's project and
    /// location.
    pub subnetwork: std::string::String,

    /// Optional. The disk size in GB used for node VMs. Minimum size is 30GB.
    /// If unspecified, defaults to 100GB. Cannot be updated.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub disk_size_gb: i32,

    /// Optional. The set of Google API scopes to be made available on all
    /// node VMs. If `oauth_scopes` is empty, defaults to
    /// [`https://www.googleapis.com/auth/cloud-platform`]. Cannot be updated.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub oauth_scopes: std::vec::Vec<std::string::String>,

    /// Optional. The Google Cloud Platform Service Account to be used by the node
    /// VMs. If a service account is not specified, the "default" Compute Engine
    /// service account is used. Cannot be updated.
    pub service_account: std::string::String,

    /// Optional. The list of instance tags applied to all node VMs. Tags are used
    /// to identify valid sources or targets for network firewalls. Each tag within
    /// the list must comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Cannot be updated.
    pub tags: std::vec::Vec<std::string::String>,

    /// Optional. The configuration for controlling how IPs are allocated in the
    /// GKE cluster.
    pub ip_allocation_policy: std::option::Option<crate::model::IPAllocationPolicy>,

    /// Optional. Deploys 'ip-masq-agent' daemon set in the GKE cluster and defines
    /// nonMasqueradeCIDRs equals to pod IP range so IP masquerading is used for
    /// all destination addresses, except between pods traffic.
    ///
    /// See:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent>
    pub enable_ip_masq_agent: bool,

    /// Optional. Network Attachment that Cloud Composer environment is connected
    /// to, which provides connectivity with a user's VPC network. Takes precedence
    /// over network and subnetwork settings. If not provided, but network and
    /// subnetwork are defined during environment, it will be provisioned. If not
    /// provided and network and subnetwork are also empty, then connectivity to
    /// user's VPC network is disabled. Network attachment must be provided in
    /// format
    /// projects/{project}/regions/{region}/networkAttachments/{networkAttachment}.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    pub composer_network_attachment: std::string::String,

    /// Optional. The IP range in CIDR notation to use internally by Cloud
    /// Composer. IP addresses are not reserved - and the same range can be used by
    /// multiple Cloud Composer environments. In case of overlap, IPs from this
    /// range will not be accessible in the user's VPC network. Cannot be updated.
    /// If not specified, the default value of '100.64.128.0/20' is used.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    pub composer_internal_ipv4_cidr_block: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::NodeConfig::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::NodeConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network][crate::model::NodeConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NodeConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::NodeConfig::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [oauth_scopes][crate::model::NodeConfig::oauth_scopes].
    pub fn set_oauth_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oauth_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::NodeConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::NodeConfig::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ip_allocation_policy][crate::model::NodeConfig::ip_allocation_policy].
    pub fn set_ip_allocation_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IPAllocationPolicy>,
    {
        self.ip_allocation_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_allocation_policy][crate::model::NodeConfig::ip_allocation_policy].
    pub fn set_or_clear_ip_allocation_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IPAllocationPolicy>,
    {
        self.ip_allocation_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_ip_masq_agent][crate::model::NodeConfig::enable_ip_masq_agent].
    pub fn set_enable_ip_masq_agent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_ip_masq_agent = v.into();
        self
    }

    /// Sets the value of [composer_network_attachment][crate::model::NodeConfig::composer_network_attachment].
    pub fn set_composer_network_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.composer_network_attachment = v.into();
        self
    }

    /// Sets the value of [composer_internal_ipv4_cidr_block][crate::model::NodeConfig::composer_internal_ipv4_cidr_block].
    pub fn set_composer_internal_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.composer_internal_ipv4_cidr_block = v.into();
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.NodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __machine_type,
            __network,
            __subnetwork,
            __disk_size_gb,
            __oauth_scopes,
            __service_account,
            __tags,
            __ip_allocation_policy,
            __enable_ip_masq_agent,
            __composer_network_attachment,
            __composer_internal_ipv4_cidr_block,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "oauthScopes" => Ok(__FieldTag::__oauth_scopes),
                            "oauth_scopes" => Ok(__FieldTag::__oauth_scopes),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "tags" => Ok(__FieldTag::__tags),
                            "ipAllocationPolicy" => Ok(__FieldTag::__ip_allocation_policy),
                            "ip_allocation_policy" => Ok(__FieldTag::__ip_allocation_policy),
                            "enableIpMasqAgent" => Ok(__FieldTag::__enable_ip_masq_agent),
                            "enable_ip_masq_agent" => Ok(__FieldTag::__enable_ip_masq_agent),
                            "composerNetworkAttachment" => {
                                Ok(__FieldTag::__composer_network_attachment)
                            }
                            "composer_network_attachment" => {
                                Ok(__FieldTag::__composer_network_attachment)
                            }
                            "composerInternalIpv4CidrBlock" => {
                                Ok(__FieldTag::__composer_internal_ipv4_cidr_block)
                            }
                            "composer_internal_ipv4_cidr_block" => {
                                Ok(__FieldTag::__composer_internal_ipv4_cidr_block)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oauth_scopes => {
                            if !fields.insert(__FieldTag::__oauth_scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_scopes",
                                ));
                            }
                            result.oauth_scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ip_allocation_policy => {
                            if !fields.insert(__FieldTag::__ip_allocation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_allocation_policy",
                                ));
                            }
                            result.ip_allocation_policy = map.next_value::<std::option::Option<crate::model::IPAllocationPolicy>>()?
                                ;
                        }
                        __FieldTag::__enable_ip_masq_agent => {
                            if !fields.insert(__FieldTag::__enable_ip_masq_agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_ip_masq_agent",
                                ));
                            }
                            result.enable_ip_masq_agent = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__composer_network_attachment => {
                            if !fields.insert(__FieldTag::__composer_network_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for composer_network_attachment",
                                ));
                            }
                            result.composer_network_attachment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__composer_internal_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__composer_internal_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for composer_internal_ipv4_cidr_block",
                                ));
                            }
                            result.composer_internal_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !self.oauth_scopes.is_empty() {
            state.serialize_entry("oauthScopes", &self.oauth_scopes)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.ip_allocation_policy.is_some() {
            state.serialize_entry("ipAllocationPolicy", &self.ip_allocation_policy)?;
        }
        if !wkt::internal::is_default(&self.enable_ip_masq_agent) {
            state.serialize_entry("enableIpMasqAgent", &self.enable_ip_masq_agent)?;
        }
        if !self.composer_network_attachment.is_empty() {
            state.serialize_entry(
                "composerNetworkAttachment",
                &self.composer_network_attachment,
            )?;
        }
        if !self.composer_internal_ipv4_cidr_block.is_empty() {
            state.serialize_entry(
                "composerInternalIpv4CidrBlock",
                &self.composer_internal_ipv4_cidr_block,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfig");
        debug_struct.field("location", &self.location);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("oauth_scopes", &self.oauth_scopes);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("ip_allocation_policy", &self.ip_allocation_policy);
        debug_struct.field("enable_ip_masq_agent", &self.enable_ip_masq_agent);
        debug_struct.field(
            "composer_network_attachment",
            &self.composer_network_attachment,
        );
        debug_struct.field(
            "composer_internal_ipv4_cidr_block",
            &self.composer_internal_ipv4_cidr_block,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the private GKE cluster in a Cloud Composer
/// environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateClusterConfig {
    /// Optional. If `true`, access to the public endpoint of the GKE cluster is
    /// denied.
    pub enable_private_endpoint: bool,

    /// Optional. The CIDR block from which IPv4 range for GKE master will be
    /// reserved. If left blank, the default value of '172.16.0.0/23' is used.
    pub master_ipv4_cidr_block: std::string::String,

    /// Output only. The IP range in CIDR notation to use for the hosted master
    /// network. This range is used for assigning internal IP addresses to the GKE
    /// cluster master or set of masters and to the internal load balancer virtual
    /// IP. This range must not overlap with any other ranges in use within the
    /// cluster's network.
    pub master_ipv4_reserved_range: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_endpoint][crate::model::PrivateClusterConfig::enable_private_endpoint].
    pub fn set_enable_private_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_endpoint = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::PrivateClusterConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [master_ipv4_reserved_range][crate::model::PrivateClusterConfig::master_ipv4_reserved_range].
    pub fn set_master_ipv4_reserved_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_reserved_range = v.into();
        self
    }
}

impl wkt::message::Message for PrivateClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PrivateClusterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_private_endpoint,
            __master_ipv4_cidr_block,
            __master_ipv4_reserved_range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enablePrivateEndpoint" => Ok(__FieldTag::__enable_private_endpoint),
                            "enable_private_endpoint" => Ok(__FieldTag::__enable_private_endpoint),
                            "masterIpv4CidrBlock" => Ok(__FieldTag::__master_ipv4_cidr_block),
                            "master_ipv4_cidr_block" => Ok(__FieldTag::__master_ipv4_cidr_block),
                            "masterIpv4ReservedRange" => {
                                Ok(__FieldTag::__master_ipv4_reserved_range)
                            }
                            "master_ipv4_reserved_range" => {
                                Ok(__FieldTag::__master_ipv4_reserved_range)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_private_endpoint => {
                            if !fields.insert(__FieldTag::__enable_private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_endpoint",
                                ));
                            }
                            result.enable_private_endpoint = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__master_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_ipv4_cidr_block",
                                ));
                            }
                            result.master_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_ipv4_reserved_range => {
                            if !fields.insert(__FieldTag::__master_ipv4_reserved_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_ipv4_reserved_range",
                                ));
                            }
                            result.master_ipv4_reserved_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_private_endpoint) {
            state.serialize_entry("enablePrivateEndpoint", &self.enable_private_endpoint)?;
        }
        if !self.master_ipv4_cidr_block.is_empty() {
            state.serialize_entry("masterIpv4CidrBlock", &self.master_ipv4_cidr_block)?;
        }
        if !self.master_ipv4_reserved_range.is_empty() {
            state.serialize_entry("masterIpv4ReservedRange", &self.master_ipv4_reserved_range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateClusterConfig");
        debug_struct.field("enable_private_endpoint", &self.enable_private_endpoint);
        debug_struct.field("master_ipv4_cidr_block", &self.master_ipv4_cidr_block);
        debug_struct.field(
            "master_ipv4_reserved_range",
            &self.master_ipv4_reserved_range,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for networking connections in the Composer 2
/// environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkingConfig {
    /// Optional. Indicates the user requested specific connection type between
    /// Tenant and Customer projects. You cannot set networking connection type in
    /// public IP environment.
    pub connection_type: crate::model::networking_config::ConnectionType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_type][crate::model::NetworkingConfig::connection_type].
    pub fn set_connection_type<
        T: std::convert::Into<crate::model::networking_config::ConnectionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for NetworkingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.NetworkingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionType" => Ok(__FieldTag::__connection_type),
                            "connection_type" => Ok(__FieldTag::__connection_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_type => {
                            if !fields.insert(__FieldTag::__connection_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_type",
                                ));
                            }
                            result.connection_type = map
                                .next_value::<std::option::Option<
                                    crate::model::networking_config::ConnectionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.connection_type) {
            state.serialize_entry("connectionType", &self.connection_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkingConfig");
        debug_struct.field("connection_type", &self.connection_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NetworkingConfig].
pub mod networking_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents connection type between Composer environment in Customer
    /// Project and the corresponding Tenant project, from a predefined list
    /// of available connection modes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionType {
        /// No specific connection type was requested, so the environment uses
        /// the default value corresponding to the rest of its configuration.
        Unspecified,
        /// Requests the use of VPC peerings for connecting the Customer and Tenant
        /// projects.
        VpcPeering,
        /// Requests the use of Private Service Connect for connecting the Customer
        /// and Tenant projects.
        PrivateServiceConnect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectionType::value] or
        /// [ConnectionType::name].
        UnknownValue(connection_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connection_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VpcPeering => std::option::Option::Some(1),
                Self::PrivateServiceConnect => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTION_TYPE_UNSPECIFIED"),
                Self::VpcPeering => std::option::Option::Some("VPC_PEERING"),
                Self::PrivateServiceConnect => std::option::Option::Some("PRIVATE_SERVICE_CONNECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VpcPeering,
                2 => Self::PrivateServiceConnect,
                _ => Self::UnknownValue(connection_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConnectionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "VPC_PEERING" => Self::VpcPeering,
                "PRIVATE_SERVICE_CONNECT" => Self::PrivateServiceConnect,
                _ => Self::UnknownValue(connection_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConnectionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VpcPeering => serializer.serialize_i32(1),
                Self::PrivateServiceConnect => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionType>::new(
                ".google.cloud.orchestration.airflow.service.v1.NetworkingConfig.ConnectionType",
            ))
        }
    }
}

/// The configuration information for configuring a Private IP Cloud Composer
/// environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateEnvironmentConfig {
    /// Optional. If `true`, a Private IP Cloud Composer environment is created.
    /// If this field is set to true, `IPAllocationPolicy.use_ip_aliases` must be
    /// set to true for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub enable_private_environment: bool,

    /// Optional. If `true`, builds performed during operations that install Python
    /// packages have only private connectivity to Google services (including
    /// Artifact Registry) and VPC network (if either `NodeConfig.network` and
    /// `NodeConfig.subnetwork` fields or `NodeConfig.composer_network_attachment`
    /// field are specified). If `false`, the builds also have access to the
    /// internet.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    pub enable_private_builds_only: bool,

    /// Optional. Configuration for the private GKE cluster for a Private IP
    /// Cloud Composer environment.
    pub private_cluster_config: std::option::Option<crate::model::PrivateClusterConfig>,

    /// Optional. The CIDR block from which IP range for web server will be
    /// reserved. Needs to be disjoint from
    /// `private_cluster_config.master_ipv4_cidr_block` and
    /// `cloud_sql_ipv4_cidr_block`.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub web_server_ipv4_cidr_block: std::string::String,

    /// Optional. The CIDR block from which IP range in tenant project will be
    /// reserved for Cloud SQL. Needs to be disjoint from
    /// `web_server_ipv4_cidr_block`.
    pub cloud_sql_ipv4_cidr_block: std::string::String,

    /// Output only. The IP range reserved for the tenant project's App Engine VMs.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-1.*.*-airflow-*.*.*.
    pub web_server_ipv4_reserved_range: std::string::String,

    /// Optional. The CIDR block from which IP range for Cloud Composer Network in
    /// tenant project will be reserved. Needs to be disjoint from
    /// private_cluster_config.master_ipv4_cidr_block and
    /// cloud_sql_ipv4_cidr_block.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    pub cloud_composer_network_ipv4_cidr_block: std::string::String,

    /// Output only. The IP range reserved for the tenant project's Cloud Composer
    /// network.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-2.*.*-airflow-*.*.* and newer.
    pub cloud_composer_network_ipv4_reserved_range: std::string::String,

    /// Optional. When enabled, IPs from public (non-RFC1918) ranges can be used
    /// for `IPAllocationPolicy.cluster_ipv4_cidr_block` and
    /// `IPAllocationPolicy.service_ipv4_cidr_block`.
    pub enable_privately_used_public_ips: bool,

    /// Optional. When specified, the environment will use Private Service Connect
    /// instead of VPC peerings to connect to Cloud SQL in the Tenant Project,
    /// and the PSC endpoint in the Customer Project will use an IP address from
    /// this subnetwork.
    pub cloud_composer_connection_subnetwork: std::string::String,

    /// Optional. Configuration for the network connections configuration in the
    /// environment.
    pub networking_config: std::option::Option<crate::model::NetworkingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateEnvironmentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_environment][crate::model::PrivateEnvironmentConfig::enable_private_environment].
    pub fn set_enable_private_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_environment = v.into();
        self
    }

    /// Sets the value of [enable_private_builds_only][crate::model::PrivateEnvironmentConfig::enable_private_builds_only].
    pub fn set_enable_private_builds_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_builds_only = v.into();
        self
    }

    /// Sets the value of [private_cluster_config][crate::model::PrivateEnvironmentConfig::private_cluster_config].
    pub fn set_private_cluster_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterConfig>,
    {
        self.private_cluster_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_cluster_config][crate::model::PrivateEnvironmentConfig::private_cluster_config].
    pub fn set_or_clear_private_cluster_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterConfig>,
    {
        self.private_cluster_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [web_server_ipv4_cidr_block][crate::model::PrivateEnvironmentConfig::web_server_ipv4_cidr_block].
    pub fn set_web_server_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cloud_sql_ipv4_cidr_block][crate::model::PrivateEnvironmentConfig::cloud_sql_ipv4_cidr_block].
    pub fn set_cloud_sql_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_sql_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [web_server_ipv4_reserved_range][crate::model::PrivateEnvironmentConfig::web_server_ipv4_reserved_range].
    pub fn set_web_server_ipv4_reserved_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.web_server_ipv4_reserved_range = v.into();
        self
    }

    /// Sets the value of [cloud_composer_network_ipv4_cidr_block][crate::model::PrivateEnvironmentConfig::cloud_composer_network_ipv4_cidr_block].
    pub fn set_cloud_composer_network_ipv4_cidr_block<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_composer_network_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cloud_composer_network_ipv4_reserved_range][crate::model::PrivateEnvironmentConfig::cloud_composer_network_ipv4_reserved_range].
    pub fn set_cloud_composer_network_ipv4_reserved_range<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_composer_network_ipv4_reserved_range = v.into();
        self
    }

    /// Sets the value of [enable_privately_used_public_ips][crate::model::PrivateEnvironmentConfig::enable_privately_used_public_ips].
    pub fn set_enable_privately_used_public_ips<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_privately_used_public_ips = v.into();
        self
    }

    /// Sets the value of [cloud_composer_connection_subnetwork][crate::model::PrivateEnvironmentConfig::cloud_composer_connection_subnetwork].
    pub fn set_cloud_composer_connection_subnetwork<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_composer_connection_subnetwork = v.into();
        self
    }

    /// Sets the value of [networking_config][crate::model::PrivateEnvironmentConfig::networking_config].
    pub fn set_networking_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkingConfig>,
    {
        self.networking_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [networking_config][crate::model::PrivateEnvironmentConfig::networking_config].
    pub fn set_or_clear_networking_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkingConfig>,
    {
        self.networking_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PrivateEnvironmentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.PrivateEnvironmentConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateEnvironmentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_private_environment,
            __enable_private_builds_only,
            __private_cluster_config,
            __web_server_ipv4_cidr_block,
            __cloud_sql_ipv4_cidr_block,
            __web_server_ipv4_reserved_range,
            __cloud_composer_network_ipv4_cidr_block,
            __cloud_composer_network_ipv4_reserved_range,
            __enable_privately_used_public_ips,
            __cloud_composer_connection_subnetwork,
            __networking_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateEnvironmentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enablePrivateEnvironment" => {
                                Ok(__FieldTag::__enable_private_environment)
                            }
                            "enable_private_environment" => {
                                Ok(__FieldTag::__enable_private_environment)
                            }
                            "enablePrivateBuildsOnly" => {
                                Ok(__FieldTag::__enable_private_builds_only)
                            }
                            "enable_private_builds_only" => {
                                Ok(__FieldTag::__enable_private_builds_only)
                            }
                            "privateClusterConfig" => Ok(__FieldTag::__private_cluster_config),
                            "private_cluster_config" => Ok(__FieldTag::__private_cluster_config),
                            "webServerIpv4CidrBlock" => {
                                Ok(__FieldTag::__web_server_ipv4_cidr_block)
                            }
                            "web_server_ipv4_cidr_block" => {
                                Ok(__FieldTag::__web_server_ipv4_cidr_block)
                            }
                            "cloudSqlIpv4CidrBlock" => Ok(__FieldTag::__cloud_sql_ipv4_cidr_block),
                            "cloud_sql_ipv4_cidr_block" => {
                                Ok(__FieldTag::__cloud_sql_ipv4_cidr_block)
                            }
                            "webServerIpv4ReservedRange" => {
                                Ok(__FieldTag::__web_server_ipv4_reserved_range)
                            }
                            "web_server_ipv4_reserved_range" => {
                                Ok(__FieldTag::__web_server_ipv4_reserved_range)
                            }
                            "cloudComposerNetworkIpv4CidrBlock" => {
                                Ok(__FieldTag::__cloud_composer_network_ipv4_cidr_block)
                            }
                            "cloud_composer_network_ipv4_cidr_block" => {
                                Ok(__FieldTag::__cloud_composer_network_ipv4_cidr_block)
                            }
                            "cloudComposerNetworkIpv4ReservedRange" => {
                                Ok(__FieldTag::__cloud_composer_network_ipv4_reserved_range)
                            }
                            "cloud_composer_network_ipv4_reserved_range" => {
                                Ok(__FieldTag::__cloud_composer_network_ipv4_reserved_range)
                            }
                            "enablePrivatelyUsedPublicIps" => {
                                Ok(__FieldTag::__enable_privately_used_public_ips)
                            }
                            "enable_privately_used_public_ips" => {
                                Ok(__FieldTag::__enable_privately_used_public_ips)
                            }
                            "cloudComposerConnectionSubnetwork" => {
                                Ok(__FieldTag::__cloud_composer_connection_subnetwork)
                            }
                            "cloud_composer_connection_subnetwork" => {
                                Ok(__FieldTag::__cloud_composer_connection_subnetwork)
                            }
                            "networkingConfig" => Ok(__FieldTag::__networking_config),
                            "networking_config" => Ok(__FieldTag::__networking_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateEnvironmentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateEnvironmentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_private_environment => {
                            if !fields.insert(__FieldTag::__enable_private_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_environment",
                                ));
                            }
                            result.enable_private_environment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_private_builds_only => {
                            if !fields.insert(__FieldTag::__enable_private_builds_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_builds_only",
                                ));
                            }
                            result.enable_private_builds_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_cluster_config => {
                            if !fields.insert(__FieldTag::__private_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_cluster_config",
                                ));
                            }
                            result.private_cluster_config = map.next_value::<std::option::Option<crate::model::PrivateClusterConfig>>()?
                                ;
                        }
                        __FieldTag::__web_server_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__web_server_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_server_ipv4_cidr_block",
                                ));
                            }
                            result.web_server_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_sql_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__cloud_sql_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_ipv4_cidr_block",
                                ));
                            }
                            result.cloud_sql_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__web_server_ipv4_reserved_range => {
                            if !fields.insert(__FieldTag::__web_server_ipv4_reserved_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_server_ipv4_reserved_range",
                                ));
                            }
                            result.web_server_ipv4_reserved_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_composer_network_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__cloud_composer_network_ipv4_cidr_block)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_composer_network_ipv4_cidr_block",
                                ));
                            }
                            result.cloud_composer_network_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_composer_network_ipv4_reserved_range => {
                            if !fields
                                .insert(__FieldTag::__cloud_composer_network_ipv4_reserved_range)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_composer_network_ipv4_reserved_range",
                                ));
                            }
                            result.cloud_composer_network_ipv4_reserved_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_privately_used_public_ips => {
                            if !fields.insert(__FieldTag::__enable_privately_used_public_ips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_privately_used_public_ips",
                                ));
                            }
                            result.enable_privately_used_public_ips = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_composer_connection_subnetwork => {
                            if !fields.insert(__FieldTag::__cloud_composer_connection_subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_composer_connection_subnetwork",
                                ));
                            }
                            result.cloud_composer_connection_subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__networking_config => {
                            if !fields.insert(__FieldTag::__networking_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networking_config",
                                ));
                            }
                            result.networking_config = map
                                .next_value::<std::option::Option<crate::model::NetworkingConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateEnvironmentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_private_environment) {
            state.serialize_entry("enablePrivateEnvironment", &self.enable_private_environment)?;
        }
        if !wkt::internal::is_default(&self.enable_private_builds_only) {
            state.serialize_entry("enablePrivateBuildsOnly", &self.enable_private_builds_only)?;
        }
        if self.private_cluster_config.is_some() {
            state.serialize_entry("privateClusterConfig", &self.private_cluster_config)?;
        }
        if !self.web_server_ipv4_cidr_block.is_empty() {
            state.serialize_entry("webServerIpv4CidrBlock", &self.web_server_ipv4_cidr_block)?;
        }
        if !self.cloud_sql_ipv4_cidr_block.is_empty() {
            state.serialize_entry("cloudSqlIpv4CidrBlock", &self.cloud_sql_ipv4_cidr_block)?;
        }
        if !self.web_server_ipv4_reserved_range.is_empty() {
            state.serialize_entry(
                "webServerIpv4ReservedRange",
                &self.web_server_ipv4_reserved_range,
            )?;
        }
        if !self.cloud_composer_network_ipv4_cidr_block.is_empty() {
            state.serialize_entry(
                "cloudComposerNetworkIpv4CidrBlock",
                &self.cloud_composer_network_ipv4_cidr_block,
            )?;
        }
        if !self.cloud_composer_network_ipv4_reserved_range.is_empty() {
            state.serialize_entry(
                "cloudComposerNetworkIpv4ReservedRange",
                &self.cloud_composer_network_ipv4_reserved_range,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_privately_used_public_ips) {
            state.serialize_entry(
                "enablePrivatelyUsedPublicIps",
                &self.enable_privately_used_public_ips,
            )?;
        }
        if !self.cloud_composer_connection_subnetwork.is_empty() {
            state.serialize_entry(
                "cloudComposerConnectionSubnetwork",
                &self.cloud_composer_connection_subnetwork,
            )?;
        }
        if self.networking_config.is_some() {
            state.serialize_entry("networkingConfig", &self.networking_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateEnvironmentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateEnvironmentConfig");
        debug_struct.field(
            "enable_private_environment",
            &self.enable_private_environment,
        );
        debug_struct.field(
            "enable_private_builds_only",
            &self.enable_private_builds_only,
        );
        debug_struct.field("private_cluster_config", &self.private_cluster_config);
        debug_struct.field(
            "web_server_ipv4_cidr_block",
            &self.web_server_ipv4_cidr_block,
        );
        debug_struct.field("cloud_sql_ipv4_cidr_block", &self.cloud_sql_ipv4_cidr_block);
        debug_struct.field(
            "web_server_ipv4_reserved_range",
            &self.web_server_ipv4_reserved_range,
        );
        debug_struct.field(
            "cloud_composer_network_ipv4_cidr_block",
            &self.cloud_composer_network_ipv4_cidr_block,
        );
        debug_struct.field(
            "cloud_composer_network_ipv4_reserved_range",
            &self.cloud_composer_network_ipv4_reserved_range,
        );
        debug_struct.field(
            "enable_privately_used_public_ips",
            &self.enable_privately_used_public_ips,
        );
        debug_struct.field(
            "cloud_composer_connection_subnetwork",
            &self.cloud_composer_connection_subnetwork,
        );
        debug_struct.field("networking_config", &self.networking_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The Kubernetes workloads configuration for GKE cluster associated with the
/// Cloud Composer environment. Supported for Cloud Composer environments in
/// versions composer-2.*.*-airflow-*.*.* and newer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkloadsConfig {
    /// Optional. Resources used by Airflow schedulers.
    pub scheduler: std::option::Option<crate::model::workloads_config::SchedulerResource>,

    /// Optional. Resources used by Airflow web server.
    pub web_server: std::option::Option<crate::model::workloads_config::WebServerResource>,

    /// Optional. Resources used by Airflow workers.
    pub worker: std::option::Option<crate::model::workloads_config::WorkerResource>,

    /// Optional. Resources used by Airflow triggerers.
    pub triggerer: std::option::Option<crate::model::workloads_config::TriggererResource>,

    /// Optional. Resources used by Airflow DAG processors.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    pub dag_processor: std::option::Option<crate::model::workloads_config::DagProcessorResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scheduler][crate::model::WorkloadsConfig::scheduler].
    pub fn set_scheduler<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::SchedulerResource>,
    {
        self.scheduler = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduler][crate::model::WorkloadsConfig::scheduler].
    pub fn set_or_clear_scheduler<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::SchedulerResource>,
    {
        self.scheduler = v.map(|x| x.into());
        self
    }

    /// Sets the value of [web_server][crate::model::WorkloadsConfig::web_server].
    pub fn set_web_server<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::WebServerResource>,
    {
        self.web_server = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [web_server][crate::model::WorkloadsConfig::web_server].
    pub fn set_or_clear_web_server<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::WebServerResource>,
    {
        self.web_server = v.map(|x| x.into());
        self
    }

    /// Sets the value of [worker][crate::model::WorkloadsConfig::worker].
    pub fn set_worker<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::WorkerResource>,
    {
        self.worker = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker][crate::model::WorkloadsConfig::worker].
    pub fn set_or_clear_worker<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::WorkerResource>,
    {
        self.worker = v.map(|x| x.into());
        self
    }

    /// Sets the value of [triggerer][crate::model::WorkloadsConfig::triggerer].
    pub fn set_triggerer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::TriggererResource>,
    {
        self.triggerer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [triggerer][crate::model::WorkloadsConfig::triggerer].
    pub fn set_or_clear_triggerer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::TriggererResource>,
    {
        self.triggerer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dag_processor][crate::model::WorkloadsConfig::dag_processor].
    pub fn set_dag_processor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::DagProcessorResource>,
    {
        self.dag_processor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dag_processor][crate::model::WorkloadsConfig::dag_processor].
    pub fn set_or_clear_dag_processor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workloads_config::DagProcessorResource>,
    {
        self.dag_processor = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WorkloadsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkloadsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scheduler,
            __web_server,
            __worker,
            __triggerer,
            __dag_processor,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scheduler" => Ok(__FieldTag::__scheduler),
                            "webServer" => Ok(__FieldTag::__web_server),
                            "web_server" => Ok(__FieldTag::__web_server),
                            "worker" => Ok(__FieldTag::__worker),
                            "triggerer" => Ok(__FieldTag::__triggerer),
                            "dagProcessor" => Ok(__FieldTag::__dag_processor),
                            "dag_processor" => Ok(__FieldTag::__dag_processor),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkloadsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scheduler => {
                            if !fields.insert(__FieldTag::__scheduler) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduler",
                                ));
                            }
                            result.scheduler = map.next_value::<std::option::Option<
                                crate::model::workloads_config::SchedulerResource,
                            >>()?;
                        }
                        __FieldTag::__web_server => {
                            if !fields.insert(__FieldTag::__web_server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_server",
                                ));
                            }
                            result.web_server = map.next_value::<std::option::Option<
                                crate::model::workloads_config::WebServerResource,
                            >>()?;
                        }
                        __FieldTag::__worker => {
                            if !fields.insert(__FieldTag::__worker) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker",
                                ));
                            }
                            result.worker = map.next_value::<std::option::Option<
                                crate::model::workloads_config::WorkerResource,
                            >>()?;
                        }
                        __FieldTag::__triggerer => {
                            if !fields.insert(__FieldTag::__triggerer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for triggerer",
                                ));
                            }
                            result.triggerer = map.next_value::<std::option::Option<
                                crate::model::workloads_config::TriggererResource,
                            >>()?;
                        }
                        __FieldTag::__dag_processor => {
                            if !fields.insert(__FieldTag::__dag_processor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dag_processor",
                                ));
                            }
                            result.dag_processor = map.next_value::<std::option::Option<
                                crate::model::workloads_config::DagProcessorResource,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkloadsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.scheduler.is_some() {
            state.serialize_entry("scheduler", &self.scheduler)?;
        }
        if self.web_server.is_some() {
            state.serialize_entry("webServer", &self.web_server)?;
        }
        if self.worker.is_some() {
            state.serialize_entry("worker", &self.worker)?;
        }
        if self.triggerer.is_some() {
            state.serialize_entry("triggerer", &self.triggerer)?;
        }
        if self.dag_processor.is_some() {
            state.serialize_entry("dagProcessor", &self.dag_processor)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WorkloadsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadsConfig");
        debug_struct.field("scheduler", &self.scheduler);
        debug_struct.field("web_server", &self.web_server);
        debug_struct.field("worker", &self.worker);
        debug_struct.field("triggerer", &self.triggerer);
        debug_struct.field("dag_processor", &self.dag_processor);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WorkloadsConfig].
pub mod workloads_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for resources used by Airflow schedulers.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SchedulerResource {
        /// Optional. CPU request and limit for a single Airflow scheduler replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow scheduler
        /// replica.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for a single Airflow scheduler
        /// replica.
        pub storage_gb: f32,

        /// Optional. The number of schedulers.
        pub count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SchedulerResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::SchedulerResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::SchedulerResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::SchedulerResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }

        /// Sets the value of [count][crate::model::workloads_config::SchedulerResource::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for SchedulerResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.SchedulerResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SchedulerResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cpu,
                __memory_gb,
                __storage_gb,
                __count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SchedulerResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cpu" => Ok(__FieldTag::__cpu),
                                "memoryGb" => Ok(__FieldTag::__memory_gb),
                                "memory_gb" => Ok(__FieldTag::__memory_gb),
                                "storageGb" => Ok(__FieldTag::__storage_gb),
                                "storage_gb" => Ok(__FieldTag::__storage_gb),
                                "count" => Ok(__FieldTag::__count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SchedulerResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SchedulerResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cpu => {
                                if !fields.insert(__FieldTag::__cpu) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cpu",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.cpu = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__memory_gb => {
                                if !fields.insert(__FieldTag::__memory_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.memory_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__storage_gb => {
                                if !fields.insert(__FieldTag::__storage_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for storage_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.storage_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SchedulerResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.cpu) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("cpu", &__With(&self.cpu))?;
            }
            if !wkt::internal::is_default(&self.memory_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("memoryGb", &__With(&self.memory_gb))?;
            }
            if !wkt::internal::is_default(&self.storage_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("storageGb", &__With(&self.storage_gb))?;
            }
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SchedulerResource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SchedulerResource");
            debug_struct.field("cpu", &self.cpu);
            debug_struct.field("memory_gb", &self.memory_gb);
            debug_struct.field("storage_gb", &self.storage_gb);
            debug_struct.field("count", &self.count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration for resources used by Airflow web server.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WebServerResource {
        /// Optional. CPU request and limit for Airflow web server.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for Airflow web server.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for Airflow web server.
        pub storage_gb: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebServerResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::WebServerResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::WebServerResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::WebServerResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for WebServerResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.WebServerResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WebServerResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cpu,
                __memory_gb,
                __storage_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WebServerResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cpu" => Ok(__FieldTag::__cpu),
                                "memoryGb" => Ok(__FieldTag::__memory_gb),
                                "memory_gb" => Ok(__FieldTag::__memory_gb),
                                "storageGb" => Ok(__FieldTag::__storage_gb),
                                "storage_gb" => Ok(__FieldTag::__storage_gb),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WebServerResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WebServerResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cpu => {
                                if !fields.insert(__FieldTag::__cpu) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cpu",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.cpu = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__memory_gb => {
                                if !fields.insert(__FieldTag::__memory_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.memory_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__storage_gb => {
                                if !fields.insert(__FieldTag::__storage_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for storage_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.storage_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WebServerResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.cpu) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("cpu", &__With(&self.cpu))?;
            }
            if !wkt::internal::is_default(&self.memory_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("memoryGb", &__With(&self.memory_gb))?;
            }
            if !wkt::internal::is_default(&self.storage_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("storageGb", &__With(&self.storage_gb))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WebServerResource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WebServerResource");
            debug_struct.field("cpu", &self.cpu);
            debug_struct.field("memory_gb", &self.memory_gb);
            debug_struct.field("storage_gb", &self.storage_gb);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration for resources used by Airflow workers.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WorkerResource {
        /// Optional. CPU request and limit for a single Airflow worker replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow worker
        /// replica.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for a single Airflow worker
        /// replica.
        pub storage_gb: f32,

        /// Optional. Minimum number of workers for autoscaling.
        pub min_count: i32,

        /// Optional. Maximum number of workers for autoscaling.
        pub max_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WorkerResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::WorkerResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::WorkerResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::WorkerResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }

        /// Sets the value of [min_count][crate::model::workloads_config::WorkerResource::min_count].
        pub fn set_min_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_count = v.into();
            self
        }

        /// Sets the value of [max_count][crate::model::workloads_config::WorkerResource::max_count].
        pub fn set_max_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_count = v.into();
            self
        }
    }

    impl wkt::message::Message for WorkerResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.WorkerResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WorkerResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cpu,
                __memory_gb,
                __storage_gb,
                __min_count,
                __max_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WorkerResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cpu" => Ok(__FieldTag::__cpu),
                                "memoryGb" => Ok(__FieldTag::__memory_gb),
                                "memory_gb" => Ok(__FieldTag::__memory_gb),
                                "storageGb" => Ok(__FieldTag::__storage_gb),
                                "storage_gb" => Ok(__FieldTag::__storage_gb),
                                "minCount" => Ok(__FieldTag::__min_count),
                                "min_count" => Ok(__FieldTag::__min_count),
                                "maxCount" => Ok(__FieldTag::__max_count),
                                "max_count" => Ok(__FieldTag::__max_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WorkerResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WorkerResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cpu => {
                                if !fields.insert(__FieldTag::__cpu) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cpu",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.cpu = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__memory_gb => {
                                if !fields.insert(__FieldTag::__memory_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.memory_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__storage_gb => {
                                if !fields.insert(__FieldTag::__storage_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for storage_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.storage_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__min_count => {
                                if !fields.insert(__FieldTag::__min_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.min_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max_count => {
                                if !fields.insert(__FieldTag::__max_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WorkerResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.cpu) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("cpu", &__With(&self.cpu))?;
            }
            if !wkt::internal::is_default(&self.memory_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("memoryGb", &__With(&self.memory_gb))?;
            }
            if !wkt::internal::is_default(&self.storage_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("storageGb", &__With(&self.storage_gb))?;
            }
            if !wkt::internal::is_default(&self.min_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("minCount", &__With(&self.min_count))?;
            }
            if !wkt::internal::is_default(&self.max_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxCount", &__With(&self.max_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WorkerResource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WorkerResource");
            debug_struct.field("cpu", &self.cpu);
            debug_struct.field("memory_gb", &self.memory_gb);
            debug_struct.field("storage_gb", &self.storage_gb);
            debug_struct.field("min_count", &self.min_count);
            debug_struct.field("max_count", &self.max_count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration for resources used by Airflow triggerers.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TriggererResource {
        /// Optional. The number of triggerers.
        pub count: i32,

        /// Optional. CPU request and limit for a single Airflow triggerer replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow triggerer
        /// replica.
        pub memory_gb: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TriggererResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::workloads_config::TriggererResource::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [cpu][crate::model::workloads_config::TriggererResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::TriggererResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for TriggererResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.TriggererResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TriggererResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __count,
                __cpu,
                __memory_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TriggererResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "count" => Ok(__FieldTag::__count),
                                "cpu" => Ok(__FieldTag::__cpu),
                                "memoryGb" => Ok(__FieldTag::__memory_gb),
                                "memory_gb" => Ok(__FieldTag::__memory_gb),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TriggererResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TriggererResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__cpu => {
                                if !fields.insert(__FieldTag::__cpu) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cpu",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.cpu = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__memory_gb => {
                                if !fields.insert(__FieldTag::__memory_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.memory_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TriggererResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !wkt::internal::is_default(&self.cpu) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("cpu", &__With(&self.cpu))?;
            }
            if !wkt::internal::is_default(&self.memory_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("memoryGb", &__With(&self.memory_gb))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TriggererResource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TriggererResource");
            debug_struct.field("count", &self.count);
            debug_struct.field("cpu", &self.cpu);
            debug_struct.field("memory_gb", &self.memory_gb);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration for resources used by Airflow DAG processors.
    ///
    /// This field is supported for Cloud Composer environments in versions
    /// composer-3-airflow-*.*.*-build.* and newer.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DagProcessorResource {
        /// Optional. CPU request and limit for a single Airflow DAG processor
        /// replica.
        pub cpu: f32,

        /// Optional. Memory (GB) request and limit for a single Airflow DAG
        /// processor replica.
        pub memory_gb: f32,

        /// Optional. Storage (GB) request and limit for a single Airflow DAG
        /// processor replica.
        pub storage_gb: f32,

        /// Optional. The number of DAG processors. If not provided or set to 0, a
        /// single DAG processor instance will be created.
        pub count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DagProcessorResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu][crate::model::workloads_config::DagProcessorResource::cpu].
        pub fn set_cpu<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.cpu = v.into();
            self
        }

        /// Sets the value of [memory_gb][crate::model::workloads_config::DagProcessorResource::memory_gb].
        pub fn set_memory_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.memory_gb = v.into();
            self
        }

        /// Sets the value of [storage_gb][crate::model::workloads_config::DagProcessorResource::storage_gb].
        pub fn set_storage_gb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.storage_gb = v.into();
            self
        }

        /// Sets the value of [count][crate::model::workloads_config::DagProcessorResource::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for DagProcessorResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.WorkloadsConfig.DagProcessorResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DagProcessorResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cpu,
                __memory_gb,
                __storage_gb,
                __count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DagProcessorResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cpu" => Ok(__FieldTag::__cpu),
                                "memoryGb" => Ok(__FieldTag::__memory_gb),
                                "memory_gb" => Ok(__FieldTag::__memory_gb),
                                "storageGb" => Ok(__FieldTag::__storage_gb),
                                "storage_gb" => Ok(__FieldTag::__storage_gb),
                                "count" => Ok(__FieldTag::__count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DagProcessorResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DagProcessorResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cpu => {
                                if !fields.insert(__FieldTag::__cpu) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cpu",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.cpu = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__memory_gb => {
                                if !fields.insert(__FieldTag::__memory_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.memory_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__storage_gb => {
                                if !fields.insert(__FieldTag::__storage_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for storage_gb",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.storage_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DagProcessorResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.cpu) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("cpu", &__With(&self.cpu))?;
            }
            if !wkt::internal::is_default(&self.memory_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("memoryGb", &__With(&self.memory_gb))?;
            }
            if !wkt::internal::is_default(&self.storage_gb) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("storageGb", &__With(&self.storage_gb))?;
            }
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DagProcessorResource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DagProcessorResource");
            debug_struct.field("cpu", &self.cpu);
            debug_struct.field("memory_gb", &self.memory_gb);
            debug_struct.field("storage_gb", &self.storage_gb);
            debug_struct.field("count", &self.count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The Recovery settings of an environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecoveryConfig {
    /// Optional. The configuration for scheduled snapshot creation mechanism.
    pub scheduled_snapshots_config: std::option::Option<crate::model::ScheduledSnapshotsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecoveryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scheduled_snapshots_config][crate::model::RecoveryConfig::scheduled_snapshots_config].
    pub fn set_scheduled_snapshots_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScheduledSnapshotsConfig>,
    {
        self.scheduled_snapshots_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduled_snapshots_config][crate::model::RecoveryConfig::scheduled_snapshots_config].
    pub fn set_or_clear_scheduled_snapshots_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScheduledSnapshotsConfig>,
    {
        self.scheduled_snapshots_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecoveryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.RecoveryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecoveryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scheduled_snapshots_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecoveryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scheduledSnapshotsConfig" => {
                                Ok(__FieldTag::__scheduled_snapshots_config)
                            }
                            "scheduled_snapshots_config" => {
                                Ok(__FieldTag::__scheduled_snapshots_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecoveryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecoveryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scheduled_snapshots_config => {
                            if !fields.insert(__FieldTag::__scheduled_snapshots_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduled_snapshots_config",
                                ));
                            }
                            result.scheduled_snapshots_config = map.next_value::<std::option::Option<crate::model::ScheduledSnapshotsConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecoveryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.scheduled_snapshots_config.is_some() {
            state.serialize_entry("scheduledSnapshotsConfig", &self.scheduled_snapshots_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecoveryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecoveryConfig");
        debug_struct.field(
            "scheduled_snapshots_config",
            &self.scheduled_snapshots_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The configuration for scheduled snapshot creation mechanism.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScheduledSnapshotsConfig {
    /// Optional. Whether scheduled snapshots creation is enabled.
    pub enabled: bool,

    /// Optional. The Cloud Storage location for storing automatically created
    /// snapshots.
    pub snapshot_location: std::string::String,

    /// Optional. The cron expression representing the time when snapshots creation
    /// mechanism runs. This field is subject to additional validation around
    /// frequency of execution.
    pub snapshot_creation_schedule: std::string::String,

    /// Optional. Time zone that sets the context to interpret
    /// snapshot_creation_schedule.
    pub time_zone: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduledSnapshotsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ScheduledSnapshotsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [snapshot_location][crate::model::ScheduledSnapshotsConfig::snapshot_location].
    pub fn set_snapshot_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_location = v.into();
        self
    }

    /// Sets the value of [snapshot_creation_schedule][crate::model::ScheduledSnapshotsConfig::snapshot_creation_schedule].
    pub fn set_snapshot_creation_schedule<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_creation_schedule = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::ScheduledSnapshotsConfig::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }
}

impl wkt::message::Message for ScheduledSnapshotsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ScheduledSnapshotsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScheduledSnapshotsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __snapshot_location,
            __snapshot_creation_schedule,
            __time_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScheduledSnapshotsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "snapshotLocation" => Ok(__FieldTag::__snapshot_location),
                            "snapshot_location" => Ok(__FieldTag::__snapshot_location),
                            "snapshotCreationSchedule" => {
                                Ok(__FieldTag::__snapshot_creation_schedule)
                            }
                            "snapshot_creation_schedule" => {
                                Ok(__FieldTag::__snapshot_creation_schedule)
                            }
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScheduledSnapshotsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScheduledSnapshotsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_location => {
                            if !fields.insert(__FieldTag::__snapshot_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_location",
                                ));
                            }
                            result.snapshot_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_creation_schedule => {
                            if !fields.insert(__FieldTag::__snapshot_creation_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_creation_schedule",
                                ));
                            }
                            result.snapshot_creation_schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScheduledSnapshotsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.snapshot_location.is_empty() {
            state.serialize_entry("snapshotLocation", &self.snapshot_location)?;
        }
        if !self.snapshot_creation_schedule.is_empty() {
            state.serialize_entry("snapshotCreationSchedule", &self.snapshot_creation_schedule)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ScheduledSnapshotsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScheduledSnapshotsConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("snapshot_location", &self.snapshot_location);
        debug_struct.field(
            "snapshot_creation_schedule",
            &self.snapshot_creation_schedule,
        );
        debug_struct.field("time_zone", &self.time_zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the master authorized networks feature. Enabled
/// master authorized networks will disallow all external traffic to access
/// Kubernetes master through HTTPS except traffic from the given CIDR blocks,
/// Google Compute Engine Public IPs and Google Prod IPs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MasterAuthorizedNetworksConfig {
    /// Optional. Whether or not master authorized networks feature is enabled.
    pub enabled: bool,

    /// Up to 50 external networks that could access Kubernetes master through
    /// HTTPS.
    pub cidr_blocks: std::vec::Vec<crate::model::master_authorized_networks_config::CidrBlock>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MasterAuthorizedNetworksConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::MasterAuthorizedNetworksConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [cidr_blocks][crate::model::MasterAuthorizedNetworksConfig::cidr_blocks].
    pub fn set_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::master_authorized_networks_config::CidrBlock>,
    {
        use std::iter::Iterator;
        self.cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MasterAuthorizedNetworksConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.MasterAuthorizedNetworksConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MasterAuthorizedNetworksConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __cidr_blocks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MasterAuthorizedNetworksConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "cidrBlocks" => Ok(__FieldTag::__cidr_blocks),
                            "cidr_blocks" => Ok(__FieldTag::__cidr_blocks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MasterAuthorizedNetworksConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MasterAuthorizedNetworksConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr_blocks => {
                            if !fields.insert(__FieldTag::__cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr_blocks",
                                ));
                            }
                            result.cidr_blocks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::master_authorized_networks_config::CidrBlock,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MasterAuthorizedNetworksConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.cidr_blocks.is_empty() {
            state.serialize_entry("cidrBlocks", &self.cidr_blocks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MasterAuthorizedNetworksConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MasterAuthorizedNetworksConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("cidr_blocks", &self.cidr_blocks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MasterAuthorizedNetworksConfig].
pub mod master_authorized_networks_config {
    #[allow(unused_imports)]
    use super::*;

    /// CIDR block with an optional name.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CidrBlock {
        /// User-defined name that identifies the CIDR block.
        pub display_name: std::string::String,

        /// CIDR block that must be specified in CIDR notation.
        pub cidr_block: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CidrBlock {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::master_authorized_networks_config::CidrBlock::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [cidr_block][crate::model::master_authorized_networks_config::CidrBlock::cidr_block].
        pub fn set_cidr_block<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cidr_block = v.into();
            self
        }
    }

    impl wkt::message::Message for CidrBlock {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.MasterAuthorizedNetworksConfig.CidrBlock"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CidrBlock {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __cidr_block,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CidrBlock")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "cidrBlock" => Ok(__FieldTag::__cidr_block),
                                "cidr_block" => Ok(__FieldTag::__cidr_block),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CidrBlock;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CidrBlock")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cidr_block => {
                                if !fields.insert(__FieldTag::__cidr_block) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cidr_block",
                                    ));
                                }
                                result.cidr_block = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CidrBlock {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.cidr_block.is_empty() {
                state.serialize_entry("cidrBlock", &self.cidr_block)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CidrBlock {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CidrBlock");
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("cidr_block", &self.cidr_block);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Configuration for Cloud Data Lineage integration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudDataLineageIntegration {
    /// Optional. Whether or not Cloud Data Lineage integration is enabled.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudDataLineageIntegration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::CloudDataLineageIntegration::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for CloudDataLineageIntegration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CloudDataLineageIntegration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudDataLineageIntegration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudDataLineageIntegration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudDataLineageIntegration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudDataLineageIntegration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudDataLineageIntegration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudDataLineageIntegration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudDataLineageIntegration");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An environment for running orchestration tasks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Environment {
    /// Identifier. The resource name of the environment, in the form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    ///
    /// EnvironmentId must start with a lowercase letter followed by up to 63
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    pub name: std::string::String,

    /// Optional. Configuration parameters for this environment.
    pub config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Output only. The UUID (Universally Unique IDentifier) associated with this
    /// environment. This value is generated when the environment is created.
    pub uuid: std::string::String,

    /// The current state of the environment.
    pub state: crate::model::environment::State,

    /// Output only. The time at which this environment was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this environment was last modified.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-defined labels for this environment.
    /// The labels map can contain no more than 64 entries. Entries of the labels
    /// map are UTF8 strings that comply with the following restrictions:
    ///
    /// * Keys must conform to regexp: [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
    /// * Values must conform to regexp:  [\p{Ll}\p{Lo}\p{N}_-]{0,63}
    /// * Both keys and values are additionally constrained to be <= 128 bytes in
    ///   size.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// Optional. Storage configuration for this environment.
    pub storage_config: std::option::Option<crate::model::StorageConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Environment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Environment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Environment::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::Environment::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uuid][crate::model::Environment::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Environment::state].
    pub fn set_state<T: std::convert::Into<crate::model::environment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Environment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Environment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Environment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Environment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Environment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Environment::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Environment::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [storage_config][crate::model::Environment::storage_config].
    pub fn set_storage_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageConfig>,
    {
        self.storage_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_config][crate::model::Environment::storage_config].
    pub fn set_or_clear_storage_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageConfig>,
    {
        self.storage_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Environment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.Environment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Environment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __config,
            __uuid,
            __state,
            __create_time,
            __update_time,
            __labels,
            __satisfies_pzs,
            __satisfies_pzi,
            __storage_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Environment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "config" => Ok(__FieldTag::__config),
                            "uuid" => Ok(__FieldTag::__uuid),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "storageConfig" => Ok(__FieldTag::__storage_config),
                            "storage_config" => Ok(__FieldTag::__storage_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Environment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Environment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::EnvironmentConfig>>(
                                )?;
                        }
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::environment::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_config => {
                            if !fields.insert(__FieldTag::__storage_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_config",
                                ));
                            }
                            result.storage_config = map
                                .next_value::<std::option::Option<crate::model::StorageConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Environment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.storage_config.is_some() {
            state.serialize_entry("storageConfig", &self.storage_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Environment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Environment");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("storage_config", &self.storage_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Environment].
pub mod environment {
    #[allow(unused_imports)]
    use super::*;

    /// State of the environment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the environment is unknown.
        Unspecified,
        /// The environment is in the process of being created.
        Creating,
        /// The environment is currently running and healthy. It is ready for use.
        Running,
        /// The environment is being updated. It remains usable but cannot receive
        /// additional update requests or be deleted at this time.
        Updating,
        /// The environment is undergoing deletion. It cannot be used.
        Deleting,
        /// The environment has encountered an error and cannot be used.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Running,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "RUNNING" => Self::Running,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.orchestration.airflow.service.v1.Environment.State",
            ))
        }
    }
}

/// Request to check whether image upgrade will succeed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckUpgradeRequest {
    /// Required. The resource name of the environment to check upgrade for, in the
    /// form:
    /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
    pub environment: std::string::String,

    /// Optional. The version of the software running in the environment.
    /// This encapsulates both the version of Cloud Composer functionality and the
    /// version of Apache Airflow. It must match the regular expression
    /// `composer-([0-9]+(\.[0-9]+\.[0-9]+(-preview\.[0-9]+)?)?|latest)-airflow-([0-9]+(\.[0-9]+(\.[0-9]+)?)?)`.
    /// When used as input, the server also checks if the provided version is
    /// supported and denies the request for an unsupported version.
    ///
    /// The Cloud Composer portion of the image version is a full
    /// [semantic version](https://semver.org), or an alias in the form of major
    /// version number or `latest`. When an alias is provided, the server replaces
    /// it with the current Cloud Composer version that satisfies the alias.
    ///
    /// The Apache Airflow portion of the image version is a full semantic version
    /// that points to one of the supported Apache Airflow versions, or an alias in
    /// the form of only major or major.minor versions specified. When an alias is
    /// provided, the server replaces it with the latest Apache Airflow version
    /// that satisfies the alias and is supported in the given Cloud Composer
    /// version.
    ///
    /// In all cases, the resolved image version is stored in the same field.
    ///
    /// See also [version
    /// list](/composer/docs/concepts/versioning/composer-versions) and [versioning
    /// overview](/composer/docs/concepts/versioning/composer-versioning-overview).
    pub image_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckUpgradeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::CheckUpgradeRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [image_version][crate::model::CheckUpgradeRequest::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }
}

impl wkt::message::Message for CheckUpgradeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CheckUpgradeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckUpgradeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __image_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckUpgradeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "imageVersion" => Ok(__FieldTag::__image_version),
                            "image_version" => Ok(__FieldTag::__image_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckUpgradeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckUpgradeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_version => {
                            if !fields.insert(__FieldTag::__image_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_version",
                                ));
                            }
                            result.image_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckUpgradeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.image_version.is_empty() {
            state.serialize_entry("imageVersion", &self.image_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckUpgradeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckUpgradeRequest");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("image_version", &self.image_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message containing information about the result of an upgrade check
/// operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckUpgradeResponse {
    /// Output only. Url for a docker build log of an upgraded image.
    pub build_log_uri: std::string::String,

    /// Output only. Whether build has succeeded or failed on modules conflicts.
    pub contains_pypi_modules_conflict: crate::model::check_upgrade_response::ConflictResult,

    /// Output only. Extract from a docker image build log containing information
    /// about pypi modules conflicts.
    pub pypi_conflict_build_log_extract: std::string::String,

    /// Composer image for which the build was happening.
    pub image_version: std::string::String,

    /// Pypi dependencies specified in the environment configuration, at the time
    /// when the build was triggered.
    pub pypi_dependencies: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckUpgradeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build_log_uri][crate::model::CheckUpgradeResponse::build_log_uri].
    pub fn set_build_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_log_uri = v.into();
        self
    }

    /// Sets the value of [contains_pypi_modules_conflict][crate::model::CheckUpgradeResponse::contains_pypi_modules_conflict].
    pub fn set_contains_pypi_modules_conflict<
        T: std::convert::Into<crate::model::check_upgrade_response::ConflictResult>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.contains_pypi_modules_conflict = v.into();
        self
    }

    /// Sets the value of [pypi_conflict_build_log_extract][crate::model::CheckUpgradeResponse::pypi_conflict_build_log_extract].
    pub fn set_pypi_conflict_build_log_extract<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pypi_conflict_build_log_extract = v.into();
        self
    }

    /// Sets the value of [image_version][crate::model::CheckUpgradeResponse::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }

    /// Sets the value of [pypi_dependencies][crate::model::CheckUpgradeResponse::pypi_dependencies].
    pub fn set_pypi_dependencies<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pypi_dependencies = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CheckUpgradeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.CheckUpgradeResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckUpgradeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_log_uri,
            __contains_pypi_modules_conflict,
            __pypi_conflict_build_log_extract,
            __image_version,
            __pypi_dependencies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckUpgradeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildLogUri" => Ok(__FieldTag::__build_log_uri),
                            "build_log_uri" => Ok(__FieldTag::__build_log_uri),
                            "containsPypiModulesConflict" => {
                                Ok(__FieldTag::__contains_pypi_modules_conflict)
                            }
                            "contains_pypi_modules_conflict" => {
                                Ok(__FieldTag::__contains_pypi_modules_conflict)
                            }
                            "pypiConflictBuildLogExtract" => {
                                Ok(__FieldTag::__pypi_conflict_build_log_extract)
                            }
                            "pypi_conflict_build_log_extract" => {
                                Ok(__FieldTag::__pypi_conflict_build_log_extract)
                            }
                            "imageVersion" => Ok(__FieldTag::__image_version),
                            "image_version" => Ok(__FieldTag::__image_version),
                            "pypiDependencies" => Ok(__FieldTag::__pypi_dependencies),
                            "pypi_dependencies" => Ok(__FieldTag::__pypi_dependencies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckUpgradeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckUpgradeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_log_uri => {
                            if !fields.insert(__FieldTag::__build_log_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_log_uri",
                                ));
                            }
                            result.build_log_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contains_pypi_modules_conflict => {
                            if !fields.insert(__FieldTag::__contains_pypi_modules_conflict) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contains_pypi_modules_conflict",
                                ));
                            }
                            result.contains_pypi_modules_conflict = map
                                .next_value::<std::option::Option<
                                    crate::model::check_upgrade_response::ConflictResult,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pypi_conflict_build_log_extract => {
                            if !fields.insert(__FieldTag::__pypi_conflict_build_log_extract) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pypi_conflict_build_log_extract",
                                ));
                            }
                            result.pypi_conflict_build_log_extract = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_version => {
                            if !fields.insert(__FieldTag::__image_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_version",
                                ));
                            }
                            result.image_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pypi_dependencies => {
                            if !fields.insert(__FieldTag::__pypi_dependencies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pypi_dependencies",
                                ));
                            }
                            result.pypi_dependencies = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckUpgradeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.build_log_uri.is_empty() {
            state.serialize_entry("buildLogUri", &self.build_log_uri)?;
        }
        if !wkt::internal::is_default(&self.contains_pypi_modules_conflict) {
            state.serialize_entry(
                "containsPypiModulesConflict",
                &self.contains_pypi_modules_conflict,
            )?;
        }
        if !self.pypi_conflict_build_log_extract.is_empty() {
            state.serialize_entry(
                "pypiConflictBuildLogExtract",
                &self.pypi_conflict_build_log_extract,
            )?;
        }
        if !self.image_version.is_empty() {
            state.serialize_entry("imageVersion", &self.image_version)?;
        }
        if !self.pypi_dependencies.is_empty() {
            state.serialize_entry("pypiDependencies", &self.pypi_dependencies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckUpgradeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckUpgradeResponse");
        debug_struct.field("build_log_uri", &self.build_log_uri);
        debug_struct.field(
            "contains_pypi_modules_conflict",
            &self.contains_pypi_modules_conflict,
        );
        debug_struct.field(
            "pypi_conflict_build_log_extract",
            &self.pypi_conflict_build_log_extract,
        );
        debug_struct.field("image_version", &self.image_version);
        debug_struct.field("pypi_dependencies", &self.pypi_dependencies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CheckUpgradeResponse].
pub mod check_upgrade_response {
    #[allow(unused_imports)]
    use super::*;

    /// Whether there were python modules conflict during image build.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConflictResult {
        /// It is unknown whether build had conflicts or not.
        Unspecified,
        /// There were python packages conflicts.
        Conflict,
        /// There were no python packages conflicts.
        NoConflict,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConflictResult::value] or
        /// [ConflictResult::name].
        UnknownValue(conflict_result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod conflict_result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConflictResult {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Conflict => std::option::Option::Some(1),
                Self::NoConflict => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONFLICT_RESULT_UNSPECIFIED"),
                Self::Conflict => std::option::Option::Some("CONFLICT"),
                Self::NoConflict => std::option::Option::Some("NO_CONFLICT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConflictResult {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConflictResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConflictResult {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Conflict,
                2 => Self::NoConflict,
                _ => Self::UnknownValue(conflict_result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConflictResult {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONFLICT_RESULT_UNSPECIFIED" => Self::Unspecified,
                "CONFLICT" => Self::Conflict,
                "NO_CONFLICT" => Self::NoConflict,
                _ => Self::UnknownValue(conflict_result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConflictResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Conflict => serializer.serialize_i32(1),
                Self::NoConflict => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConflictResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConflictResult>::new(
                ".google.cloud.orchestration.airflow.service.v1.CheckUpgradeResponse.ConflictResult"))
        }
    }
}

/// The configuration setting for Airflow database data retention mechanism.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataRetentionConfig {
    /// Optional. The retention policy for airflow metadata database.
    pub airflow_metadata_retention_config:
        std::option::Option<crate::model::AirflowMetadataRetentionPolicyConfig>,

    /// Optional. The configuration settings for task logs retention
    pub task_logs_retention_config: std::option::Option<crate::model::TaskLogsRetentionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataRetentionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [airflow_metadata_retention_config][crate::model::DataRetentionConfig::airflow_metadata_retention_config].
    pub fn set_airflow_metadata_retention_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AirflowMetadataRetentionPolicyConfig>,
    {
        self.airflow_metadata_retention_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [airflow_metadata_retention_config][crate::model::DataRetentionConfig::airflow_metadata_retention_config].
    pub fn set_or_clear_airflow_metadata_retention_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AirflowMetadataRetentionPolicyConfig>,
    {
        self.airflow_metadata_retention_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [task_logs_retention_config][crate::model::DataRetentionConfig::task_logs_retention_config].
    pub fn set_task_logs_retention_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TaskLogsRetentionConfig>,
    {
        self.task_logs_retention_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [task_logs_retention_config][crate::model::DataRetentionConfig::task_logs_retention_config].
    pub fn set_or_clear_task_logs_retention_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TaskLogsRetentionConfig>,
    {
        self.task_logs_retention_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataRetentionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.DataRetentionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataRetentionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __airflow_metadata_retention_config,
            __task_logs_retention_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataRetentionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "airflowMetadataRetentionConfig" => {
                                Ok(__FieldTag::__airflow_metadata_retention_config)
                            }
                            "airflow_metadata_retention_config" => {
                                Ok(__FieldTag::__airflow_metadata_retention_config)
                            }
                            "taskLogsRetentionConfig" => {
                                Ok(__FieldTag::__task_logs_retention_config)
                            }
                            "task_logs_retention_config" => {
                                Ok(__FieldTag::__task_logs_retention_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataRetentionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataRetentionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__airflow_metadata_retention_config => {
                            if !fields.insert(__FieldTag::__airflow_metadata_retention_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for airflow_metadata_retention_config",
                                ));
                            }
                            result.airflow_metadata_retention_config = map
                                .next_value::<std::option::Option<
                                    crate::model::AirflowMetadataRetentionPolicyConfig,
                                >>()?;
                        }
                        __FieldTag::__task_logs_retention_config => {
                            if !fields.insert(__FieldTag::__task_logs_retention_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task_logs_retention_config",
                                ));
                            }
                            result.task_logs_retention_config = map.next_value::<std::option::Option<crate::model::TaskLogsRetentionConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataRetentionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.airflow_metadata_retention_config.is_some() {
            state.serialize_entry(
                "airflowMetadataRetentionConfig",
                &self.airflow_metadata_retention_config,
            )?;
        }
        if self.task_logs_retention_config.is_some() {
            state.serialize_entry("taskLogsRetentionConfig", &self.task_logs_retention_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataRetentionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataRetentionConfig");
        debug_struct.field(
            "airflow_metadata_retention_config",
            &self.airflow_metadata_retention_config,
        );
        debug_struct.field(
            "task_logs_retention_config",
            &self.task_logs_retention_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The configuration setting for Task Logs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TaskLogsRetentionConfig {
    /// Optional. The mode of storage for Airflow workers task logs.
    pub storage_mode: crate::model::task_logs_retention_config::TaskLogsStorageMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaskLogsRetentionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_mode][crate::model::TaskLogsRetentionConfig::storage_mode].
    pub fn set_storage_mode<
        T: std::convert::Into<crate::model::task_logs_retention_config::TaskLogsStorageMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_mode = v.into();
        self
    }
}

impl wkt::message::Message for TaskLogsRetentionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.TaskLogsRetentionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TaskLogsRetentionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TaskLogsRetentionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storageMode" => Ok(__FieldTag::__storage_mode),
                            "storage_mode" => Ok(__FieldTag::__storage_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TaskLogsRetentionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TaskLogsRetentionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_mode => {
                            if !fields.insert(__FieldTag::__storage_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_mode",
                                ));
                            }
                            result.storage_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::task_logs_retention_config::TaskLogsStorageMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TaskLogsRetentionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.storage_mode) {
            state.serialize_entry("storageMode", &self.storage_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TaskLogsRetentionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TaskLogsRetentionConfig");
        debug_struct.field("storage_mode", &self.storage_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TaskLogsRetentionConfig].
pub mod task_logs_retention_config {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of task_logs_storage_mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TaskLogsStorageMode {
        /// This configuration is not specified by the user.
        Unspecified,
        /// Store task logs in Cloud Logging and in the environment's Cloud Storage
        /// bucket.
        CloudLoggingAndCloudStorage,
        /// Store task logs in Cloud Logging only.
        CloudLoggingOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TaskLogsStorageMode::value] or
        /// [TaskLogsStorageMode::name].
        UnknownValue(task_logs_storage_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod task_logs_storage_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TaskLogsStorageMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudLoggingAndCloudStorage => std::option::Option::Some(1),
                Self::CloudLoggingOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TASK_LOGS_STORAGE_MODE_UNSPECIFIED")
                }
                Self::CloudLoggingAndCloudStorage => {
                    std::option::Option::Some("CLOUD_LOGGING_AND_CLOUD_STORAGE")
                }
                Self::CloudLoggingOnly => std::option::Option::Some("CLOUD_LOGGING_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TaskLogsStorageMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TaskLogsStorageMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TaskLogsStorageMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudLoggingAndCloudStorage,
                2 => Self::CloudLoggingOnly,
                _ => Self::UnknownValue(task_logs_storage_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TaskLogsStorageMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TASK_LOGS_STORAGE_MODE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_LOGGING_AND_CLOUD_STORAGE" => Self::CloudLoggingAndCloudStorage,
                "CLOUD_LOGGING_ONLY" => Self::CloudLoggingOnly,
                _ => Self::UnknownValue(task_logs_storage_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TaskLogsStorageMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudLoggingAndCloudStorage => serializer.serialize_i32(1),
                Self::CloudLoggingOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TaskLogsStorageMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TaskLogsStorageMode>::new(
                ".google.cloud.orchestration.airflow.service.v1.TaskLogsRetentionConfig.TaskLogsStorageMode"))
        }
    }
}

/// The policy for airflow metadata database retention.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AirflowMetadataRetentionPolicyConfig {
    /// Optional. Retention can be either enabled or disabled.
    pub retention_mode: crate::model::airflow_metadata_retention_policy_config::RetentionMode,

    /// Optional. How many days data should be retained for.
    pub retention_days: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AirflowMetadataRetentionPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retention_mode][crate::model::AirflowMetadataRetentionPolicyConfig::retention_mode].
    pub fn set_retention_mode<
        T: std::convert::Into<crate::model::airflow_metadata_retention_policy_config::RetentionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention_mode = v.into();
        self
    }

    /// Sets the value of [retention_days][crate::model::AirflowMetadataRetentionPolicyConfig::retention_days].
    pub fn set_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_days = v.into();
        self
    }
}

impl wkt::message::Message for AirflowMetadataRetentionPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.AirflowMetadataRetentionPolicyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AirflowMetadataRetentionPolicyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retention_mode,
            __retention_days,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AirflowMetadataRetentionPolicyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retentionMode" => Ok(__FieldTag::__retention_mode),
                            "retention_mode" => Ok(__FieldTag::__retention_mode),
                            "retentionDays" => Ok(__FieldTag::__retention_days),
                            "retention_days" => Ok(__FieldTag::__retention_days),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AirflowMetadataRetentionPolicyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AirflowMetadataRetentionPolicyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retention_mode => {
                            if !fields.insert(__FieldTag::__retention_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_mode",
                                ));
                            }
                            result.retention_mode = map.next_value::<std::option::Option<crate::model::airflow_metadata_retention_policy_config::RetentionMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__retention_days => {
                            if !fields.insert(__FieldTag::__retention_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retention_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AirflowMetadataRetentionPolicyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.retention_mode) {
            state.serialize_entry("retentionMode", &self.retention_mode)?;
        }
        if !wkt::internal::is_default(&self.retention_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retentionDays", &__With(&self.retention_days))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AirflowMetadataRetentionPolicyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AirflowMetadataRetentionPolicyConfig");
        debug_struct.field("retention_mode", &self.retention_mode);
        debug_struct.field("retention_days", &self.retention_days);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AirflowMetadataRetentionPolicyConfig].
pub mod airflow_metadata_retention_policy_config {
    #[allow(unused_imports)]
    use super::*;

    /// Describes retention policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RetentionMode {
        /// Default mode doesn't change environment parameters.
        Unspecified,
        /// Retention policy is enabled.
        Enabled,
        /// Retention policy is disabled.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RetentionMode::value] or
        /// [RetentionMode::name].
        UnknownValue(retention_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod retention_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RetentionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RETENTION_MODE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("RETENTION_MODE_ENABLED"),
                Self::Disabled => std::option::Option::Some("RETENTION_MODE_DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RetentionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RetentionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RetentionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(retention_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RetentionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RETENTION_MODE_UNSPECIFIED" => Self::Unspecified,
                "RETENTION_MODE_ENABLED" => Self::Enabled,
                "RETENTION_MODE_DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(retention_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RetentionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RetentionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RetentionMode>::new(
                ".google.cloud.orchestration.airflow.service.v1.AirflowMetadataRetentionPolicyConfig.RetentionMode"))
        }
    }
}

/// List ImageVersions in a project and location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImageVersionsRequest {
    /// List ImageVersions in the given project and location, in the form:
    /// "projects/{projectId}/locations/{locationId}"
    pub parent: std::string::String,

    /// The maximum number of image_versions to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    /// Whether or not image versions from old releases should be included.
    pub include_past_releases: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImageVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImageVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImageVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImageVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [include_past_releases][crate::model::ListImageVersionsRequest::include_past_releases].
    pub fn set_include_past_releases<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_past_releases = v.into();
        self
    }
}

impl wkt::message::Message for ListImageVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListImageVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImageVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __include_past_releases,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImageVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "includePastReleases" => Ok(__FieldTag::__include_past_releases),
                            "include_past_releases" => Ok(__FieldTag::__include_past_releases),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImageVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImageVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_past_releases => {
                            if !fields.insert(__FieldTag::__include_past_releases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_past_releases",
                                ));
                            }
                            result.include_past_releases = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImageVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.include_past_releases) {
            state.serialize_entry("includePastReleases", &self.include_past_releases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImageVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("include_past_releases", &self.include_past_releases);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The ImageVersions in a project and location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImageVersionsResponse {
    /// The list of supported ImageVersions in a location.
    pub image_versions: std::vec::Vec<crate::model::ImageVersion>,

    /// The page token used to query for the next page if one exists.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImageVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_versions][crate::model::ListImageVersionsResponse::image_versions].
    pub fn set_image_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImageVersion>,
    {
        use std::iter::Iterator;
        self.image_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListImageVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListImageVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ListImageVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListImageVersionsResponse {
    type PageItem = crate::model::ImageVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.image_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImageVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImageVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageVersions" => Ok(__FieldTag::__image_versions),
                            "image_versions" => Ok(__FieldTag::__image_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImageVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImageVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_versions => {
                            if !fields.insert(__FieldTag::__image_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_versions",
                                ));
                            }
                            result.image_versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ImageVersion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImageVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image_versions.is_empty() {
            state.serialize_entry("imageVersions", &self.image_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImageVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageVersionsResponse");
        debug_struct.field("image_versions", &self.image_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ImageVersion information
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageVersion {
    /// The string identifier of the ImageVersion, in the form:
    /// "composer-x.y.z-airflow-a.b.c"
    pub image_version_id: std::string::String,

    /// Whether this is the default ImageVersion used by Composer during
    /// environment creation if no input ImageVersion is specified.
    pub is_default: bool,

    /// supported python versions
    pub supported_python_versions: std::vec::Vec<std::string::String>,

    /// The date of the version release.
    pub release_date: std::option::Option<gtype::model::Date>,

    /// Whether it is impossible to create an environment with the image version.
    pub creation_disabled: bool,

    /// Whether it is impossible to upgrade an environment running with the image
    /// version.
    pub upgrade_disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_version_id][crate::model::ImageVersion::image_version_id].
    pub fn set_image_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.image_version_id = v.into();
        self
    }

    /// Sets the value of [is_default][crate::model::ImageVersion::is_default].
    pub fn set_is_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_default = v.into();
        self
    }

    /// Sets the value of [supported_python_versions][crate::model::ImageVersion::supported_python_versions].
    pub fn set_supported_python_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_python_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [release_date][crate::model::ImageVersion::release_date].
    pub fn set_release_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_date][crate::model::ImageVersion::release_date].
    pub fn set_or_clear_release_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_disabled][crate::model::ImageVersion::creation_disabled].
    pub fn set_creation_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.creation_disabled = v.into();
        self
    }

    /// Sets the value of [upgrade_disabled][crate::model::ImageVersion::upgrade_disabled].
    pub fn set_upgrade_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.upgrade_disabled = v.into();
        self
    }
}

impl wkt::message::Message for ImageVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.ImageVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_version_id,
            __is_default,
            __supported_python_versions,
            __release_date,
            __creation_disabled,
            __upgrade_disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageVersionId" => Ok(__FieldTag::__image_version_id),
                            "image_version_id" => Ok(__FieldTag::__image_version_id),
                            "isDefault" => Ok(__FieldTag::__is_default),
                            "is_default" => Ok(__FieldTag::__is_default),
                            "supportedPythonVersions" => {
                                Ok(__FieldTag::__supported_python_versions)
                            }
                            "supported_python_versions" => {
                                Ok(__FieldTag::__supported_python_versions)
                            }
                            "releaseDate" => Ok(__FieldTag::__release_date),
                            "release_date" => Ok(__FieldTag::__release_date),
                            "creationDisabled" => Ok(__FieldTag::__creation_disabled),
                            "creation_disabled" => Ok(__FieldTag::__creation_disabled),
                            "upgradeDisabled" => Ok(__FieldTag::__upgrade_disabled),
                            "upgrade_disabled" => Ok(__FieldTag::__upgrade_disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_version_id => {
                            if !fields.insert(__FieldTag::__image_version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_version_id",
                                ));
                            }
                            result.image_version_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_default => {
                            if !fields.insert(__FieldTag::__is_default) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_default",
                                ));
                            }
                            result.is_default = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_python_versions => {
                            if !fields.insert(__FieldTag::__supported_python_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_python_versions",
                                ));
                            }
                            result.supported_python_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__release_date => {
                            if !fields.insert(__FieldTag::__release_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_date",
                                ));
                            }
                            result.release_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__creation_disabled => {
                            if !fields.insert(__FieldTag::__creation_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_disabled",
                                ));
                            }
                            result.creation_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_disabled => {
                            if !fields.insert(__FieldTag::__upgrade_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_disabled",
                                ));
                            }
                            result.upgrade_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image_version_id.is_empty() {
            state.serialize_entry("imageVersionId", &self.image_version_id)?;
        }
        if !wkt::internal::is_default(&self.is_default) {
            state.serialize_entry("isDefault", &self.is_default)?;
        }
        if !self.supported_python_versions.is_empty() {
            state.serialize_entry("supportedPythonVersions", &self.supported_python_versions)?;
        }
        if self.release_date.is_some() {
            state.serialize_entry("releaseDate", &self.release_date)?;
        }
        if !wkt::internal::is_default(&self.creation_disabled) {
            state.serialize_entry("creationDisabled", &self.creation_disabled)?;
        }
        if !wkt::internal::is_default(&self.upgrade_disabled) {
            state.serialize_entry("upgradeDisabled", &self.upgrade_disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageVersion");
        debug_struct.field("image_version_id", &self.image_version_id);
        debug_struct.field("is_default", &self.is_default);
        debug_struct.field("supported_python_versions", &self.supported_python_versions);
        debug_struct.field("release_date", &self.release_date);
        debug_struct.field("creation_disabled", &self.creation_disabled);
        debug_struct.field("upgrade_disabled", &self.upgrade_disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata describing an operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The current operation state.
    pub state: crate::model::operation_metadata::State,

    /// Output only. The type of operation being performed.
    pub operation_type: crate::model::operation_metadata::Type,

    /// Output only. The resource being operated on, as a [relative resource name](
    /// /apis/design/resource_names#relative_resource_name).
    pub resource: std::string::String,

    /// Output only. The UUID of the resource being operated on.
    pub resource_uuid: std::string::String,

    /// Output only. The time the operation was submitted to the server.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the operation terminated, regardless of its
    /// success. This field is unset if the operation is still ongoing.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::OperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::OperationMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation_metadata::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::OperationMetadata::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [resource_uuid][crate::model::OperationMetadata::resource_uuid].
    pub fn set_resource_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orchestration.airflow.service.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __operation_type,
            __resource,
            __resource_uuid,
            __create_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "resource" => Ok(__FieldTag::__resource),
                            "resourceUuid" => Ok(__FieldTag::__resource_uuid),
                            "resource_uuid" => Ok(__FieldTag::__resource_uuid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::operation_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map.next_value::<std::option::Option<crate::model::operation_metadata::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uuid => {
                            if !fields.insert(__FieldTag::__resource_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uuid",
                                ));
                            }
                            result.resource_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.resource_uuid.is_empty() {
            state.serialize_entry("resourceUuid", &self.resource_uuid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("resource_uuid", &self.resource_uuid);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// An enum describing the overall state of an operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The operation has been created but is not yet started.
        Pending,
        /// The operation is underway.
        Running,
        /// The operation completed successfully.
        Succeeded,
        Successful,
        /// The operation is no longer running but did not succeed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Successful => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Successful => std::option::Option::Some("SUCCESSFUL"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "SUCCESSFUL" => Self::Successful,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Successful => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.orchestration.airflow.service.v1.OperationMetadata.State",
            ))
        }
    }

    /// Type of longrunning operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unused.
        Unspecified,
        /// A resource creation operation.
        Create,
        /// A resource deletion operation.
        Delete,
        /// A resource update operation.
        Update,
        /// A resource check operation.
        Check,
        /// Saves snapshot of the resource operation.
        SaveSnapshot,
        /// Loads snapshot of the resource operation.
        LoadSnapshot,
        /// Triggers failover of environment's Cloud SQL instance (only for highly
        /// resilient environments).
        DatabaseFailover,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Delete => std::option::Option::Some(2),
                Self::Update => std::option::Option::Some(3),
                Self::Check => std::option::Option::Some(4),
                Self::SaveSnapshot => std::option::Option::Some(5),
                Self::LoadSnapshot => std::option::Option::Some(6),
                Self::DatabaseFailover => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Check => std::option::Option::Some("CHECK"),
                Self::SaveSnapshot => std::option::Option::Some("SAVE_SNAPSHOT"),
                Self::LoadSnapshot => std::option::Option::Some("LOAD_SNAPSHOT"),
                Self::DatabaseFailover => std::option::Option::Some("DATABASE_FAILOVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Delete,
                3 => Self::Update,
                4 => Self::Check,
                5 => Self::SaveSnapshot,
                6 => Self::LoadSnapshot,
                7 => Self::DatabaseFailover,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "DELETE" => Self::Delete,
                "UPDATE" => Self::Update,
                "CHECK" => Self::Check,
                "SAVE_SNAPSHOT" => Self::SaveSnapshot,
                "LOAD_SNAPSHOT" => Self::LoadSnapshot,
                "DATABASE_FAILOVER" => Self::DatabaseFailover,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Delete => serializer.serialize_i32(2),
                Self::Update => serializer.serialize_i32(3),
                Self::Check => serializer.serialize_i32(4),
                Self::SaveSnapshot => serializer.serialize_i32(5),
                Self::LoadSnapshot => serializer.serialize_i32(6),
                Self::DatabaseFailover => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.orchestration.airflow.service.v1.OperationMetadata.Type",
            ))
        }
    }
}
