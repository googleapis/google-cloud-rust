// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __database,
            __display_name,
            __entitlement_id,
            __admin_password,
            __properties,
            __labels,
            __network,
            __cidr,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "database" => Ok(__FieldTag::__database),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "entitlementId" => Ok(__FieldTag::__entitlement_id),
                            "entitlement_id" => Ok(__FieldTag::__entitlement_id),
                            "adminPassword" => Ok(__FieldTag::__admin_password),
                            "admin_password" => Ok(__FieldTag::__admin_password),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            "network" => Ok(__FieldTag::__network),
                            "cidr" => Ok(__FieldTag::__cidr),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entitlement_id => {
                            if !fields.insert(__FieldTag::__entitlement_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement_id",
                                ));
                            }
                            result.entitlement_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admin_password => {
                            if !fields.insert(__FieldTag::__admin_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_password",
                                ));
                            }
                            result.admin_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<crate::model::AutonomousDatabaseProperties>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr => {
                            if !fields.insert(__FieldTag::__cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr",
                                ));
                            }
                            result.cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __compute_count,
            __cpu_core_count,
            __data_storage_size_tb,
            __data_storage_size_gb,
            __db_workload,
            __db_edition,
            __character_set,
            __n_character_set,
            __private_endpoint_ip,
            __private_endpoint_label,
            __db_version,
            __is_auto_scaling_enabled,
            __is_storage_auto_scaling_enabled,
            __license_type,
            __customer_contacts,
            __secret_id,
            __vault_id,
            __maintenance_schedule_type,
            __mtls_connection_required,
            __backup_retention_period_days,
            __actual_used_data_storage_size_tb,
            __allocated_storage_size_tb,
            __apex_details,
            __are_primary_allowlisted_ips_used,
            __lifecycle_details,
            __state,
            __autonomous_container_database_id,
            __available_upgrade_versions,
            __connection_strings,
            __connection_urls,
            __failed_data_recovery_duration,
            __memory_table_gbs,
            __is_local_data_guard_enabled,
            __local_adg_auto_failover_max_data_loss_limit,
            __local_standby_db,
            __memory_per_oracle_compute_unit_gbs,
            __local_disaster_recovery_type,
            __data_safe_state,
            __database_management_state,
            __open_mode,
            __operations_insights_state,
            __peer_db_ids,
            __permission_level,
            __private_endpoint,
            __refreshable_mode,
            __refreshable_state,
            __role,
            __scheduled_operation_details,
            __sql_web_developer_url,
            __supported_clone_regions,
            __used_data_storage_size_tbs,
            __oci_url,
            __total_auto_backup_storage_size_gbs,
            __next_long_term_backup_time,
            __maintenance_begin_time,
            __maintenance_end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "computeCount" => Ok(__FieldTag::__compute_count),
                            "compute_count" => Ok(__FieldTag::__compute_count),
                            "cpuCoreCount" => Ok(__FieldTag::__cpu_core_count),
                            "cpu_core_count" => Ok(__FieldTag::__cpu_core_count),
                            "dataStorageSizeTb" => Ok(__FieldTag::__data_storage_size_tb),
                            "data_storage_size_tb" => Ok(__FieldTag::__data_storage_size_tb),
                            "dataStorageSizeGb" => Ok(__FieldTag::__data_storage_size_gb),
                            "data_storage_size_gb" => Ok(__FieldTag::__data_storage_size_gb),
                            "dbWorkload" => Ok(__FieldTag::__db_workload),
                            "db_workload" => Ok(__FieldTag::__db_workload),
                            "dbEdition" => Ok(__FieldTag::__db_edition),
                            "db_edition" => Ok(__FieldTag::__db_edition),
                            "characterSet" => Ok(__FieldTag::__character_set),
                            "character_set" => Ok(__FieldTag::__character_set),
                            "nCharacterSet" => Ok(__FieldTag::__n_character_set),
                            "n_character_set" => Ok(__FieldTag::__n_character_set),
                            "privateEndpointIp" => Ok(__FieldTag::__private_endpoint_ip),
                            "private_endpoint_ip" => Ok(__FieldTag::__private_endpoint_ip),
                            "privateEndpointLabel" => Ok(__FieldTag::__private_endpoint_label),
                            "private_endpoint_label" => Ok(__FieldTag::__private_endpoint_label),
                            "dbVersion" => Ok(__FieldTag::__db_version),
                            "db_version" => Ok(__FieldTag::__db_version),
                            "isAutoScalingEnabled" => Ok(__FieldTag::__is_auto_scaling_enabled),
                            "is_auto_scaling_enabled" => Ok(__FieldTag::__is_auto_scaling_enabled),
                            "isStorageAutoScalingEnabled" => {
                                Ok(__FieldTag::__is_storage_auto_scaling_enabled)
                            }
                            "is_storage_auto_scaling_enabled" => {
                                Ok(__FieldTag::__is_storage_auto_scaling_enabled)
                            }
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "customerContacts" => Ok(__FieldTag::__customer_contacts),
                            "customer_contacts" => Ok(__FieldTag::__customer_contacts),
                            "secretId" => Ok(__FieldTag::__secret_id),
                            "secret_id" => Ok(__FieldTag::__secret_id),
                            "vaultId" => Ok(__FieldTag::__vault_id),
                            "vault_id" => Ok(__FieldTag::__vault_id),
                            "maintenanceScheduleType" => {
                                Ok(__FieldTag::__maintenance_schedule_type)
                            }
                            "maintenance_schedule_type" => {
                                Ok(__FieldTag::__maintenance_schedule_type)
                            }
                            "mtlsConnectionRequired" => Ok(__FieldTag::__mtls_connection_required),
                            "mtls_connection_required" => {
                                Ok(__FieldTag::__mtls_connection_required)
                            }
                            "backupRetentionPeriodDays" => {
                                Ok(__FieldTag::__backup_retention_period_days)
                            }
                            "backup_retention_period_days" => {
                                Ok(__FieldTag::__backup_retention_period_days)
                            }
                            "actualUsedDataStorageSizeTb" => {
                                Ok(__FieldTag::__actual_used_data_storage_size_tb)
                            }
                            "actual_used_data_storage_size_tb" => {
                                Ok(__FieldTag::__actual_used_data_storage_size_tb)
                            }
                            "allocatedStorageSizeTb" => Ok(__FieldTag::__allocated_storage_size_tb),
                            "allocated_storage_size_tb" => {
                                Ok(__FieldTag::__allocated_storage_size_tb)
                            }
                            "apexDetails" => Ok(__FieldTag::__apex_details),
                            "apex_details" => Ok(__FieldTag::__apex_details),
                            "arePrimaryAllowlistedIpsUsed" => {
                                Ok(__FieldTag::__are_primary_allowlisted_ips_used)
                            }
                            "are_primary_allowlisted_ips_used" => {
                                Ok(__FieldTag::__are_primary_allowlisted_ips_used)
                            }
                            "lifecycleDetails" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycle_details" => Ok(__FieldTag::__lifecycle_details),
                            "state" => Ok(__FieldTag::__state),
                            "autonomousContainerDatabaseId" => {
                                Ok(__FieldTag::__autonomous_container_database_id)
                            }
                            "autonomous_container_database_id" => {
                                Ok(__FieldTag::__autonomous_container_database_id)
                            }
                            "availableUpgradeVersions" => {
                                Ok(__FieldTag::__available_upgrade_versions)
                            }
                            "available_upgrade_versions" => {
                                Ok(__FieldTag::__available_upgrade_versions)
                            }
                            "connectionStrings" => Ok(__FieldTag::__connection_strings),
                            "connection_strings" => Ok(__FieldTag::__connection_strings),
                            "connectionUrls" => Ok(__FieldTag::__connection_urls),
                            "connection_urls" => Ok(__FieldTag::__connection_urls),
                            "failedDataRecoveryDuration" => {
                                Ok(__FieldTag::__failed_data_recovery_duration)
                            }
                            "failed_data_recovery_duration" => {
                                Ok(__FieldTag::__failed_data_recovery_duration)
                            }
                            "memoryTableGbs" => Ok(__FieldTag::__memory_table_gbs),
                            "memory_table_gbs" => Ok(__FieldTag::__memory_table_gbs),
                            "isLocalDataGuardEnabled" => {
                                Ok(__FieldTag::__is_local_data_guard_enabled)
                            }
                            "is_local_data_guard_enabled" => {
                                Ok(__FieldTag::__is_local_data_guard_enabled)
                            }
                            "localAdgAutoFailoverMaxDataLossLimit" => {
                                Ok(__FieldTag::__local_adg_auto_failover_max_data_loss_limit)
                            }
                            "local_adg_auto_failover_max_data_loss_limit" => {
                                Ok(__FieldTag::__local_adg_auto_failover_max_data_loss_limit)
                            }
                            "localStandbyDb" => Ok(__FieldTag::__local_standby_db),
                            "local_standby_db" => Ok(__FieldTag::__local_standby_db),
                            "memoryPerOracleComputeUnitGbs" => {
                                Ok(__FieldTag::__memory_per_oracle_compute_unit_gbs)
                            }
                            "memory_per_oracle_compute_unit_gbs" => {
                                Ok(__FieldTag::__memory_per_oracle_compute_unit_gbs)
                            }
                            "localDisasterRecoveryType" => {
                                Ok(__FieldTag::__local_disaster_recovery_type)
                            }
                            "local_disaster_recovery_type" => {
                                Ok(__FieldTag::__local_disaster_recovery_type)
                            }
                            "dataSafeState" => Ok(__FieldTag::__data_safe_state),
                            "data_safe_state" => Ok(__FieldTag::__data_safe_state),
                            "databaseManagementState" => {
                                Ok(__FieldTag::__database_management_state)
                            }
                            "database_management_state" => {
                                Ok(__FieldTag::__database_management_state)
                            }
                            "openMode" => Ok(__FieldTag::__open_mode),
                            "open_mode" => Ok(__FieldTag::__open_mode),
                            "operationsInsightsState" => {
                                Ok(__FieldTag::__operations_insights_state)
                            }
                            "operations_insights_state" => {
                                Ok(__FieldTag::__operations_insights_state)
                            }
                            "peerDbIds" => Ok(__FieldTag::__peer_db_ids),
                            "peer_db_ids" => Ok(__FieldTag::__peer_db_ids),
                            "permissionLevel" => Ok(__FieldTag::__permission_level),
                            "permission_level" => Ok(__FieldTag::__permission_level),
                            "privateEndpoint" => Ok(__FieldTag::__private_endpoint),
                            "private_endpoint" => Ok(__FieldTag::__private_endpoint),
                            "refreshableMode" => Ok(__FieldTag::__refreshable_mode),
                            "refreshable_mode" => Ok(__FieldTag::__refreshable_mode),
                            "refreshableState" => Ok(__FieldTag::__refreshable_state),
                            "refreshable_state" => Ok(__FieldTag::__refreshable_state),
                            "role" => Ok(__FieldTag::__role),
                            "scheduledOperationDetails" => {
                                Ok(__FieldTag::__scheduled_operation_details)
                            }
                            "scheduled_operation_details" => {
                                Ok(__FieldTag::__scheduled_operation_details)
                            }
                            "sqlWebDeveloperUrl" => Ok(__FieldTag::__sql_web_developer_url),
                            "sql_web_developer_url" => Ok(__FieldTag::__sql_web_developer_url),
                            "supportedCloneRegions" => Ok(__FieldTag::__supported_clone_regions),
                            "supported_clone_regions" => Ok(__FieldTag::__supported_clone_regions),
                            "usedDataStorageSizeTbs" => {
                                Ok(__FieldTag::__used_data_storage_size_tbs)
                            }
                            "used_data_storage_size_tbs" => {
                                Ok(__FieldTag::__used_data_storage_size_tbs)
                            }
                            "ociUrl" => Ok(__FieldTag::__oci_url),
                            "oci_url" => Ok(__FieldTag::__oci_url),
                            "totalAutoBackupStorageSizeGbs" => {
                                Ok(__FieldTag::__total_auto_backup_storage_size_gbs)
                            }
                            "total_auto_backup_storage_size_gbs" => {
                                Ok(__FieldTag::__total_auto_backup_storage_size_gbs)
                            }
                            "nextLongTermBackupTime" => {
                                Ok(__FieldTag::__next_long_term_backup_time)
                            }
                            "next_long_term_backup_time" => {
                                Ok(__FieldTag::__next_long_term_backup_time)
                            }
                            "maintenanceBeginTime" => Ok(__FieldTag::__maintenance_begin_time),
                            "maintenance_begin_time" => Ok(__FieldTag::__maintenance_begin_time),
                            "maintenanceEndTime" => Ok(__FieldTag::__maintenance_end_time),
                            "maintenance_end_time" => Ok(__FieldTag::__maintenance_end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_count => {
                            if !fields.insert(__FieldTag::__compute_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_count",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cpu_core_count => {
                            if !fields.insert(__FieldTag::__cpu_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_gb => {
                            if !fields.insert(__FieldTag::__data_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_workload => {
                            if !fields.insert(__FieldTag::__db_workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_workload",
                                ));
                            }
                            result.db_workload = map
                                .next_value::<std::option::Option<crate::model::DBWorkload>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_edition => {
                            if !fields.insert(__FieldTag::__db_edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_edition",
                                ));
                            }
                            result.db_edition = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::DatabaseEdition,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__character_set => {
                            if !fields.insert(__FieldTag::__character_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character_set",
                                ));
                            }
                            result.character_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__n_character_set => {
                            if !fields.insert(__FieldTag::__n_character_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for n_character_set",
                                ));
                            }
                            result.n_character_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint_ip => {
                            if !fields.insert(__FieldTag::__private_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_ip",
                                ));
                            }
                            result.private_endpoint_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint_label => {
                            if !fields.insert(__FieldTag::__private_endpoint_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_label",
                                ));
                            }
                            result.private_endpoint_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_version => {
                            if !fields.insert(__FieldTag::__db_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_version",
                                ));
                            }
                            result.db_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_auto_scaling_enabled => {
                            if !fields.insert(__FieldTag::__is_auto_scaling_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_auto_scaling_enabled",
                                ));
                            }
                            result.is_auto_scaling_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_storage_auto_scaling_enabled => {
                            if !fields.insert(__FieldTag::__is_storage_auto_scaling_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_storage_auto_scaling_enabled",
                                ));
                            }
                            result.is_storage_auto_scaling_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::LicenseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customer_contacts => {
                            if !fields.insert(__FieldTag::__customer_contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_contacts",
                                ));
                            }
                            result.customer_contacts =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomerContact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_id => {
                            if !fields.insert(__FieldTag::__secret_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_id",
                                ));
                            }
                            result.secret_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vault_id => {
                            if !fields.insert(__FieldTag::__vault_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vault_id",
                                ));
                            }
                            result.vault_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_schedule_type => {
                            if !fields.insert(__FieldTag::__maintenance_schedule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_schedule_type",
                                ));
                            }
                            result.maintenance_schedule_type = map.next_value::<std::option::Option<crate::model::autonomous_database_properties::MaintenanceScheduleType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mtls_connection_required => {
                            if !fields.insert(__FieldTag::__mtls_connection_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mtls_connection_required",
                                ));
                            }
                            result.mtls_connection_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_retention_period_days => {
                            if !fields.insert(__FieldTag::__backup_retention_period_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_retention_period_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_retention_period_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__actual_used_data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__actual_used_data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actual_used_data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.actual_used_data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__allocated_storage_size_tb => {
                            if !fields.insert(__FieldTag::__allocated_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocated_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.allocated_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__apex_details => {
                            if !fields.insert(__FieldTag::__apex_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apex_details",
                                ));
                            }
                            result.apex_details = map.next_value::<std::option::Option<crate::model::AutonomousDatabaseApex>>()?
                                ;
                        }
                        __FieldTag::__are_primary_allowlisted_ips_used => {
                            if !fields.insert(__FieldTag::__are_primary_allowlisted_ips_used) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for are_primary_allowlisted_ips_used",
                                ));
                            }
                            result.are_primary_allowlisted_ips_used =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__lifecycle_details => {
                            if !fields.insert(__FieldTag::__lifecycle_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_details",
                                ));
                            }
                            result.lifecycle_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_container_database_id => {
                            if !fields.insert(__FieldTag::__autonomous_container_database_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_container_database_id",
                                ));
                            }
                            result.autonomous_container_database_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_upgrade_versions => {
                            if !fields.insert(__FieldTag::__available_upgrade_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_upgrade_versions",
                                ));
                            }
                            result.available_upgrade_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__connection_strings => {
                            if !fields.insert(__FieldTag::__connection_strings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_strings",
                                ));
                            }
                            result.connection_strings = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseConnectionStrings,
                            >>()?;
                        }
                        __FieldTag::__connection_urls => {
                            if !fields.insert(__FieldTag::__connection_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_urls",
                                ));
                            }
                            result.connection_urls = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseConnectionUrls,
                            >>()?;
                        }
                        __FieldTag::__failed_data_recovery_duration => {
                            if !fields.insert(__FieldTag::__failed_data_recovery_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_data_recovery_duration",
                                ));
                            }
                            result.failed_data_recovery_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__memory_table_gbs => {
                            if !fields.insert(__FieldTag::__memory_table_gbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_table_gbs",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_table_gbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__is_local_data_guard_enabled => {
                            if !fields.insert(__FieldTag::__is_local_data_guard_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_local_data_guard_enabled",
                                ));
                            }
                            result.is_local_data_guard_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_adg_auto_failover_max_data_loss_limit => {
                            if !fields
                                .insert(__FieldTag::__local_adg_auto_failover_max_data_loss_limit)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_adg_auto_failover_max_data_loss_limit",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_adg_auto_failover_max_data_loss_limit =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__local_standby_db => {
                            if !fields.insert(__FieldTag::__local_standby_db) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_standby_db",
                                ));
                            }
                            result.local_standby_db = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseStandbySummary,
                            >>()?;
                        }
                        __FieldTag::__memory_per_oracle_compute_unit_gbs => {
                            if !fields.insert(__FieldTag::__memory_per_oracle_compute_unit_gbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_per_oracle_compute_unit_gbs",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_per_oracle_compute_unit_gbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__local_disaster_recovery_type => {
                            if !fields.insert(__FieldTag::__local_disaster_recovery_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_disaster_recovery_type",
                                ));
                            }
                            result.local_disaster_recovery_type = map.next_value::<std::option::Option<crate::model::autonomous_database_properties::LocalDisasterRecoveryType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_safe_state => {
                            if !fields.insert(__FieldTag::__data_safe_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_safe_state",
                                ));
                            }
                            result.data_safe_state = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::DataSafeState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_management_state => {
                            if !fields.insert(__FieldTag::__database_management_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_management_state",
                                ));
                            }
                            result.database_management_state = map.next_value::<std::option::Option<crate::model::autonomous_database_properties::DatabaseManagementState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__open_mode => {
                            if !fields.insert(__FieldTag::__open_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for open_mode",
                                ));
                            }
                            result.open_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::OpenMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operations_insights_state => {
                            if !fields.insert(__FieldTag::__operations_insights_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations_insights_state",
                                ));
                            }
                            result.operations_insights_state = map.next_value::<std::option::Option<crate::model::OperationsInsightsState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__peer_db_ids => {
                            if !fields.insert(__FieldTag::__peer_db_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_db_ids",
                                ));
                            }
                            result.peer_db_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__permission_level => {
                            if !fields.insert(__FieldTag::__permission_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permission_level",
                                ));
                            }
                            result.permission_level = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::PermissionLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint => {
                            if !fields.insert(__FieldTag::__private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint",
                                ));
                            }
                            result.private_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__refreshable_mode => {
                            if !fields.insert(__FieldTag::__refreshable_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refreshable_mode",
                                ));
                            }
                            result.refreshable_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::RefreshableMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__refreshable_state => {
                            if !fields.insert(__FieldTag::__refreshable_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refreshable_state",
                                ));
                            }
                            result.refreshable_state = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::RefreshableState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::Role,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduled_operation_details => {
                            if !fields.insert(__FieldTag::__scheduled_operation_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduled_operation_details",
                                ));
                            }
                            result.scheduled_operation_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ScheduledOperationDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_web_developer_url => {
                            if !fields.insert(__FieldTag::__sql_web_developer_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_web_developer_url",
                                ));
                            }
                            result.sql_web_developer_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_clone_regions => {
                            if !fields.insert(__FieldTag::__supported_clone_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_clone_regions",
                                ));
                            }
                            result.supported_clone_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__used_data_storage_size_tbs => {
                            if !fields.insert(__FieldTag::__used_data_storage_size_tbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_data_storage_size_tbs",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.used_data_storage_size_tbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oci_url => {
                            if !fields.insert(__FieldTag::__oci_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oci_url",
                                ));
                            }
                            result.oci_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_auto_backup_storage_size_gbs => {
                            if !fields.insert(__FieldTag::__total_auto_backup_storage_size_gbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_auto_backup_storage_size_gbs",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_auto_backup_storage_size_gbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__next_long_term_backup_time => {
                            if !fields.insert(__FieldTag::__next_long_term_backup_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_long_term_backup_time",
                                ));
                            }
                            result.next_long_term_backup_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__maintenance_begin_time => {
                            if !fields.insert(__FieldTag::__maintenance_begin_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_begin_time",
                                ));
                            }
                            result.maintenance_begin_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__maintenance_end_time => {
                            if !fields.insert(__FieldTag::__maintenance_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_end_time",
                                ));
                            }
                            result.maintenance_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseApex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __apex_version,
            __ords_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseApex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apexVersion" => Ok(__FieldTag::__apex_version),
                            "apex_version" => Ok(__FieldTag::__apex_version),
                            "ordsVersion" => Ok(__FieldTag::__ords_version),
                            "ords_version" => Ok(__FieldTag::__ords_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseApex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseApex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__apex_version => {
                            if !fields.insert(__FieldTag::__apex_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apex_version",
                                ));
                            }
                            result.apex_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ords_version => {
                            if !fields.insert(__FieldTag::__ords_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ords_version",
                                ));
                            }
                            result.ords_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseConnectionStrings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all_connection_strings,
            __dedicated,
            __high,
            __low,
            __medium,
            __profiles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseConnectionStrings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allConnectionStrings" => Ok(__FieldTag::__all_connection_strings),
                            "all_connection_strings" => Ok(__FieldTag::__all_connection_strings),
                            "dedicated" => Ok(__FieldTag::__dedicated),
                            "high" => Ok(__FieldTag::__high),
                            "low" => Ok(__FieldTag::__low),
                            "medium" => Ok(__FieldTag::__medium),
                            "profiles" => Ok(__FieldTag::__profiles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseConnectionStrings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseConnectionStrings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all_connection_strings => {
                            if !fields.insert(__FieldTag::__all_connection_strings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_connection_strings",
                                ));
                            }
                            result.all_connection_strings = map.next_value::<std::option::Option<crate::model::AllConnectionStrings>>()?
                                ;
                        }
                        __FieldTag::__dedicated => {
                            if !fields.insert(__FieldTag::__dedicated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dedicated",
                                ));
                            }
                            result.dedicated = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__high => {
                            if !fields.insert(__FieldTag::__high) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for high",
                                ));
                            }
                            result.high = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__low => {
                            if !fields.insert(__FieldTag::__low) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for low",
                                ));
                            }
                            result.low = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__medium => {
                            if !fields.insert(__FieldTag::__medium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for medium",
                                ));
                            }
                            result.medium = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__profiles => {
                            if !fields.insert(__FieldTag::__profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profiles",
                                ));
                            }
                            result.profiles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatabaseConnectionStringProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DatabaseConnectionStringProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consumer_group,
            __display_name,
            __host_format,
            __is_regional,
            __protocol,
            __session_mode,
            __syntax_format,
            __tls_authentication,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseConnectionStringProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consumerGroup" => Ok(__FieldTag::__consumer_group),
                            "consumer_group" => Ok(__FieldTag::__consumer_group),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "hostFormat" => Ok(__FieldTag::__host_format),
                            "host_format" => Ok(__FieldTag::__host_format),
                            "isRegional" => Ok(__FieldTag::__is_regional),
                            "is_regional" => Ok(__FieldTag::__is_regional),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "sessionMode" => Ok(__FieldTag::__session_mode),
                            "session_mode" => Ok(__FieldTag::__session_mode),
                            "syntaxFormat" => Ok(__FieldTag::__syntax_format),
                            "syntax_format" => Ok(__FieldTag::__syntax_format),
                            "tlsAuthentication" => Ok(__FieldTag::__tls_authentication),
                            "tls_authentication" => Ok(__FieldTag::__tls_authentication),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DatabaseConnectionStringProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseConnectionStringProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consumer_group => {
                            if !fields.insert(__FieldTag::__consumer_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumer_group",
                                ));
                            }
                            result.consumer_group = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::ConsumerGroup,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_format => {
                            if !fields.insert(__FieldTag::__host_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_format",
                                ));
                            }
                            result.host_format = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::HostFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_regional => {
                            if !fields.insert(__FieldTag::__is_regional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_regional",
                                ));
                            }
                            result.is_regional = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::Protocol,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_mode => {
                            if !fields.insert(__FieldTag::__session_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_mode",
                                ));
                            }
                            result.session_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::SessionMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__syntax_format => {
                            if !fields.insert(__FieldTag::__syntax_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for syntax_format",
                                ));
                            }
                            result.syntax_format = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::SyntaxFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tls_authentication => {
                            if !fields.insert(__FieldTag::__tls_authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tls_authentication",
                                ));
                            }
                            result.tls_authentication = map.next_value::<std::option::Option<crate::model::database_connection_string_profile::TLSAuthentication>>()?.unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AllConnectionStrings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __high,
            __low,
            __medium,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllConnectionStrings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "high" => Ok(__FieldTag::__high),
                            "low" => Ok(__FieldTag::__low),
                            "medium" => Ok(__FieldTag::__medium),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AllConnectionStrings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllConnectionStrings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__high => {
                            if !fields.insert(__FieldTag::__high) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for high",
                                ));
                            }
                            result.high = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__low => {
                            if !fields.insert(__FieldTag::__low) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for low",
                                ));
                            }
                            result.low = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__medium => {
                            if !fields.insert(__FieldTag::__medium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for medium",
                                ));
                            }
                            result.medium = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseConnectionUrls {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __apex_uri,
            __database_transforms_uri,
            __graph_studio_uri,
            __machine_learning_notebook_uri,
            __machine_learning_user_management_uri,
            __mongo_db_uri,
            __ords_uri,
            __sql_dev_web_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseConnectionUrls")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apexUri" => Ok(__FieldTag::__apex_uri),
                            "apex_uri" => Ok(__FieldTag::__apex_uri),
                            "databaseTransformsUri" => Ok(__FieldTag::__database_transforms_uri),
                            "database_transforms_uri" => Ok(__FieldTag::__database_transforms_uri),
                            "graphStudioUri" => Ok(__FieldTag::__graph_studio_uri),
                            "graph_studio_uri" => Ok(__FieldTag::__graph_studio_uri),
                            "machineLearningNotebookUri" => {
                                Ok(__FieldTag::__machine_learning_notebook_uri)
                            }
                            "machine_learning_notebook_uri" => {
                                Ok(__FieldTag::__machine_learning_notebook_uri)
                            }
                            "machineLearningUserManagementUri" => {
                                Ok(__FieldTag::__machine_learning_user_management_uri)
                            }
                            "machine_learning_user_management_uri" => {
                                Ok(__FieldTag::__machine_learning_user_management_uri)
                            }
                            "mongoDbUri" => Ok(__FieldTag::__mongo_db_uri),
                            "mongo_db_uri" => Ok(__FieldTag::__mongo_db_uri),
                            "ordsUri" => Ok(__FieldTag::__ords_uri),
                            "ords_uri" => Ok(__FieldTag::__ords_uri),
                            "sqlDevWebUri" => Ok(__FieldTag::__sql_dev_web_uri),
                            "sql_dev_web_uri" => Ok(__FieldTag::__sql_dev_web_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseConnectionUrls;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseConnectionUrls")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__apex_uri => {
                            if !fields.insert(__FieldTag::__apex_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apex_uri",
                                ));
                            }
                            result.apex_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_transforms_uri => {
                            if !fields.insert(__FieldTag::__database_transforms_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_transforms_uri",
                                ));
                            }
                            result.database_transforms_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__graph_studio_uri => {
                            if !fields.insert(__FieldTag::__graph_studio_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for graph_studio_uri",
                                ));
                            }
                            result.graph_studio_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_learning_notebook_uri => {
                            if !fields.insert(__FieldTag::__machine_learning_notebook_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_learning_notebook_uri",
                                ));
                            }
                            result.machine_learning_notebook_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_learning_user_management_uri => {
                            if !fields.insert(__FieldTag::__machine_learning_user_management_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_learning_user_management_uri",
                                ));
                            }
                            result.machine_learning_user_management_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mongo_db_uri => {
                            if !fields.insert(__FieldTag::__mongo_db_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mongo_db_uri",
                                ));
                            }
                            result.mongo_db_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ords_uri => {
                            if !fields.insert(__FieldTag::__ords_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ords_uri",
                                ));
                            }
                            result.ords_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_dev_web_uri => {
                            if !fields.insert(__FieldTag::__sql_dev_web_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_dev_web_uri",
                                ));
                            }
                            result.sql_dev_web_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseStandbySummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lag_time_duration,
            __lifecycle_details,
            __state,
            __data_guard_role_changed_time,
            __disaster_recovery_role_changed_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseStandbySummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lagTimeDuration" => Ok(__FieldTag::__lag_time_duration),
                            "lag_time_duration" => Ok(__FieldTag::__lag_time_duration),
                            "lifecycleDetails" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycle_details" => Ok(__FieldTag::__lifecycle_details),
                            "state" => Ok(__FieldTag::__state),
                            "dataGuardRoleChangedTime" => {
                                Ok(__FieldTag::__data_guard_role_changed_time)
                            }
                            "data_guard_role_changed_time" => {
                                Ok(__FieldTag::__data_guard_role_changed_time)
                            }
                            "disasterRecoveryRoleChangedTime" => {
                                Ok(__FieldTag::__disaster_recovery_role_changed_time)
                            }
                            "disaster_recovery_role_changed_time" => {
                                Ok(__FieldTag::__disaster_recovery_role_changed_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseStandbySummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseStandbySummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lag_time_duration => {
                            if !fields.insert(__FieldTag::__lag_time_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lag_time_duration",
                                ));
                            }
                            result.lag_time_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__lifecycle_details => {
                            if !fields.insert(__FieldTag::__lifecycle_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_details",
                                ));
                            }
                            result.lifecycle_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_guard_role_changed_time => {
                            if !fields.insert(__FieldTag::__data_guard_role_changed_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_guard_role_changed_time",
                                ));
                            }
                            result.data_guard_role_changed_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__disaster_recovery_role_changed_time => {
                            if !fields.insert(__FieldTag::__disaster_recovery_role_changed_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disaster_recovery_role_changed_time",
                                ));
                            }
                            result.disaster_recovery_role_changed_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ScheduledOperationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __day_of_week,
            __start_time,
            __stop_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScheduledOperationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "stopTime" => Ok(__FieldTag::__stop_time),
                            "stop_time" => Ok(__FieldTag::__stop_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ScheduledOperationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScheduledOperationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__stop_time => {
                            if !fields.insert(__FieldTag::__stop_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stop_time",
                                ));
                            }
                            result.stop_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseCharacterSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __character_set_type,
            __character_set,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseCharacterSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "characterSetType" => Ok(__FieldTag::__character_set_type),
                            "character_set_type" => Ok(__FieldTag::__character_set_type),
                            "characterSet" => Ok(__FieldTag::__character_set),
                            "character_set" => Ok(__FieldTag::__character_set),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseCharacterSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseCharacterSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__character_set_type => {
                            if !fields.insert(__FieldTag::__character_set_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character_set_type",
                                ));
                            }
                            result.character_set_type = map.next_value::<std::option::Option<crate::model::autonomous_database_character_set::CharacterSetType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__character_set => {
                            if !fields.insert(__FieldTag::__character_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character_set",
                                ));
                            }
                            result.character_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseBackup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __autonomous_database,
            __display_name,
            __properties,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseBackup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "autonomousDatabase" => Ok(__FieldTag::__autonomous_database),
                            "autonomous_database" => Ok(__FieldTag::__autonomous_database),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseBackup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseBackup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_database => {
                            if !fields.insert(__FieldTag::__autonomous_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database",
                                ));
                            }
                            result.autonomous_database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseBackupProperties,
                            >>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDatabaseBackupProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __retention_period_days,
            __compartment_id,
            __database_size_tb,
            __db_version,
            __is_long_term_backup,
            __is_automatic_backup,
            __is_restorable,
            __key_store_id,
            __key_store_wallet,
            __kms_key_id,
            __kms_key_version_id,
            __lifecycle_details,
            __lifecycle_state,
            __size_tb,
            __available_till_time,
            __end_time,
            __start_time,
            __type,
            __vault_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseBackupProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "retentionPeriodDays" => Ok(__FieldTag::__retention_period_days),
                            "retention_period_days" => Ok(__FieldTag::__retention_period_days),
                            "compartmentId" => Ok(__FieldTag::__compartment_id),
                            "compartment_id" => Ok(__FieldTag::__compartment_id),
                            "databaseSizeTb" => Ok(__FieldTag::__database_size_tb),
                            "database_size_tb" => Ok(__FieldTag::__database_size_tb),
                            "dbVersion" => Ok(__FieldTag::__db_version),
                            "db_version" => Ok(__FieldTag::__db_version),
                            "isLongTermBackup" => Ok(__FieldTag::__is_long_term_backup),
                            "is_long_term_backup" => Ok(__FieldTag::__is_long_term_backup),
                            "isAutomaticBackup" => Ok(__FieldTag::__is_automatic_backup),
                            "is_automatic_backup" => Ok(__FieldTag::__is_automatic_backup),
                            "isRestorable" => Ok(__FieldTag::__is_restorable),
                            "is_restorable" => Ok(__FieldTag::__is_restorable),
                            "keyStoreId" => Ok(__FieldTag::__key_store_id),
                            "key_store_id" => Ok(__FieldTag::__key_store_id),
                            "keyStoreWallet" => Ok(__FieldTag::__key_store_wallet),
                            "key_store_wallet" => Ok(__FieldTag::__key_store_wallet),
                            "kmsKeyId" => Ok(__FieldTag::__kms_key_id),
                            "kms_key_id" => Ok(__FieldTag::__kms_key_id),
                            "kmsKeyVersionId" => Ok(__FieldTag::__kms_key_version_id),
                            "kms_key_version_id" => Ok(__FieldTag::__kms_key_version_id),
                            "lifecycleDetails" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycle_details" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycleState" => Ok(__FieldTag::__lifecycle_state),
                            "lifecycle_state" => Ok(__FieldTag::__lifecycle_state),
                            "sizeTb" => Ok(__FieldTag::__size_tb),
                            "size_tb" => Ok(__FieldTag::__size_tb),
                            "availableTillTime" => Ok(__FieldTag::__available_till_time),
                            "available_till_time" => Ok(__FieldTag::__available_till_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "type" => Ok(__FieldTag::__type),
                            "vaultId" => Ok(__FieldTag::__vault_id),
                            "vault_id" => Ok(__FieldTag::__vault_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDatabaseBackupProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseBackupProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention_period_days => {
                            if !fields.insert(__FieldTag::__retention_period_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_period_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retention_period_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__compartment_id => {
                            if !fields.insert(__FieldTag::__compartment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compartment_id",
                                ));
                            }
                            result.compartment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_size_tb => {
                            if !fields.insert(__FieldTag::__database_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.database_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_version => {
                            if !fields.insert(__FieldTag::__db_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_version",
                                ));
                            }
                            result.db_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_long_term_backup => {
                            if !fields.insert(__FieldTag::__is_long_term_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_long_term_backup",
                                ));
                            }
                            result.is_long_term_backup = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_automatic_backup => {
                            if !fields.insert(__FieldTag::__is_automatic_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_automatic_backup",
                                ));
                            }
                            result.is_automatic_backup = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_restorable => {
                            if !fields.insert(__FieldTag::__is_restorable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_restorable",
                                ));
                            }
                            result.is_restorable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_store_id => {
                            if !fields.insert(__FieldTag::__key_store_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_store_id",
                                ));
                            }
                            result.key_store_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_store_wallet => {
                            if !fields.insert(__FieldTag::__key_store_wallet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_store_wallet",
                                ));
                            }
                            result.key_store_wallet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_id => {
                            if !fields.insert(__FieldTag::__kms_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_id",
                                ));
                            }
                            result.kms_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_id => {
                            if !fields.insert(__FieldTag::__kms_key_version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_id",
                                ));
                            }
                            result.kms_key_version_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifecycle_details => {
                            if !fields.insert(__FieldTag::__lifecycle_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_details",
                                ));
                            }
                            result.lifecycle_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifecycle_state => {
                            if !fields.insert(__FieldTag::__lifecycle_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_state",
                                ));
                            }
                            result.lifecycle_state = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_backup_properties::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_tb => {
                            if !fields.insert(__FieldTag::__size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_tb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_till_time => {
                            if !fields.insert(__FieldTag::__available_till_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_till_time",
                                ));
                            }
                            result.available_till_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_backup_properties::Type,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vault_id => {
                            if !fields.insert(__FieldTag::__vault_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vault_id",
                                ));
                            }
                            result.vault_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutonomousDbVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __db_workload,
            __workload_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDbVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "dbWorkload" => Ok(__FieldTag::__db_workload),
                            "db_workload" => Ok(__FieldTag::__db_workload),
                            "workloadUri" => Ok(__FieldTag::__workload_uri),
                            "workload_uri" => Ok(__FieldTag::__workload_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutonomousDbVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDbVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_workload => {
                            if !fields.insert(__FieldTag::__db_workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_workload",
                                ));
                            }
                            result.db_workload = map
                                .next_value::<std::option::Option<crate::model::DBWorkload>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_uri => {
                            if !fields.insert(__FieldTag::__workload_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_uri",
                                ));
                            }
                            result.workload_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CustomerContact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerContact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CustomerContact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerContact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DbNode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbNode")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "properties" => Ok(__FieldTag::__properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DbNode;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbNode")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<crate::model::DbNodeProperties>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DbNodeProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __ocpu_count,
            __memory_size_gb,
            __db_node_storage_size_gb,
            __db_server_ocid,
            __hostname,
            __state,
            __total_cpu_core_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbNodeProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "ocpuCount" => Ok(__FieldTag::__ocpu_count),
                            "ocpu_count" => Ok(__FieldTag::__ocpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "dbServerOcid" => Ok(__FieldTag::__db_server_ocid),
                            "db_server_ocid" => Ok(__FieldTag::__db_server_ocid),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "state" => Ok(__FieldTag::__state),
                            "totalCpuCoreCount" => Ok(__FieldTag::__total_cpu_core_count),
                            "total_cpu_core_count" => Ok(__FieldTag::__total_cpu_core_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DbNodeProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbNodeProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ocpu_count => {
                            if !fields.insert(__FieldTag::__ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ocpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_server_ocid => {
                            if !fields.insert(__FieldTag::__db_server_ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_server_ocid",
                                ));
                            }
                            result.db_server_ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::db_node_properties::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__total_cpu_core_count => {
                            if !fields.insert(__FieldTag::__total_cpu_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_cpu_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_cpu_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DbServer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbServer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "properties" => Ok(__FieldTag::__properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DbServer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbServer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<crate::model::DbServerProperties>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DbServerProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __ocpu_count,
            __max_ocpu_count,
            __memory_size_gb,
            __max_memory_size_gb,
            __db_node_storage_size_gb,
            __max_db_node_storage_size_gb,
            __vm_count,
            __state,
            __db_node_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbServerProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "ocpuCount" => Ok(__FieldTag::__ocpu_count),
                            "ocpu_count" => Ok(__FieldTag::__ocpu_count),
                            "maxOcpuCount" => Ok(__FieldTag::__max_ocpu_count),
                            "max_ocpu_count" => Ok(__FieldTag::__max_ocpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "maxMemorySizeGb" => Ok(__FieldTag::__max_memory_size_gb),
                            "max_memory_size_gb" => Ok(__FieldTag::__max_memory_size_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "maxDbNodeStorageSizeGb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "max_db_node_storage_size_gb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "vmCount" => Ok(__FieldTag::__vm_count),
                            "vm_count" => Ok(__FieldTag::__vm_count),
                            "state" => Ok(__FieldTag::__state),
                            "dbNodeIds" => Ok(__FieldTag::__db_node_ids),
                            "db_node_ids" => Ok(__FieldTag::__db_node_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DbServerProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbServerProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ocpu_count => {
                            if !fields.insert(__FieldTag::__ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ocpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_ocpu_count => {
                            if !fields.insert(__FieldTag::__max_ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_ocpu_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_memory_size_gb => {
                            if !fields.insert(__FieldTag::__max_memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__max_db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vm_count => {
                            if !fields.insert(__FieldTag::__vm_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vm_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::db_server_properties::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__db_node_ids => {
                            if !fields.insert(__FieldTag::__db_node_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_ids",
                                ));
                            }
                            result.db_node_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DbSystemShape {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __shape,
            __min_node_count,
            __max_node_count,
            __min_storage_count,
            __max_storage_count,
            __available_core_count_per_node,
            __available_memory_per_node_gb,
            __available_data_storage_tb,
            __min_core_count_per_node,
            __min_memory_per_node_gb,
            __min_db_node_storage_per_node_gb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbSystemShape")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "shape" => Ok(__FieldTag::__shape),
                            "minNodeCount" => Ok(__FieldTag::__min_node_count),
                            "min_node_count" => Ok(__FieldTag::__min_node_count),
                            "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                            "max_node_count" => Ok(__FieldTag::__max_node_count),
                            "minStorageCount" => Ok(__FieldTag::__min_storage_count),
                            "min_storage_count" => Ok(__FieldTag::__min_storage_count),
                            "maxStorageCount" => Ok(__FieldTag::__max_storage_count),
                            "max_storage_count" => Ok(__FieldTag::__max_storage_count),
                            "availableCoreCountPerNode" => {
                                Ok(__FieldTag::__available_core_count_per_node)
                            }
                            "available_core_count_per_node" => {
                                Ok(__FieldTag::__available_core_count_per_node)
                            }
                            "availableMemoryPerNodeGb" => {
                                Ok(__FieldTag::__available_memory_per_node_gb)
                            }
                            "available_memory_per_node_gb" => {
                                Ok(__FieldTag::__available_memory_per_node_gb)
                            }
                            "availableDataStorageTb" => Ok(__FieldTag::__available_data_storage_tb),
                            "available_data_storage_tb" => {
                                Ok(__FieldTag::__available_data_storage_tb)
                            }
                            "minCoreCountPerNode" => Ok(__FieldTag::__min_core_count_per_node),
                            "min_core_count_per_node" => Ok(__FieldTag::__min_core_count_per_node),
                            "minMemoryPerNodeGb" => Ok(__FieldTag::__min_memory_per_node_gb),
                            "min_memory_per_node_gb" => Ok(__FieldTag::__min_memory_per_node_gb),
                            "minDbNodeStoragePerNodeGb" => {
                                Ok(__FieldTag::__min_db_node_storage_per_node_gb)
                            }
                            "min_db_node_storage_per_node_gb" => {
                                Ok(__FieldTag::__min_db_node_storage_per_node_gb)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DbSystemShape;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbSystemShape")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shape => {
                            if !fields.insert(__FieldTag::__shape) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shape",
                                ));
                            }
                            result.shape = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_count => {
                            if !fields.insert(__FieldTag::__min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_node_count => {
                            if !fields.insert(__FieldTag::__max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_storage_count => {
                            if !fields.insert(__FieldTag::__min_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_storage_count => {
                            if !fields.insert(__FieldTag::__max_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_core_count_per_node => {
                            if !fields.insert(__FieldTag::__available_core_count_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_core_count_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_core_count_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_memory_per_node_gb => {
                            if !fields.insert(__FieldTag::__available_memory_per_node_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_memory_per_node_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_memory_per_node_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_data_storage_tb => {
                            if !fields.insert(__FieldTag::__available_data_storage_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_data_storage_tb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_data_storage_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_core_count_per_node => {
                            if !fields.insert(__FieldTag::__min_core_count_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_core_count_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_core_count_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_memory_per_node_gb => {
                            if !fields.insert(__FieldTag::__min_memory_per_node_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_memory_per_node_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_memory_per_node_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_db_node_storage_per_node_gb => {
                            if !fields.insert(__FieldTag::__min_db_node_storage_per_node_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_db_node_storage_per_node_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_db_node_storage_per_node_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Entitlement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cloud_account_details,
            __entitlement_id,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entitlement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cloudAccountDetails" => Ok(__FieldTag::__cloud_account_details),
                            "cloud_account_details" => Ok(__FieldTag::__cloud_account_details),
                            "entitlementId" => Ok(__FieldTag::__entitlement_id),
                            "entitlement_id" => Ok(__FieldTag::__entitlement_id),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Entitlement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entitlement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_account_details => {
                            if !fields.insert(__FieldTag::__cloud_account_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_account_details",
                                ));
                            }
                            result.cloud_account_details = map.next_value::<std::option::Option<crate::model::CloudAccountDetails>>()?
                                ;
                        }
                        __FieldTag::__entitlement_id => {
                            if !fields.insert(__FieldTag::__entitlement_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement_id",
                                ));
                            }
                            result.entitlement_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::entitlement::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudAccountDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_account,
            __cloud_account_home_region,
            __link_existing_account_uri,
            __account_creation_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudAccountDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudAccount" => Ok(__FieldTag::__cloud_account),
                            "cloud_account" => Ok(__FieldTag::__cloud_account),
                            "cloudAccountHomeRegion" => Ok(__FieldTag::__cloud_account_home_region),
                            "cloud_account_home_region" => {
                                Ok(__FieldTag::__cloud_account_home_region)
                            }
                            "linkExistingAccountUri" => Ok(__FieldTag::__link_existing_account_uri),
                            "link_existing_account_uri" => {
                                Ok(__FieldTag::__link_existing_account_uri)
                            }
                            "accountCreationUri" => Ok(__FieldTag::__account_creation_uri),
                            "account_creation_uri" => Ok(__FieldTag::__account_creation_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudAccountDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudAccountDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_account => {
                            if !fields.insert(__FieldTag::__cloud_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_account",
                                ));
                            }
                            result.cloud_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_account_home_region => {
                            if !fields.insert(__FieldTag::__cloud_account_home_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_account_home_region",
                                ));
                            }
                            result.cloud_account_home_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__link_existing_account_uri => {
                            if !fields.insert(__FieldTag::__link_existing_account_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for link_existing_account_uri",
                                ));
                            }
                            result.link_existing_account_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__account_creation_uri => {
                            if !fields.insert(__FieldTag::__account_creation_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_creation_uri",
                                ));
                            }
                            result.account_creation_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudExadataInfrastructure {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __gcp_oracle_zone,
            __entitlement_id,
            __properties,
            __labels,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudExadataInfrastructure")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "gcpOracleZone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "gcp_oracle_zone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "entitlementId" => Ok(__FieldTag::__entitlement_id),
                            "entitlement_id" => Ok(__FieldTag::__entitlement_id),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudExadataInfrastructure;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudExadataInfrastructure")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_oracle_zone => {
                            if !fields.insert(__FieldTag::__gcp_oracle_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_oracle_zone",
                                ));
                            }
                            result.gcp_oracle_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entitlement_id => {
                            if !fields.insert(__FieldTag::__entitlement_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement_id",
                                ));
                            }
                            result.entitlement_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<
                                crate::model::CloudExadataInfrastructureProperties,
                            >>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudExadataInfrastructureProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __compute_count,
            __storage_count,
            __total_storage_size_gb,
            __available_storage_size_gb,
            __maintenance_window,
            __state,
            __shape,
            __oci_url,
            __cpu_count,
            __max_cpu_count,
            __memory_size_gb,
            __max_memory_gb,
            __db_node_storage_size_gb,
            __max_db_node_storage_size_gb,
            __data_storage_size_tb,
            __max_data_storage_tb,
            __activated_storage_count,
            __additional_storage_count,
            __db_server_version,
            __storage_server_version,
            __next_maintenance_run_id,
            __next_maintenance_run_time,
            __next_security_maintenance_run_time,
            __customer_contacts,
            __monthly_storage_server_version,
            __monthly_db_server_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudExadataInfrastructureProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "computeCount" => Ok(__FieldTag::__compute_count),
                            "compute_count" => Ok(__FieldTag::__compute_count),
                            "storageCount" => Ok(__FieldTag::__storage_count),
                            "storage_count" => Ok(__FieldTag::__storage_count),
                            "totalStorageSizeGb" => Ok(__FieldTag::__total_storage_size_gb),
                            "total_storage_size_gb" => Ok(__FieldTag::__total_storage_size_gb),
                            "availableStorageSizeGb" => Ok(__FieldTag::__available_storage_size_gb),
                            "available_storage_size_gb" => {
                                Ok(__FieldTag::__available_storage_size_gb)
                            }
                            "maintenanceWindow" => Ok(__FieldTag::__maintenance_window),
                            "maintenance_window" => Ok(__FieldTag::__maintenance_window),
                            "state" => Ok(__FieldTag::__state),
                            "shape" => Ok(__FieldTag::__shape),
                            "ociUrl" => Ok(__FieldTag::__oci_url),
                            "oci_url" => Ok(__FieldTag::__oci_url),
                            "cpuCount" => Ok(__FieldTag::__cpu_count),
                            "cpu_count" => Ok(__FieldTag::__cpu_count),
                            "maxCpuCount" => Ok(__FieldTag::__max_cpu_count),
                            "max_cpu_count" => Ok(__FieldTag::__max_cpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "maxMemoryGb" => Ok(__FieldTag::__max_memory_gb),
                            "max_memory_gb" => Ok(__FieldTag::__max_memory_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "maxDbNodeStorageSizeGb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "max_db_node_storage_size_gb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "dataStorageSizeTb" => Ok(__FieldTag::__data_storage_size_tb),
                            "data_storage_size_tb" => Ok(__FieldTag::__data_storage_size_tb),
                            "maxDataStorageTb" => Ok(__FieldTag::__max_data_storage_tb),
                            "max_data_storage_tb" => Ok(__FieldTag::__max_data_storage_tb),
                            "activatedStorageCount" => Ok(__FieldTag::__activated_storage_count),
                            "activated_storage_count" => Ok(__FieldTag::__activated_storage_count),
                            "additionalStorageCount" => Ok(__FieldTag::__additional_storage_count),
                            "additional_storage_count" => {
                                Ok(__FieldTag::__additional_storage_count)
                            }
                            "dbServerVersion" => Ok(__FieldTag::__db_server_version),
                            "db_server_version" => Ok(__FieldTag::__db_server_version),
                            "storageServerVersion" => Ok(__FieldTag::__storage_server_version),
                            "storage_server_version" => Ok(__FieldTag::__storage_server_version),
                            "nextMaintenanceRunId" => Ok(__FieldTag::__next_maintenance_run_id),
                            "next_maintenance_run_id" => Ok(__FieldTag::__next_maintenance_run_id),
                            "nextMaintenanceRunTime" => Ok(__FieldTag::__next_maintenance_run_time),
                            "next_maintenance_run_time" => {
                                Ok(__FieldTag::__next_maintenance_run_time)
                            }
                            "nextSecurityMaintenanceRunTime" => {
                                Ok(__FieldTag::__next_security_maintenance_run_time)
                            }
                            "next_security_maintenance_run_time" => {
                                Ok(__FieldTag::__next_security_maintenance_run_time)
                            }
                            "customerContacts" => Ok(__FieldTag::__customer_contacts),
                            "customer_contacts" => Ok(__FieldTag::__customer_contacts),
                            "monthlyStorageServerVersion" => {
                                Ok(__FieldTag::__monthly_storage_server_version)
                            }
                            "monthly_storage_server_version" => {
                                Ok(__FieldTag::__monthly_storage_server_version)
                            }
                            "monthlyDbServerVersion" => Ok(__FieldTag::__monthly_db_server_version),
                            "monthly_db_server_version" => {
                                Ok(__FieldTag::__monthly_db_server_version)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudExadataInfrastructureProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudExadataInfrastructureProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_count => {
                            if !fields.insert(__FieldTag::__compute_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_count => {
                            if !fields.insert(__FieldTag::__storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_storage_size_gb => {
                            if !fields.insert(__FieldTag::__total_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_storage_size_gb => {
                            if !fields.insert(__FieldTag::__available_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__maintenance_window => {
                            if !fields.insert(__FieldTag::__maintenance_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_window",
                                ));
                            }
                            result.maintenance_window = map
                                .next_value::<std::option::Option<crate::model::MaintenanceWindow>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_exadata_infrastructure_properties::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shape => {
                            if !fields.insert(__FieldTag::__shape) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shape",
                                ));
                            }
                            result.shape = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oci_url => {
                            if !fields.insert(__FieldTag::__oci_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oci_url",
                                ));
                            }
                            result.oci_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_count => {
                            if !fields.insert(__FieldTag::__cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_cpu_count => {
                            if !fields.insert(__FieldTag::__max_cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_cpu_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_memory_gb => {
                            if !fields.insert(__FieldTag::__max_memory_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_memory_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_memory_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__max_db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_data_storage_tb => {
                            if !fields.insert(__FieldTag::__max_data_storage_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_data_storage_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_data_storage_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__activated_storage_count => {
                            if !fields.insert(__FieldTag::__activated_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activated_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.activated_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_storage_count => {
                            if !fields.insert(__FieldTag::__additional_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_server_version => {
                            if !fields.insert(__FieldTag::__db_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_server_version",
                                ));
                            }
                            result.db_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_server_version => {
                            if !fields.insert(__FieldTag::__storage_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_server_version",
                                ));
                            }
                            result.storage_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_maintenance_run_id => {
                            if !fields.insert(__FieldTag::__next_maintenance_run_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_maintenance_run_id",
                                ));
                            }
                            result.next_maintenance_run_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_maintenance_run_time => {
                            if !fields.insert(__FieldTag::__next_maintenance_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_maintenance_run_time",
                                ));
                            }
                            result.next_maintenance_run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__next_security_maintenance_run_time => {
                            if !fields.insert(__FieldTag::__next_security_maintenance_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_security_maintenance_run_time",
                                ));
                            }
                            result.next_security_maintenance_run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__customer_contacts => {
                            if !fields.insert(__FieldTag::__customer_contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_contacts",
                                ));
                            }
                            result.customer_contacts =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomerContact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monthly_storage_server_version => {
                            if !fields.insert(__FieldTag::__monthly_storage_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly_storage_server_version",
                                ));
                            }
                            result.monthly_storage_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monthly_db_server_version => {
                            if !fields.insert(__FieldTag::__monthly_db_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly_db_server_version",
                                ));
                            }
                            result.monthly_db_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __preference,
            __months,
            __weeks_of_month,
            __days_of_week,
            __hours_of_day,
            __lead_time_week,
            __patching_mode,
            __custom_action_timeout_mins,
            __is_custom_action_timeout_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "preference" => Ok(__FieldTag::__preference),
                            "months" => Ok(__FieldTag::__months),
                            "weeksOfMonth" => Ok(__FieldTag::__weeks_of_month),
                            "weeks_of_month" => Ok(__FieldTag::__weeks_of_month),
                            "daysOfWeek" => Ok(__FieldTag::__days_of_week),
                            "days_of_week" => Ok(__FieldTag::__days_of_week),
                            "hoursOfDay" => Ok(__FieldTag::__hours_of_day),
                            "hours_of_day" => Ok(__FieldTag::__hours_of_day),
                            "leadTimeWeek" => Ok(__FieldTag::__lead_time_week),
                            "lead_time_week" => Ok(__FieldTag::__lead_time_week),
                            "patchingMode" => Ok(__FieldTag::__patching_mode),
                            "patching_mode" => Ok(__FieldTag::__patching_mode),
                            "customActionTimeoutMins" => {
                                Ok(__FieldTag::__custom_action_timeout_mins)
                            }
                            "custom_action_timeout_mins" => {
                                Ok(__FieldTag::__custom_action_timeout_mins)
                            }
                            "isCustomActionTimeoutEnabled" => {
                                Ok(__FieldTag::__is_custom_action_timeout_enabled)
                            }
                            "is_custom_action_timeout_enabled" => {
                                Ok(__FieldTag::__is_custom_action_timeout_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__preference => {
                            if !fields.insert(__FieldTag::__preference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preference",
                                ));
                            }
                            result.preference = map
                                .next_value::<std::option::Option<
                                    crate::model::maintenance_window::MaintenanceWindowPreference,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__months => {
                            if !fields.insert(__FieldTag::__months) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for months",
                                ));
                            }
                            result.months = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::Month>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__weeks_of_month => {
                            if !fields.insert(__FieldTag::__weeks_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weeks_of_month",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.weeks_of_month =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__days_of_week => {
                            if !fields.insert(__FieldTag::__days_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for days_of_week",
                                ));
                            }
                            result.days_of_week = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::DayOfWeek>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hours_of_day => {
                            if !fields.insert(__FieldTag::__hours_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hours_of_day",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.hours_of_day = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__lead_time_week => {
                            if !fields.insert(__FieldTag::__lead_time_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lead_time_week",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.lead_time_week =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__patching_mode => {
                            if !fields.insert(__FieldTag::__patching_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patching_mode",
                                ));
                            }
                            result.patching_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::maintenance_window::PatchingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_action_timeout_mins => {
                            if !fields.insert(__FieldTag::__custom_action_timeout_mins) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_action_timeout_mins",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.custom_action_timeout_mins =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__is_custom_action_timeout_enabled => {
                            if !fields.insert(__FieldTag::__is_custom_action_timeout_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_custom_action_timeout_enabled",
                                ));
                            }
                            result.is_custom_action_timeout_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GiVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GiVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GiVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GiVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcp_oracle_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcpOracleZones" => Ok(__FieldTag::__gcp_oracle_zones),
                            "gcp_oracle_zones" => Ok(__FieldTag::__gcp_oracle_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcp_oracle_zones => {
                            if !fields.insert(__FieldTag::__gcp_oracle_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_oracle_zones",
                                ));
                            }
                            result.gcp_oracle_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCloudExadataInfrastructuresRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCloudExadataInfrastructuresRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCloudExadataInfrastructuresRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudExadataInfrastructuresRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCloudExadataInfrastructuresResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_exadata_infrastructures,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCloudExadataInfrastructuresResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudExadataInfrastructures" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructures)
                            }
                            "cloud_exadata_infrastructures" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructures)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCloudExadataInfrastructuresResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudExadataInfrastructuresResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_exadata_infrastructures => {
                            if !fields.insert(__FieldTag::__cloud_exadata_infrastructures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_exadata_infrastructures",
                                ));
                            }
                            result.cloud_exadata_infrastructures = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudExadataInfrastructure>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetCloudExadataInfrastructureRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloudExadataInfrastructureRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetCloudExadataInfrastructureRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloudExadataInfrastructureRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateCloudExadataInfrastructureRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cloud_exadata_infrastructure_id,
            __cloud_exadata_infrastructure,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for CreateCloudExadataInfrastructureRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cloudExadataInfrastructureId" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure_id)
                            }
                            "cloud_exadata_infrastructure_id" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure_id)
                            }
                            "cloudExadataInfrastructure" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure)
                            }
                            "cloud_exadata_infrastructure" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure)
                            }
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateCloudExadataInfrastructureRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCloudExadataInfrastructureRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_exadata_infrastructure_id => {
                            if !fields.insert(__FieldTag::__cloud_exadata_infrastructure_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_exadata_infrastructure_id",
                                ));
                            }
                            result.cloud_exadata_infrastructure_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_exadata_infrastructure => {
                            if !fields.insert(__FieldTag::__cloud_exadata_infrastructure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_exadata_infrastructure",
                                ));
                            }
                            result.cloud_exadata_infrastructure = map.next_value::<std::option::Option<crate::model::CloudExadataInfrastructure>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteCloudExadataInfrastructureRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DeleteCloudExadataInfrastructureRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteCloudExadataInfrastructureRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCloudExadataInfrastructureRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCloudVmClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudVmClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCloudVmClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudVmClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCloudVmClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_vm_clusters,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudVmClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudVmClusters" => Ok(__FieldTag::__cloud_vm_clusters),
                            "cloud_vm_clusters" => Ok(__FieldTag::__cloud_vm_clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCloudVmClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudVmClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_vm_clusters => {
                            if !fields.insert(__FieldTag::__cloud_vm_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_vm_clusters",
                                ));
                            }
                            result.cloud_vm_clusters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudVmCluster>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetCloudVmClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloudVmClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetCloudVmClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloudVmClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateCloudVmClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cloud_vm_cluster_id,
            __cloud_vm_cluster,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCloudVmClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cloudVmClusterId" => Ok(__FieldTag::__cloud_vm_cluster_id),
                            "cloud_vm_cluster_id" => Ok(__FieldTag::__cloud_vm_cluster_id),
                            "cloudVmCluster" => Ok(__FieldTag::__cloud_vm_cluster),
                            "cloud_vm_cluster" => Ok(__FieldTag::__cloud_vm_cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateCloudVmClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCloudVmClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_vm_cluster_id => {
                            if !fields.insert(__FieldTag::__cloud_vm_cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_vm_cluster_id",
                                ));
                            }
                            result.cloud_vm_cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_vm_cluster => {
                            if !fields.insert(__FieldTag::__cloud_vm_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_vm_cluster",
                                ));
                            }
                            result.cloud_vm_cluster = map
                                .next_value::<std::option::Option<crate::model::CloudVmCluster>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteCloudVmClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCloudVmClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteCloudVmClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCloudVmClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListEntitlementsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitlementsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListEntitlementsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitlementsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListEntitlementsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entitlements,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitlementsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entitlements" => Ok(__FieldTag::__entitlements),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListEntitlementsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitlementsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entitlements => {
                            if !fields.insert(__FieldTag::__entitlements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlements",
                                ));
                            }
                            result.entitlements = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entitlement>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDbServersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbServersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDbServersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbServersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDbServersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __db_servers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbServersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dbServers" => Ok(__FieldTag::__db_servers),
                            "db_servers" => Ok(__FieldTag::__db_servers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDbServersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbServersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__db_servers => {
                            if !fields.insert(__FieldTag::__db_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_servers",
                                ));
                            }
                            result.db_servers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DbServer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDbNodesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbNodesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDbNodesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbNodesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDbNodesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __db_nodes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbNodesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dbNodes" => Ok(__FieldTag::__db_nodes),
                            "db_nodes" => Ok(__FieldTag::__db_nodes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDbNodesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbNodesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__db_nodes => {
                            if !fields.insert(__FieldTag::__db_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_nodes",
                                ));
                            }
                            result.db_nodes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DbNode>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListGiVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGiVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListGiVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGiVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListGiVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gi_versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGiVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "giVersions" => Ok(__FieldTag::__gi_versions),
                            "gi_versions" => Ok(__FieldTag::__gi_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListGiVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGiVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gi_versions => {
                            if !fields.insert(__FieldTag::__gi_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gi_versions",
                                ));
                            }
                            result.gi_versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GiVersion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDbSystemShapesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbSystemShapesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDbSystemShapesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbSystemShapesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDbSystemShapesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __db_system_shapes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbSystemShapesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dbSystemShapes" => Ok(__FieldTag::__db_system_shapes),
                            "db_system_shapes" => Ok(__FieldTag::__db_system_shapes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDbSystemShapesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbSystemShapesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__db_system_shapes => {
                            if !fields.insert(__FieldTag::__db_system_shapes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_system_shapes",
                                ));
                            }
                            result.db_system_shapes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DbSystemShape>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            __percent_complete,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "percentComplete" => Ok(__FieldTag::__percent_complete),
                            "percent_complete" => Ok(__FieldTag::__percent_complete),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__percent_complete => {
                            if !fields.insert(__FieldTag::__percent_complete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent_complete",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent_complete =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDatabasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDatabasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDatabasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDatabasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_databases,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDatabasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDatabases" => Ok(__FieldTag::__autonomous_databases),
                            "autonomous_databases" => Ok(__FieldTag::__autonomous_databases),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDatabasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_databases => {
                            if !fields.insert(__FieldTag::__autonomous_databases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_databases",
                                ));
                            }
                            result.autonomous_databases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDatabase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __autonomous_database_id,
            __autonomous_database,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "autonomousDatabaseId" => Ok(__FieldTag::__autonomous_database_id),
                            "autonomous_database_id" => Ok(__FieldTag::__autonomous_database_id),
                            "autonomousDatabase" => Ok(__FieldTag::__autonomous_database),
                            "autonomous_database" => Ok(__FieldTag::__autonomous_database),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_database_id => {
                            if !fields.insert(__FieldTag::__autonomous_database_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database_id",
                                ));
                            }
                            result.autonomous_database_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_database => {
                            if !fields.insert(__FieldTag::__autonomous_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database",
                                ));
                            }
                            result.autonomous_database = map.next_value::<std::option::Option<crate::model::AutonomousDatabase>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RestoreAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __restore_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "restoreTime" => Ok(__FieldTag::__restore_time),
                            "restore_time" => Ok(__FieldTag::__restore_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RestoreAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_time => {
                            if !fields.insert(__FieldTag::__restore_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_time",
                                ));
                            }
                            result.restore_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StopAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StopAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StartAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StartAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RestartAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestartAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RestartAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestartAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateAutonomousDatabaseWalletRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __is_regional,
            __password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAutonomousDatabaseWalletRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "isRegional" => Ok(__FieldTag::__is_regional),
                            "is_regional" => Ok(__FieldTag::__is_regional),
                            "password" => Ok(__FieldTag::__password),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateAutonomousDatabaseWalletRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAutonomousDatabaseWalletRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::GenerateType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_regional => {
                            if !fields.insert(__FieldTag::__is_regional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_regional",
                                ));
                            }
                            result.is_regional = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateAutonomousDatabaseWalletResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __archive_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAutonomousDatabaseWalletResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "archiveContent" => Ok(__FieldTag::__archive_content),
                            "archive_content" => Ok(__FieldTag::__archive_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateAutonomousDatabaseWalletResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAutonomousDatabaseWalletResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__archive_content => {
                            if !fields.insert(__FieldTag::__archive_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.archive_content =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDbVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDbVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDbVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDbVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDbVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_db_versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDbVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDbVersions" => Ok(__FieldTag::__autonomous_db_versions),
                            "autonomous_db_versions" => Ok(__FieldTag::__autonomous_db_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDbVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDbVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_db_versions => {
                            if !fields.insert(__FieldTag::__autonomous_db_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_db_versions",
                                ));
                            }
                            result.autonomous_db_versions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDbVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDatabaseCharacterSetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ListAutonomousDatabaseCharacterSetsRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDatabaseCharacterSetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseCharacterSetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDatabaseCharacterSetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_database_character_sets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ListAutonomousDatabaseCharacterSetsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDatabaseCharacterSets" => {
                                Ok(__FieldTag::__autonomous_database_character_sets)
                            }
                            "autonomous_database_character_sets" => {
                                Ok(__FieldTag::__autonomous_database_character_sets)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDatabaseCharacterSetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseCharacterSetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_database_character_sets => {
                            if !fields.insert(__FieldTag::__autonomous_database_character_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database_character_sets",
                                ));
                            }
                            result.autonomous_database_character_sets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDatabaseCharacterSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDatabaseBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDatabaseBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDatabaseBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAutonomousDatabaseBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_database_backups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListAutonomousDatabaseBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDatabaseBackups" => {
                                Ok(__FieldTag::__autonomous_database_backups)
                            }
                            "autonomous_database_backups" => {
                                Ok(__FieldTag::__autonomous_database_backups)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAutonomousDatabaseBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_database_backups => {
                            if !fields.insert(__FieldTag::__autonomous_database_backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database_backups",
                                ));
                            }
                            result.autonomous_database_backups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDatabaseBackup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudVmCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __exadata_infrastructure,
            __display_name,
            __gcp_oracle_zone,
            __properties,
            __labels,
            __create_time,
            __cidr,
            __backup_subnet_cidr,
            __network,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudVmCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "exadataInfrastructure" => Ok(__FieldTag::__exadata_infrastructure),
                            "exadata_infrastructure" => Ok(__FieldTag::__exadata_infrastructure),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "gcpOracleZone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "gcp_oracle_zone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "cidr" => Ok(__FieldTag::__cidr),
                            "backupSubnetCidr" => Ok(__FieldTag::__backup_subnet_cidr),
                            "backup_subnet_cidr" => Ok(__FieldTag::__backup_subnet_cidr),
                            "network" => Ok(__FieldTag::__network),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudVmCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudVmCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exadata_infrastructure => {
                            if !fields.insert(__FieldTag::__exadata_infrastructure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exadata_infrastructure",
                                ));
                            }
                            result.exadata_infrastructure = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_oracle_zone => {
                            if !fields.insert(__FieldTag::__gcp_oracle_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_oracle_zone",
                                ));
                            }
                            result.gcp_oracle_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<crate::model::CloudVmClusterProperties>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cidr => {
                            if !fields.insert(__FieldTag::__cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr",
                                ));
                            }
                            result.cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_subnet_cidr => {
                            if !fields.insert(__FieldTag::__backup_subnet_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_subnet_cidr",
                                ));
                            }
                            result.backup_subnet_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudVmClusterProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __license_type,
            __gi_version,
            __time_zone,
            __ssh_public_keys,
            __node_count,
            __shape,
            __ocpu_count,
            __memory_size_gb,
            __db_node_storage_size_gb,
            __storage_size_gb,
            __data_storage_size_tb,
            __disk_redundancy,
            __sparse_diskgroup_enabled,
            __local_backup_enabled,
            __hostname_prefix,
            __diagnostics_data_collection_options,
            __state,
            __scan_listener_port_tcp,
            __scan_listener_port_tcp_ssl,
            __domain,
            __scan_dns,
            __hostname,
            __cpu_core_count,
            __system_version,
            __scan_ip_ids,
            __scan_dns_record_id,
            __oci_url,
            __db_server_ocids,
            __compartment_id,
            __dns_listener_ip,
            __cluster_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudVmClusterProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "giVersion" => Ok(__FieldTag::__gi_version),
                            "gi_version" => Ok(__FieldTag::__gi_version),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "sshPublicKeys" => Ok(__FieldTag::__ssh_public_keys),
                            "ssh_public_keys" => Ok(__FieldTag::__ssh_public_keys),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "shape" => Ok(__FieldTag::__shape),
                            "ocpuCount" => Ok(__FieldTag::__ocpu_count),
                            "ocpu_count" => Ok(__FieldTag::__ocpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "storageSizeGb" => Ok(__FieldTag::__storage_size_gb),
                            "storage_size_gb" => Ok(__FieldTag::__storage_size_gb),
                            "dataStorageSizeTb" => Ok(__FieldTag::__data_storage_size_tb),
                            "data_storage_size_tb" => Ok(__FieldTag::__data_storage_size_tb),
                            "diskRedundancy" => Ok(__FieldTag::__disk_redundancy),
                            "disk_redundancy" => Ok(__FieldTag::__disk_redundancy),
                            "sparseDiskgroupEnabled" => Ok(__FieldTag::__sparse_diskgroup_enabled),
                            "sparse_diskgroup_enabled" => {
                                Ok(__FieldTag::__sparse_diskgroup_enabled)
                            }
                            "localBackupEnabled" => Ok(__FieldTag::__local_backup_enabled),
                            "local_backup_enabled" => Ok(__FieldTag::__local_backup_enabled),
                            "hostnamePrefix" => Ok(__FieldTag::__hostname_prefix),
                            "hostname_prefix" => Ok(__FieldTag::__hostname_prefix),
                            "diagnosticsDataCollectionOptions" => {
                                Ok(__FieldTag::__diagnostics_data_collection_options)
                            }
                            "diagnostics_data_collection_options" => {
                                Ok(__FieldTag::__diagnostics_data_collection_options)
                            }
                            "state" => Ok(__FieldTag::__state),
                            "scanListenerPortTcp" => Ok(__FieldTag::__scan_listener_port_tcp),
                            "scan_listener_port_tcp" => Ok(__FieldTag::__scan_listener_port_tcp),
                            "scanListenerPortTcpSsl" => {
                                Ok(__FieldTag::__scan_listener_port_tcp_ssl)
                            }
                            "scan_listener_port_tcp_ssl" => {
                                Ok(__FieldTag::__scan_listener_port_tcp_ssl)
                            }
                            "domain" => Ok(__FieldTag::__domain),
                            "scanDns" => Ok(__FieldTag::__scan_dns),
                            "scan_dns" => Ok(__FieldTag::__scan_dns),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "cpuCoreCount" => Ok(__FieldTag::__cpu_core_count),
                            "cpu_core_count" => Ok(__FieldTag::__cpu_core_count),
                            "systemVersion" => Ok(__FieldTag::__system_version),
                            "system_version" => Ok(__FieldTag::__system_version),
                            "scanIpIds" => Ok(__FieldTag::__scan_ip_ids),
                            "scan_ip_ids" => Ok(__FieldTag::__scan_ip_ids),
                            "scanDnsRecordId" => Ok(__FieldTag::__scan_dns_record_id),
                            "scan_dns_record_id" => Ok(__FieldTag::__scan_dns_record_id),
                            "ociUrl" => Ok(__FieldTag::__oci_url),
                            "oci_url" => Ok(__FieldTag::__oci_url),
                            "dbServerOcids" => Ok(__FieldTag::__db_server_ocids),
                            "db_server_ocids" => Ok(__FieldTag::__db_server_ocids),
                            "compartmentId" => Ok(__FieldTag::__compartment_id),
                            "compartment_id" => Ok(__FieldTag::__compartment_id),
                            "dnsListenerIp" => Ok(__FieldTag::__dns_listener_ip),
                            "dns_listener_ip" => Ok(__FieldTag::__dns_listener_ip),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudVmClusterProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudVmClusterProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_vm_cluster_properties::LicenseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gi_version => {
                            if !fields.insert(__FieldTag::__gi_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gi_version",
                                ));
                            }
                            result.gi_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone =
                                map.next_value::<std::option::Option<gtype::model::TimeZone>>()?;
                        }
                        __FieldTag::__ssh_public_keys => {
                            if !fields.insert(__FieldTag::__ssh_public_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_public_keys",
                                ));
                            }
                            result.ssh_public_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shape => {
                            if !fields.insert(__FieldTag::__shape) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shape",
                                ));
                            }
                            result.shape = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ocpu_count => {
                            if !fields.insert(__FieldTag::__ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ocpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_size_gb => {
                            if !fields.insert(__FieldTag::__storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_redundancy => {
                            if !fields.insert(__FieldTag::__disk_redundancy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_redundancy",
                                ));
                            }
                            result.disk_redundancy = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_vm_cluster_properties::DiskRedundancy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sparse_diskgroup_enabled => {
                            if !fields.insert(__FieldTag::__sparse_diskgroup_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sparse_diskgroup_enabled",
                                ));
                            }
                            result.sparse_diskgroup_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_backup_enabled => {
                            if !fields.insert(__FieldTag::__local_backup_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_backup_enabled",
                                ));
                            }
                            result.local_backup_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname_prefix => {
                            if !fields.insert(__FieldTag::__hostname_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname_prefix",
                                ));
                            }
                            result.hostname_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diagnostics_data_collection_options => {
                            if !fields.insert(__FieldTag::__diagnostics_data_collection_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostics_data_collection_options",
                                ));
                            }
                            result.diagnostics_data_collection_options = map.next_value::<std::option::Option<crate::model::DataCollectionOptions>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_vm_cluster_properties::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scan_listener_port_tcp => {
                            if !fields.insert(__FieldTag::__scan_listener_port_tcp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_listener_port_tcp",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scan_listener_port_tcp =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scan_listener_port_tcp_ssl => {
                            if !fields.insert(__FieldTag::__scan_listener_port_tcp_ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_listener_port_tcp_ssl",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scan_listener_port_tcp_ssl =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scan_dns => {
                            if !fields.insert(__FieldTag::__scan_dns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_dns",
                                ));
                            }
                            result.scan_dns = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_core_count => {
                            if !fields.insert(__FieldTag::__cpu_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__system_version => {
                            if !fields.insert(__FieldTag::__system_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system_version",
                                ));
                            }
                            result.system_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scan_ip_ids => {
                            if !fields.insert(__FieldTag::__scan_ip_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_ip_ids",
                                ));
                            }
                            result.scan_ip_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scan_dns_record_id => {
                            if !fields.insert(__FieldTag::__scan_dns_record_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_dns_record_id",
                                ));
                            }
                            result.scan_dns_record_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oci_url => {
                            if !fields.insert(__FieldTag::__oci_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oci_url",
                                ));
                            }
                            result.oci_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_server_ocids => {
                            if !fields.insert(__FieldTag::__db_server_ocids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_server_ocids",
                                ));
                            }
                            result.db_server_ocids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compartment_id => {
                            if !fields.insert(__FieldTag::__compartment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compartment_id",
                                ));
                            }
                            result.compartment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dns_listener_ip => {
                            if !fields.insert(__FieldTag::__dns_listener_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_listener_ip",
                                ));
                            }
                            result.dns_listener_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DataCollectionOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __diagnostics_events_enabled,
            __health_monitoring_enabled,
            __incident_logs_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataCollectionOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diagnosticsEventsEnabled" => {
                                Ok(__FieldTag::__diagnostics_events_enabled)
                            }
                            "diagnostics_events_enabled" => {
                                Ok(__FieldTag::__diagnostics_events_enabled)
                            }
                            "healthMonitoringEnabled" => {
                                Ok(__FieldTag::__health_monitoring_enabled)
                            }
                            "health_monitoring_enabled" => {
                                Ok(__FieldTag::__health_monitoring_enabled)
                            }
                            "incidentLogsEnabled" => Ok(__FieldTag::__incident_logs_enabled),
                            "incident_logs_enabled" => Ok(__FieldTag::__incident_logs_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DataCollectionOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataCollectionOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__diagnostics_events_enabled => {
                            if !fields.insert(__FieldTag::__diagnostics_events_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostics_events_enabled",
                                ));
                            }
                            result.diagnostics_events_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_monitoring_enabled => {
                            if !fields.insert(__FieldTag::__health_monitoring_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_monitoring_enabled",
                                ));
                            }
                            result.health_monitoring_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__incident_logs_enabled => {
                            if !fields.insert(__FieldTag::__incident_logs_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incident_logs_enabled",
                                ));
                            }
                            result.incident_logs_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
