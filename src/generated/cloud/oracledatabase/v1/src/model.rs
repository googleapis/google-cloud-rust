// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Details of the Autonomous Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabase/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabase {
    /// Identifier. The name of the Autonomous Database resource in the following
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The name of the Autonomous Database. The database name must be
    /// unique in the project. The name must begin with a letter and can contain a
    /// maximum of 30 alphanumeric characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Optional. The display name for the Autonomous Database. The name does not
    /// have to be unique within your project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The ID of the subscription entitlement associated with the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entitlement_id: std::string::String,

    /// Optional. The password for the default ADMIN user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub admin_password: std::string::String,

    /// Optional. The properties of the Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::AutonomousDatabaseProperties>,

    /// Optional. The labels or tags associated with the Autonomous Database.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The name of the VPC network used by the Autonomous Database in
    /// the following format: projects/{project}/global/networks/{network}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Required. The subnet CIDR range for the Autonmous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cidr: std::string::String,

    /// Output only. The date and time that the Autonomous Database was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,
}

impl AutonomousDatabase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabase::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::AutonomousDatabase::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabase::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::AutonomousDatabase::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [admin_password][crate::model::AutonomousDatabase::admin_password].
    pub fn set_admin_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin_password = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabase::properties].
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::AutonomousDatabaseProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// Sets the value of [network][crate::model::AutonomousDatabase::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::AutonomousDatabase::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AutonomousDatabase::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabase::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabase"
    }
}

/// The properties of an Autonomous Database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseProperties {
    /// Output only. OCID of the Autonomous Database.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Autonomous Database.
    pub compute_count: f32,

    /// Optional. The number of CPU cores to be made available to the database.
    pub cpu_core_count: i32,

    /// Optional. The size of the data stored in the database, in terabytes.
    pub data_storage_size_tb: i32,

    /// Optional. The size of the data stored in the database, in gigabytes.
    pub data_storage_size_gb: i32,

    /// Required. The workload type of the Autonomous Database.
    pub db_workload: crate::model::DBWorkload,

    /// Optional. The edition of the Autonomous Databases.
    pub db_edition: crate::model::autonomous_database_properties::DatabaseEdition,

    /// Optional. The character set for the Autonomous Database. The default is
    /// AL32UTF8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub character_set: std::string::String,

    /// Optional. The national character set for the Autonomous Database. The
    /// default is AL16UTF16.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub n_character_set: std::string::String,

    /// Optional. The private endpoint IP address for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_endpoint_ip: std::string::String,

    /// Optional. The private endpoint label for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_endpoint_label: std::string::String,

    /// Optional. The Oracle Database version for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub db_version: std::string::String,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database CPU core count.
    pub is_auto_scaling_enabled: bool,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database storage.
    pub is_storage_auto_scaling_enabled: bool,

    /// Required. The license type used for the Autonomous Database.
    pub license_type: crate::model::autonomous_database_properties::LicenseType,

    /// Optional. The list of customer contacts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault secret.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_id: std::string::String,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vault_id: std::string::String,

    /// Optional. The maintenance schedule of the Autonomous Database.
    pub maintenance_schedule_type:
        crate::model::autonomous_database_properties::MaintenanceScheduleType,

    /// Optional. This field specifies if the Autonomous Database requires mTLS
    /// connections.
    pub mtls_connection_required: bool,

    /// Optional. The retention period for the Autonomous Database. This field is
    /// specified in days, can range from 1 day to 60 days, and has a default value
    /// of 60 days.
    pub backup_retention_period_days: i32,

    /// Output only. The amount of storage currently being used for user and system
    /// data, in terabytes.
    pub actual_used_data_storage_size_tb: f64,

    /// Output only. The amount of storage currently allocated for the database
    /// tables and billed for, rounded up in terabytes.
    pub allocated_storage_size_tb: f64,

    /// Output only. The details for the Oracle APEX Application Development.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub apex_details: std::option::Option<crate::model::AutonomousDatabaseApex>,

    /// Output only. This field indicates the status of Data Guard and Access
    /// control for the Autonomous Database. The field's value is null if Data
    /// Guard is disabled or Access Control is disabled. The field's value is TRUE
    /// if both Data Guard and Access Control are enabled, and the Autonomous
    /// Database is using primary IP access control list (ACL) for standby. The
    /// field's value is FALSE if both Data Guard and Access Control are enabled,
    /// and the Autonomous Database is using a different IP access control list
    /// (ACL) for standby compared to primary.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub are_primary_allowlisted_ips_used: std::option::Option<bool>,

    /// Output only. The details of the current lifestyle state of the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    pub state: crate::model::State,

    /// Output only. The Autonomous Container Database OCID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub autonomous_container_database_id: std::string::String,

    /// Output only. The list of available Oracle Database upgrade versions for an
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub available_upgrade_versions: std::vec::Vec<std::string::String>,

    /// Output only. The connection strings used to connect to an Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_strings: std::option::Option<crate::model::AutonomousDatabaseConnectionStrings>,

    /// Output only. The Oracle Connection URLs for an Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_urls: std::option::Option<crate::model::AutonomousDatabaseConnectionUrls>,

    /// Output only. This field indicates the number of seconds of data loss during
    /// a Data Guard failover.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failed_data_recovery_duration: std::option::Option<wkt::Duration>,

    /// Output only. The memory assigned to in-memory tables in an Autonomous
    /// Database.
    pub memory_table_gbs: i32,

    /// Output only. This field indicates whether the Autonomous Database has local
    /// (in-region) Data Guard enabled.
    pub is_local_data_guard_enabled: bool,

    /// Output only. This field indicates the maximum data loss limit for an
    /// Autonomous Database, in seconds.
    pub local_adg_auto_failover_max_data_loss_limit: i32,

    /// Output only. The details of the Autonomous Data Guard standby database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub local_standby_db: std::option::Option<crate::model::AutonomousDatabaseStandbySummary>,

    /// Output only. The amount of memory enabled per ECPU, in gigabytes.
    pub memory_per_oracle_compute_unit_gbs: i32,

    /// Output only. This field indicates the local disaster recovery (DR) type of
    /// an Autonomous Database.
    pub local_disaster_recovery_type:
        crate::model::autonomous_database_properties::LocalDisasterRecoveryType,

    /// Output only. The current state of the Data Safe registration for the
    /// Autonomous Database.
    pub data_safe_state: crate::model::autonomous_database_properties::DataSafeState,

    /// Output only. The current state of database management for the Autonomous
    /// Database.
    pub database_management_state:
        crate::model::autonomous_database_properties::DatabaseManagementState,

    /// Output only. This field indicates the current mode of the Autonomous
    /// Database.
    pub open_mode: crate::model::autonomous_database_properties::OpenMode,

    /// Output only. This field indicates the state of Operations Insights for the
    /// Autonomous Database.
    pub operations_insights_state: crate::model::OperationsInsightsState,

    /// Output only. The list of OCIDs of standby databases located in Autonomous
    /// Data Guard remote regions that are associated with the source database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub peer_db_ids: std::vec::Vec<std::string::String>,

    /// Output only. The permission level of the Autonomous Database.
    pub permission_level: crate::model::autonomous_database_properties::PermissionLevel,

    /// Output only. The private endpoint for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_endpoint: std::string::String,

    /// Output only. The refresh mode of the cloned Autonomous Database.
    pub refreshable_mode: crate::model::autonomous_database_properties::RefreshableMode,

    /// Output only. The refresh State of the clone.
    pub refreshable_state: crate::model::autonomous_database_properties::RefreshableState,

    /// Output only. The Data Guard role of the Autonomous Database.
    pub role: crate::model::autonomous_database_properties::Role,

    /// Output only. The list and details of the scheduled operations of the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scheduled_operation_details: std::vec::Vec<crate::model::ScheduledOperationDetails>,

    /// Output only. The SQL Web Developer URL for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_web_developer_url: std::string::String,

    /// Output only. The list of available regions that can be used to create a
    /// clone for the Autonomous Database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_clone_regions: std::vec::Vec<std::string::String>,

    /// Output only. The storage space used by Autonomous Database, in gigabytes.
    pub used_data_storage_size_tbs: i32,

    /// Output only. The Oracle Cloud Infrastructure link for the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oci_url: std::string::String,

    /// Output only. The storage space used by automatic backups of Autonomous
    /// Database, in gigabytes.
    pub total_auto_backup_storage_size_gbs: f32,

    /// Output only. The long term backup schedule of the Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_long_term_backup_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will begin.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will end.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_end_time: std::option::Option<wkt::Timestamp>,
}

impl AutonomousDatabaseProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::AutonomousDatabaseProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::AutonomousDatabaseProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::AutonomousDatabaseProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_gb][crate::model::AutonomousDatabaseProperties::data_storage_size_gb].
    pub fn set_data_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDatabaseProperties::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [db_edition][crate::model::AutonomousDatabaseProperties::db_edition].
    pub fn set_db_edition<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseEdition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.db_edition = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseProperties::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }

    /// Sets the value of [n_character_set][crate::model::AutonomousDatabaseProperties::n_character_set].
    pub fn set_n_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n_character_set = v.into();
        self
    }

    /// Sets the value of [private_endpoint_ip][crate::model::AutonomousDatabaseProperties::private_endpoint_ip].
    pub fn set_private_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [private_endpoint_label][crate::model::AutonomousDatabaseProperties::private_endpoint_label].
    pub fn set_private_endpoint_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_label = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_auto_scaling_enabled].
    pub fn set_is_auto_scaling_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [is_storage_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_storage_auto_scaling_enabled].
    pub fn set_is_storage_auto_scaling_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_storage_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::AutonomousDatabaseProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [secret_id][crate::model::AutonomousDatabaseProperties::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }

    /// Sets the value of [maintenance_schedule_type][crate::model::AutonomousDatabaseProperties::maintenance_schedule_type].
    pub fn set_maintenance_schedule_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::MaintenanceScheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_schedule_type = v.into();
        self
    }

    /// Sets the value of [mtls_connection_required][crate::model::AutonomousDatabaseProperties::mtls_connection_required].
    pub fn set_mtls_connection_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.mtls_connection_required = v.into();
        self
    }

    /// Sets the value of [backup_retention_period_days][crate::model::AutonomousDatabaseProperties::backup_retention_period_days].
    pub fn set_backup_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.backup_retention_period_days = v.into();
        self
    }

    /// Sets the value of [actual_used_data_storage_size_tb][crate::model::AutonomousDatabaseProperties::actual_used_data_storage_size_tb].
    pub fn set_actual_used_data_storage_size_tb<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.actual_used_data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [allocated_storage_size_tb][crate::model::AutonomousDatabaseProperties::allocated_storage_size_tb].
    pub fn set_allocated_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.allocated_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [apex_details][crate::model::AutonomousDatabaseProperties::apex_details].
    pub fn set_apex_details<
        T: std::convert::Into<std::option::Option<crate::model::AutonomousDatabaseApex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.apex_details = v.into();
        self
    }

    /// Sets the value of [are_primary_allowlisted_ips_used][crate::model::AutonomousDatabaseProperties::are_primary_allowlisted_ips_used].
    pub fn set_are_primary_allowlisted_ips_used<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.are_primary_allowlisted_ips_used = v.into();
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [autonomous_container_database_id][crate::model::AutonomousDatabaseProperties::autonomous_container_database_id].
    pub fn set_autonomous_container_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_container_database_id = v.into();
        self
    }

    /// Sets the value of [connection_strings][crate::model::AutonomousDatabaseProperties::connection_strings].
    pub fn set_connection_strings<
        T: std::convert::Into<std::option::Option<crate::model::AutonomousDatabaseConnectionStrings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_strings = v.into();
        self
    }

    /// Sets the value of [connection_urls][crate::model::AutonomousDatabaseProperties::connection_urls].
    pub fn set_connection_urls<
        T: std::convert::Into<std::option::Option<crate::model::AutonomousDatabaseConnectionUrls>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_urls = v.into();
        self
    }

    /// Sets the value of [failed_data_recovery_duration][crate::model::AutonomousDatabaseProperties::failed_data_recovery_duration].
    pub fn set_failed_data_recovery_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.failed_data_recovery_duration = v.into();
        self
    }

    /// Sets the value of [memory_table_gbs][crate::model::AutonomousDatabaseProperties::memory_table_gbs].
    pub fn set_memory_table_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_table_gbs = v.into();
        self
    }

    /// Sets the value of [is_local_data_guard_enabled][crate::model::AutonomousDatabaseProperties::is_local_data_guard_enabled].
    pub fn set_is_local_data_guard_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_local_data_guard_enabled = v.into();
        self
    }

    /// Sets the value of [local_adg_auto_failover_max_data_loss_limit][crate::model::AutonomousDatabaseProperties::local_adg_auto_failover_max_data_loss_limit].
    pub fn set_local_adg_auto_failover_max_data_loss_limit<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_adg_auto_failover_max_data_loss_limit = v.into();
        self
    }

    /// Sets the value of [local_standby_db][crate::model::AutonomousDatabaseProperties::local_standby_db].
    pub fn set_local_standby_db<
        T: std::convert::Into<std::option::Option<crate::model::AutonomousDatabaseStandbySummary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_standby_db = v.into();
        self
    }

    /// Sets the value of [memory_per_oracle_compute_unit_gbs][crate::model::AutonomousDatabaseProperties::memory_per_oracle_compute_unit_gbs].
    pub fn set_memory_per_oracle_compute_unit_gbs<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.memory_per_oracle_compute_unit_gbs = v.into();
        self
    }

    /// Sets the value of [local_disaster_recovery_type][crate::model::AutonomousDatabaseProperties::local_disaster_recovery_type].
    pub fn set_local_disaster_recovery_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LocalDisasterRecoveryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_disaster_recovery_type = v.into();
        self
    }

    /// Sets the value of [data_safe_state][crate::model::AutonomousDatabaseProperties::data_safe_state].
    pub fn set_data_safe_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DataSafeState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_safe_state = v.into();
        self
    }

    /// Sets the value of [database_management_state][crate::model::AutonomousDatabaseProperties::database_management_state].
    pub fn set_database_management_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseManagementState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_management_state = v.into();
        self
    }

    /// Sets the value of [open_mode][crate::model::AutonomousDatabaseProperties::open_mode].
    pub fn set_open_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::OpenMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_mode = v.into();
        self
    }

    /// Sets the value of [operations_insights_state][crate::model::AutonomousDatabaseProperties::operations_insights_state].
    pub fn set_operations_insights_state<
        T: std::convert::Into<crate::model::OperationsInsightsState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operations_insights_state = v.into();
        self
    }

    /// Sets the value of [permission_level][crate::model::AutonomousDatabaseProperties::permission_level].
    pub fn set_permission_level<
        T: std::convert::Into<crate::model::autonomous_database_properties::PermissionLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.permission_level = v.into();
        self
    }

    /// Sets the value of [private_endpoint][crate::model::AutonomousDatabaseProperties::private_endpoint].
    pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint = v.into();
        self
    }

    /// Sets the value of [refreshable_mode][crate::model::AutonomousDatabaseProperties::refreshable_mode].
    pub fn set_refreshable_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_mode = v.into();
        self
    }

    /// Sets the value of [refreshable_state][crate::model::AutonomousDatabaseProperties::refreshable_state].
    pub fn set_refreshable_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_state = v.into();
        self
    }

    /// Sets the value of [role][crate::model::AutonomousDatabaseProperties::role].
    pub fn set_role<T: std::convert::Into<crate::model::autonomous_database_properties::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [sql_web_developer_url][crate::model::AutonomousDatabaseProperties::sql_web_developer_url].
    pub fn set_sql_web_developer_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sql_web_developer_url = v.into();
        self
    }

    /// Sets the value of [used_data_storage_size_tbs][crate::model::AutonomousDatabaseProperties::used_data_storage_size_tbs].
    pub fn set_used_data_storage_size_tbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.used_data_storage_size_tbs = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::AutonomousDatabaseProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [total_auto_backup_storage_size_gbs][crate::model::AutonomousDatabaseProperties::total_auto_backup_storage_size_gbs].
    pub fn set_total_auto_backup_storage_size_gbs<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_auto_backup_storage_size_gbs = v.into();
        self
    }

    /// Sets the value of [next_long_term_backup_time][crate::model::AutonomousDatabaseProperties::next_long_term_backup_time].
    pub fn set_next_long_term_backup_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.next_long_term_backup_time = v.into();
        self
    }

    /// Sets the value of [maintenance_begin_time][crate::model::AutonomousDatabaseProperties::maintenance_begin_time].
    pub fn set_maintenance_begin_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_begin_time = v.into();
        self
    }

    /// Sets the value of [maintenance_end_time][crate::model::AutonomousDatabaseProperties::maintenance_end_time].
    pub fn set_maintenance_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_end_time = v.into();
        self
    }

    /// Sets the value of [customer_contacts][crate::model::AutonomousDatabaseProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [available_upgrade_versions][crate::model::AutonomousDatabaseProperties::available_upgrade_versions].
    pub fn set_available_upgrade_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_upgrade_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [peer_db_ids][crate::model::AutonomousDatabaseProperties::peer_db_ids].
    pub fn set_peer_db_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_db_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scheduled_operation_details][crate::model::AutonomousDatabaseProperties::scheduled_operation_details].
    pub fn set_scheduled_operation_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScheduledOperationDetails>,
    {
        use std::iter::Iterator;
        self.scheduled_operation_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_clone_regions][crate::model::AutonomousDatabaseProperties::supported_clone_regions].
    pub fn set_supported_clone_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_clone_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseProperties"
    }
}

/// Defines additional types related to AutonomousDatabaseProperties
pub mod autonomous_database_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The editions available for the Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct DatabaseEdition(wkt::enumerations::Enumeration);

    /// Useful constants to work with [DatabaseEdition](DatabaseEdition)
    pub mod database_edition {
        use super::DatabaseEdition;

        /// Default unspecified value.
        pub const DATABASE_EDITION_UNSPECIFIED: DatabaseEdition =
            DatabaseEdition::known("DATABASE_EDITION_UNSPECIFIED", 0);

        /// Standard Database Edition
        pub const STANDARD_EDITION: DatabaseEdition = DatabaseEdition::known("STANDARD_EDITION", 1);

        /// Enterprise Database Edition
        pub const ENTERPRISE_EDITION: DatabaseEdition =
            DatabaseEdition::known("ENTERPRISE_EDITION", 2);
    }

    impl DatabaseEdition {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for DatabaseEdition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEdition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(DatabaseEdition::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(DatabaseEdition::from(val)),
                Enumeration::UnknownNum { str } => Ok(DatabaseEdition::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for DatabaseEdition {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "DATABASE_EDITION_UNSPECIFIED" => database_edition::DATABASE_EDITION_UNSPECIFIED,
                "STANDARD_EDITION" => database_edition::STANDARD_EDITION,
                "ENTERPRISE_EDITION" => database_edition::ENTERPRISE_EDITION,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for DatabaseEdition {
        fn from(value: i32) -> Self {
            match value {
                0 => database_edition::DATABASE_EDITION_UNSPECIFIED,
                1 => database_edition::STANDARD_EDITION,
                2 => database_edition::ENTERPRISE_EDITION,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for DatabaseEdition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The license types available for the Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct LicenseType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [LicenseType](LicenseType)
    pub mod license_type {
        use super::LicenseType;

        /// Unspecified
        pub const LICENSE_TYPE_UNSPECIFIED: LicenseType =
            LicenseType::known("LICENSE_TYPE_UNSPECIFIED", 0);

        /// License included part of offer
        pub const LICENSE_INCLUDED: LicenseType = LicenseType::known("LICENSE_INCLUDED", 1);

        /// Bring your own license
        pub const BRING_YOUR_OWN_LICENSE: LicenseType =
            LicenseType::known("BRING_YOUR_OWN_LICENSE", 2);
    }

    impl LicenseType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(LicenseType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(LicenseType::from(val)),
                Enumeration::UnknownNum { str } => Ok(LicenseType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for LicenseType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "LICENSE_TYPE_UNSPECIFIED" => license_type::LICENSE_TYPE_UNSPECIFIED,
                "LICENSE_INCLUDED" => license_type::LICENSE_INCLUDED,
                "BRING_YOUR_OWN_LICENSE" => license_type::BRING_YOUR_OWN_LICENSE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => license_type::LICENSE_TYPE_UNSPECIFIED,
                1 => license_type::LICENSE_INCLUDED,
                2 => license_type::BRING_YOUR_OWN_LICENSE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The available maintenance schedules for the Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct MaintenanceScheduleType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [MaintenanceScheduleType](MaintenanceScheduleType)
    pub mod maintenance_schedule_type {
        use super::MaintenanceScheduleType;

        /// Default unspecified value.
        pub const MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED: MaintenanceScheduleType =
            MaintenanceScheduleType::known("MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED", 0);

        /// An EARLY maintenance schedule patches the database before
        /// the regular scheduled maintenance.
        pub const EARLY: MaintenanceScheduleType = MaintenanceScheduleType::known("EARLY", 1);

        /// A REGULAR maintenance schedule follows the normal maintenance cycle.
        pub const REGULAR: MaintenanceScheduleType = MaintenanceScheduleType::known("REGULAR", 2);
    }

    impl MaintenanceScheduleType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for MaintenanceScheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceScheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(MaintenanceScheduleType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(MaintenanceScheduleType::from(val)),
                Enumeration::UnknownNum { str } => Ok(MaintenanceScheduleType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for MaintenanceScheduleType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED" => {
                    maintenance_schedule_type::MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED
                }
                "EARLY" => maintenance_schedule_type::EARLY,
                "REGULAR" => maintenance_schedule_type::REGULAR,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for MaintenanceScheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => maintenance_schedule_type::MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED,
                1 => maintenance_schedule_type::EARLY,
                2 => maintenance_schedule_type::REGULAR,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for MaintenanceScheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The types of local disaster recovery available for an Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct LocalDisasterRecoveryType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [LocalDisasterRecoveryType](LocalDisasterRecoveryType)
    pub mod local_disaster_recovery_type {
        use super::LocalDisasterRecoveryType;

        /// Default unspecified value.
        pub const LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED: LocalDisasterRecoveryType =
            LocalDisasterRecoveryType::known("LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED", 0);

        /// Autonomous Data Guard recovery.
        pub const ADG: LocalDisasterRecoveryType = LocalDisasterRecoveryType::known("ADG", 1);

        /// Backup based recovery.
        pub const BACKUP_BASED: LocalDisasterRecoveryType =
            LocalDisasterRecoveryType::known("BACKUP_BASED", 2);
    }

    impl LocalDisasterRecoveryType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for LocalDisasterRecoveryType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocalDisasterRecoveryType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(LocalDisasterRecoveryType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(LocalDisasterRecoveryType::from(val)),
                Enumeration::UnknownNum { str } => Ok(LocalDisasterRecoveryType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for LocalDisasterRecoveryType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED" => {
                    local_disaster_recovery_type::LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED
                }
                "ADG" => local_disaster_recovery_type::ADG,
                "BACKUP_BASED" => local_disaster_recovery_type::BACKUP_BASED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for LocalDisasterRecoveryType {
        fn from(value: i32) -> Self {
            match value {
                0 => local_disaster_recovery_type::LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED,
                1 => local_disaster_recovery_type::ADG,
                2 => local_disaster_recovery_type::BACKUP_BASED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for LocalDisasterRecoveryType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// Varies states of the Data Safe registration for the Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct DataSafeState(wkt::enumerations::Enumeration);

    /// Useful constants to work with [DataSafeState](DataSafeState)
    pub mod data_safe_state {
        use super::DataSafeState;

        /// Default unspecified value.
        pub const DATA_SAFE_STATE_UNSPECIFIED: DataSafeState =
            DataSafeState::known("DATA_SAFE_STATE_UNSPECIFIED", 0);

        /// Registering data safe state.
        pub const REGISTERING: DataSafeState = DataSafeState::known("REGISTERING", 1);

        /// Registered data safe state.
        pub const REGISTERED: DataSafeState = DataSafeState::known("REGISTERED", 2);

        /// Deregistering data safe state.
        pub const DEREGISTERING: DataSafeState = DataSafeState::known("DEREGISTERING", 3);

        /// Not registered data safe state.
        pub const NOT_REGISTERED: DataSafeState = DataSafeState::known("NOT_REGISTERED", 4);

        /// Failed data safe state.
        pub const FAILED: DataSafeState = DataSafeState::known("FAILED", 5);
    }

    impl DataSafeState {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for DataSafeState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataSafeState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(DataSafeState::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(DataSafeState::from(val)),
                Enumeration::UnknownNum { str } => Ok(DataSafeState::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for DataSafeState {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "DATA_SAFE_STATE_UNSPECIFIED" => data_safe_state::DATA_SAFE_STATE_UNSPECIFIED,
                "REGISTERING" => data_safe_state::REGISTERING,
                "REGISTERED" => data_safe_state::REGISTERED,
                "DEREGISTERING" => data_safe_state::DEREGISTERING,
                "NOT_REGISTERED" => data_safe_state::NOT_REGISTERED,
                "FAILED" => data_safe_state::FAILED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for DataSafeState {
        fn from(value: i32) -> Self {
            match value {
                0 => data_safe_state::DATA_SAFE_STATE_UNSPECIFIED,
                1 => data_safe_state::REGISTERING,
                2 => data_safe_state::REGISTERED,
                3 => data_safe_state::DEREGISTERING,
                4 => data_safe_state::NOT_REGISTERED,
                5 => data_safe_state::FAILED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for DataSafeState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The different states of database management for an Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct DatabaseManagementState(wkt::enumerations::Enumeration);

    /// Useful constants to work with [DatabaseManagementState](DatabaseManagementState)
    pub mod database_management_state {
        use super::DatabaseManagementState;

        /// Default unspecified value.
        pub const DATABASE_MANAGEMENT_STATE_UNSPECIFIED: DatabaseManagementState =
            DatabaseManagementState::known("DATABASE_MANAGEMENT_STATE_UNSPECIFIED", 0);

        /// Enabling Database Management state
        pub const ENABLING: DatabaseManagementState = DatabaseManagementState::known("ENABLING", 1);

        /// Enabled Database Management state
        pub const ENABLED: DatabaseManagementState = DatabaseManagementState::known("ENABLED", 2);

        /// Disabling Database Management state
        pub const DISABLING: DatabaseManagementState =
            DatabaseManagementState::known("DISABLING", 3);

        /// Not Enabled Database Management state
        pub const NOT_ENABLED: DatabaseManagementState =
            DatabaseManagementState::known("NOT_ENABLED", 4);

        /// Failed enabling Database Management state
        pub const FAILED_ENABLING: DatabaseManagementState =
            DatabaseManagementState::known("FAILED_ENABLING", 5);

        /// Failed disabling Database Management state
        pub const FAILED_DISABLING: DatabaseManagementState =
            DatabaseManagementState::known("FAILED_DISABLING", 6);
    }

    impl DatabaseManagementState {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for DatabaseManagementState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseManagementState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(DatabaseManagementState::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(DatabaseManagementState::from(val)),
                Enumeration::UnknownNum { str } => Ok(DatabaseManagementState::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for DatabaseManagementState {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "DATABASE_MANAGEMENT_STATE_UNSPECIFIED" => {
                    database_management_state::DATABASE_MANAGEMENT_STATE_UNSPECIFIED
                }
                "ENABLING" => database_management_state::ENABLING,
                "ENABLED" => database_management_state::ENABLED,
                "DISABLING" => database_management_state::DISABLING,
                "NOT_ENABLED" => database_management_state::NOT_ENABLED,
                "FAILED_ENABLING" => database_management_state::FAILED_ENABLING,
                "FAILED_DISABLING" => database_management_state::FAILED_DISABLING,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for DatabaseManagementState {
        fn from(value: i32) -> Self {
            match value {
                0 => database_management_state::DATABASE_MANAGEMENT_STATE_UNSPECIFIED,
                1 => database_management_state::ENABLING,
                2 => database_management_state::ENABLED,
                3 => database_management_state::DISABLING,
                4 => database_management_state::NOT_ENABLED,
                5 => database_management_state::FAILED_ENABLING,
                6 => database_management_state::FAILED_DISABLING,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for DatabaseManagementState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// This field indicates the modes of an Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct OpenMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [OpenMode](OpenMode)
    pub mod open_mode {
        use super::OpenMode;

        /// Default unspecified value.
        pub const OPEN_MODE_UNSPECIFIED: OpenMode = OpenMode::known("OPEN_MODE_UNSPECIFIED", 0);

        /// Read Only Mode
        pub const READ_ONLY: OpenMode = OpenMode::known("READ_ONLY", 1);

        /// Read Write Mode
        pub const READ_WRITE: OpenMode = OpenMode::known("READ_WRITE", 2);
    }

    impl OpenMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for OpenMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OpenMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(OpenMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(OpenMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(OpenMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for OpenMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "OPEN_MODE_UNSPECIFIED" => open_mode::OPEN_MODE_UNSPECIFIED,
                "READ_ONLY" => open_mode::READ_ONLY,
                "READ_WRITE" => open_mode::READ_WRITE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for OpenMode {
        fn from(value: i32) -> Self {
            match value {
                0 => open_mode::OPEN_MODE_UNSPECIFIED,
                1 => open_mode::READ_ONLY,
                2 => open_mode::READ_WRITE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for OpenMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The types of permission levels for an Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct PermissionLevel(wkt::enumerations::Enumeration);

    /// Useful constants to work with [PermissionLevel](PermissionLevel)
    pub mod permission_level {
        use super::PermissionLevel;

        /// Default unspecified value.
        pub const PERMISSION_LEVEL_UNSPECIFIED: PermissionLevel =
            PermissionLevel::known("PERMISSION_LEVEL_UNSPECIFIED", 0);

        /// Restricted mode allows access only by admin users.
        pub const RESTRICTED: PermissionLevel = PermissionLevel::known("RESTRICTED", 1);

        /// Normal access.
        pub const UNRESTRICTED: PermissionLevel = PermissionLevel::known("UNRESTRICTED", 2);
    }

    impl PermissionLevel {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for PermissionLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PermissionLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(PermissionLevel::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(PermissionLevel::from(val)),
                Enumeration::UnknownNum { str } => Ok(PermissionLevel::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for PermissionLevel {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "PERMISSION_LEVEL_UNSPECIFIED" => permission_level::PERMISSION_LEVEL_UNSPECIFIED,
                "RESTRICTED" => permission_level::RESTRICTED,
                "UNRESTRICTED" => permission_level::UNRESTRICTED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for PermissionLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => permission_level::PERMISSION_LEVEL_UNSPECIFIED,
                1 => permission_level::RESTRICTED,
                2 => permission_level::UNRESTRICTED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for PermissionLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The refresh mode of the cloned Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct RefreshableMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [RefreshableMode](RefreshableMode)
    pub mod refreshable_mode {
        use super::RefreshableMode;

        /// The default unspecified value.
        pub const REFRESHABLE_MODE_UNSPECIFIED: RefreshableMode =
            RefreshableMode::known("REFRESHABLE_MODE_UNSPECIFIED", 0);

        /// AUTOMATIC indicates that the cloned database is automatically
        /// refreshed with data from the source Autonomous Database.
        pub const AUTOMATIC: RefreshableMode = RefreshableMode::known("AUTOMATIC", 1);

        /// MANUAL indicates that the cloned database is manually refreshed with
        /// data from the source Autonomous Database.
        pub const MANUAL: RefreshableMode = RefreshableMode::known("MANUAL", 2);
    }

    impl RefreshableMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for RefreshableMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(RefreshableMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(RefreshableMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(RefreshableMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for RefreshableMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "REFRESHABLE_MODE_UNSPECIFIED" => refreshable_mode::REFRESHABLE_MODE_UNSPECIFIED,
                "AUTOMATIC" => refreshable_mode::AUTOMATIC,
                "MANUAL" => refreshable_mode::MANUAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for RefreshableMode {
        fn from(value: i32) -> Self {
            match value {
                0 => refreshable_mode::REFRESHABLE_MODE_UNSPECIFIED,
                1 => refreshable_mode::AUTOMATIC,
                2 => refreshable_mode::MANUAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for RefreshableMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The refresh state of the cloned Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct RefreshableState(wkt::enumerations::Enumeration);

    /// Useful constants to work with [RefreshableState](RefreshableState)
    pub mod refreshable_state {
        use super::RefreshableState;

        /// Default unspecified value.
        pub const REFRESHABLE_STATE_UNSPECIFIED: RefreshableState =
            RefreshableState::known("REFRESHABLE_STATE_UNSPECIFIED", 0);

        /// Refreshing
        pub const REFRESHING: RefreshableState = RefreshableState::known("REFRESHING", 1);

        /// Not refreshed
        pub const NOT_REFRESHING: RefreshableState = RefreshableState::known("NOT_REFRESHING", 2);
    }

    impl RefreshableState {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for RefreshableState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(RefreshableState::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(RefreshableState::from(val)),
                Enumeration::UnknownNum { str } => Ok(RefreshableState::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for RefreshableState {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "REFRESHABLE_STATE_UNSPECIFIED" => refreshable_state::REFRESHABLE_STATE_UNSPECIFIED,
                "REFRESHING" => refreshable_state::REFRESHING,
                "NOT_REFRESHING" => refreshable_state::NOT_REFRESHING,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for RefreshableState {
        fn from(value: i32) -> Self {
            match value {
                0 => refreshable_state::REFRESHABLE_STATE_UNSPECIFIED,
                1 => refreshable_state::REFRESHING,
                2 => refreshable_state::NOT_REFRESHING,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for RefreshableState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The Data Guard role of the Autonomous Database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Role(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Role](Role)
    pub mod role {
        use super::Role;

        /// Default unspecified value.
        pub const ROLE_UNSPECIFIED: Role = Role::known("ROLE_UNSPECIFIED", 0);

        /// Primary role
        pub const PRIMARY: Role = Role::known("PRIMARY", 1);

        /// Standby role
        pub const STANDBY: Role = Role::known("STANDBY", 2);

        /// Disabled standby role
        pub const DISABLED_STANDBY: Role = Role::known("DISABLED_STANDBY", 3);

        /// Backup copy role
        pub const BACKUP_COPY: Role = Role::known("BACKUP_COPY", 4);

        /// Snapshot standby role
        pub const SNAPSHOT_STANDBY: Role = Role::known("SNAPSHOT_STANDBY", 5);
    }

    impl Role {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Role::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Role::from(val)),
                Enumeration::UnknownNum { str } => Ok(Role::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Role {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "ROLE_UNSPECIFIED" => role::ROLE_UNSPECIFIED,
                "PRIMARY" => role::PRIMARY,
                "STANDBY" => role::STANDBY,
                "DISABLED_STANDBY" => role::DISABLED_STANDBY,
                "BACKUP_COPY" => role::BACKUP_COPY,
                "SNAPSHOT_STANDBY" => role::SNAPSHOT_STANDBY,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => role::ROLE_UNSPECIFIED,
                1 => role::PRIMARY,
                2 => role::STANDBY,
                3 => role::DISABLED_STANDBY,
                4 => role::BACKUP_COPY,
                5 => role::SNAPSHOT_STANDBY,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Oracle APEX Application Development.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseApex>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseApex {
    /// Output only. The Oracle APEX Application Development version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub apex_version: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ords_version: std::string::String,
}

impl AutonomousDatabaseApex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_version][crate::model::AutonomousDatabaseApex::apex_version].
    pub fn set_apex_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_version = v.into();
        self
    }

    /// Sets the value of [ords_version][crate::model::AutonomousDatabaseApex::ords_version].
    pub fn set_ords_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_version = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseApex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseApex"
    }
}

/// The connection string used to connect to the Autonomous Database.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionStrings>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionStrings {
    /// Output only. Returns all connection strings that can be used to connect to
    /// the Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub all_connection_strings: std::option::Option<crate::model::AllConnectionStrings>,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement, but supports the most number of concurrent SQL
    /// statements.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dedicated: std::string::String,

    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub medium: std::string::String,

    /// Output only. A list of connection string profiles to allow clients to
    /// group, filter, and select values based on the structured metadata.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub profiles: std::vec::Vec<crate::model::DatabaseConnectionStringProfile>,
}

impl AutonomousDatabaseConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_connection_strings][crate::model::AutonomousDatabaseConnectionStrings::all_connection_strings].
    pub fn set_all_connection_strings<
        T: std::convert::Into<std::option::Option<crate::model::AllConnectionStrings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.all_connection_strings = v.into();
        self
    }

    /// Sets the value of [dedicated][crate::model::AutonomousDatabaseConnectionStrings::dedicated].
    pub fn set_dedicated<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dedicated = v.into();
        self
    }

    /// Sets the value of [high][crate::model::AutonomousDatabaseConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AutonomousDatabaseConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AutonomousDatabaseConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [profiles][crate::model::AutonomousDatabaseConnectionStrings::profiles].
    pub fn set_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseConnectionStringProfile>,
    {
        use std::iter::Iterator;
        self.profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionStrings"
    }
}

/// The connection string profile to allow clients to group.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DatabaseConnectionStringProfile>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseConnectionStringProfile {
    /// Output only. The current consumer group being used by the connection.
    pub consumer_group: crate::model::database_connection_string_profile::ConsumerGroup,

    /// Output only. The display name for the database connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The host name format being currently used in connection
    /// string.
    pub host_format: crate::model::database_connection_string_profile::HostFormat,

    /// Output only. This field indicates if the connection string is regional and
    /// is only applicable for cross-region Data Guard.
    pub is_regional: bool,

    /// Output only. The protocol being used by the connection.
    pub protocol: crate::model::database_connection_string_profile::Protocol,

    /// Output only. The current session mode of the connection.
    pub session_mode: crate::model::database_connection_string_profile::SessionMode,

    /// Output only. The syntax of the connection string.
    pub syntax_format: crate::model::database_connection_string_profile::SyntaxFormat,

    /// Output only. This field indicates the TLS authentication type of the
    /// connection.
    pub tls_authentication: crate::model::database_connection_string_profile::TLSAuthentication,

    /// Output only. The value of the connection string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,
}

impl DatabaseConnectionStringProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consumer_group][crate::model::DatabaseConnectionStringProfile::consumer_group].
    pub fn set_consumer_group<
        T: std::convert::Into<crate::model::database_connection_string_profile::ConsumerGroup>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consumer_group = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DatabaseConnectionStringProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [host_format][crate::model::DatabaseConnectionStringProfile::host_format].
    pub fn set_host_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::HostFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.host_format = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::DatabaseConnectionStringProfile::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::DatabaseConnectionStringProfile::protocol].
    pub fn set_protocol<
        T: std::convert::Into<crate::model::database_connection_string_profile::Protocol>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [session_mode][crate::model::DatabaseConnectionStringProfile::session_mode].
    pub fn set_session_mode<
        T: std::convert::Into<crate::model::database_connection_string_profile::SessionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_mode = v.into();
        self
    }

    /// Sets the value of [syntax_format][crate::model::DatabaseConnectionStringProfile::syntax_format].
    pub fn set_syntax_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::SyntaxFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.syntax_format = v.into();
        self
    }

    /// Sets the value of [tls_authentication][crate::model::DatabaseConnectionStringProfile::tls_authentication].
    pub fn set_tls_authentication<
        T: std::convert::Into<crate::model::database_connection_string_profile::TLSAuthentication>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tls_authentication = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DatabaseConnectionStringProfile::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseConnectionStringProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile"
    }
}

/// Defines additional types related to DatabaseConnectionStringProfile
pub mod database_connection_string_profile {
    #[allow(unused_imports)]
    use super::*;

    /// The various consumer groups available in the connection string profile.
    #[derive(Clone, Debug, PartialEq)]
    pub struct ConsumerGroup(wkt::enumerations::Enumeration);

    /// Useful constants to work with [ConsumerGroup](ConsumerGroup)
    pub mod consumer_group {
        use super::ConsumerGroup;

        /// Default unspecified value.
        pub const CONSUMER_GROUP_UNSPECIFIED: ConsumerGroup =
            ConsumerGroup::known("CONSUMER_GROUP_UNSPECIFIED", 0);

        /// High consumer group.
        pub const HIGH: ConsumerGroup = ConsumerGroup::known("HIGH", 1);

        /// Medium consumer group.
        pub const MEDIUM: ConsumerGroup = ConsumerGroup::known("MEDIUM", 2);

        /// Low consumer group.
        pub const LOW: ConsumerGroup = ConsumerGroup::known("LOW", 3);

        /// TP consumer group.
        pub const TP: ConsumerGroup = ConsumerGroup::known("TP", 4);

        /// TPURGENT consumer group.
        pub const TPURGENT: ConsumerGroup = ConsumerGroup::known("TPURGENT", 5);
    }

    impl ConsumerGroup {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for ConsumerGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConsumerGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(ConsumerGroup::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(ConsumerGroup::from(val)),
                Enumeration::UnknownNum { str } => Ok(ConsumerGroup::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for ConsumerGroup {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "CONSUMER_GROUP_UNSPECIFIED" => consumer_group::CONSUMER_GROUP_UNSPECIFIED,
                "HIGH" => consumer_group::HIGH,
                "MEDIUM" => consumer_group::MEDIUM,
                "LOW" => consumer_group::LOW,
                "TP" => consumer_group::TP,
                "TPURGENT" => consumer_group::TPURGENT,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for ConsumerGroup {
        fn from(value: i32) -> Self {
            match value {
                0 => consumer_group::CONSUMER_GROUP_UNSPECIFIED,
                1 => consumer_group::HIGH,
                2 => consumer_group::MEDIUM,
                3 => consumer_group::LOW,
                4 => consumer_group::TP,
                5 => consumer_group::TPURGENT,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for ConsumerGroup {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The host name format being used in the connection string.
    #[derive(Clone, Debug, PartialEq)]
    pub struct HostFormat(wkt::enumerations::Enumeration);

    /// Useful constants to work with [HostFormat](HostFormat)
    pub mod host_format {
        use super::HostFormat;

        /// Default unspecified value.
        pub const HOST_FORMAT_UNSPECIFIED: HostFormat =
            HostFormat::known("HOST_FORMAT_UNSPECIFIED", 0);

        /// FQDN
        pub const FQDN: HostFormat = HostFormat::known("FQDN", 1);

        /// IP
        pub const IP: HostFormat = HostFormat::known("IP", 2);
    }

    impl HostFormat {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for HostFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HostFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(HostFormat::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(HostFormat::from(val)),
                Enumeration::UnknownNum { str } => Ok(HostFormat::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for HostFormat {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "HOST_FORMAT_UNSPECIFIED" => host_format::HOST_FORMAT_UNSPECIFIED,
                "FQDN" => host_format::FQDN,
                "IP" => host_format::IP,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for HostFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => host_format::HOST_FORMAT_UNSPECIFIED,
                1 => host_format::FQDN,
                2 => host_format::IP,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for HostFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The protocol being used by the connection.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Protocol(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Protocol](Protocol)
    pub mod protocol {
        use super::Protocol;

        /// Default unspecified value.
        pub const PROTOCOL_UNSPECIFIED: Protocol = Protocol::known("PROTOCOL_UNSPECIFIED", 0);

        /// Tcp
        pub const TCP: Protocol = Protocol::known("TCP", 1);

        /// Tcps
        pub const TCPS: Protocol = Protocol::known("TCPS", 2);
    }

    impl Protocol {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Protocol::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Protocol::from(val)),
                Enumeration::UnknownNum { str } => Ok(Protocol::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Protocol {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "PROTOCOL_UNSPECIFIED" => protocol::PROTOCOL_UNSPECIFIED,
                "TCP" => protocol::TCP,
                "TCPS" => protocol::TCPS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => protocol::PROTOCOL_UNSPECIFIED,
                1 => protocol::TCP,
                2 => protocol::TCPS,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The session mode of the connection.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SessionMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SessionMode](SessionMode)
    pub mod session_mode {
        use super::SessionMode;

        /// Default unspecified value.
        pub const SESSION_MODE_UNSPECIFIED: SessionMode =
            SessionMode::known("SESSION_MODE_UNSPECIFIED", 0);

        /// Direct
        pub const DIRECT: SessionMode = SessionMode::known("DIRECT", 1);

        /// Indirect
        pub const INDIRECT: SessionMode = SessionMode::known("INDIRECT", 2);
    }

    impl SessionMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SessionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SessionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SessionMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SessionMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(SessionMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SessionMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SESSION_MODE_UNSPECIFIED" => session_mode::SESSION_MODE_UNSPECIFIED,
                "DIRECT" => session_mode::DIRECT,
                "INDIRECT" => session_mode::INDIRECT,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SessionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => session_mode::SESSION_MODE_UNSPECIFIED,
                1 => session_mode::DIRECT,
                2 => session_mode::INDIRECT,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SessionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// Specifies syntax of the connection string.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SyntaxFormat(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SyntaxFormat](SyntaxFormat)
    pub mod syntax_format {
        use super::SyntaxFormat;

        /// Default unspecified value.
        pub const SYNTAX_FORMAT_UNSPECIFIED: SyntaxFormat =
            SyntaxFormat::known("SYNTAX_FORMAT_UNSPECIFIED", 0);

        /// Long
        pub const LONG: SyntaxFormat = SyntaxFormat::known("LONG", 1);

        /// Ezconnect
        pub const EZCONNECT: SyntaxFormat = SyntaxFormat::known("EZCONNECT", 2);

        /// Ezconnectplus
        pub const EZCONNECTPLUS: SyntaxFormat = SyntaxFormat::known("EZCONNECTPLUS", 3);
    }

    impl SyntaxFormat {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SyntaxFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SyntaxFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SyntaxFormat::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SyntaxFormat::from(val)),
                Enumeration::UnknownNum { str } => Ok(SyntaxFormat::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SyntaxFormat {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SYNTAX_FORMAT_UNSPECIFIED" => syntax_format::SYNTAX_FORMAT_UNSPECIFIED,
                "LONG" => syntax_format::LONG,
                "EZCONNECT" => syntax_format::EZCONNECT,
                "EZCONNECTPLUS" => syntax_format::EZCONNECTPLUS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SyntaxFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => syntax_format::SYNTAX_FORMAT_UNSPECIFIED,
                1 => syntax_format::LONG,
                2 => syntax_format::EZCONNECT,
                3 => syntax_format::EZCONNECTPLUS,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SyntaxFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// This field indicates the TLS authentication type of the connection.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TLSAuthentication(wkt::enumerations::Enumeration);

    /// Useful constants to work with [TLSAuthentication](TLSAuthentication)
    pub mod tls_authentication {
        use super::TLSAuthentication;

        /// Default unspecified value.
        pub const TLS_AUTHENTICATION_UNSPECIFIED: TLSAuthentication =
            TLSAuthentication::known("TLS_AUTHENTICATION_UNSPECIFIED", 0);

        /// Server
        pub const SERVER: TLSAuthentication = TLSAuthentication::known("SERVER", 1);

        /// Mutual
        pub const MUTUAL: TLSAuthentication = TLSAuthentication::known("MUTUAL", 2);
    }

    impl TLSAuthentication {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for TLSAuthentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TLSAuthentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(TLSAuthentication::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(TLSAuthentication::from(val)),
                Enumeration::UnknownNum { str } => Ok(TLSAuthentication::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for TLSAuthentication {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "TLS_AUTHENTICATION_UNSPECIFIED" => {
                    tls_authentication::TLS_AUTHENTICATION_UNSPECIFIED
                }
                "SERVER" => tls_authentication::SERVER,
                "MUTUAL" => tls_authentication::MUTUAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for TLSAuthentication {
        fn from(value: i32) -> Self {
            match value {
                0 => tls_authentication::TLS_AUTHENTICATION_UNSPECIFIED,
                1 => tls_authentication::SERVER,
                2 => tls_authentication::MUTUAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for TLSAuthentication {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// A list of all connection strings that can be used to connect to the
/// Autonomous Database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllConnectionStrings {
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub medium: std::string::String,
}

impl AllConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [high][crate::model::AllConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AllConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AllConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }
}

impl wkt::message::Message for AllConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AllConnectionStrings"
    }
}

/// The URLs for accessing Oracle Application Express (APEX) and SQL Developer
/// Web with a browser from a Compute instance.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionUrls>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionUrls {
    /// Output only. Oracle Application Express (APEX) URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub apex_uri: std::string::String,

    /// Output only. The URL of the Database Transforms for the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_transforms_uri: std::string::String,

    /// Output only. The URL of the Graph Studio for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub graph_studio_uri: std::string::String,

    /// Output only. The URL of the Oracle Machine Learning (OML) Notebook for the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_learning_notebook_uri: std::string::String,

    /// Output only. The URL of Machine Learning user management the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_learning_user_management_uri: std::string::String,

    /// Output only. The URL of the MongoDB API for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mongo_db_uri: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) URL of the Web Access for
    /// the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ords_uri: std::string::String,

    /// Output only. The URL of the Oracle SQL Developer Web for the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_dev_web_uri: std::string::String,
}

impl AutonomousDatabaseConnectionUrls {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_uri][crate::model::AutonomousDatabaseConnectionUrls::apex_uri].
    pub fn set_apex_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_uri = v.into();
        self
    }

    /// Sets the value of [database_transforms_uri][crate::model::AutonomousDatabaseConnectionUrls::database_transforms_uri].
    pub fn set_database_transforms_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_transforms_uri = v.into();
        self
    }

    /// Sets the value of [graph_studio_uri][crate::model::AutonomousDatabaseConnectionUrls::graph_studio_uri].
    pub fn set_graph_studio_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.graph_studio_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_notebook_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_notebook_uri].
    pub fn set_machine_learning_notebook_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_notebook_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_user_management_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_user_management_uri].
    pub fn set_machine_learning_user_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_user_management_uri = v.into();
        self
    }

    /// Sets the value of [mongo_db_uri][crate::model::AutonomousDatabaseConnectionUrls::mongo_db_uri].
    pub fn set_mongo_db_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mongo_db_uri = v.into();
        self
    }

    /// Sets the value of [ords_uri][crate::model::AutonomousDatabaseConnectionUrls::ords_uri].
    pub fn set_ords_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_uri = v.into();
        self
    }

    /// Sets the value of [sql_dev_web_uri][crate::model::AutonomousDatabaseConnectionUrls::sql_dev_web_uri].
    pub fn set_sql_dev_web_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_dev_web_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionUrls {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionUrls"
    }
}

/// Autonomous Data Guard standby database details.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseStandbySummary>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseStandbySummary {
    /// Output only. The amount of time, in seconds, that the data of the standby
    /// database lags in comparison to the data of the primary database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lag_time_duration: std::option::Option<wkt::Duration>,

    /// Output only. The additional details about the current lifecycle state of
    /// the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    pub state: crate::model::State,

    /// Output only. The date and time the Autonomous Data Guard role was switched
    /// for the standby Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_guard_role_changed_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the Disaster Recovery role was switched for
    /// the standby Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disaster_recovery_role_changed_time: std::option::Option<wkt::Timestamp>,
}

impl AutonomousDatabaseStandbySummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lag_time_duration][crate::model::AutonomousDatabaseStandbySummary::lag_time_duration].
    pub fn set_lag_time_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lag_time_duration = v.into();
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseStandbySummary::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseStandbySummary::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::data_guard_role_changed_time].
    pub fn set_data_guard_role_changed_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_guard_role_changed_time = v.into();
        self
    }

    /// Sets the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::disaster_recovery_role_changed_time].
    pub fn set_disaster_recovery_role_changed_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disaster_recovery_role_changed_time = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseStandbySummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseStandbySummary"
    }
}

/// Details of scheduled operation.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/ScheduledOperationDetails>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScheduledOperationDetails {
    /// Output only. Day of week.
    pub day_of_week: gtype::model::DayOfWeek,

    /// Output only. Auto start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Output only. Auto stop time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stop_time: std::option::Option<gtype::model::TimeOfDay>,
}

impl ScheduledOperationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_week][crate::model::ScheduledOperationDetails::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScheduledOperationDetails::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [stop_time][crate::model::ScheduledOperationDetails::stop_time].
    pub fn set_stop_time<T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.stop_time = v.into();
        self
    }
}

impl wkt::message::Message for ScheduledOperationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ScheduledOperationDetails"
    }
}

/// Details of the Autonomous Database character set resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseCharacterSet {
    /// Identifier. The name of the Autonomous Database Character Set resource in
    /// the following format:
    /// projects/{project}/locations/{region}/autonomousDatabaseCharacterSets/{autonomous_database_character_set}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The character set type for the Autonomous Database.
    pub character_set_type: crate::model::autonomous_database_character_set::CharacterSetType,

    /// Output only. The character set name for the Autonomous Database which is
    /// the ID in the resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub character_set: std::string::String,
}

impl AutonomousDatabaseCharacterSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseCharacterSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [character_set_type][crate::model::AutonomousDatabaseCharacterSet::character_set_type].
    pub fn set_character_set_type<
        T: std::convert::Into<crate::model::autonomous_database_character_set::CharacterSetType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.character_set_type = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseCharacterSet::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseCharacterSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseCharacterSet"
    }
}

/// Defines additional types related to AutonomousDatabaseCharacterSet
pub mod autonomous_database_character_set {
    #[allow(unused_imports)]
    use super::*;

    /// The type of character set an Autonomous Database can have.
    #[derive(Clone, Debug, PartialEq)]
    pub struct CharacterSetType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [CharacterSetType](CharacterSetType)
    pub mod character_set_type {
        use super::CharacterSetType;

        /// Character set type is not specified.
        pub const CHARACTER_SET_TYPE_UNSPECIFIED: CharacterSetType =
            CharacterSetType::known("CHARACTER_SET_TYPE_UNSPECIFIED", 0);

        /// Character set type is set to database.
        pub const DATABASE: CharacterSetType = CharacterSetType::known("DATABASE", 1);

        /// Character set type is set to national.
        pub const NATIONAL: CharacterSetType = CharacterSetType::known("NATIONAL", 2);
    }

    impl CharacterSetType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for CharacterSetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CharacterSetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(CharacterSetType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(CharacterSetType::from(val)),
                Enumeration::UnknownNum { str } => Ok(CharacterSetType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for CharacterSetType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => {
                    character_set_type::CHARACTER_SET_TYPE_UNSPECIFIED
                }
                "DATABASE" => character_set_type::DATABASE,
                "NATIONAL" => character_set_type::NATIONAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for CharacterSetType {
        fn from(value: i32) -> Self {
            match value {
                0 => character_set_type::CHARACTER_SET_TYPE_UNSPECIFIED,
                1 => character_set_type::DATABASE,
                2 => character_set_type::NATIONAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for CharacterSetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Details of the Autonomous Database Backup resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseBackup/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseBackup {
    /// Identifier. The name of the Autonomous Database Backup resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabaseBackups/{autonomous_database_backup}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The name of the Autonomous Database resource for which the backup
    /// is being created. Format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub autonomous_database: std::string::String,

    /// Optional. User friendly name for the Backup. The name does not have to be
    /// unique.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Various properties of the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::AutonomousDatabaseBackupProperties>,

    /// Optional. labels or tags associated with the resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl AutonomousDatabaseBackup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseBackup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::AutonomousDatabaseBackup::autonomous_database].
    pub fn set_autonomous_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabaseBackup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabaseBackup::properties].
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::AutonomousDatabaseBackupProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabaseBackup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackup"
    }
}

/// Properties of the Autonomous Database Backup resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseBackupProperties {
    /// Output only. OCID of the Autonomous Database backup.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ocid: std::string::String,

    /// Optional. Retention period in days for the backup.
    pub retention_period_days: i32,

    /// Output only. The OCID of the compartment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub compartment_id: std::string::String,

    /// Output only. The quantity of data in the database, in terabytes.
    pub database_size_tb: f32,

    /// Output only. A valid Oracle Database version for Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub db_version: std::string::String,

    /// Output only. Indicates if the backup is long term backup.
    pub is_long_term_backup: bool,

    /// Output only. Indicates if the backup is automatic or user initiated.
    pub is_automatic_backup: bool,

    /// Output only. Indicates if the backup can be used to restore the Autonomous
    /// Database.
    pub is_restorable: bool,

    /// Optional. The OCID of the key store of Oracle Vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_store_id: std::string::String,

    /// Optional. The wallet name for Oracle Key Vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_store_wallet: std::string::String,

    /// Optional. The OCID of the key container that is used as the master
    /// encryption key in database transparent data encryption (TDE) operations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_id: std::string::String,

    /// Optional. The OCID of the key container version that is used in database
    /// transparent data encryption (TDE) operations KMS Key can have multiple key
    /// versions. If none is specified, the current key version (latest) of the Key
    /// Id is used for the operation. Autonomous Database Serverless does not use
    /// key versions, hence is not applicable for Autonomous Database Serverless
    /// instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_id: std::string::String,

    /// Output only. Additional information about the current lifecycle state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lifecycle_details: std::string::String,

    /// Output only. The lifecycle state of the backup.
    pub lifecycle_state: crate::model::autonomous_database_backup_properties::State,

    /// Output only. The backup size in terabytes.
    pub size_tb: f32,

    /// Output only. Timestamp until when the backup will be available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub available_till_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The type of the backup.
    #[serde(rename = "type")]
    pub r#type: crate::model::autonomous_database_backup_properties::Type,

    /// Optional. The OCID of the vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vault_id: std::string::String,
}

impl AutonomousDatabaseBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseBackupProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [retention_period_days][crate::model::AutonomousDatabaseBackupProperties::retention_period_days].
    pub fn set_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_period_days = v.into();
        self
    }

    /// Sets the value of [compartment_id][crate::model::AutonomousDatabaseBackupProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [database_size_tb][crate::model::AutonomousDatabaseBackupProperties::database_size_tb].
    pub fn set_database_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.database_size_tb = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseBackupProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_long_term_backup][crate::model::AutonomousDatabaseBackupProperties::is_long_term_backup].
    pub fn set_is_long_term_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_long_term_backup = v.into();
        self
    }

    /// Sets the value of [is_automatic_backup][crate::model::AutonomousDatabaseBackupProperties::is_automatic_backup].
    pub fn set_is_automatic_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_automatic_backup = v.into();
        self
    }

    /// Sets the value of [is_restorable][crate::model::AutonomousDatabaseBackupProperties::is_restorable].
    pub fn set_is_restorable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_restorable = v.into();
        self
    }

    /// Sets the value of [key_store_id][crate::model::AutonomousDatabaseBackupProperties::key_store_id].
    pub fn set_key_store_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_store_id = v.into();
        self
    }

    /// Sets the value of [key_store_wallet][crate::model::AutonomousDatabaseBackupProperties::key_store_wallet].
    pub fn set_key_store_wallet<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_store_wallet = v.into();
        self
    }

    /// Sets the value of [kms_key_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_id].
    pub fn set_kms_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_id = v.into();
        self
    }

    /// Sets the value of [kms_key_version_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_version_id].
    pub fn set_kms_key_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_id = v.into();
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseBackupProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::AutonomousDatabaseBackupProperties::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [size_tb][crate::model::AutonomousDatabaseBackupProperties::size_tb].
    pub fn set_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.size_tb = v.into();
        self
    }

    /// Sets the value of [available_till_time][crate::model::AutonomousDatabaseBackupProperties::available_till_time].
    pub fn set_available_till_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.available_till_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::AutonomousDatabaseBackupProperties::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::AutonomousDatabaseBackupProperties::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::AutonomousDatabaseBackupProperties::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseBackupProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties"
    }
}

/// Defines additional types related to AutonomousDatabaseBackupProperties
pub mod autonomous_database_backup_properties {
    #[allow(unused_imports)]
    use super::*;

    /// // The various lifecycle states of the Autonomous Database Backup.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default unspecified value.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// Indicates that the resource is in creating state.
        pub const CREATING: State = State::known("CREATING", 1);

        /// Indicates that the resource is in active state.
        pub const ACTIVE: State = State::known("ACTIVE", 2);

        /// Indicates that the resource is in deleting state.
        pub const DELETING: State = State::known("DELETING", 3);

        /// Indicates that the resource is in deleted state.
        pub const DELETED: State = State::known("DELETED", 4);

        /// Indicates that the resource is in failed state.
        pub const FAILED: State = State::known("FAILED", 6);

        /// Indicates that the resource is in updating state.
        pub const UPDATING: State = State::known("UPDATING", 7);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "CREATING" => state::CREATING,
                "ACTIVE" => state::ACTIVE,
                "DELETING" => state::DELETING,
                "DELETED" => state::DELETED,
                "FAILED" => state::FAILED,
                "UPDATING" => state::UPDATING,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::CREATING,
                2 => state::ACTIVE,
                3 => state::DELETING,
                4 => state::DELETED,
                6 => state::FAILED,
                7 => state::UPDATING,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The type of the backup.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Type(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// Default unspecified value.
        pub const TYPE_UNSPECIFIED: Type = Type::known("TYPE_UNSPECIFIED", 0);

        /// Incremental backups.
        pub const INCREMENTAL: Type = Type::known("INCREMENTAL", 1);

        /// Full backups.
        pub const FULL: Type = Type::known("FULL", 2);

        /// Long term backups.
        pub const LONG_TERM: Type = Type::known("LONG_TERM", 3);
    }

    impl Type {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Type::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Type::from(val)),
                Enumeration::UnknownNum { str } => Ok(Type::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "TYPE_UNSPECIFIED" => r#type::TYPE_UNSPECIFIED,
                "INCREMENTAL" => r#type::INCREMENTAL,
                "FULL" => r#type::FULL,
                "LONG_TERM" => r#type::LONG_TERM,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => r#type::TYPE_UNSPECIFIED,
                1 => r#type::INCREMENTAL,
                2 => r#type::FULL,
                3 => r#type::LONG_TERM,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Details of the Autonomous Database version.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDbVersionSummary/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDbVersion {
    /// Identifier. The name of the Autonomous Database Version resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDbVersions/{autonomous_db_version}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. An Oracle Database version for Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The Autonomous Database workload type.
    pub db_workload: crate::model::DBWorkload,

    /// Output only. A URL that points to a detailed description of the Autonomous
    /// Database version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workload_uri: std::string::String,
}

impl AutonomousDbVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDbVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AutonomousDbVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDbVersion::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [workload_uri][crate::model::AutonomousDbVersion::workload_uri].
    pub fn set_workload_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDbVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDbVersion"
    }
}

/// The CustomerContact reference as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/CustomerContact>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerContact {
    /// Required. The email address used by Oracle to send notifications regarding
    /// databases and infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,
}

impl CustomerContact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::CustomerContact::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for CustomerContact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CustomerContact"
    }
}

/// Details of the database node resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbNode/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbNode {
    /// Identifier. The name of the database node resource in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}/dbNodes/{db_node}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Various properties of the database node.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::DbNodeProperties>,
}

impl DbNode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbNode::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbNode::properties].
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::DbNodeProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }
}

impl wkt::message::Message for DbNode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNode"
    }
}

/// Various properties and settings associated with Db node.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbNodeProperties {
    /// Output only. OCID of database node.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ocid: std::string::String,

    /// Optional. OCPU count per database node.
    pub ocpu_count: i32,

    /// Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Local storage per database node.
    pub db_node_storage_size_gb: i32,

    /// Optional. Database server OCID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub db_server_ocid: std::string::String,

    /// Optional. DNS
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Output only. State of the database node.
    pub state: crate::model::db_node_properties::State,

    /// Total CPU core count of the database node.
    pub total_cpu_core_count: i32,
}

impl DbNodeProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbNodeProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbNodeProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbNodeProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbNodeProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_server_ocid][crate::model::DbNodeProperties::db_server_ocid].
    pub fn set_db_server_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_server_ocid = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::DbNodeProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbNodeProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_node_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [total_cpu_core_count][crate::model::DbNodeProperties::total_cpu_core_count].
    pub fn set_total_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_cpu_core_count = v.into();
        self
    }
}

impl wkt::message::Message for DbNodeProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNodeProperties"
    }
}

/// Defines additional types related to DbNodeProperties
pub mod db_node_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database node.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default unspecified value.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// Indicates that the resource is in provisioning state.
        pub const PROVISIONING: State = State::known("PROVISIONING", 1);

        /// Indicates that the resource is in available state.
        pub const AVAILABLE: State = State::known("AVAILABLE", 2);

        /// Indicates that the resource is in updating state.
        pub const UPDATING: State = State::known("UPDATING", 3);

        /// Indicates that the resource is in stopping state.
        pub const STOPPING: State = State::known("STOPPING", 4);

        /// Indicates that the resource is in stopped state.
        pub const STOPPED: State = State::known("STOPPED", 5);

        /// Indicates that the resource is in starting state.
        pub const STARTING: State = State::known("STARTING", 6);

        /// Indicates that the resource is in terminating state.
        pub const TERMINATING: State = State::known("TERMINATING", 7);

        /// Indicates that the resource is in terminated state.
        pub const TERMINATED: State = State::known("TERMINATED", 8);

        /// Indicates that the resource is in failed state.
        pub const FAILED: State = State::known("FAILED", 9);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "PROVISIONING" => state::PROVISIONING,
                "AVAILABLE" => state::AVAILABLE,
                "UPDATING" => state::UPDATING,
                "STOPPING" => state::STOPPING,
                "STOPPED" => state::STOPPED,
                "STARTING" => state::STARTING,
                "TERMINATING" => state::TERMINATING,
                "TERMINATED" => state::TERMINATED,
                "FAILED" => state::FAILED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::PROVISIONING,
                2 => state::AVAILABLE,
                3 => state::UPDATING,
                4 => state::STOPPING,
                5 => state::STOPPED,
                6 => state::STARTING,
                7 => state::TERMINATING,
                8 => state::TERMINATED,
                9 => state::FAILED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Details of the database server resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbServer/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbServer {
    /// Identifier. The name of the database server resource with the format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}/dbServers/{db_server}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Various properties of the database server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::DbServerProperties>,
}

impl DbServer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbServer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DbServer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbServer::properties].
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::DbServerProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }
}

impl wkt::message::Message for DbServer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServer"
    }
}

/// Various properties and settings associated with Exadata database server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbServerProperties {
    /// Output only. OCID of database server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ocid: std::string::String,

    /// Optional. OCPU count per database.
    pub ocpu_count: i32,

    /// Optional. Maximum OCPU count per database.
    pub max_ocpu_count: i32,

    /// Optional. Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Maximum memory allocated in GBs.
    pub max_memory_size_gb: i32,

    /// Optional. Local storage per VM.
    pub db_node_storage_size_gb: i32,

    /// Optional. Maximum local storage per VM.
    pub max_db_node_storage_size_gb: i32,

    /// Optional. Vm count per database.
    pub vm_count: i32,

    /// Output only. State of the database server.
    pub state: crate::model::db_server_properties::State,

    /// Output only. OCID of database nodes associated with the database server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub db_node_ids: std::vec::Vec<std::string::String>,
}

impl DbServerProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbServerProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbServerProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [max_ocpu_count][crate::model::DbServerProperties::max_ocpu_count].
    pub fn set_max_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbServerProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_size_gb][crate::model::DbServerProperties::max_memory_size_gb].
    pub fn set_max_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbServerProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::DbServerProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [vm_count][crate::model::DbServerProperties::vm_count].
    pub fn set_vm_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbServerProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_server_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [db_node_ids][crate::model::DbServerProperties::db_node_ids].
    pub fn set_db_node_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_node_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DbServerProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServerProperties"
    }
}

/// Defines additional types related to DbServerProperties
pub mod db_server_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database server.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default unspecified value.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// Indicates that the resource is in creating state.
        pub const CREATING: State = State::known("CREATING", 1);

        /// Indicates that the resource is in available state.
        pub const AVAILABLE: State = State::known("AVAILABLE", 2);

        /// Indicates that the resource is in unavailable state.
        pub const UNAVAILABLE: State = State::known("UNAVAILABLE", 3);

        /// Indicates that the resource is in deleting state.
        pub const DELETING: State = State::known("DELETING", 4);

        /// Indicates that the resource is in deleted state.
        pub const DELETED: State = State::known("DELETED", 5);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "CREATING" => state::CREATING,
                "AVAILABLE" => state::AVAILABLE,
                "UNAVAILABLE" => state::UNAVAILABLE,
                "DELETING" => state::DELETING,
                "DELETED" => state::DELETED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::CREATING,
                2 => state::AVAILABLE,
                3 => state::UNAVAILABLE,
                4 => state::DELETING,
                5 => state::DELETED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Details of the Database System Shapes resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystemShapeSummary/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbSystemShape {
    /// Identifier. The name of the Database System Shape resource with the format:
    /// projects/{project}/locations/{region}/dbSystemShapes/{db_system_shape}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. shape
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub shape: std::string::String,

    /// Optional. Minimum number of database servers.
    pub min_node_count: i32,

    /// Optional. Maximum number of database servers.
    pub max_node_count: i32,

    /// Optional. Minimum number of storage servers.
    pub min_storage_count: i32,

    /// Optional. Maximum number of storage servers.
    pub max_storage_count: i32,

    /// Optional. Number of cores per node.
    pub available_core_count_per_node: i32,

    /// Optional. Memory per database server node in gigabytes.
    pub available_memory_per_node_gb: i32,

    /// Optional. Storage per storage server in terabytes.
    pub available_data_storage_tb: i32,

    /// Optional. Minimum core count per node.
    pub min_core_count_per_node: i32,

    /// Optional. Minimum memory per node in gigabytes.
    pub min_memory_per_node_gb: i32,

    /// Optional. Minimum node storage per database server in gigabytes.
    pub min_db_node_storage_per_node_gb: i32,
}

impl DbSystemShape {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbSystemShape::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::DbSystemShape::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [min_node_count][crate::model::DbSystemShape::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::DbSystemShape::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }

    /// Sets the value of [min_storage_count][crate::model::DbSystemShape::min_storage_count].
    pub fn set_min_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_storage_count = v.into();
        self
    }

    /// Sets the value of [max_storage_count][crate::model::DbSystemShape::max_storage_count].
    pub fn set_max_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_storage_count = v.into();
        self
    }

    /// Sets the value of [available_core_count_per_node][crate::model::DbSystemShape::available_core_count_per_node].
    pub fn set_available_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [available_memory_per_node_gb][crate::model::DbSystemShape::available_memory_per_node_gb].
    pub fn set_available_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [available_data_storage_tb][crate::model::DbSystemShape::available_data_storage_tb].
    pub fn set_available_data_storage_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [min_core_count_per_node][crate::model::DbSystemShape::min_core_count_per_node].
    pub fn set_min_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [min_memory_per_node_gb][crate::model::DbSystemShape::min_memory_per_node_gb].
    pub fn set_min_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [min_db_node_storage_per_node_gb][crate::model::DbSystemShape::min_db_node_storage_per_node_gb].
    pub fn set_min_db_node_storage_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_db_node_storage_per_node_gb = v.into();
        self
    }
}

impl wkt::message::Message for DbSystemShape {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemShape"
    }
}

/// Details of the Entitlement resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entitlement {
    /// Identifier. The name of the Entitlement resource with the format:
    /// projects/{project}/locations/{region}/entitlements/{entitlement}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Details of the OCI Cloud Account.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_account_details: std::option::Option<crate::model::CloudAccountDetails>,

    /// Output only. Google Cloud Marketplace order ID (aka entitlement ID)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entitlement_id: std::string::String,

    /// Output only. Entitlement State.
    pub state: crate::model::entitlement::State,
}

impl Entitlement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entitlement::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cloud_account_details][crate::model::Entitlement::cloud_account_details].
    pub fn set_cloud_account_details<
        T: std::convert::Into<std::option::Option<crate::model::CloudAccountDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_account_details = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::Entitlement::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Entitlement::state].
    pub fn set_state<T: std::convert::Into<crate::model::entitlement::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Entitlement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.Entitlement"
    }
}

/// Defines additional types related to Entitlement
pub mod entitlement {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the subscription.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default unspecified value.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// Account not linked.
        pub const ACCOUNT_NOT_LINKED: State = State::known("ACCOUNT_NOT_LINKED", 1);

        /// Account is linked but not active.
        pub const ACCOUNT_NOT_ACTIVE: State = State::known("ACCOUNT_NOT_ACTIVE", 2);

        /// Entitlement and Account are active.
        pub const ACTIVE: State = State::known("ACTIVE", 3);

        /// Account is suspended.
        pub const ACCOUNT_SUSPENDED: State = State::known("ACCOUNT_SUSPENDED", 4);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "ACCOUNT_NOT_LINKED" => state::ACCOUNT_NOT_LINKED,
                "ACCOUNT_NOT_ACTIVE" => state::ACCOUNT_NOT_ACTIVE,
                "ACTIVE" => state::ACTIVE,
                "ACCOUNT_SUSPENDED" => state::ACCOUNT_SUSPENDED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::ACCOUNT_NOT_LINKED,
                2 => state::ACCOUNT_NOT_ACTIVE,
                3 => state::ACTIVE,
                4 => state::ACCOUNT_SUSPENDED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Details of the OCI Cloud Account.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudAccountDetails {
    /// Output only. OCI account name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_account: std::string::String,

    /// Output only. OCI account home region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_account_home_region: std::string::String,

    /// Output only. URL to link an existing account.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub link_existing_account_uri: std::option::Option<std::string::String>,

    /// Output only. URL to create a new account and link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub account_creation_uri: std::option::Option<std::string::String>,
}

impl CloudAccountDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_account][crate::model::CloudAccountDetails::cloud_account].
    pub fn set_cloud_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_account = v.into();
        self
    }

    /// Sets the value of [cloud_account_home_region][crate::model::CloudAccountDetails::cloud_account_home_region].
    pub fn set_cloud_account_home_region<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_account_home_region = v.into();
        self
    }

    /// Sets the value of [link_existing_account_uri][crate::model::CloudAccountDetails::link_existing_account_uri].
    pub fn set_link_existing_account_uri<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.link_existing_account_uri = v.into();
        self
    }

    /// Sets the value of [account_creation_uri][crate::model::CloudAccountDetails::account_creation_uri].
    pub fn set_account_creation_uri<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.account_creation_uri = v.into();
        self
    }
}

impl wkt::message::Message for CloudAccountDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudAccountDetails"
    }
}

/// Represents CloudExadataInfrastructure resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudExadataInfrastructure/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudExadataInfrastructure {
    /// Identifier. The name of the Exadata Infrastructure resource with the
    /// format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Google Cloud Platform location where Oracle Exadata is hosted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_oracle_zone: std::string::String,

    /// Output only. Entitlement ID of the private offer against which this
    /// infrastructure resource is provisioned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entitlement_id: std::string::String,

    /// Optional. Various properties of the infra.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::CloudExadataInfrastructureProperties>,

    /// Optional. Labels or tags associated with the resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the Exadata Infrastructure was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,
}

impl CloudExadataInfrastructure {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudExadataInfrastructure::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudExadataInfrastructure::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudExadataInfrastructure::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::CloudExadataInfrastructure::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudExadataInfrastructure::properties].
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::CloudExadataInfrastructureProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudExadataInfrastructure::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CloudExadataInfrastructure::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructure {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructure"
    }
}

/// Various properties of Exadata Infrastructure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudExadataInfrastructureProperties {
    /// Output only. OCID of created infra.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Exadata Infrastructure.
    pub compute_count: i32,

    /// Optional. The number of Cloud Exadata storage servers for the Exadata
    /// Infrastructure.
    pub storage_count: i32,

    /// Optional. The total storage allocated to the Exadata Infrastructure
    /// resource, in gigabytes (GB).
    pub total_storage_size_gb: i32,

    /// Output only. The available storage can be allocated to the Exadata
    /// Infrastructure resource, in gigabytes (GB).
    pub available_storage_size_gb: i32,

    /// Optional. Maintenance window for repair.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Output only. The current lifecycle state of the Exadata Infrastructure.
    pub state: crate::model::cloud_exadata_infrastructure_properties::State,

    /// Required. The shape of the Exadata Infrastructure. The shape determines the
    /// amount of CPU, storage, and memory resources allocated to the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub shape: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oci_url: std::string::String,

    /// Output only. The number of enabled CPU cores.
    pub cpu_count: i32,

    /// Output only. The total number of CPU cores available.
    pub max_cpu_count: i32,

    /// Output only. The memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Output only. The total memory available in GBs.
    pub max_memory_gb: i32,

    /// Output only. The local node storage allocated in GBs.
    pub db_node_storage_size_gb: i32,

    /// Output only. The total local node storage available in GBs.
    pub max_db_node_storage_size_gb: i32,

    /// Output only. Size, in terabytes, of the DATA disk group.
    pub data_storage_size_tb: f64,

    /// Output only. The total available DATA disk group size.
    pub max_data_storage_tb: f64,

    /// Output only. The requested number of additional storage servers activated
    /// for the Exadata Infrastructure.
    pub activated_storage_count: i32,

    /// Output only. The requested number of additional storage servers for the
    /// Exadata Infrastructure.
    pub additional_storage_count: i32,

    /// Output only. The software version of the database servers (dom0) in the
    /// Exadata Infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub db_server_version: std::string::String,

    /// Output only. The software version of the storage servers (cells) in the
    /// Exadata Infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_server_version: std::string::String,

    /// Output only. The OCID of the next maintenance run.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_maintenance_run_id: std::string::String,

    /// Output only. The time when the next maintenance run will occur.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the next security maintenance run will occur.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_security_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of customer contacts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Output only. The monthly software version of the storage servers (cells)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub monthly_storage_server_version: std::string::String,

    /// Output only. The monthly software version of the database servers (dom0)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub monthly_db_server_version: std::string::String,
}

impl CloudExadataInfrastructureProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudExadataInfrastructureProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::CloudExadataInfrastructureProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [storage_count][crate::model::CloudExadataInfrastructureProperties::storage_count].
    pub fn set_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_count = v.into();
        self
    }

    /// Sets the value of [total_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::total_storage_size_gb].
    pub fn set_total_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [available_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::available_storage_size_gb].
    pub fn set_available_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::CloudExadataInfrastructureProperties::maintenance_window].
    pub fn set_maintenance_window<
        T: std::convert::Into<std::option::Option<crate::model::MaintenanceWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_window = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CloudExadataInfrastructureProperties::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::cloud_exadata_infrastructure_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudExadataInfrastructureProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudExadataInfrastructureProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::CloudExadataInfrastructureProperties::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [max_cpu_count][crate::model::CloudExadataInfrastructureProperties::max_cpu_count].
    pub fn set_max_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudExadataInfrastructureProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_gb][crate::model::CloudExadataInfrastructureProperties::max_memory_gb].
    pub fn set_max_memory_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudExadataInfrastructureProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [max_data_storage_tb][crate::model::CloudExadataInfrastructureProperties::max_data_storage_tb].
    pub fn set_max_data_storage_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [activated_storage_count][crate::model::CloudExadataInfrastructureProperties::activated_storage_count].
    pub fn set_activated_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.activated_storage_count = v.into();
        self
    }

    /// Sets the value of [additional_storage_count][crate::model::CloudExadataInfrastructureProperties::additional_storage_count].
    pub fn set_additional_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.additional_storage_count = v.into();
        self
    }

    /// Sets the value of [db_server_version][crate::model::CloudExadataInfrastructureProperties::db_server_version].
    pub fn set_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_server_version = v.into();
        self
    }

    /// Sets the value of [storage_server_version][crate::model::CloudExadataInfrastructureProperties::storage_server_version].
    pub fn set_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_server_version = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_id][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_id].
    pub fn set_next_maintenance_run_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_maintenance_run_id = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_time].
    pub fn set_next_maintenance_run_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.next_maintenance_run_time = v.into();
        self
    }

    /// Sets the value of [next_security_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_security_maintenance_run_time].
    pub fn set_next_security_maintenance_run_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.next_security_maintenance_run_time = v.into();
        self
    }

    /// Sets the value of [monthly_storage_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_storage_server_version].
    pub fn set_monthly_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_storage_server_version = v.into();
        self
    }

    /// Sets the value of [monthly_db_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_db_server_version].
    pub fn set_monthly_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_db_server_version = v.into();
        self
    }

    /// Sets the value of [customer_contacts][crate::model::CloudExadataInfrastructureProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructureProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructureProperties"
    }
}

/// Defines additional types related to CloudExadataInfrastructureProperties
pub mod cloud_exadata_infrastructure_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the Exadata Infrastructure.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default unspecified value.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// The Exadata Infrastructure is being provisioned.
        pub const PROVISIONING: State = State::known("PROVISIONING", 1);

        /// The Exadata Infrastructure is available for use.
        pub const AVAILABLE: State = State::known("AVAILABLE", 2);

        /// The Exadata Infrastructure is being updated.
        pub const UPDATING: State = State::known("UPDATING", 3);

        /// The Exadata Infrastructure is being terminated.
        pub const TERMINATING: State = State::known("TERMINATING", 4);

        /// The Exadata Infrastructure is terminated.
        pub const TERMINATED: State = State::known("TERMINATED", 5);

        /// The Exadata Infrastructure is in failed state.
        pub const FAILED: State = State::known("FAILED", 6);

        /// The Exadata Infrastructure is in maintenance.
        pub const MAINTENANCE_IN_PROGRESS: State = State::known("MAINTENANCE_IN_PROGRESS", 7);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "PROVISIONING" => state::PROVISIONING,
                "AVAILABLE" => state::AVAILABLE,
                "UPDATING" => state::UPDATING,
                "TERMINATING" => state::TERMINATING,
                "TERMINATED" => state::TERMINATED,
                "FAILED" => state::FAILED,
                "MAINTENANCE_IN_PROGRESS" => state::MAINTENANCE_IN_PROGRESS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::PROVISIONING,
                2 => state::AVAILABLE,
                3 => state::UPDATING,
                4 => state::TERMINATING,
                5 => state::TERMINATED,
                6 => state::FAILED,
                7 => state::MAINTENANCE_IN_PROGRESS,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Maintenance window as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/MaintenanceWindow>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Optional. The maintenance window scheduling preference.
    pub preference: crate::model::maintenance_window::MaintenanceWindowPreference,

    /// Optional. Months during the year when maintenance should be performed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub months: std::vec::Vec<gtype::model::Month>,

    /// Optional. Weeks during the month when maintenance should be performed.
    /// Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a
    /// duration of 7 days. Weeks start and end based on calendar dates, not days
    /// of the week.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub weeks_of_month: std::vec::Vec<i32>,

    /// Optional. Days during the week when maintenance should be performed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. The window of hours during the day when maintenance should be
    /// performed. The window is a 4 hour slot. Valid values are:
    /// 0 - represents time slot 0:00 - 3:59 UTC
    /// 4 - represents time slot 4:00 - 7:59 UTC
    /// 8 - represents time slot 8:00 - 11:59 UTC
    /// 12 - represents time slot 12:00 - 15:59 UTC
    /// 16 - represents time slot 16:00 - 19:59 UTC
    /// 20 - represents time slot 20:00 - 23:59 UTC
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hours_of_day: std::vec::Vec<i32>,

    /// Optional. Lead time window allows user to set a lead time to prepare for a
    /// down time. The lead time is in weeks and valid value is between 1 to 4.
    pub lead_time_week: i32,

    /// Optional. Cloud CloudExadataInfrastructure node patching method, either
    /// "ROLLING"
    /// or "NONROLLING". Default value is ROLLING.
    pub patching_mode: crate::model::maintenance_window::PatchingMode,

    /// Optional. Determines the amount of time the system will wait before the
    /// start of each database server patching operation. Custom action timeout is
    /// in minutes and valid value is between 15 to 120 (inclusive).
    pub custom_action_timeout_mins: i32,

    /// Optional. If true, enables the configuration of a custom action timeout
    /// (waiting period) between database server patching operations.
    pub is_custom_action_timeout_enabled: bool,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preference][crate::model::MaintenanceWindow::preference].
    pub fn set_preference<
        T: std::convert::Into<crate::model::maintenance_window::MaintenanceWindowPreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preference = v.into();
        self
    }

    /// Sets the value of [lead_time_week][crate::model::MaintenanceWindow::lead_time_week].
    pub fn set_lead_time_week<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lead_time_week = v.into();
        self
    }

    /// Sets the value of [patching_mode][crate::model::MaintenanceWindow::patching_mode].
    pub fn set_patching_mode<
        T: std::convert::Into<crate::model::maintenance_window::PatchingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patching_mode = v.into();
        self
    }

    /// Sets the value of [custom_action_timeout_mins][crate::model::MaintenanceWindow::custom_action_timeout_mins].
    pub fn set_custom_action_timeout_mins<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.custom_action_timeout_mins = v.into();
        self
    }

    /// Sets the value of [is_custom_action_timeout_enabled][crate::model::MaintenanceWindow::is_custom_action_timeout_enabled].
    pub fn set_is_custom_action_timeout_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_custom_action_timeout_enabled = v.into();
        self
    }

    /// Sets the value of [months][crate::model::MaintenanceWindow::months].
    pub fn set_months<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::Month>,
    {
        use std::iter::Iterator;
        self.months = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [weeks_of_month][crate::model::MaintenanceWindow::weeks_of_month].
    pub fn set_weeks_of_month<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.weeks_of_month = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [days_of_week][crate::model::MaintenanceWindow::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hours_of_day][crate::model::MaintenanceWindow::hours_of_day].
    pub fn set_hours_of_day<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.hours_of_day = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.MaintenanceWindow"
    }
}

/// Defines additional types related to MaintenanceWindow
pub mod maintenance_window {
    #[allow(unused_imports)]
    use super::*;

    /// Maintenance window preference.
    #[derive(Clone, Debug, PartialEq)]
    pub struct MaintenanceWindowPreference(wkt::enumerations::Enumeration);

    /// Useful constants to work with [MaintenanceWindowPreference](MaintenanceWindowPreference)
    pub mod maintenance_window_preference {
        use super::MaintenanceWindowPreference;

        /// Default unspecified value.
        pub const MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED: MaintenanceWindowPreference =
            MaintenanceWindowPreference::known("MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED", 0);

        /// Custom preference.
        pub const CUSTOM_PREFERENCE: MaintenanceWindowPreference =
            MaintenanceWindowPreference::known("CUSTOM_PREFERENCE", 1);

        /// No preference.
        pub const NO_PREFERENCE: MaintenanceWindowPreference =
            MaintenanceWindowPreference::known("NO_PREFERENCE", 2);
    }

    impl MaintenanceWindowPreference {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for MaintenanceWindowPreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceWindowPreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(MaintenanceWindowPreference::from(val)),
                Enumeration::UnknownStr { val, str: _ } => {
                    Ok(MaintenanceWindowPreference::from(val))
                }
                Enumeration::UnknownNum { str } => Ok(MaintenanceWindowPreference::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for MaintenanceWindowPreference {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED" => {
                    maintenance_window_preference::MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED
                }
                "CUSTOM_PREFERENCE" => maintenance_window_preference::CUSTOM_PREFERENCE,
                "NO_PREFERENCE" => maintenance_window_preference::NO_PREFERENCE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for MaintenanceWindowPreference {
        fn from(value: i32) -> Self {
            match value {
                0 => maintenance_window_preference::MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED,
                1 => maintenance_window_preference::CUSTOM_PREFERENCE,
                2 => maintenance_window_preference::NO_PREFERENCE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for MaintenanceWindowPreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// Patching mode.
    #[derive(Clone, Debug, PartialEq)]
    pub struct PatchingMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [PatchingMode](PatchingMode)
    pub mod patching_mode {
        use super::PatchingMode;

        /// Default unspecified value.
        pub const PATCHING_MODE_UNSPECIFIED: PatchingMode =
            PatchingMode::known("PATCHING_MODE_UNSPECIFIED", 0);

        /// Updates the Cloud Exadata database server hosts in a rolling fashion.
        pub const ROLLING: PatchingMode = PatchingMode::known("ROLLING", 1);

        /// The non-rolling maintenance method first updates your storage servers at
        /// the same time, then your database servers at the same time.
        pub const NON_ROLLING: PatchingMode = PatchingMode::known("NON_ROLLING", 2);
    }

    impl PatchingMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for PatchingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PatchingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(PatchingMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(PatchingMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(PatchingMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for PatchingMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "PATCHING_MODE_UNSPECIFIED" => patching_mode::PATCHING_MODE_UNSPECIFIED,
                "ROLLING" => patching_mode::ROLLING,
                "NON_ROLLING" => patching_mode::NON_ROLLING,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for PatchingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => patching_mode::PATCHING_MODE_UNSPECIFIED,
                1 => patching_mode::ROLLING,
                2 => patching_mode::NON_ROLLING,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for PatchingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Details of the Oracle Grid Infrastructure (GI) version resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiVersionSummary/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GiVersion {
    /// Identifier. The name of the Oracle Grid Infrastructure (GI) version
    /// resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_versions}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,
}

impl GiVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GiVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GiVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GiVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GiVersion"
    }
}

/// Metadata for a given [Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Output only. Google Cloud Platform Oracle zones in a location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub gcp_oracle_zones: std::vec::Vec<std::string::String>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_oracle_zones][crate::model::LocationMetadata::gcp_oracle_zones].
    pub fn set_gcp_oracle_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.gcp_oracle_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.LocationMetadata"
    }
}

/// The request for `CloudExadataInfrastructures.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Exadata infrastructures will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListCloudExadataInfrastructuresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudExadataInfrastructuresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudExadataInfrastructuresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudExadataInfrastructuresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresRequest"
    }
}

/// The response for `CloudExadataInfrastructures.list`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresResponse {
    /// The list of Exadata Infrastructures.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cloud_exadata_infrastructures: std::vec::Vec<crate::model::CloudExadataInfrastructure>,

    /// A token for fetching next page of response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListCloudExadataInfrastructuresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudExadataInfrastructuresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructures][crate::model::ListCloudExadataInfrastructuresResponse::cloud_exadata_infrastructures].
    pub fn set_cloud_exadata_infrastructures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        use std::iter::Iterator;
        self.cloud_exadata_infrastructures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListCloudExadataInfrastructuresResponse {
    type PageItem = crate::model::CloudExadataInfrastructure;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_exadata_infrastructures
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `CloudExadataInfrastructure.Get`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudExadataInfrastructure.Create`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCloudExadataInfrastructureRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the Exadata Infrastructure to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_exadata_infrastructure_id: std::string::String,

    /// Required. Details of the Exadata Infrastructure instance to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_exadata_infrastructure: std::option::Option<crate::model::CloudExadataInfrastructure>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudExadataInfrastructureRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure_id][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure_id].
    pub fn set_cloud_exadata_infrastructure_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_exadata_infrastructure_id = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure].
    pub fn set_cloud_exadata_infrastructure<
        T: std::convert::Into<std::option::Option<crate::model::CloudExadataInfrastructure>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_exadata_infrastructure = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudExadataInfrastructure.Delete`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, all VM clusters for this Exadata Infrastructure
    /// will be deleted. An Exadata Infrastructure can only be deleted once all its
    /// VM clusters have been deleted.
    pub force: bool,
}

impl DeleteCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudExadataInfrastructureRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudVmCluster.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudVmClustersRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The number of VM clusters to return.
    /// If unspecified, at most 50 VM clusters will be returned.
    /// The maximum value is 1,000.
    pub page_size: i32,

    /// Optional. A token identifying the page of results the server returns.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListCloudVmClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudVmClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudVmClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudVmClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloudVmClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersRequest"
    }
}

/// The response for `CloudVmCluster.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudVmClustersResponse {
    /// The list of VM Clusters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cloud_vm_clusters: std::vec::Vec<crate::model::CloudVmCluster>,

    /// A token to fetch the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListCloudVmClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudVmClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [cloud_vm_clusters][crate::model::ListCloudVmClustersResponse::cloud_vm_clusters].
    pub fn set_cloud_vm_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudVmCluster>,
    {
        use std::iter::Iterator;
        self.cloud_vm_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListCloudVmClustersResponse {
    type PageItem = crate::model::CloudVmCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_vm_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `CloudVmCluster.Get`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudVmClusterRequest"
    }
}

/// The request for `CloudVmCluster.Create`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCloudVmClusterRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the VM Cluster to create. This value is restricted
    /// to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_vm_cluster_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_vm_cluster: std::option::Option<crate::model::CloudVmCluster>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudVmClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster_id][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster_id].
    pub fn set_cloud_vm_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_vm_cluster_id = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster].
    pub fn set_cloud_vm_cluster<
        T: std::convert::Into<std::option::Option<crate::model::CloudVmCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_vm_cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudVmClusterRequest"
    }
}

/// The request for `CloudVmCluster.Delete`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, all child resources for the VM Cluster will be
    /// deleted. A VM Cluster can only be deleted once all its child resources have
    /// been deleted.
    pub force: bool,
}

impl DeleteCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudVmClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudVmClusterRequest"
    }
}

/// The request for `Entitlement.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitlementsRequest {
    /// Required. The parent value for the entitlement in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 entitlements will be returned.
    /// The maximum value is 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsRequest"
    }
}

/// The response for `Entitlement.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitlementsResponse {
    /// The list of Entitlements
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [entitlements][crate::model::ListEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `DbServer.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbServersRequest {
    /// Required. The parent value for database server in the following format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloudExadataInfrastructure}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 db servers will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDbServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbServersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbServersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbServersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersRequest"
    }
}

/// The response for `DbServer.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbServersResponse {
    /// The list of database servers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub db_servers: std::vec::Vec<crate::model::DbServer>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDbServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDbServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [db_servers][crate::model::ListDbServersResponse::db_servers].
    pub fn set_db_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbServer>,
    {
        use std::iter::Iterator;
        self.db_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDbServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDbServersResponse {
    type PageItem = crate::model::DbServer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_servers
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `DbNode.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbNodesRequest {
    /// Required. The parent value for database node in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloudVmCluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 db nodes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the node should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDbNodesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbNodesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbNodesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbNodesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbNodesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesRequest"
    }
}

/// The response for `DbNode.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbNodesResponse {
    /// The list of DB Nodes
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub db_nodes: std::vec::Vec<crate::model::DbNode>,

    /// A token identifying a page of results the node should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDbNodesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDbNodesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [db_nodes][crate::model::ListDbNodesResponse::db_nodes].
    pub fn set_db_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbNode>,
    {
        use std::iter::Iterator;
        self.db_nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDbNodesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDbNodesResponse {
    type PageItem = crate::model::DbNode;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_nodes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `GiVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGiVersionsRequest {
    /// Required. The parent value for Grid Infrastructure Version in the following
    /// format: Format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Oracle Grid Infrastructure (GI) versions
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListGiVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGiVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGiVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGiVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGiVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsRequest"
    }
}

/// The response for `GiVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGiVersionsResponse {
    /// The list of Oracle Grid Infrastructure (GI) versions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub gi_versions: std::vec::Vec<crate::model::GiVersion>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListGiVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListGiVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [gi_versions][crate::model::ListGiVersionsResponse::gi_versions].
    pub fn set_gi_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GiVersion>,
    {
        use std::iter::Iterator;
        self.gi_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGiVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListGiVersionsResponse {
    type PageItem = crate::model::GiVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.gi_versions
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `DbSystemShape.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbSystemShapesRequest {
    /// Required. The parent value for Database System Shapes in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 database system shapes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDbSystemShapesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbSystemShapesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbSystemShapesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbSystemShapesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesRequest"
    }
}

/// The response for `DbSystemShape.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbSystemShapesResponse {
    /// The list of Database System shapes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub db_system_shapes: std::vec::Vec<crate::model::DbSystemShape>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDbSystemShapesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDbSystemShapesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [db_system_shapes][crate::model::ListDbSystemShapesResponse::db_system_shapes].
    pub fn set_db_system_shapes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbSystemShape>,
    {
        use std::iter::Iterator;
        self.db_system_shapes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDbSystemShapesResponse {
    type PageItem = crate::model::DbSystemShape;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_system_shapes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. The status of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// Output only. An estimated percentage of the operation that has been
    /// completed at a given moment of time, between 0 and 100.
    pub percent_complete: f64,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [percent_complete][crate::model::OperationMetadata::percent_complete].
    pub fn set_percent_complete<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.percent_complete = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.OperationMetadata"
    }
}

/// The request for `AutonomousDatabase.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabasesRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous Database will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListAutonomousDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutonomousDatabasesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesRequest"
    }
}

/// The response for `AutonomousDatabase.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabasesResponse {
    /// The list of Autonomous Databases.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub autonomous_databases: std::vec::Vec<crate::model::AutonomousDatabase>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAutonomousDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [autonomous_databases][crate::model::ListAutonomousDatabasesResponse::autonomous_databases].
    pub fn set_autonomous_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        use std::iter::Iterator;
        self.autonomous_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAutonomousDatabasesResponse {
    type PageItem = crate::model::AutonomousDatabase;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_databases
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `AutonomousDatabase.Get`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Create`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAutonomousDatabaseRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the Autonomous Database to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub autonomous_database_id: std::string::String,

    /// Required. The Autonomous Database being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autonomous_database: std::option::Option<crate::model::AutonomousDatabase>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutonomousDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [autonomous_database_id][crate::model::CreateAutonomousDatabaseRequest::autonomous_database_id].
    pub fn set_autonomous_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database_id = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::CreateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_autonomous_database<
        T: std::convert::Into<std::option::Option<crate::model::AutonomousDatabase>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Delete`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAutonomousDatabaseRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Restore`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The time and date to restore the database to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restore_time: std::option::Option<wkt::Timestamp>,
}

impl RestoreAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [restore_time][crate::model::RestoreAutonomousDatabaseRequest::restore_time].
    pub fn set_restore_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.restore_time = v.into();
        self
    }
}

impl wkt::message::Message for RestoreAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RestoreAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.GenerateWallet`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The type of wallet generation for the Autonomous Database. The
    /// default value is SINGLE.
    #[serde(rename = "type")]
    pub r#type: crate::model::GenerateType,

    /// Optional. True when requesting regional connection strings in PDB connect
    /// info, applicable to cross-region Data Guard only.
    pub is_regional: bool,

    /// Required. The password used to encrypt the keys inside the wallet. The
    /// password must be a minimum of 8 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,
}

impl GenerateAutonomousDatabaseWalletRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateAutonomousDatabaseWalletRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::GenerateAutonomousDatabaseWalletRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::GenerateType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::GenerateAutonomousDatabaseWalletRequest::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [password][crate::model::GenerateAutonomousDatabaseWalletRequest::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletRequest"
    }
}

/// The response for `AutonomousDatabase.GenerateWallet`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletResponse {
    /// Output only. The base64 encoded wallet files.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub archive_content: bytes::Bytes,
}

impl GenerateAutonomousDatabaseWalletResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [archive_content][crate::model::GenerateAutonomousDatabaseWalletResponse::archive_content].
    pub fn set_archive_content<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.archive_content = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletResponse"
    }
}

/// The request for `AutonomousDbVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAutonomousDbVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDbVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDbVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDbVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsRequest"
    }
}

/// The response for `AutonomousDbVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsResponse {
    /// The list of Autonomous Database versions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub autonomous_db_versions: std::vec::Vec<crate::model::AutonomousDbVersion>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAutonomousDbVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDbVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [autonomous_db_versions][crate::model::ListAutonomousDbVersionsResponse::autonomous_db_versions].
    pub fn set_autonomous_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDbVersion>,
    {
        use std::iter::Iterator;
        self.autonomous_db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAutonomousDbVersionsResponse {
    type PageItem = crate::model::AutonomousDbVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_db_versions
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `AutonomousDatabaseCharacterSet.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Character Sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListAutonomousDatabaseCharacterSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseCharacterSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseCharacterSetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsRequest"
    }
}

/// The response for `AutonomousDatabaseCharacterSet.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsResponse {
    /// The list of Autonomous Database Character Sets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub autonomous_database_character_sets:
        std::vec::Vec<crate::model::AutonomousDatabaseCharacterSet>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAutonomousDatabaseCharacterSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseCharacterSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [autonomous_database_character_sets][crate::model::ListAutonomousDatabaseCharacterSetsResponse::autonomous_database_character_sets].
    pub fn set_autonomous_database_character_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseCharacterSet>,
    {
        use std::iter::Iterator;
        self.autonomous_database_character_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAutonomousDatabaseCharacterSetsResponse {
    type PageItem = crate::model::AutonomousDatabaseCharacterSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_character_sets
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for `AutonomousDatabaseBackup.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsRequest {
    /// Required. The parent value for ListAutonomousDatabaseBackups in the
    /// following format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **autonomous_database_id** field is supported in the following format:
    /// `autonomous_database_id="{autonomous_database_id}"`. The accepted values
    /// must be a valid Autonomous Database ID, limited to the naming
    /// restrictions of the ID: ^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    /// The ID must start with a letter, end with a letter or a number, and be
    /// a maximum of 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Backups will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAutonomousDatabaseBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsRequest"
    }
}

/// The response for `AutonomousDatabaseBackup.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsResponse {
    /// The list of Autonomous Database Backups.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub autonomous_database_backups: std::vec::Vec<crate::model::AutonomousDatabaseBackup>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAutonomousDatabaseBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [autonomous_database_backups][crate::model::ListAutonomousDatabaseBackupsResponse::autonomous_database_backups].
    pub fn set_autonomous_database_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseBackup>,
    {
        use std::iter::Iterator;
        self.autonomous_database_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAutonomousDatabaseBackupsResponse {
    type PageItem = crate::model::AutonomousDatabaseBackup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_backups
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Details of the Cloud VM Cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudVmCluster/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudVmCluster {
    /// Identifier. The name of the VM Cluster resource with the format:
    /// projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The name of the Exadata Infrastructure resource on which VM
    /// cluster resource is created, in the following format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub exadata_infrastructure: std::string::String,

    /// Optional. User friendly name for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Google Cloud Platform location where Oracle Exadata is hosted.
    /// It is same as Google Cloud Platform Oracle zone of Exadata infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_oracle_zone: std::string::String,

    /// Optional. Various properties of the VM Cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::CloudVmClusterProperties>,

    /// Optional. Labels or tags associated with the VM Cluster.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the VM cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Network settings. CIDR to use for cluster IP allocation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cidr: std::string::String,

    /// Required. CIDR range of the backup subnet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_subnet_cidr: std::string::String,

    /// Required. The name of the VPC network.
    /// Format: projects/{project}/global/networks/{network}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,
}

impl CloudVmCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudVmCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [exadata_infrastructure][crate::model::CloudVmCluster::exadata_infrastructure].
    pub fn set_exadata_infrastructure<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exadata_infrastructure = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudVmCluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudVmCluster::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudVmCluster::properties].
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::CloudVmClusterProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudVmCluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::CloudVmCluster::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [backup_subnet_cidr][crate::model::CloudVmCluster::backup_subnet_cidr].
    pub fn set_backup_subnet_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_subnet_cidr = v.into();
        self
    }

    /// Sets the value of [network][crate::model::CloudVmCluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CloudVmCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CloudVmCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmCluster"
    }
}

/// Various properties and settings associated with Exadata VM cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudVmClusterProperties {
    /// Output only. Oracle Cloud Infrastructure ID of VM Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ocid: std::string::String,

    /// Required. License type of VM Cluster.
    pub license_type: crate::model::cloud_vm_cluster_properties::LicenseType,

    /// Optional. Grid Infrastructure Version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gi_version: std::string::String,

    /// Optional. Time zone of VM Cluster to set. Defaults to UTC if not specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Optional. SSH public keys to be stored with cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ssh_public_keys: std::vec::Vec<std::string::String>,

    /// Optional. Number of database servers.
    pub node_count: i32,

    /// Output only. Shape of VM Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub shape: std::string::String,

    /// Optional. OCPU count per VM. Minimum is 0.1.
    pub ocpu_count: f32,

    /// Optional. Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Local storage per VM.
    pub db_node_storage_size_gb: i32,

    /// Output only. The storage allocation for the disk group, in gigabytes (GB).
    pub storage_size_gb: i32,

    /// Optional. The data disk group size to be allocated in TBs.
    pub data_storage_size_tb: f64,

    /// Optional. The type of redundancy.
    pub disk_redundancy: crate::model::cloud_vm_cluster_properties::DiskRedundancy,

    /// Optional. Use exadata sparse snapshots.
    pub sparse_diskgroup_enabled: bool,

    /// Optional. Use local backup.
    pub local_backup_enabled: bool,

    /// Optional. Prefix for VM cluster host names.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname_prefix: std::string::String,

    /// Optional. Data collection options for diagnostics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub diagnostics_data_collection_options:
        std::option::Option<crate::model::DataCollectionOptions>,

    /// Output only. State of the cluster.
    pub state: crate::model::cloud_vm_cluster_properties::State,

    /// Output only. SCAN listener port - TCP
    pub scan_listener_port_tcp: i32,

    /// Output only. SCAN listener port - TLS
    pub scan_listener_port_tcp_ssl: i32,

    /// Output only. Parent DNS domain where SCAN DNS and hosts names are
    /// qualified. ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// Output only. SCAN DNS name.
    /// ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub scan_dns: std::string::String,

    /// Output only. host name without domain.
    /// format: "<hostname_prefix>-" with some suffix.
    /// ex: sp2-yi0xq where "sp2" is the hostname_prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Required. Number of enabled CPU cores.
    pub cpu_core_count: i32,

    /// Optional. Operating system version of the image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub system_version: std::string::String,

    /// Output only. OCIDs of scan IPs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scan_ip_ids: std::vec::Vec<std::string::String>,

    /// Output only. OCID of scan DNS record.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub scan_dns_record_id: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oci_url: std::string::String,

    /// Optional. OCID of database servers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub db_server_ocids: std::vec::Vec<std::string::String>,

    /// Output only. Compartment ID of cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub compartment_id: std::string::String,

    /// Output only. DNS listener IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dns_listener_ip: std::string::String,

    /// Optional. OCI Cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,
}

impl CloudVmClusterProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudVmClusterProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::CloudVmClusterProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [gi_version][crate::model::CloudVmClusterProperties::gi_version].
    pub fn set_gi_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gi_version = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::CloudVmClusterProperties::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::option::Option<gtype::model::TimeZone>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::CloudVmClusterProperties::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudVmClusterProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::CloudVmClusterProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudVmClusterProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudVmClusterProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [storage_size_gb][crate::model::CloudVmClusterProperties::storage_size_gb].
    pub fn set_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudVmClusterProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [disk_redundancy][crate::model::CloudVmClusterProperties::disk_redundancy].
    pub fn set_disk_redundancy<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::DiskRedundancy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_redundancy = v.into();
        self
    }

    /// Sets the value of [sparse_diskgroup_enabled][crate::model::CloudVmClusterProperties::sparse_diskgroup_enabled].
    pub fn set_sparse_diskgroup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.sparse_diskgroup_enabled = v.into();
        self
    }

    /// Sets the value of [local_backup_enabled][crate::model::CloudVmClusterProperties::local_backup_enabled].
    pub fn set_local_backup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.local_backup_enabled = v.into();
        self
    }

    /// Sets the value of [hostname_prefix][crate::model::CloudVmClusterProperties::hostname_prefix].
    pub fn set_hostname_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname_prefix = v.into();
        self
    }

    /// Sets the value of [diagnostics_data_collection_options][crate::model::CloudVmClusterProperties::diagnostics_data_collection_options].
    pub fn set_diagnostics_data_collection_options<
        T: std::convert::Into<std::option::Option<crate::model::DataCollectionOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.diagnostics_data_collection_options = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CloudVmClusterProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::cloud_vm_cluster_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp][crate::model::CloudVmClusterProperties::scan_listener_port_tcp].
    pub fn set_scan_listener_port_tcp<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp_ssl][crate::model::CloudVmClusterProperties::scan_listener_port_tcp_ssl].
    pub fn set_scan_listener_port_tcp_ssl<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp_ssl = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::CloudVmClusterProperties::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [scan_dns][crate::model::CloudVmClusterProperties::scan_dns].
    pub fn set_scan_dns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scan_dns = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::CloudVmClusterProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::CloudVmClusterProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [system_version][crate::model::CloudVmClusterProperties::system_version].
    pub fn set_system_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system_version = v.into();
        self
    }

    /// Sets the value of [scan_dns_record_id][crate::model::CloudVmClusterProperties::scan_dns_record_id].
    pub fn set_scan_dns_record_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_dns_record_id = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudVmClusterProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [compartment_id][crate::model::CloudVmClusterProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [dns_listener_ip][crate::model::CloudVmClusterProperties::dns_listener_ip].
    pub fn set_dns_listener_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_listener_ip = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::CloudVmClusterProperties::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [ssh_public_keys][crate::model::CloudVmClusterProperties::ssh_public_keys].
    pub fn set_ssh_public_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_public_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scan_ip_ids][crate::model::CloudVmClusterProperties::scan_ip_ids].
    pub fn set_scan_ip_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scan_ip_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [db_server_ocids][crate::model::CloudVmClusterProperties::db_server_ocids].
    pub fn set_db_server_ocids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_server_ocids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudVmClusterProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmClusterProperties"
    }
}

/// Defines additional types related to CloudVmClusterProperties
pub mod cloud_vm_cluster_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Different licenses supported.
    #[derive(Clone, Debug, PartialEq)]
    pub struct LicenseType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [LicenseType](LicenseType)
    pub mod license_type {
        use super::LicenseType;

        /// Unspecified
        pub const LICENSE_TYPE_UNSPECIFIED: LicenseType =
            LicenseType::known("LICENSE_TYPE_UNSPECIFIED", 0);

        /// License included part of offer
        pub const LICENSE_INCLUDED: LicenseType = LicenseType::known("LICENSE_INCLUDED", 1);

        /// Bring your own license
        pub const BRING_YOUR_OWN_LICENSE: LicenseType =
            LicenseType::known("BRING_YOUR_OWN_LICENSE", 2);
    }

    impl LicenseType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(LicenseType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(LicenseType::from(val)),
                Enumeration::UnknownNum { str } => Ok(LicenseType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for LicenseType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "LICENSE_TYPE_UNSPECIFIED" => license_type::LICENSE_TYPE_UNSPECIFIED,
                "LICENSE_INCLUDED" => license_type::LICENSE_INCLUDED,
                "BRING_YOUR_OWN_LICENSE" => license_type::BRING_YOUR_OWN_LICENSE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => license_type::LICENSE_TYPE_UNSPECIFIED,
                1 => license_type::LICENSE_INCLUDED,
                2 => license_type::BRING_YOUR_OWN_LICENSE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// Types of disk redundancy provided by Oracle.
    #[derive(Clone, Debug, PartialEq)]
    pub struct DiskRedundancy(wkt::enumerations::Enumeration);

    /// Useful constants to work with [DiskRedundancy](DiskRedundancy)
    pub mod disk_redundancy {
        use super::DiskRedundancy;

        /// Unspecified.
        pub const DISK_REDUNDANCY_UNSPECIFIED: DiskRedundancy =
            DiskRedundancy::known("DISK_REDUNDANCY_UNSPECIFIED", 0);

        /// High -  3 way mirror.
        pub const HIGH: DiskRedundancy = DiskRedundancy::known("HIGH", 1);

        /// Normal - 2 way mirror.
        pub const NORMAL: DiskRedundancy = DiskRedundancy::known("NORMAL", 2);
    }

    impl DiskRedundancy {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for DiskRedundancy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskRedundancy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(DiskRedundancy::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(DiskRedundancy::from(val)),
                Enumeration::UnknownNum { str } => Ok(DiskRedundancy::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for DiskRedundancy {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "DISK_REDUNDANCY_UNSPECIFIED" => disk_redundancy::DISK_REDUNDANCY_UNSPECIFIED,
                "HIGH" => disk_redundancy::HIGH,
                "NORMAL" => disk_redundancy::NORMAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for DiskRedundancy {
        fn from(value: i32) -> Self {
            match value {
                0 => disk_redundancy::DISK_REDUNDANCY_UNSPECIFIED,
                1 => disk_redundancy::HIGH,
                2 => disk_redundancy::NORMAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for DiskRedundancy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The various lifecycle states of the VM cluster.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default unspecified value.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// Indicates that the resource is in provisioning state.
        pub const PROVISIONING: State = State::known("PROVISIONING", 1);

        /// Indicates that the resource is in available state.
        pub const AVAILABLE: State = State::known("AVAILABLE", 2);

        /// Indicates that the resource is in updating state.
        pub const UPDATING: State = State::known("UPDATING", 3);

        /// Indicates that the resource is in terminating state.
        pub const TERMINATING: State = State::known("TERMINATING", 4);

        /// Indicates that the resource is in terminated state.
        pub const TERMINATED: State = State::known("TERMINATED", 5);

        /// Indicates that the resource is in failed state.
        pub const FAILED: State = State::known("FAILED", 6);

        /// Indicates that the resource is in maintenance in progress state.
        pub const MAINTENANCE_IN_PROGRESS: State = State::known("MAINTENANCE_IN_PROGRESS", 7);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "PROVISIONING" => state::PROVISIONING,
                "AVAILABLE" => state::AVAILABLE,
                "UPDATING" => state::UPDATING,
                "TERMINATING" => state::TERMINATING,
                "TERMINATED" => state::TERMINATED,
                "FAILED" => state::FAILED,
                "MAINTENANCE_IN_PROGRESS" => state::MAINTENANCE_IN_PROGRESS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::PROVISIONING,
                2 => state::AVAILABLE,
                3 => state::UPDATING,
                4 => state::TERMINATING,
                5 => state::TERMINATED,
                6 => state::FAILED,
                7 => state::MAINTENANCE_IN_PROGRESS,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Data collection options for diagnostics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataCollectionOptions {
    /// Optional. Indicates whether diagnostic collection is enabled for the VM
    /// cluster
    pub diagnostics_events_enabled: bool,

    /// Optional. Indicates whether health monitoring is enabled for the VM cluster
    pub health_monitoring_enabled: bool,

    /// Optional. Indicates whether incident logs and trace collection are enabled
    /// for the VM cluster
    pub incident_logs_enabled: bool,
}

impl DataCollectionOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [diagnostics_events_enabled][crate::model::DataCollectionOptions::diagnostics_events_enabled].
    pub fn set_diagnostics_events_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.diagnostics_events_enabled = v.into();
        self
    }

    /// Sets the value of [health_monitoring_enabled][crate::model::DataCollectionOptions::health_monitoring_enabled].
    pub fn set_health_monitoring_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.health_monitoring_enabled = v.into();
        self
    }

    /// Sets the value of [incident_logs_enabled][crate::model::DataCollectionOptions::incident_logs_enabled].
    pub fn set_incident_logs_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.incident_logs_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCollectionOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DataCollectionOptions"
    }
}

/// The type of wallet generation.
#[derive(Clone, Debug, PartialEq)]
pub struct GenerateType(wkt::enumerations::Enumeration);

/// Useful constants to work with [GenerateType](GenerateType)
pub mod generate_type {
    use super::GenerateType;

    /// Default unspecified value.
    pub const GENERATE_TYPE_UNSPECIFIED: GenerateType =
        GenerateType::known("GENERATE_TYPE_UNSPECIFIED", 0);

    /// Used to generate wallet for all databases in the region.
    pub const ALL: GenerateType = GenerateType::known("ALL", 1);

    /// Used to generate wallet for a single database.
    pub const SINGLE: GenerateType = GenerateType::known("SINGLE", 2);
}

impl GenerateType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for GenerateType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for GenerateType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(GenerateType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(GenerateType::from(val)),
            Enumeration::UnknownNum { str } => Ok(GenerateType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for GenerateType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "GENERATE_TYPE_UNSPECIFIED" => generate_type::GENERATE_TYPE_UNSPECIFIED,
            "ALL" => generate_type::ALL,
            "SINGLE" => generate_type::SINGLE,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for GenerateType {
    fn from(value: i32) -> Self {
        match value {
            0 => generate_type::GENERATE_TYPE_UNSPECIFIED,
            1 => generate_type::ALL,
            2 => generate_type::SINGLE,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for GenerateType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The various lifecycle states of the Autonomous Database.
#[derive(Clone, Debug, PartialEq)]
pub struct State(wkt::enumerations::Enumeration);

/// Useful constants to work with [State](State)
pub mod state {
    use super::State;

    /// Default unspecified value.
    pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

    /// Indicates that the Autonomous Database is in provisioning state.
    pub const PROVISIONING: State = State::known("PROVISIONING", 1);

    /// Indicates that the Autonomous Database is in available state.
    pub const AVAILABLE: State = State::known("AVAILABLE", 2);

    /// Indicates that the Autonomous Database is in stopping state.
    pub const STOPPING: State = State::known("STOPPING", 3);

    /// Indicates that the Autonomous Database is in stopped state.
    pub const STOPPED: State = State::known("STOPPED", 4);

    /// Indicates that the Autonomous Database is in starting state.
    pub const STARTING: State = State::known("STARTING", 5);

    /// Indicates that the Autonomous Database is in terminating state.
    pub const TERMINATING: State = State::known("TERMINATING", 6);

    /// Indicates that the Autonomous Database is in terminated state.
    pub const TERMINATED: State = State::known("TERMINATED", 7);

    /// Indicates that the Autonomous Database is in unavailable state.
    pub const UNAVAILABLE: State = State::known("UNAVAILABLE", 8);

    /// Indicates that the Autonomous Database restore is in progress.
    pub const RESTORE_IN_PROGRESS: State = State::known("RESTORE_IN_PROGRESS", 9);

    /// Indicates that the Autonomous Database failed to restore.
    pub const RESTORE_FAILED: State = State::known("RESTORE_FAILED", 10);

    /// Indicates that the Autonomous Database backup is in progress.
    pub const BACKUP_IN_PROGRESS: State = State::known("BACKUP_IN_PROGRESS", 11);

    /// Indicates that the Autonomous Database scale is in progress.
    pub const SCALE_IN_PROGRESS: State = State::known("SCALE_IN_PROGRESS", 12);

    /// Indicates that the Autonomous Database is available but needs attention
    /// state.
    pub const AVAILABLE_NEEDS_ATTENTION: State = State::known("AVAILABLE_NEEDS_ATTENTION", 13);

    /// Indicates that the Autonomous Database is in updating state.
    pub const UPDATING: State = State::known("UPDATING", 14);

    /// Indicates that the Autonomous Database's maintenance is in progress state.
    pub const MAINTENANCE_IN_PROGRESS: State = State::known("MAINTENANCE_IN_PROGRESS", 15);

    /// Indicates that the Autonomous Database is in restarting state.
    pub const RESTARTING: State = State::known("RESTARTING", 16);

    /// Indicates that the Autonomous Database is in recreating state.
    pub const RECREATING: State = State::known("RECREATING", 17);

    /// Indicates that the Autonomous Database's role change is in progress state.
    pub const ROLE_CHANGE_IN_PROGRESS: State = State::known("ROLE_CHANGE_IN_PROGRESS", 18);

    /// Indicates that the Autonomous Database is in upgrading state.
    pub const UPGRADING: State = State::known("UPGRADING", 19);

    /// Indicates that the Autonomous Database is in inaccessible state.
    pub const INACCESSIBLE: State = State::known("INACCESSIBLE", 20);

    /// Indicates that the Autonomous Database is in standby state.
    pub const STANDBY: State = State::known("STANDBY", 21);
}

impl State {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(State::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
            Enumeration::UnknownNum { str } => Ok(State::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for State {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
            "PROVISIONING" => state::PROVISIONING,
            "AVAILABLE" => state::AVAILABLE,
            "STOPPING" => state::STOPPING,
            "STOPPED" => state::STOPPED,
            "STARTING" => state::STARTING,
            "TERMINATING" => state::TERMINATING,
            "TERMINATED" => state::TERMINATED,
            "UNAVAILABLE" => state::UNAVAILABLE,
            "RESTORE_IN_PROGRESS" => state::RESTORE_IN_PROGRESS,
            "RESTORE_FAILED" => state::RESTORE_FAILED,
            "BACKUP_IN_PROGRESS" => state::BACKUP_IN_PROGRESS,
            "SCALE_IN_PROGRESS" => state::SCALE_IN_PROGRESS,
            "AVAILABLE_NEEDS_ATTENTION" => state::AVAILABLE_NEEDS_ATTENTION,
            "UPDATING" => state::UPDATING,
            "MAINTENANCE_IN_PROGRESS" => state::MAINTENANCE_IN_PROGRESS,
            "RESTARTING" => state::RESTARTING,
            "RECREATING" => state::RECREATING,
            "ROLE_CHANGE_IN_PROGRESS" => state::ROLE_CHANGE_IN_PROGRESS,
            "UPGRADING" => state::UPGRADING,
            "INACCESSIBLE" => state::INACCESSIBLE,
            "STANDBY" => state::STANDBY,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => state::STATE_UNSPECIFIED,
            1 => state::PROVISIONING,
            2 => state::AVAILABLE,
            3 => state::STOPPING,
            4 => state::STOPPED,
            5 => state::STARTING,
            6 => state::TERMINATING,
            7 => state::TERMINATED,
            8 => state::UNAVAILABLE,
            9 => state::RESTORE_IN_PROGRESS,
            10 => state::RESTORE_FAILED,
            11 => state::BACKUP_IN_PROGRESS,
            12 => state::SCALE_IN_PROGRESS,
            13 => state::AVAILABLE_NEEDS_ATTENTION,
            14 => state::UPDATING,
            15 => state::MAINTENANCE_IN_PROGRESS,
            16 => state::RESTARTING,
            17 => state::RECREATING,
            18 => state::ROLE_CHANGE_IN_PROGRESS,
            19 => state::UPGRADING,
            20 => state::INACCESSIBLE,
            21 => state::STANDBY,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The state of the Operations Insights for this Autonomous Database.
#[derive(Clone, Debug, PartialEq)]
pub struct OperationsInsightsState(wkt::enumerations::Enumeration);

/// Useful constants to work with [OperationsInsightsState](OperationsInsightsState)
pub mod operations_insights_state {
    use super::OperationsInsightsState;

    /// Default unspecified value.
    pub const OPERATIONS_INSIGHTS_STATE_UNSPECIFIED: OperationsInsightsState =
        OperationsInsightsState::known("OPERATIONS_INSIGHTS_STATE_UNSPECIFIED", 0);

    /// Enabling status for operation insights.
    pub const ENABLING: OperationsInsightsState = OperationsInsightsState::known("ENABLING", 1);

    /// Enabled status for operation insights.
    pub const ENABLED: OperationsInsightsState = OperationsInsightsState::known("ENABLED", 2);

    /// Disabling status for operation insights.
    pub const DISABLING: OperationsInsightsState = OperationsInsightsState::known("DISABLING", 3);

    /// Not Enabled status for operation insights.
    pub const NOT_ENABLED: OperationsInsightsState =
        OperationsInsightsState::known("NOT_ENABLED", 4);

    /// Failed enabling status for operation insights.
    pub const FAILED_ENABLING: OperationsInsightsState =
        OperationsInsightsState::known("FAILED_ENABLING", 5);

    /// Failed disabling status for operation insights.
    pub const FAILED_DISABLING: OperationsInsightsState =
        OperationsInsightsState::known("FAILED_DISABLING", 6);
}

impl OperationsInsightsState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for OperationsInsightsState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationsInsightsState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(OperationsInsightsState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(OperationsInsightsState::from(val)),
            Enumeration::UnknownNum { str } => Ok(OperationsInsightsState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for OperationsInsightsState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => {
                operations_insights_state::OPERATIONS_INSIGHTS_STATE_UNSPECIFIED
            }
            "ENABLING" => operations_insights_state::ENABLING,
            "ENABLED" => operations_insights_state::ENABLED,
            "DISABLING" => operations_insights_state::DISABLING,
            "NOT_ENABLED" => operations_insights_state::NOT_ENABLED,
            "FAILED_ENABLING" => operations_insights_state::FAILED_ENABLING,
            "FAILED_DISABLING" => operations_insights_state::FAILED_DISABLING,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for OperationsInsightsState {
    fn from(value: i32) -> Self {
        match value {
            0 => operations_insights_state::OPERATIONS_INSIGHTS_STATE_UNSPECIFIED,
            1 => operations_insights_state::ENABLING,
            2 => operations_insights_state::ENABLED,
            3 => operations_insights_state::DISABLING,
            4 => operations_insights_state::NOT_ENABLED,
            5 => operations_insights_state::FAILED_ENABLING,
            6 => operations_insights_state::FAILED_DISABLING,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for OperationsInsightsState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The various states available for the Autonomous Database workload type.
#[derive(Clone, Debug, PartialEq)]
pub struct DBWorkload(wkt::enumerations::Enumeration);

/// Useful constants to work with [DBWorkload](DBWorkload)
pub mod db_workload {
    use super::DBWorkload;

    /// Default unspecified value.
    pub const DB_WORKLOAD_UNSPECIFIED: DBWorkload = DBWorkload::known("DB_WORKLOAD_UNSPECIFIED", 0);

    /// Autonomous Transaction Processing database.
    pub const OLTP: DBWorkload = DBWorkload::known("OLTP", 1);

    /// Autonomous Data Warehouse database.
    pub const DW: DBWorkload = DBWorkload::known("DW", 2);

    /// Autonomous JSON Database.
    pub const AJD: DBWorkload = DBWorkload::known("AJD", 3);

    /// Autonomous Database with the Oracle APEX Application Development workload
    /// type.
    pub const APEX: DBWorkload = DBWorkload::known("APEX", 4);
}

impl DBWorkload {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for DBWorkload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for DBWorkload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(DBWorkload::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(DBWorkload::from(val)),
            Enumeration::UnknownNum { str } => Ok(DBWorkload::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for DBWorkload {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "DB_WORKLOAD_UNSPECIFIED" => db_workload::DB_WORKLOAD_UNSPECIFIED,
            "OLTP" => db_workload::OLTP,
            "DW" => db_workload::DW,
            "AJD" => db_workload::AJD,
            "APEX" => db_workload::APEX,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for DBWorkload {
    fn from(value: i32) -> Self {
        match value {
            0 => db_workload::DB_WORKLOAD_UNSPECIFIED,
            1 => db_workload::OLTP,
            2 => db_workload::DW,
            3 => db_workload::AJD,
            4 => db_workload::APEX,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for DBWorkload {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}
