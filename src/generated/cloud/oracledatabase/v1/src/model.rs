// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Details of the Autonomous Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabase/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabase {
    /// Identifier. The name of the Autonomous Database resource in the following
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    pub name: std::string::String,

    /// Optional. The name of the Autonomous Database. The database name must be
    /// unique in the project. The name must begin with a letter and can contain a
    /// maximum of 30 alphanumeric characters.
    pub database: std::string::String,

    /// Optional. The display name for the Autonomous Database. The name does not
    /// have to be unique within your project.
    pub display_name: std::string::String,

    /// Output only. The ID of the subscription entitlement associated with the
    /// Autonomous Database.
    pub entitlement_id: std::string::String,

    /// Optional. The password for the default ADMIN user.
    pub admin_password: std::string::String,

    /// Optional. The properties of the Autonomous Database.
    pub properties: std::option::Option<crate::model::AutonomousDatabaseProperties>,

    /// Optional. The labels or tags associated with the Autonomous Database.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The name of the VPC network used by the Autonomous Database in
    /// the following format: projects/{project}/global/networks/{network}
    pub network: std::string::String,

    /// Optional. The subnet CIDR range for the Autonmous Database.
    pub cidr: std::string::String,

    /// Output only. The date and time that the Autonomous Database was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabase::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::AutonomousDatabase::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabase::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::AutonomousDatabase::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [admin_password][crate::model::AutonomousDatabase::admin_password].
    pub fn set_admin_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin_password = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabase::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::AutonomousDatabase::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabase::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network][crate::model::AutonomousDatabase::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::AutonomousDatabase::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AutonomousDatabase::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AutonomousDatabase::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutonomousDatabase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabase"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __database,
            __display_name,
            __entitlement_id,
            __admin_password,
            __properties,
            __labels,
            __network,
            __cidr,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "database" => Ok(__FieldTag::__database),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "entitlementId" => Ok(__FieldTag::__entitlement_id),
                            "entitlement_id" => Ok(__FieldTag::__entitlement_id),
                            "adminPassword" => Ok(__FieldTag::__admin_password),
                            "admin_password" => Ok(__FieldTag::__admin_password),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            "network" => Ok(__FieldTag::__network),
                            "cidr" => Ok(__FieldTag::__cidr),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entitlement_id => {
                            if !fields.insert(__FieldTag::__entitlement_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement_id",
                                ));
                            }
                            result.entitlement_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admin_password => {
                            if !fields.insert(__FieldTag::__admin_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_password",
                                ));
                            }
                            result.admin_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<crate::model::AutonomousDatabaseProperties>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr => {
                            if !fields.insert(__FieldTag::__cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr",
                                ));
                            }
                            result.cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.entitlement_id.is_empty() {
            state.serialize_entry("entitlementId", &self.entitlement_id)?;
        }
        if !self.admin_password.is_empty() {
            state.serialize_entry("adminPassword", &self.admin_password)?;
        }
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.cidr.is_empty() {
            state.serialize_entry("cidr", &self.cidr)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabase");
        debug_struct.field("name", &self.name);
        debug_struct.field("database", &self.database);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("entitlement_id", &self.entitlement_id);
        debug_struct.field("admin_password", &self.admin_password);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("network", &self.network);
        debug_struct.field("cidr", &self.cidr);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The properties of an Autonomous Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseProperties {
    /// Output only. OCID of the Autonomous Database.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Autonomous Database.
    pub compute_count: f32,

    /// Optional. The number of CPU cores to be made available to the database.
    pub cpu_core_count: i32,

    /// Optional. The size of the data stored in the database, in terabytes.
    pub data_storage_size_tb: i32,

    /// Optional. The size of the data stored in the database, in gigabytes.
    pub data_storage_size_gb: i32,

    /// Required. The workload type of the Autonomous Database.
    pub db_workload: crate::model::DBWorkload,

    /// Optional. The edition of the Autonomous Databases.
    pub db_edition: crate::model::autonomous_database_properties::DatabaseEdition,

    /// Optional. The character set for the Autonomous Database. The default is
    /// AL32UTF8.
    pub character_set: std::string::String,

    /// Optional. The national character set for the Autonomous Database. The
    /// default is AL16UTF16.
    pub n_character_set: std::string::String,

    /// Optional. The private endpoint IP address for the Autonomous Database.
    pub private_endpoint_ip: std::string::String,

    /// Optional. The private endpoint label for the Autonomous Database.
    pub private_endpoint_label: std::string::String,

    /// Optional. The Oracle Database version for the Autonomous Database.
    pub db_version: std::string::String,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database CPU core count.
    pub is_auto_scaling_enabled: bool,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database storage.
    pub is_storage_auto_scaling_enabled: bool,

    /// Required. The license type used for the Autonomous Database.
    pub license_type: crate::model::autonomous_database_properties::LicenseType,

    /// Optional. The list of customer contacts.
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault secret.
    pub secret_id: std::string::String,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault.
    pub vault_id: std::string::String,

    /// Optional. The maintenance schedule of the Autonomous Database.
    pub maintenance_schedule_type:
        crate::model::autonomous_database_properties::MaintenanceScheduleType,

    /// Optional. This field specifies if the Autonomous Database requires mTLS
    /// connections.
    pub mtls_connection_required: bool,

    /// Optional. The retention period for the Autonomous Database. This field is
    /// specified in days, can range from 1 day to 60 days, and has a default value
    /// of 60 days.
    pub backup_retention_period_days: i32,

    /// Output only. The amount of storage currently being used for user and system
    /// data, in terabytes.
    pub actual_used_data_storage_size_tb: f64,

    /// Output only. The amount of storage currently allocated for the database
    /// tables and billed for, rounded up in terabytes.
    pub allocated_storage_size_tb: f64,

    /// Output only. The details for the Oracle APEX Application Development.
    pub apex_details: std::option::Option<crate::model::AutonomousDatabaseApex>,

    /// Output only. This field indicates the status of Data Guard and Access
    /// control for the Autonomous Database. The field's value is null if Data
    /// Guard is disabled or Access Control is disabled. The field's value is TRUE
    /// if both Data Guard and Access Control are enabled, and the Autonomous
    /// Database is using primary IP access control list (ACL) for standby. The
    /// field's value is FALSE if both Data Guard and Access Control are enabled,
    /// and the Autonomous Database is using a different IP access control list
    /// (ACL) for standby compared to primary.
    pub are_primary_allowlisted_ips_used: std::option::Option<bool>,

    /// Output only. The details of the current lifestyle state of the Autonomous
    /// Database.
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    pub state: crate::model::State,

    /// Output only. The Autonomous Container Database OCID.
    pub autonomous_container_database_id: std::string::String,

    /// Output only. The list of available Oracle Database upgrade versions for an
    /// Autonomous Database.
    pub available_upgrade_versions: std::vec::Vec<std::string::String>,

    /// Output only. The connection strings used to connect to an Autonomous
    /// Database.
    pub connection_strings: std::option::Option<crate::model::AutonomousDatabaseConnectionStrings>,

    /// Output only. The Oracle Connection URLs for an Autonomous Database.
    pub connection_urls: std::option::Option<crate::model::AutonomousDatabaseConnectionUrls>,

    /// Output only. This field indicates the number of seconds of data loss during
    /// a Data Guard failover.
    pub failed_data_recovery_duration: std::option::Option<wkt::Duration>,

    /// Output only. The memory assigned to in-memory tables in an Autonomous
    /// Database.
    pub memory_table_gbs: i32,

    /// Output only. This field indicates whether the Autonomous Database has local
    /// (in-region) Data Guard enabled.
    pub is_local_data_guard_enabled: bool,

    /// Output only. This field indicates the maximum data loss limit for an
    /// Autonomous Database, in seconds.
    pub local_adg_auto_failover_max_data_loss_limit: i32,

    /// Output only. The details of the Autonomous Data Guard standby database.
    pub local_standby_db: std::option::Option<crate::model::AutonomousDatabaseStandbySummary>,

    /// Output only. The amount of memory enabled per ECPU, in gigabytes.
    pub memory_per_oracle_compute_unit_gbs: i32,

    /// Output only. This field indicates the local disaster recovery (DR) type of
    /// an Autonomous Database.
    pub local_disaster_recovery_type:
        crate::model::autonomous_database_properties::LocalDisasterRecoveryType,

    /// Output only. The current state of the Data Safe registration for the
    /// Autonomous Database.
    pub data_safe_state: crate::model::autonomous_database_properties::DataSafeState,

    /// Output only. The current state of database management for the Autonomous
    /// Database.
    pub database_management_state:
        crate::model::autonomous_database_properties::DatabaseManagementState,

    /// Output only. This field indicates the current mode of the Autonomous
    /// Database.
    pub open_mode: crate::model::autonomous_database_properties::OpenMode,

    /// Output only. This field indicates the state of Operations Insights for the
    /// Autonomous Database.
    pub operations_insights_state: crate::model::OperationsInsightsState,

    /// Output only. The list of OCIDs of standby databases located in Autonomous
    /// Data Guard remote regions that are associated with the source database.
    pub peer_db_ids: std::vec::Vec<std::string::String>,

    /// Output only. The permission level of the Autonomous Database.
    pub permission_level: crate::model::autonomous_database_properties::PermissionLevel,

    /// Output only. The private endpoint for the Autonomous Database.
    pub private_endpoint: std::string::String,

    /// Output only. The refresh mode of the cloned Autonomous Database.
    pub refreshable_mode: crate::model::autonomous_database_properties::RefreshableMode,

    /// Output only. The refresh State of the clone.
    pub refreshable_state: crate::model::autonomous_database_properties::RefreshableState,

    /// Output only. The Data Guard role of the Autonomous Database.
    pub role: crate::model::autonomous_database_properties::Role,

    /// Output only. The list and details of the scheduled operations of the
    /// Autonomous Database.
    pub scheduled_operation_details: std::vec::Vec<crate::model::ScheduledOperationDetails>,

    /// Output only. The SQL Web Developer URL for the Autonomous Database.
    pub sql_web_developer_url: std::string::String,

    /// Output only. The list of available regions that can be used to create a
    /// clone for the Autonomous Database.
    pub supported_clone_regions: std::vec::Vec<std::string::String>,

    /// Output only. The storage space used by Autonomous Database, in gigabytes.
    pub used_data_storage_size_tbs: i32,

    /// Output only. The Oracle Cloud Infrastructure link for the Autonomous
    /// Database.
    pub oci_url: std::string::String,

    /// Output only. The storage space used by automatic backups of Autonomous
    /// Database, in gigabytes.
    pub total_auto_backup_storage_size_gbs: f32,

    /// Output only. The long term backup schedule of the Autonomous Database.
    pub next_long_term_backup_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will begin.
    pub maintenance_begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will end.
    pub maintenance_end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::AutonomousDatabaseProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::AutonomousDatabaseProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::AutonomousDatabaseProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_gb][crate::model::AutonomousDatabaseProperties::data_storage_size_gb].
    pub fn set_data_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDatabaseProperties::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [db_edition][crate::model::AutonomousDatabaseProperties::db_edition].
    pub fn set_db_edition<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseEdition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.db_edition = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseProperties::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }

    /// Sets the value of [n_character_set][crate::model::AutonomousDatabaseProperties::n_character_set].
    pub fn set_n_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n_character_set = v.into();
        self
    }

    /// Sets the value of [private_endpoint_ip][crate::model::AutonomousDatabaseProperties::private_endpoint_ip].
    pub fn set_private_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [private_endpoint_label][crate::model::AutonomousDatabaseProperties::private_endpoint_label].
    pub fn set_private_endpoint_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_label = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_auto_scaling_enabled].
    pub fn set_is_auto_scaling_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [is_storage_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_storage_auto_scaling_enabled].
    pub fn set_is_storage_auto_scaling_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_storage_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::AutonomousDatabaseProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [customer_contacts][crate::model::AutonomousDatabaseProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_id][crate::model::AutonomousDatabaseProperties::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }

    /// Sets the value of [maintenance_schedule_type][crate::model::AutonomousDatabaseProperties::maintenance_schedule_type].
    pub fn set_maintenance_schedule_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::MaintenanceScheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_schedule_type = v.into();
        self
    }

    /// Sets the value of [mtls_connection_required][crate::model::AutonomousDatabaseProperties::mtls_connection_required].
    pub fn set_mtls_connection_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.mtls_connection_required = v.into();
        self
    }

    /// Sets the value of [backup_retention_period_days][crate::model::AutonomousDatabaseProperties::backup_retention_period_days].
    pub fn set_backup_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.backup_retention_period_days = v.into();
        self
    }

    /// Sets the value of [actual_used_data_storage_size_tb][crate::model::AutonomousDatabaseProperties::actual_used_data_storage_size_tb].
    pub fn set_actual_used_data_storage_size_tb<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.actual_used_data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [allocated_storage_size_tb][crate::model::AutonomousDatabaseProperties::allocated_storage_size_tb].
    pub fn set_allocated_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.allocated_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [apex_details][crate::model::AutonomousDatabaseProperties::apex_details].
    pub fn set_apex_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseApex>,
    {
        self.apex_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [apex_details][crate::model::AutonomousDatabaseProperties::apex_details].
    pub fn set_or_clear_apex_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseApex>,
    {
        self.apex_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [are_primary_allowlisted_ips_used][crate::model::AutonomousDatabaseProperties::are_primary_allowlisted_ips_used].
    pub fn set_are_primary_allowlisted_ips_used<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.are_primary_allowlisted_ips_used = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [are_primary_allowlisted_ips_used][crate::model::AutonomousDatabaseProperties::are_primary_allowlisted_ips_used].
    pub fn set_or_clear_are_primary_allowlisted_ips_used<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.are_primary_allowlisted_ips_used = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [autonomous_container_database_id][crate::model::AutonomousDatabaseProperties::autonomous_container_database_id].
    pub fn set_autonomous_container_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_container_database_id = v.into();
        self
    }

    /// Sets the value of [available_upgrade_versions][crate::model::AutonomousDatabaseProperties::available_upgrade_versions].
    pub fn set_available_upgrade_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_upgrade_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_strings][crate::model::AutonomousDatabaseProperties::connection_strings].
    pub fn set_connection_strings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionStrings>,
    {
        self.connection_strings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_strings][crate::model::AutonomousDatabaseProperties::connection_strings].
    pub fn set_or_clear_connection_strings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionStrings>,
    {
        self.connection_strings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_urls][crate::model::AutonomousDatabaseProperties::connection_urls].
    pub fn set_connection_urls<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionUrls>,
    {
        self.connection_urls = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_urls][crate::model::AutonomousDatabaseProperties::connection_urls].
    pub fn set_or_clear_connection_urls<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionUrls>,
    {
        self.connection_urls = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failed_data_recovery_duration][crate::model::AutonomousDatabaseProperties::failed_data_recovery_duration].
    pub fn set_failed_data_recovery_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.failed_data_recovery_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failed_data_recovery_duration][crate::model::AutonomousDatabaseProperties::failed_data_recovery_duration].
    pub fn set_or_clear_failed_data_recovery_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.failed_data_recovery_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_table_gbs][crate::model::AutonomousDatabaseProperties::memory_table_gbs].
    pub fn set_memory_table_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_table_gbs = v.into();
        self
    }

    /// Sets the value of [is_local_data_guard_enabled][crate::model::AutonomousDatabaseProperties::is_local_data_guard_enabled].
    pub fn set_is_local_data_guard_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_local_data_guard_enabled = v.into();
        self
    }

    /// Sets the value of [local_adg_auto_failover_max_data_loss_limit][crate::model::AutonomousDatabaseProperties::local_adg_auto_failover_max_data_loss_limit].
    pub fn set_local_adg_auto_failover_max_data_loss_limit<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_adg_auto_failover_max_data_loss_limit = v.into();
        self
    }

    /// Sets the value of [local_standby_db][crate::model::AutonomousDatabaseProperties::local_standby_db].
    pub fn set_local_standby_db<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseStandbySummary>,
    {
        self.local_standby_db = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_standby_db][crate::model::AutonomousDatabaseProperties::local_standby_db].
    pub fn set_or_clear_local_standby_db<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseStandbySummary>,
    {
        self.local_standby_db = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_per_oracle_compute_unit_gbs][crate::model::AutonomousDatabaseProperties::memory_per_oracle_compute_unit_gbs].
    pub fn set_memory_per_oracle_compute_unit_gbs<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.memory_per_oracle_compute_unit_gbs = v.into();
        self
    }

    /// Sets the value of [local_disaster_recovery_type][crate::model::AutonomousDatabaseProperties::local_disaster_recovery_type].
    pub fn set_local_disaster_recovery_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LocalDisasterRecoveryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_disaster_recovery_type = v.into();
        self
    }

    /// Sets the value of [data_safe_state][crate::model::AutonomousDatabaseProperties::data_safe_state].
    pub fn set_data_safe_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DataSafeState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_safe_state = v.into();
        self
    }

    /// Sets the value of [database_management_state][crate::model::AutonomousDatabaseProperties::database_management_state].
    pub fn set_database_management_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseManagementState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_management_state = v.into();
        self
    }

    /// Sets the value of [open_mode][crate::model::AutonomousDatabaseProperties::open_mode].
    pub fn set_open_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::OpenMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_mode = v.into();
        self
    }

    /// Sets the value of [operations_insights_state][crate::model::AutonomousDatabaseProperties::operations_insights_state].
    pub fn set_operations_insights_state<
        T: std::convert::Into<crate::model::OperationsInsightsState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operations_insights_state = v.into();
        self
    }

    /// Sets the value of [peer_db_ids][crate::model::AutonomousDatabaseProperties::peer_db_ids].
    pub fn set_peer_db_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_db_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [permission_level][crate::model::AutonomousDatabaseProperties::permission_level].
    pub fn set_permission_level<
        T: std::convert::Into<crate::model::autonomous_database_properties::PermissionLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.permission_level = v.into();
        self
    }

    /// Sets the value of [private_endpoint][crate::model::AutonomousDatabaseProperties::private_endpoint].
    pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint = v.into();
        self
    }

    /// Sets the value of [refreshable_mode][crate::model::AutonomousDatabaseProperties::refreshable_mode].
    pub fn set_refreshable_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_mode = v.into();
        self
    }

    /// Sets the value of [refreshable_state][crate::model::AutonomousDatabaseProperties::refreshable_state].
    pub fn set_refreshable_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_state = v.into();
        self
    }

    /// Sets the value of [role][crate::model::AutonomousDatabaseProperties::role].
    pub fn set_role<T: std::convert::Into<crate::model::autonomous_database_properties::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [scheduled_operation_details][crate::model::AutonomousDatabaseProperties::scheduled_operation_details].
    pub fn set_scheduled_operation_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScheduledOperationDetails>,
    {
        use std::iter::Iterator;
        self.scheduled_operation_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sql_web_developer_url][crate::model::AutonomousDatabaseProperties::sql_web_developer_url].
    pub fn set_sql_web_developer_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sql_web_developer_url = v.into();
        self
    }

    /// Sets the value of [supported_clone_regions][crate::model::AutonomousDatabaseProperties::supported_clone_regions].
    pub fn set_supported_clone_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_clone_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [used_data_storage_size_tbs][crate::model::AutonomousDatabaseProperties::used_data_storage_size_tbs].
    pub fn set_used_data_storage_size_tbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.used_data_storage_size_tbs = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::AutonomousDatabaseProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [total_auto_backup_storage_size_gbs][crate::model::AutonomousDatabaseProperties::total_auto_backup_storage_size_gbs].
    pub fn set_total_auto_backup_storage_size_gbs<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_auto_backup_storage_size_gbs = v.into();
        self
    }

    /// Sets the value of [next_long_term_backup_time][crate::model::AutonomousDatabaseProperties::next_long_term_backup_time].
    pub fn set_next_long_term_backup_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_long_term_backup_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_long_term_backup_time][crate::model::AutonomousDatabaseProperties::next_long_term_backup_time].
    pub fn set_or_clear_next_long_term_backup_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_long_term_backup_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_begin_time][crate::model::AutonomousDatabaseProperties::maintenance_begin_time].
    pub fn set_maintenance_begin_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_begin_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_begin_time][crate::model::AutonomousDatabaseProperties::maintenance_begin_time].
    pub fn set_or_clear_maintenance_begin_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_begin_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_end_time][crate::model::AutonomousDatabaseProperties::maintenance_end_time].
    pub fn set_maintenance_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_end_time][crate::model::AutonomousDatabaseProperties::maintenance_end_time].
    pub fn set_or_clear_maintenance_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __compute_count,
            __cpu_core_count,
            __data_storage_size_tb,
            __data_storage_size_gb,
            __db_workload,
            __db_edition,
            __character_set,
            __n_character_set,
            __private_endpoint_ip,
            __private_endpoint_label,
            __db_version,
            __is_auto_scaling_enabled,
            __is_storage_auto_scaling_enabled,
            __license_type,
            __customer_contacts,
            __secret_id,
            __vault_id,
            __maintenance_schedule_type,
            __mtls_connection_required,
            __backup_retention_period_days,
            __actual_used_data_storage_size_tb,
            __allocated_storage_size_tb,
            __apex_details,
            __are_primary_allowlisted_ips_used,
            __lifecycle_details,
            __state,
            __autonomous_container_database_id,
            __available_upgrade_versions,
            __connection_strings,
            __connection_urls,
            __failed_data_recovery_duration,
            __memory_table_gbs,
            __is_local_data_guard_enabled,
            __local_adg_auto_failover_max_data_loss_limit,
            __local_standby_db,
            __memory_per_oracle_compute_unit_gbs,
            __local_disaster_recovery_type,
            __data_safe_state,
            __database_management_state,
            __open_mode,
            __operations_insights_state,
            __peer_db_ids,
            __permission_level,
            __private_endpoint,
            __refreshable_mode,
            __refreshable_state,
            __role,
            __scheduled_operation_details,
            __sql_web_developer_url,
            __supported_clone_regions,
            __used_data_storage_size_tbs,
            __oci_url,
            __total_auto_backup_storage_size_gbs,
            __next_long_term_backup_time,
            __maintenance_begin_time,
            __maintenance_end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "computeCount" => Ok(__FieldTag::__compute_count),
                            "compute_count" => Ok(__FieldTag::__compute_count),
                            "cpuCoreCount" => Ok(__FieldTag::__cpu_core_count),
                            "cpu_core_count" => Ok(__FieldTag::__cpu_core_count),
                            "dataStorageSizeTb" => Ok(__FieldTag::__data_storage_size_tb),
                            "data_storage_size_tb" => Ok(__FieldTag::__data_storage_size_tb),
                            "dataStorageSizeGb" => Ok(__FieldTag::__data_storage_size_gb),
                            "data_storage_size_gb" => Ok(__FieldTag::__data_storage_size_gb),
                            "dbWorkload" => Ok(__FieldTag::__db_workload),
                            "db_workload" => Ok(__FieldTag::__db_workload),
                            "dbEdition" => Ok(__FieldTag::__db_edition),
                            "db_edition" => Ok(__FieldTag::__db_edition),
                            "characterSet" => Ok(__FieldTag::__character_set),
                            "character_set" => Ok(__FieldTag::__character_set),
                            "nCharacterSet" => Ok(__FieldTag::__n_character_set),
                            "n_character_set" => Ok(__FieldTag::__n_character_set),
                            "privateEndpointIp" => Ok(__FieldTag::__private_endpoint_ip),
                            "private_endpoint_ip" => Ok(__FieldTag::__private_endpoint_ip),
                            "privateEndpointLabel" => Ok(__FieldTag::__private_endpoint_label),
                            "private_endpoint_label" => Ok(__FieldTag::__private_endpoint_label),
                            "dbVersion" => Ok(__FieldTag::__db_version),
                            "db_version" => Ok(__FieldTag::__db_version),
                            "isAutoScalingEnabled" => Ok(__FieldTag::__is_auto_scaling_enabled),
                            "is_auto_scaling_enabled" => Ok(__FieldTag::__is_auto_scaling_enabled),
                            "isStorageAutoScalingEnabled" => {
                                Ok(__FieldTag::__is_storage_auto_scaling_enabled)
                            }
                            "is_storage_auto_scaling_enabled" => {
                                Ok(__FieldTag::__is_storage_auto_scaling_enabled)
                            }
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "customerContacts" => Ok(__FieldTag::__customer_contacts),
                            "customer_contacts" => Ok(__FieldTag::__customer_contacts),
                            "secretId" => Ok(__FieldTag::__secret_id),
                            "secret_id" => Ok(__FieldTag::__secret_id),
                            "vaultId" => Ok(__FieldTag::__vault_id),
                            "vault_id" => Ok(__FieldTag::__vault_id),
                            "maintenanceScheduleType" => {
                                Ok(__FieldTag::__maintenance_schedule_type)
                            }
                            "maintenance_schedule_type" => {
                                Ok(__FieldTag::__maintenance_schedule_type)
                            }
                            "mtlsConnectionRequired" => Ok(__FieldTag::__mtls_connection_required),
                            "mtls_connection_required" => {
                                Ok(__FieldTag::__mtls_connection_required)
                            }
                            "backupRetentionPeriodDays" => {
                                Ok(__FieldTag::__backup_retention_period_days)
                            }
                            "backup_retention_period_days" => {
                                Ok(__FieldTag::__backup_retention_period_days)
                            }
                            "actualUsedDataStorageSizeTb" => {
                                Ok(__FieldTag::__actual_used_data_storage_size_tb)
                            }
                            "actual_used_data_storage_size_tb" => {
                                Ok(__FieldTag::__actual_used_data_storage_size_tb)
                            }
                            "allocatedStorageSizeTb" => Ok(__FieldTag::__allocated_storage_size_tb),
                            "allocated_storage_size_tb" => {
                                Ok(__FieldTag::__allocated_storage_size_tb)
                            }
                            "apexDetails" => Ok(__FieldTag::__apex_details),
                            "apex_details" => Ok(__FieldTag::__apex_details),
                            "arePrimaryAllowlistedIpsUsed" => {
                                Ok(__FieldTag::__are_primary_allowlisted_ips_used)
                            }
                            "are_primary_allowlisted_ips_used" => {
                                Ok(__FieldTag::__are_primary_allowlisted_ips_used)
                            }
                            "lifecycleDetails" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycle_details" => Ok(__FieldTag::__lifecycle_details),
                            "state" => Ok(__FieldTag::__state),
                            "autonomousContainerDatabaseId" => {
                                Ok(__FieldTag::__autonomous_container_database_id)
                            }
                            "autonomous_container_database_id" => {
                                Ok(__FieldTag::__autonomous_container_database_id)
                            }
                            "availableUpgradeVersions" => {
                                Ok(__FieldTag::__available_upgrade_versions)
                            }
                            "available_upgrade_versions" => {
                                Ok(__FieldTag::__available_upgrade_versions)
                            }
                            "connectionStrings" => Ok(__FieldTag::__connection_strings),
                            "connection_strings" => Ok(__FieldTag::__connection_strings),
                            "connectionUrls" => Ok(__FieldTag::__connection_urls),
                            "connection_urls" => Ok(__FieldTag::__connection_urls),
                            "failedDataRecoveryDuration" => {
                                Ok(__FieldTag::__failed_data_recovery_duration)
                            }
                            "failed_data_recovery_duration" => {
                                Ok(__FieldTag::__failed_data_recovery_duration)
                            }
                            "memoryTableGbs" => Ok(__FieldTag::__memory_table_gbs),
                            "memory_table_gbs" => Ok(__FieldTag::__memory_table_gbs),
                            "isLocalDataGuardEnabled" => {
                                Ok(__FieldTag::__is_local_data_guard_enabled)
                            }
                            "is_local_data_guard_enabled" => {
                                Ok(__FieldTag::__is_local_data_guard_enabled)
                            }
                            "localAdgAutoFailoverMaxDataLossLimit" => {
                                Ok(__FieldTag::__local_adg_auto_failover_max_data_loss_limit)
                            }
                            "local_adg_auto_failover_max_data_loss_limit" => {
                                Ok(__FieldTag::__local_adg_auto_failover_max_data_loss_limit)
                            }
                            "localStandbyDb" => Ok(__FieldTag::__local_standby_db),
                            "local_standby_db" => Ok(__FieldTag::__local_standby_db),
                            "memoryPerOracleComputeUnitGbs" => {
                                Ok(__FieldTag::__memory_per_oracle_compute_unit_gbs)
                            }
                            "memory_per_oracle_compute_unit_gbs" => {
                                Ok(__FieldTag::__memory_per_oracle_compute_unit_gbs)
                            }
                            "localDisasterRecoveryType" => {
                                Ok(__FieldTag::__local_disaster_recovery_type)
                            }
                            "local_disaster_recovery_type" => {
                                Ok(__FieldTag::__local_disaster_recovery_type)
                            }
                            "dataSafeState" => Ok(__FieldTag::__data_safe_state),
                            "data_safe_state" => Ok(__FieldTag::__data_safe_state),
                            "databaseManagementState" => {
                                Ok(__FieldTag::__database_management_state)
                            }
                            "database_management_state" => {
                                Ok(__FieldTag::__database_management_state)
                            }
                            "openMode" => Ok(__FieldTag::__open_mode),
                            "open_mode" => Ok(__FieldTag::__open_mode),
                            "operationsInsightsState" => {
                                Ok(__FieldTag::__operations_insights_state)
                            }
                            "operations_insights_state" => {
                                Ok(__FieldTag::__operations_insights_state)
                            }
                            "peerDbIds" => Ok(__FieldTag::__peer_db_ids),
                            "peer_db_ids" => Ok(__FieldTag::__peer_db_ids),
                            "permissionLevel" => Ok(__FieldTag::__permission_level),
                            "permission_level" => Ok(__FieldTag::__permission_level),
                            "privateEndpoint" => Ok(__FieldTag::__private_endpoint),
                            "private_endpoint" => Ok(__FieldTag::__private_endpoint),
                            "refreshableMode" => Ok(__FieldTag::__refreshable_mode),
                            "refreshable_mode" => Ok(__FieldTag::__refreshable_mode),
                            "refreshableState" => Ok(__FieldTag::__refreshable_state),
                            "refreshable_state" => Ok(__FieldTag::__refreshable_state),
                            "role" => Ok(__FieldTag::__role),
                            "scheduledOperationDetails" => {
                                Ok(__FieldTag::__scheduled_operation_details)
                            }
                            "scheduled_operation_details" => {
                                Ok(__FieldTag::__scheduled_operation_details)
                            }
                            "sqlWebDeveloperUrl" => Ok(__FieldTag::__sql_web_developer_url),
                            "sql_web_developer_url" => Ok(__FieldTag::__sql_web_developer_url),
                            "supportedCloneRegions" => Ok(__FieldTag::__supported_clone_regions),
                            "supported_clone_regions" => Ok(__FieldTag::__supported_clone_regions),
                            "usedDataStorageSizeTbs" => {
                                Ok(__FieldTag::__used_data_storage_size_tbs)
                            }
                            "used_data_storage_size_tbs" => {
                                Ok(__FieldTag::__used_data_storage_size_tbs)
                            }
                            "ociUrl" => Ok(__FieldTag::__oci_url),
                            "oci_url" => Ok(__FieldTag::__oci_url),
                            "totalAutoBackupStorageSizeGbs" => {
                                Ok(__FieldTag::__total_auto_backup_storage_size_gbs)
                            }
                            "total_auto_backup_storage_size_gbs" => {
                                Ok(__FieldTag::__total_auto_backup_storage_size_gbs)
                            }
                            "nextLongTermBackupTime" => {
                                Ok(__FieldTag::__next_long_term_backup_time)
                            }
                            "next_long_term_backup_time" => {
                                Ok(__FieldTag::__next_long_term_backup_time)
                            }
                            "maintenanceBeginTime" => Ok(__FieldTag::__maintenance_begin_time),
                            "maintenance_begin_time" => Ok(__FieldTag::__maintenance_begin_time),
                            "maintenanceEndTime" => Ok(__FieldTag::__maintenance_end_time),
                            "maintenance_end_time" => Ok(__FieldTag::__maintenance_end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_count => {
                            if !fields.insert(__FieldTag::__compute_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_count",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cpu_core_count => {
                            if !fields.insert(__FieldTag::__cpu_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_gb => {
                            if !fields.insert(__FieldTag::__data_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_workload => {
                            if !fields.insert(__FieldTag::__db_workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_workload",
                                ));
                            }
                            result.db_workload = map
                                .next_value::<std::option::Option<crate::model::DBWorkload>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_edition => {
                            if !fields.insert(__FieldTag::__db_edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_edition",
                                ));
                            }
                            result.db_edition = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::DatabaseEdition,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__character_set => {
                            if !fields.insert(__FieldTag::__character_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character_set",
                                ));
                            }
                            result.character_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__n_character_set => {
                            if !fields.insert(__FieldTag::__n_character_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for n_character_set",
                                ));
                            }
                            result.n_character_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint_ip => {
                            if !fields.insert(__FieldTag::__private_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_ip",
                                ));
                            }
                            result.private_endpoint_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint_label => {
                            if !fields.insert(__FieldTag::__private_endpoint_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_label",
                                ));
                            }
                            result.private_endpoint_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_version => {
                            if !fields.insert(__FieldTag::__db_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_version",
                                ));
                            }
                            result.db_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_auto_scaling_enabled => {
                            if !fields.insert(__FieldTag::__is_auto_scaling_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_auto_scaling_enabled",
                                ));
                            }
                            result.is_auto_scaling_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_storage_auto_scaling_enabled => {
                            if !fields.insert(__FieldTag::__is_storage_auto_scaling_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_storage_auto_scaling_enabled",
                                ));
                            }
                            result.is_storage_auto_scaling_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::LicenseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customer_contacts => {
                            if !fields.insert(__FieldTag::__customer_contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_contacts",
                                ));
                            }
                            result.customer_contacts =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomerContact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_id => {
                            if !fields.insert(__FieldTag::__secret_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_id",
                                ));
                            }
                            result.secret_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vault_id => {
                            if !fields.insert(__FieldTag::__vault_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vault_id",
                                ));
                            }
                            result.vault_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_schedule_type => {
                            if !fields.insert(__FieldTag::__maintenance_schedule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_schedule_type",
                                ));
                            }
                            result.maintenance_schedule_type = map.next_value::<std::option::Option<crate::model::autonomous_database_properties::MaintenanceScheduleType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mtls_connection_required => {
                            if !fields.insert(__FieldTag::__mtls_connection_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mtls_connection_required",
                                ));
                            }
                            result.mtls_connection_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_retention_period_days => {
                            if !fields.insert(__FieldTag::__backup_retention_period_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_retention_period_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_retention_period_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__actual_used_data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__actual_used_data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actual_used_data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.actual_used_data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__allocated_storage_size_tb => {
                            if !fields.insert(__FieldTag::__allocated_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocated_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.allocated_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__apex_details => {
                            if !fields.insert(__FieldTag::__apex_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apex_details",
                                ));
                            }
                            result.apex_details = map.next_value::<std::option::Option<crate::model::AutonomousDatabaseApex>>()?
                                ;
                        }
                        __FieldTag::__are_primary_allowlisted_ips_used => {
                            if !fields.insert(__FieldTag::__are_primary_allowlisted_ips_used) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for are_primary_allowlisted_ips_used",
                                ));
                            }
                            result.are_primary_allowlisted_ips_used =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__lifecycle_details => {
                            if !fields.insert(__FieldTag::__lifecycle_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_details",
                                ));
                            }
                            result.lifecycle_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_container_database_id => {
                            if !fields.insert(__FieldTag::__autonomous_container_database_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_container_database_id",
                                ));
                            }
                            result.autonomous_container_database_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_upgrade_versions => {
                            if !fields.insert(__FieldTag::__available_upgrade_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_upgrade_versions",
                                ));
                            }
                            result.available_upgrade_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__connection_strings => {
                            if !fields.insert(__FieldTag::__connection_strings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_strings",
                                ));
                            }
                            result.connection_strings = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseConnectionStrings,
                            >>()?;
                        }
                        __FieldTag::__connection_urls => {
                            if !fields.insert(__FieldTag::__connection_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_urls",
                                ));
                            }
                            result.connection_urls = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseConnectionUrls,
                            >>()?;
                        }
                        __FieldTag::__failed_data_recovery_duration => {
                            if !fields.insert(__FieldTag::__failed_data_recovery_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_data_recovery_duration",
                                ));
                            }
                            result.failed_data_recovery_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__memory_table_gbs => {
                            if !fields.insert(__FieldTag::__memory_table_gbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_table_gbs",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_table_gbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__is_local_data_guard_enabled => {
                            if !fields.insert(__FieldTag::__is_local_data_guard_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_local_data_guard_enabled",
                                ));
                            }
                            result.is_local_data_guard_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_adg_auto_failover_max_data_loss_limit => {
                            if !fields
                                .insert(__FieldTag::__local_adg_auto_failover_max_data_loss_limit)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_adg_auto_failover_max_data_loss_limit",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_adg_auto_failover_max_data_loss_limit =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__local_standby_db => {
                            if !fields.insert(__FieldTag::__local_standby_db) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_standby_db",
                                ));
                            }
                            result.local_standby_db = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseStandbySummary,
                            >>()?;
                        }
                        __FieldTag::__memory_per_oracle_compute_unit_gbs => {
                            if !fields.insert(__FieldTag::__memory_per_oracle_compute_unit_gbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_per_oracle_compute_unit_gbs",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_per_oracle_compute_unit_gbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__local_disaster_recovery_type => {
                            if !fields.insert(__FieldTag::__local_disaster_recovery_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_disaster_recovery_type",
                                ));
                            }
                            result.local_disaster_recovery_type = map.next_value::<std::option::Option<crate::model::autonomous_database_properties::LocalDisasterRecoveryType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_safe_state => {
                            if !fields.insert(__FieldTag::__data_safe_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_safe_state",
                                ));
                            }
                            result.data_safe_state = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::DataSafeState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_management_state => {
                            if !fields.insert(__FieldTag::__database_management_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_management_state",
                                ));
                            }
                            result.database_management_state = map.next_value::<std::option::Option<crate::model::autonomous_database_properties::DatabaseManagementState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__open_mode => {
                            if !fields.insert(__FieldTag::__open_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for open_mode",
                                ));
                            }
                            result.open_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::OpenMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operations_insights_state => {
                            if !fields.insert(__FieldTag::__operations_insights_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations_insights_state",
                                ));
                            }
                            result.operations_insights_state = map.next_value::<std::option::Option<crate::model::OperationsInsightsState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__peer_db_ids => {
                            if !fields.insert(__FieldTag::__peer_db_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_db_ids",
                                ));
                            }
                            result.peer_db_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__permission_level => {
                            if !fields.insert(__FieldTag::__permission_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permission_level",
                                ));
                            }
                            result.permission_level = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::PermissionLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint => {
                            if !fields.insert(__FieldTag::__private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint",
                                ));
                            }
                            result.private_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__refreshable_mode => {
                            if !fields.insert(__FieldTag::__refreshable_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refreshable_mode",
                                ));
                            }
                            result.refreshable_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::RefreshableMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__refreshable_state => {
                            if !fields.insert(__FieldTag::__refreshable_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refreshable_state",
                                ));
                            }
                            result.refreshable_state = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::RefreshableState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_properties::Role,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduled_operation_details => {
                            if !fields.insert(__FieldTag::__scheduled_operation_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduled_operation_details",
                                ));
                            }
                            result.scheduled_operation_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ScheduledOperationDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_web_developer_url => {
                            if !fields.insert(__FieldTag::__sql_web_developer_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_web_developer_url",
                                ));
                            }
                            result.sql_web_developer_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_clone_regions => {
                            if !fields.insert(__FieldTag::__supported_clone_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_clone_regions",
                                ));
                            }
                            result.supported_clone_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__used_data_storage_size_tbs => {
                            if !fields.insert(__FieldTag::__used_data_storage_size_tbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_data_storage_size_tbs",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.used_data_storage_size_tbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oci_url => {
                            if !fields.insert(__FieldTag::__oci_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oci_url",
                                ));
                            }
                            result.oci_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_auto_backup_storage_size_gbs => {
                            if !fields.insert(__FieldTag::__total_auto_backup_storage_size_gbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_auto_backup_storage_size_gbs",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_auto_backup_storage_size_gbs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__next_long_term_backup_time => {
                            if !fields.insert(__FieldTag::__next_long_term_backup_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_long_term_backup_time",
                                ));
                            }
                            result.next_long_term_backup_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__maintenance_begin_time => {
                            if !fields.insert(__FieldTag::__maintenance_begin_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_begin_time",
                                ));
                            }
                            result.maintenance_begin_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__maintenance_end_time => {
                            if !fields.insert(__FieldTag::__maintenance_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_end_time",
                                ));
                            }
                            result.maintenance_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ocid.is_empty() {
            state.serialize_entry("ocid", &self.ocid)?;
        }
        if !wkt::internal::is_default(&self.compute_count) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("computeCount", &__With(&self.compute_count))?;
        }
        if !wkt::internal::is_default(&self.cpu_core_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCoreCount", &__With(&self.cpu_core_count))?;
        }
        if !wkt::internal::is_default(&self.data_storage_size_tb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataStorageSizeTb", &__With(&self.data_storage_size_tb))?;
        }
        if !wkt::internal::is_default(&self.data_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataStorageSizeGb", &__With(&self.data_storage_size_gb))?;
        }
        if !wkt::internal::is_default(&self.db_workload) {
            state.serialize_entry("dbWorkload", &self.db_workload)?;
        }
        if !wkt::internal::is_default(&self.db_edition) {
            state.serialize_entry("dbEdition", &self.db_edition)?;
        }
        if !self.character_set.is_empty() {
            state.serialize_entry("characterSet", &self.character_set)?;
        }
        if !self.n_character_set.is_empty() {
            state.serialize_entry("nCharacterSet", &self.n_character_set)?;
        }
        if !self.private_endpoint_ip.is_empty() {
            state.serialize_entry("privateEndpointIp", &self.private_endpoint_ip)?;
        }
        if !self.private_endpoint_label.is_empty() {
            state.serialize_entry("privateEndpointLabel", &self.private_endpoint_label)?;
        }
        if !self.db_version.is_empty() {
            state.serialize_entry("dbVersion", &self.db_version)?;
        }
        if !wkt::internal::is_default(&self.is_auto_scaling_enabled) {
            state.serialize_entry("isAutoScalingEnabled", &self.is_auto_scaling_enabled)?;
        }
        if !wkt::internal::is_default(&self.is_storage_auto_scaling_enabled) {
            state.serialize_entry(
                "isStorageAutoScalingEnabled",
                &self.is_storage_auto_scaling_enabled,
            )?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if !self.customer_contacts.is_empty() {
            state.serialize_entry("customerContacts", &self.customer_contacts)?;
        }
        if !self.secret_id.is_empty() {
            state.serialize_entry("secretId", &self.secret_id)?;
        }
        if !self.vault_id.is_empty() {
            state.serialize_entry("vaultId", &self.vault_id)?;
        }
        if !wkt::internal::is_default(&self.maintenance_schedule_type) {
            state.serialize_entry("maintenanceScheduleType", &self.maintenance_schedule_type)?;
        }
        if !wkt::internal::is_default(&self.mtls_connection_required) {
            state.serialize_entry("mtlsConnectionRequired", &self.mtls_connection_required)?;
        }
        if !wkt::internal::is_default(&self.backup_retention_period_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "backupRetentionPeriodDays",
                &__With(&self.backup_retention_period_days),
            )?;
        }
        if !wkt::internal::is_default(&self.actual_used_data_storage_size_tb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "actualUsedDataStorageSizeTb",
                &__With(&self.actual_used_data_storage_size_tb),
            )?;
        }
        if !wkt::internal::is_default(&self.allocated_storage_size_tb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "allocatedStorageSizeTb",
                &__With(&self.allocated_storage_size_tb),
            )?;
        }
        if self.apex_details.is_some() {
            state.serialize_entry("apexDetails", &self.apex_details)?;
        }
        if self.are_primary_allowlisted_ips_used.is_some() {
            state.serialize_entry(
                "arePrimaryAllowlistedIpsUsed",
                &self.are_primary_allowlisted_ips_used,
            )?;
        }
        if !self.lifecycle_details.is_empty() {
            state.serialize_entry("lifecycleDetails", &self.lifecycle_details)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.autonomous_container_database_id.is_empty() {
            state.serialize_entry(
                "autonomousContainerDatabaseId",
                &self.autonomous_container_database_id,
            )?;
        }
        if !self.available_upgrade_versions.is_empty() {
            state.serialize_entry("availableUpgradeVersions", &self.available_upgrade_versions)?;
        }
        if self.connection_strings.is_some() {
            state.serialize_entry("connectionStrings", &self.connection_strings)?;
        }
        if self.connection_urls.is_some() {
            state.serialize_entry("connectionUrls", &self.connection_urls)?;
        }
        if self.failed_data_recovery_duration.is_some() {
            state.serialize_entry(
                "failedDataRecoveryDuration",
                &self.failed_data_recovery_duration,
            )?;
        }
        if !wkt::internal::is_default(&self.memory_table_gbs) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryTableGbs", &__With(&self.memory_table_gbs))?;
        }
        if !wkt::internal::is_default(&self.is_local_data_guard_enabled) {
            state.serialize_entry("isLocalDataGuardEnabled", &self.is_local_data_guard_enabled)?;
        }
        if !wkt::internal::is_default(&self.local_adg_auto_failover_max_data_loss_limit) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "localAdgAutoFailoverMaxDataLossLimit",
                &__With(&self.local_adg_auto_failover_max_data_loss_limit),
            )?;
        }
        if self.local_standby_db.is_some() {
            state.serialize_entry("localStandbyDb", &self.local_standby_db)?;
        }
        if !wkt::internal::is_default(&self.memory_per_oracle_compute_unit_gbs) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "memoryPerOracleComputeUnitGbs",
                &__With(&self.memory_per_oracle_compute_unit_gbs),
            )?;
        }
        if !wkt::internal::is_default(&self.local_disaster_recovery_type) {
            state.serialize_entry(
                "localDisasterRecoveryType",
                &self.local_disaster_recovery_type,
            )?;
        }
        if !wkt::internal::is_default(&self.data_safe_state) {
            state.serialize_entry("dataSafeState", &self.data_safe_state)?;
        }
        if !wkt::internal::is_default(&self.database_management_state) {
            state.serialize_entry("databaseManagementState", &self.database_management_state)?;
        }
        if !wkt::internal::is_default(&self.open_mode) {
            state.serialize_entry("openMode", &self.open_mode)?;
        }
        if !wkt::internal::is_default(&self.operations_insights_state) {
            state.serialize_entry("operationsInsightsState", &self.operations_insights_state)?;
        }
        if !self.peer_db_ids.is_empty() {
            state.serialize_entry("peerDbIds", &self.peer_db_ids)?;
        }
        if !wkt::internal::is_default(&self.permission_level) {
            state.serialize_entry("permissionLevel", &self.permission_level)?;
        }
        if !self.private_endpoint.is_empty() {
            state.serialize_entry("privateEndpoint", &self.private_endpoint)?;
        }
        if !wkt::internal::is_default(&self.refreshable_mode) {
            state.serialize_entry("refreshableMode", &self.refreshable_mode)?;
        }
        if !wkt::internal::is_default(&self.refreshable_state) {
            state.serialize_entry("refreshableState", &self.refreshable_state)?;
        }
        if !wkt::internal::is_default(&self.role) {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.scheduled_operation_details.is_empty() {
            state.serialize_entry(
                "scheduledOperationDetails",
                &self.scheduled_operation_details,
            )?;
        }
        if !self.sql_web_developer_url.is_empty() {
            state.serialize_entry("sqlWebDeveloperUrl", &self.sql_web_developer_url)?;
        }
        if !self.supported_clone_regions.is_empty() {
            state.serialize_entry("supportedCloneRegions", &self.supported_clone_regions)?;
        }
        if !wkt::internal::is_default(&self.used_data_storage_size_tbs) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "usedDataStorageSizeTbs",
                &__With(&self.used_data_storage_size_tbs),
            )?;
        }
        if !self.oci_url.is_empty() {
            state.serialize_entry("ociUrl", &self.oci_url)?;
        }
        if !wkt::internal::is_default(&self.total_auto_backup_storage_size_gbs) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalAutoBackupStorageSizeGbs",
                &__With(&self.total_auto_backup_storage_size_gbs),
            )?;
        }
        if self.next_long_term_backup_time.is_some() {
            state.serialize_entry("nextLongTermBackupTime", &self.next_long_term_backup_time)?;
        }
        if self.maintenance_begin_time.is_some() {
            state.serialize_entry("maintenanceBeginTime", &self.maintenance_begin_time)?;
        }
        if self.maintenance_end_time.is_some() {
            state.serialize_entry("maintenanceEndTime", &self.maintenance_end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseProperties");
        debug_struct.field("ocid", &self.ocid);
        debug_struct.field("compute_count", &self.compute_count);
        debug_struct.field("cpu_core_count", &self.cpu_core_count);
        debug_struct.field("data_storage_size_tb", &self.data_storage_size_tb);
        debug_struct.field("data_storage_size_gb", &self.data_storage_size_gb);
        debug_struct.field("db_workload", &self.db_workload);
        debug_struct.field("db_edition", &self.db_edition);
        debug_struct.field("character_set", &self.character_set);
        debug_struct.field("n_character_set", &self.n_character_set);
        debug_struct.field("private_endpoint_ip", &self.private_endpoint_ip);
        debug_struct.field("private_endpoint_label", &self.private_endpoint_label);
        debug_struct.field("db_version", &self.db_version);
        debug_struct.field("is_auto_scaling_enabled", &self.is_auto_scaling_enabled);
        debug_struct.field(
            "is_storage_auto_scaling_enabled",
            &self.is_storage_auto_scaling_enabled,
        );
        debug_struct.field("license_type", &self.license_type);
        debug_struct.field("customer_contacts", &self.customer_contacts);
        debug_struct.field("secret_id", &self.secret_id);
        debug_struct.field("vault_id", &self.vault_id);
        debug_struct.field("maintenance_schedule_type", &self.maintenance_schedule_type);
        debug_struct.field("mtls_connection_required", &self.mtls_connection_required);
        debug_struct.field(
            "backup_retention_period_days",
            &self.backup_retention_period_days,
        );
        debug_struct.field(
            "actual_used_data_storage_size_tb",
            &self.actual_used_data_storage_size_tb,
        );
        debug_struct.field("allocated_storage_size_tb", &self.allocated_storage_size_tb);
        debug_struct.field("apex_details", &self.apex_details);
        debug_struct.field(
            "are_primary_allowlisted_ips_used",
            &self.are_primary_allowlisted_ips_used,
        );
        debug_struct.field("lifecycle_details", &self.lifecycle_details);
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "autonomous_container_database_id",
            &self.autonomous_container_database_id,
        );
        debug_struct.field(
            "available_upgrade_versions",
            &self.available_upgrade_versions,
        );
        debug_struct.field("connection_strings", &self.connection_strings);
        debug_struct.field("connection_urls", &self.connection_urls);
        debug_struct.field(
            "failed_data_recovery_duration",
            &self.failed_data_recovery_duration,
        );
        debug_struct.field("memory_table_gbs", &self.memory_table_gbs);
        debug_struct.field(
            "is_local_data_guard_enabled",
            &self.is_local_data_guard_enabled,
        );
        debug_struct.field(
            "local_adg_auto_failover_max_data_loss_limit",
            &self.local_adg_auto_failover_max_data_loss_limit,
        );
        debug_struct.field("local_standby_db", &self.local_standby_db);
        debug_struct.field(
            "memory_per_oracle_compute_unit_gbs",
            &self.memory_per_oracle_compute_unit_gbs,
        );
        debug_struct.field(
            "local_disaster_recovery_type",
            &self.local_disaster_recovery_type,
        );
        debug_struct.field("data_safe_state", &self.data_safe_state);
        debug_struct.field("database_management_state", &self.database_management_state);
        debug_struct.field("open_mode", &self.open_mode);
        debug_struct.field("operations_insights_state", &self.operations_insights_state);
        debug_struct.field("peer_db_ids", &self.peer_db_ids);
        debug_struct.field("permission_level", &self.permission_level);
        debug_struct.field("private_endpoint", &self.private_endpoint);
        debug_struct.field("refreshable_mode", &self.refreshable_mode);
        debug_struct.field("refreshable_state", &self.refreshable_state);
        debug_struct.field("role", &self.role);
        debug_struct.field(
            "scheduled_operation_details",
            &self.scheduled_operation_details,
        );
        debug_struct.field("sql_web_developer_url", &self.sql_web_developer_url);
        debug_struct.field("supported_clone_regions", &self.supported_clone_regions);
        debug_struct.field(
            "used_data_storage_size_tbs",
            &self.used_data_storage_size_tbs,
        );
        debug_struct.field("oci_url", &self.oci_url);
        debug_struct.field(
            "total_auto_backup_storage_size_gbs",
            &self.total_auto_backup_storage_size_gbs,
        );
        debug_struct.field(
            "next_long_term_backup_time",
            &self.next_long_term_backup_time,
        );
        debug_struct.field("maintenance_begin_time", &self.maintenance_begin_time);
        debug_struct.field("maintenance_end_time", &self.maintenance_end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutonomousDatabaseProperties].
pub mod autonomous_database_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The editions available for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEdition {
        /// Default unspecified value.
        Unspecified,
        /// Standard Database Edition
        StandardEdition,
        /// Enterprise Database Edition
        EnterpriseEdition,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEdition::value] or
        /// [DatabaseEdition::name].
        UnknownValue(database_edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEdition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardEdition => std::option::Option::Some(1),
                Self::EnterpriseEdition => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_EDITION_UNSPECIFIED"),
                Self::StandardEdition => std::option::Option::Some("STANDARD_EDITION"),
                Self::EnterpriseEdition => std::option::Option::Some("ENTERPRISE_EDITION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEdition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEdition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEdition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardEdition,
                2 => Self::EnterpriseEdition,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEdition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_EDITION" => Self::StandardEdition,
                "ENTERPRISE_EDITION" => Self::EnterpriseEdition,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEdition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardEdition => serializer.serialize_i32(1),
                Self::EnterpriseEdition => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEdition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEdition>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DatabaseEdition",
            ))
        }
    }

    /// The license types available for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseType {
        /// Unspecified
        Unspecified,
        /// License included part of offer
        LicenseIncluded,
        /// Bring your own license
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseType::value] or
        /// [LicenseType::name].
        UnknownValue(license_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_TYPE_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.LicenseType",
            ))
        }
    }

    /// The available maintenance schedules for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceScheduleType {
        /// Default unspecified value.
        Unspecified,
        /// An EARLY maintenance schedule patches the database before
        /// the regular scheduled maintenance.
        Early,
        /// A REGULAR maintenance schedule follows the normal maintenance cycle.
        Regular,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceScheduleType::value] or
        /// [MaintenanceScheduleType::name].
        UnknownValue(maintenance_schedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod maintenance_schedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaintenanceScheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Early => std::option::Option::Some(1),
                Self::Regular => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED")
                }
                Self::Early => std::option::Option::Some("EARLY"),
                Self::Regular => std::option::Option::Some("REGULAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaintenanceScheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaintenanceScheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaintenanceScheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Early,
                2 => Self::Regular,
                _ => Self::UnknownValue(maintenance_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaintenanceScheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EARLY" => Self::Early,
                "REGULAR" => Self::Regular,
                _ => Self::UnknownValue(maintenance_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaintenanceScheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Early => serializer.serialize_i32(1),
                Self::Regular => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceScheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaintenanceScheduleType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.MaintenanceScheduleType"))
        }
    }

    /// The types of local disaster recovery available for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocalDisasterRecoveryType {
        /// Default unspecified value.
        Unspecified,
        /// Autonomous Data Guard recovery.
        Adg,
        /// Backup based recovery.
        BackupBased,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocalDisasterRecoveryType::value] or
        /// [LocalDisasterRecoveryType::name].
        UnknownValue(local_disaster_recovery_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod local_disaster_recovery_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocalDisasterRecoveryType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Adg => std::option::Option::Some(1),
                Self::BackupBased => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED")
                }
                Self::Adg => std::option::Option::Some("ADG"),
                Self::BackupBased => std::option::Option::Some("BACKUP_BASED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocalDisasterRecoveryType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocalDisasterRecoveryType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocalDisasterRecoveryType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Adg,
                2 => Self::BackupBased,
                _ => Self::UnknownValue(local_disaster_recovery_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocalDisasterRecoveryType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ADG" => Self::Adg,
                "BACKUP_BASED" => Self::BackupBased,
                _ => Self::UnknownValue(local_disaster_recovery_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocalDisasterRecoveryType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Adg => serializer.serialize_i32(1),
                Self::BackupBased => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocalDisasterRecoveryType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocalDisasterRecoveryType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.LocalDisasterRecoveryType"))
        }
    }

    /// Varies states of the Data Safe registration for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSafeState {
        /// Default unspecified value.
        Unspecified,
        /// Registering data safe state.
        Registering,
        /// Registered data safe state.
        Registered,
        /// Deregistering data safe state.
        Deregistering,
        /// Not registered data safe state.
        NotRegistered,
        /// Failed data safe state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataSafeState::value] or
        /// [DataSafeState::name].
        UnknownValue(data_safe_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_safe_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataSafeState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Registering => std::option::Option::Some(1),
                Self::Registered => std::option::Option::Some(2),
                Self::Deregistering => std::option::Option::Some(3),
                Self::NotRegistered => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SAFE_STATE_UNSPECIFIED"),
                Self::Registering => std::option::Option::Some("REGISTERING"),
                Self::Registered => std::option::Option::Some("REGISTERED"),
                Self::Deregistering => std::option::Option::Some("DEREGISTERING"),
                Self::NotRegistered => std::option::Option::Some("NOT_REGISTERED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataSafeState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataSafeState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataSafeState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Registering,
                2 => Self::Registered,
                3 => Self::Deregistering,
                4 => Self::NotRegistered,
                5 => Self::Failed,
                _ => Self::UnknownValue(data_safe_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataSafeState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SAFE_STATE_UNSPECIFIED" => Self::Unspecified,
                "REGISTERING" => Self::Registering,
                "REGISTERED" => Self::Registered,
                "DEREGISTERING" => Self::Deregistering,
                "NOT_REGISTERED" => Self::NotRegistered,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(data_safe_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataSafeState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Registering => serializer.serialize_i32(1),
                Self::Registered => serializer.serialize_i32(2),
                Self::Deregistering => serializer.serialize_i32(3),
                Self::NotRegistered => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataSafeState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataSafeState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DataSafeState",
            ))
        }
    }

    /// The different states of database management for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseManagementState {
        /// Default unspecified value.
        Unspecified,
        /// Enabling Database Management state
        Enabling,
        /// Enabled Database Management state
        Enabled,
        /// Disabling Database Management state
        Disabling,
        /// Not Enabled Database Management state
        NotEnabled,
        /// Failed enabling Database Management state
        FailedEnabling,
        /// Failed disabling Database Management state
        FailedDisabling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseManagementState::value] or
        /// [DatabaseManagementState::name].
        UnknownValue(database_management_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_management_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseManagementState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabling => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::Disabling => std::option::Option::Some(3),
                Self::NotEnabled => std::option::Option::Some(4),
                Self::FailedEnabling => std::option::Option::Some(5),
                Self::FailedDisabling => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DATABASE_MANAGEMENT_STATE_UNSPECIFIED")
                }
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
                Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
                Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseManagementState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseManagementState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseManagementState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabling,
                2 => Self::Enabled,
                3 => Self::Disabling,
                4 => Self::NotEnabled,
                5 => Self::FailedEnabling,
                6 => Self::FailedDisabling,
                _ => Self::UnknownValue(database_management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseManagementState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_MANAGEMENT_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLING" => Self::Enabling,
                "ENABLED" => Self::Enabled,
                "DISABLING" => Self::Disabling,
                "NOT_ENABLED" => Self::NotEnabled,
                "FAILED_ENABLING" => Self::FailedEnabling,
                "FAILED_DISABLING" => Self::FailedDisabling,
                _ => Self::UnknownValue(database_management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseManagementState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabling => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::Disabling => serializer.serialize_i32(3),
                Self::NotEnabled => serializer.serialize_i32(4),
                Self::FailedEnabling => serializer.serialize_i32(5),
                Self::FailedDisabling => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseManagementState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseManagementState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DatabaseManagementState"))
        }
    }

    /// This field indicates the modes of an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OpenMode {
        /// Default unspecified value.
        Unspecified,
        /// Read Only Mode
        ReadOnly,
        /// Read Write Mode
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OpenMode::value] or
        /// [OpenMode::name].
        UnknownValue(open_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod open_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OpenMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReadOnly => std::option::Option::Some(1),
                Self::ReadWrite => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPEN_MODE_UNSPECIFIED"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OpenMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OpenMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OpenMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReadOnly,
                2 => Self::ReadWrite,
                _ => Self::UnknownValue(open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OpenMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPEN_MODE_UNSPECIFIED" => Self::Unspecified,
                "READ_ONLY" => Self::ReadOnly,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OpenMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReadOnly => serializer.serialize_i32(1),
                Self::ReadWrite => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OpenMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OpenMode>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.OpenMode",
            ))
        }
    }

    /// The types of permission levels for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PermissionLevel {
        /// Default unspecified value.
        Unspecified,
        /// Restricted mode allows access only by admin users.
        Restricted,
        /// Normal access.
        Unrestricted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PermissionLevel::value] or
        /// [PermissionLevel::name].
        UnknownValue(permission_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod permission_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PermissionLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Restricted => std::option::Option::Some(1),
                Self::Unrestricted => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERMISSION_LEVEL_UNSPECIFIED"),
                Self::Restricted => std::option::Option::Some("RESTRICTED"),
                Self::Unrestricted => std::option::Option::Some("UNRESTRICTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PermissionLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PermissionLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PermissionLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Restricted,
                2 => Self::Unrestricted,
                _ => Self::UnknownValue(permission_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PermissionLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERMISSION_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "RESTRICTED" => Self::Restricted,
                "UNRESTRICTED" => Self::Unrestricted,
                _ => Self::UnknownValue(permission_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PermissionLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Restricted => serializer.serialize_i32(1),
                Self::Unrestricted => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PermissionLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PermissionLevel>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.PermissionLevel",
            ))
        }
    }

    /// The refresh mode of the cloned Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefreshableMode {
        /// The default unspecified value.
        Unspecified,
        /// AUTOMATIC indicates that the cloned database is automatically
        /// refreshed with data from the source Autonomous Database.
        Automatic,
        /// MANUAL indicates that the cloned database is manually refreshed with
        /// data from the source Autonomous Database.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefreshableMode::value] or
        /// [RefreshableMode::name].
        UnknownValue(refreshable_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod refreshable_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefreshableMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REFRESHABLE_MODE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefreshableMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefreshableMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefreshableMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(refreshable_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefreshableMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REFRESHABLE_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(refreshable_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefreshableMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefreshableMode>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.RefreshableMode",
            ))
        }
    }

    /// The refresh state of the cloned Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefreshableState {
        /// Default unspecified value.
        Unspecified,
        /// Refreshing
        Refreshing,
        /// Not refreshed
        NotRefreshing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefreshableState::value] or
        /// [RefreshableState::name].
        UnknownValue(refreshable_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod refreshable_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefreshableState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Refreshing => std::option::Option::Some(1),
                Self::NotRefreshing => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REFRESHABLE_STATE_UNSPECIFIED"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::NotRefreshing => std::option::Option::Some("NOT_REFRESHING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefreshableState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefreshableState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefreshableState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Refreshing,
                2 => Self::NotRefreshing,
                _ => Self::UnknownValue(refreshable_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefreshableState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REFRESHABLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "REFRESHING" => Self::Refreshing,
                "NOT_REFRESHING" => Self::NotRefreshing,
                _ => Self::UnknownValue(refreshable_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefreshableState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Refreshing => serializer.serialize_i32(1),
                Self::NotRefreshing => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefreshableState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.RefreshableState",
            ))
        }
    }

    /// The Data Guard role of the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Default unspecified value.
        Unspecified,
        /// Primary role
        Primary,
        /// Standby role
        Standby,
        /// Disabled standby role
        DisabledStandby,
        /// Backup copy role
        BackupCopy,
        /// Snapshot standby role
        SnapshotStandby,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::Standby => std::option::Option::Some(2),
                Self::DisabledStandby => std::option::Option::Some(3),
                Self::BackupCopy => std::option::Option::Some(4),
                Self::SnapshotStandby => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Standby => std::option::Option::Some("STANDBY"),
                Self::DisabledStandby => std::option::Option::Some("DISABLED_STANDBY"),
                Self::BackupCopy => std::option::Option::Some("BACKUP_COPY"),
                Self::SnapshotStandby => std::option::Option::Some("SNAPSHOT_STANDBY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::Standby,
                3 => Self::DisabledStandby,
                4 => Self::BackupCopy,
                5 => Self::SnapshotStandby,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "STANDBY" => Self::Standby,
                "DISABLED_STANDBY" => Self::DisabledStandby,
                "BACKUP_COPY" => Self::BackupCopy,
                "SNAPSHOT_STANDBY" => Self::SnapshotStandby,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::Standby => serializer.serialize_i32(2),
                Self::DisabledStandby => serializer.serialize_i32(3),
                Self::BackupCopy => serializer.serialize_i32(4),
                Self::SnapshotStandby => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.Role",
            ))
        }
    }
}

/// Oracle APEX Application Development.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseApex>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseApex {
    /// Output only. The Oracle APEX Application Development version.
    pub apex_version: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) version.
    pub ords_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseApex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_version][crate::model::AutonomousDatabaseApex::apex_version].
    pub fn set_apex_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_version = v.into();
        self
    }

    /// Sets the value of [ords_version][crate::model::AutonomousDatabaseApex::ords_version].
    pub fn set_ords_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_version = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseApex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseApex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseApex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __apex_version,
            __ords_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseApex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apexVersion" => Ok(__FieldTag::__apex_version),
                            "apex_version" => Ok(__FieldTag::__apex_version),
                            "ordsVersion" => Ok(__FieldTag::__ords_version),
                            "ords_version" => Ok(__FieldTag::__ords_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseApex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseApex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__apex_version => {
                            if !fields.insert(__FieldTag::__apex_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apex_version",
                                ));
                            }
                            result.apex_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ords_version => {
                            if !fields.insert(__FieldTag::__ords_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ords_version",
                                ));
                            }
                            result.ords_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseApex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.apex_version.is_empty() {
            state.serialize_entry("apexVersion", &self.apex_version)?;
        }
        if !self.ords_version.is_empty() {
            state.serialize_entry("ordsVersion", &self.ords_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseApex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseApex");
        debug_struct.field("apex_version", &self.apex_version);
        debug_struct.field("ords_version", &self.ords_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The connection string used to connect to the Autonomous Database.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionStrings>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionStrings {
    /// Output only. Returns all connection strings that can be used to connect to
    /// the Autonomous Database.
    pub all_connection_strings: std::option::Option<crate::model::AllConnectionStrings>,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement, but supports the most number of concurrent SQL
    /// statements.
    pub dedicated: std::string::String,

    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    pub medium: std::string::String,

    /// Output only. A list of connection string profiles to allow clients to
    /// group, filter, and select values based on the structured metadata.
    pub profiles: std::vec::Vec<crate::model::DatabaseConnectionStringProfile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_connection_strings][crate::model::AutonomousDatabaseConnectionStrings::all_connection_strings].
    pub fn set_all_connection_strings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AllConnectionStrings>,
    {
        self.all_connection_strings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_connection_strings][crate::model::AutonomousDatabaseConnectionStrings::all_connection_strings].
    pub fn set_or_clear_all_connection_strings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AllConnectionStrings>,
    {
        self.all_connection_strings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dedicated][crate::model::AutonomousDatabaseConnectionStrings::dedicated].
    pub fn set_dedicated<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dedicated = v.into();
        self
    }

    /// Sets the value of [high][crate::model::AutonomousDatabaseConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AutonomousDatabaseConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AutonomousDatabaseConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [profiles][crate::model::AutonomousDatabaseConnectionStrings::profiles].
    pub fn set_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseConnectionStringProfile>,
    {
        use std::iter::Iterator;
        self.profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionStrings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseConnectionStrings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all_connection_strings,
            __dedicated,
            __high,
            __low,
            __medium,
            __profiles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseConnectionStrings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allConnectionStrings" => Ok(__FieldTag::__all_connection_strings),
                            "all_connection_strings" => Ok(__FieldTag::__all_connection_strings),
                            "dedicated" => Ok(__FieldTag::__dedicated),
                            "high" => Ok(__FieldTag::__high),
                            "low" => Ok(__FieldTag::__low),
                            "medium" => Ok(__FieldTag::__medium),
                            "profiles" => Ok(__FieldTag::__profiles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseConnectionStrings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseConnectionStrings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all_connection_strings => {
                            if !fields.insert(__FieldTag::__all_connection_strings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_connection_strings",
                                ));
                            }
                            result.all_connection_strings = map.next_value::<std::option::Option<crate::model::AllConnectionStrings>>()?
                                ;
                        }
                        __FieldTag::__dedicated => {
                            if !fields.insert(__FieldTag::__dedicated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dedicated",
                                ));
                            }
                            result.dedicated = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__high => {
                            if !fields.insert(__FieldTag::__high) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for high",
                                ));
                            }
                            result.high = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__low => {
                            if !fields.insert(__FieldTag::__low) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for low",
                                ));
                            }
                            result.low = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__medium => {
                            if !fields.insert(__FieldTag::__medium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for medium",
                                ));
                            }
                            result.medium = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__profiles => {
                            if !fields.insert(__FieldTag::__profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profiles",
                                ));
                            }
                            result.profiles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatabaseConnectionStringProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseConnectionStrings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.all_connection_strings.is_some() {
            state.serialize_entry("allConnectionStrings", &self.all_connection_strings)?;
        }
        if !self.dedicated.is_empty() {
            state.serialize_entry("dedicated", &self.dedicated)?;
        }
        if !self.high.is_empty() {
            state.serialize_entry("high", &self.high)?;
        }
        if !self.low.is_empty() {
            state.serialize_entry("low", &self.low)?;
        }
        if !self.medium.is_empty() {
            state.serialize_entry("medium", &self.medium)?;
        }
        if !self.profiles.is_empty() {
            state.serialize_entry("profiles", &self.profiles)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseConnectionStrings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseConnectionStrings");
        debug_struct.field("all_connection_strings", &self.all_connection_strings);
        debug_struct.field("dedicated", &self.dedicated);
        debug_struct.field("high", &self.high);
        debug_struct.field("low", &self.low);
        debug_struct.field("medium", &self.medium);
        debug_struct.field("profiles", &self.profiles);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The connection string profile to allow clients to group.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DatabaseConnectionStringProfile>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseConnectionStringProfile {
    /// Output only. The current consumer group being used by the connection.
    pub consumer_group: crate::model::database_connection_string_profile::ConsumerGroup,

    /// Output only. The display name for the database connection.
    pub display_name: std::string::String,

    /// Output only. The host name format being currently used in connection
    /// string.
    pub host_format: crate::model::database_connection_string_profile::HostFormat,

    /// Output only. This field indicates if the connection string is regional and
    /// is only applicable for cross-region Data Guard.
    pub is_regional: bool,

    /// Output only. The protocol being used by the connection.
    pub protocol: crate::model::database_connection_string_profile::Protocol,

    /// Output only. The current session mode of the connection.
    pub session_mode: crate::model::database_connection_string_profile::SessionMode,

    /// Output only. The syntax of the connection string.
    pub syntax_format: crate::model::database_connection_string_profile::SyntaxFormat,

    /// Output only. This field indicates the TLS authentication type of the
    /// connection.
    pub tls_authentication: crate::model::database_connection_string_profile::TLSAuthentication,

    /// Output only. The value of the connection string.
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseConnectionStringProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consumer_group][crate::model::DatabaseConnectionStringProfile::consumer_group].
    pub fn set_consumer_group<
        T: std::convert::Into<crate::model::database_connection_string_profile::ConsumerGroup>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consumer_group = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DatabaseConnectionStringProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [host_format][crate::model::DatabaseConnectionStringProfile::host_format].
    pub fn set_host_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::HostFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.host_format = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::DatabaseConnectionStringProfile::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::DatabaseConnectionStringProfile::protocol].
    pub fn set_protocol<
        T: std::convert::Into<crate::model::database_connection_string_profile::Protocol>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [session_mode][crate::model::DatabaseConnectionStringProfile::session_mode].
    pub fn set_session_mode<
        T: std::convert::Into<crate::model::database_connection_string_profile::SessionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_mode = v.into();
        self
    }

    /// Sets the value of [syntax_format][crate::model::DatabaseConnectionStringProfile::syntax_format].
    pub fn set_syntax_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::SyntaxFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.syntax_format = v.into();
        self
    }

    /// Sets the value of [tls_authentication][crate::model::DatabaseConnectionStringProfile::tls_authentication].
    pub fn set_tls_authentication<
        T: std::convert::Into<crate::model::database_connection_string_profile::TLSAuthentication>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tls_authentication = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DatabaseConnectionStringProfile::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseConnectionStringProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseConnectionStringProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consumer_group,
            __display_name,
            __host_format,
            __is_regional,
            __protocol,
            __session_mode,
            __syntax_format,
            __tls_authentication,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseConnectionStringProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consumerGroup" => Ok(__FieldTag::__consumer_group),
                            "consumer_group" => Ok(__FieldTag::__consumer_group),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "hostFormat" => Ok(__FieldTag::__host_format),
                            "host_format" => Ok(__FieldTag::__host_format),
                            "isRegional" => Ok(__FieldTag::__is_regional),
                            "is_regional" => Ok(__FieldTag::__is_regional),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "sessionMode" => Ok(__FieldTag::__session_mode),
                            "session_mode" => Ok(__FieldTag::__session_mode),
                            "syntaxFormat" => Ok(__FieldTag::__syntax_format),
                            "syntax_format" => Ok(__FieldTag::__syntax_format),
                            "tlsAuthentication" => Ok(__FieldTag::__tls_authentication),
                            "tls_authentication" => Ok(__FieldTag::__tls_authentication),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseConnectionStringProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseConnectionStringProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consumer_group => {
                            if !fields.insert(__FieldTag::__consumer_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumer_group",
                                ));
                            }
                            result.consumer_group = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::ConsumerGroup,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_format => {
                            if !fields.insert(__FieldTag::__host_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_format",
                                ));
                            }
                            result.host_format = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::HostFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_regional => {
                            if !fields.insert(__FieldTag::__is_regional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_regional",
                                ));
                            }
                            result.is_regional = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::Protocol,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_mode => {
                            if !fields.insert(__FieldTag::__session_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_mode",
                                ));
                            }
                            result.session_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::SessionMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__syntax_format => {
                            if !fields.insert(__FieldTag::__syntax_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for syntax_format",
                                ));
                            }
                            result.syntax_format = map
                                .next_value::<std::option::Option<
                                    crate::model::database_connection_string_profile::SyntaxFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tls_authentication => {
                            if !fields.insert(__FieldTag::__tls_authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tls_authentication",
                                ));
                            }
                            result.tls_authentication = map.next_value::<std::option::Option<crate::model::database_connection_string_profile::TLSAuthentication>>()?.unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseConnectionStringProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.consumer_group) {
            state.serialize_entry("consumerGroup", &self.consumer_group)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.host_format) {
            state.serialize_entry("hostFormat", &self.host_format)?;
        }
        if !wkt::internal::is_default(&self.is_regional) {
            state.serialize_entry("isRegional", &self.is_regional)?;
        }
        if !wkt::internal::is_default(&self.protocol) {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !wkt::internal::is_default(&self.session_mode) {
            state.serialize_entry("sessionMode", &self.session_mode)?;
        }
        if !wkt::internal::is_default(&self.syntax_format) {
            state.serialize_entry("syntaxFormat", &self.syntax_format)?;
        }
        if !wkt::internal::is_default(&self.tls_authentication) {
            state.serialize_entry("tlsAuthentication", &self.tls_authentication)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseConnectionStringProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseConnectionStringProfile");
        debug_struct.field("consumer_group", &self.consumer_group);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("host_format", &self.host_format);
        debug_struct.field("is_regional", &self.is_regional);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("session_mode", &self.session_mode);
        debug_struct.field("syntax_format", &self.syntax_format);
        debug_struct.field("tls_authentication", &self.tls_authentication);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DatabaseConnectionStringProfile].
pub mod database_connection_string_profile {
    #[allow(unused_imports)]
    use super::*;

    /// The various consumer groups available in the connection string profile.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConsumerGroup {
        /// Default unspecified value.
        Unspecified,
        /// High consumer group.
        High,
        /// Medium consumer group.
        Medium,
        /// Low consumer group.
        Low,
        /// TP consumer group.
        Tp,
        /// TPURGENT consumer group.
        Tpurgent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConsumerGroup::value] or
        /// [ConsumerGroup::name].
        UnknownValue(consumer_group::UnknownValue),
    }

    #[doc(hidden)]
    pub mod consumer_group {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConsumerGroup {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::Low => std::option::Option::Some(3),
                Self::Tp => std::option::Option::Some(4),
                Self::Tpurgent => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONSUMER_GROUP_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Tp => std::option::Option::Some("TP"),
                Self::Tpurgent => std::option::Option::Some("TPURGENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConsumerGroup {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConsumerGroup {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConsumerGroup {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Medium,
                3 => Self::Low,
                4 => Self::Tp,
                5 => Self::Tpurgent,
                _ => Self::UnknownValue(consumer_group::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConsumerGroup {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONSUMER_GROUP_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "MEDIUM" => Self::Medium,
                "LOW" => Self::Low,
                "TP" => Self::Tp,
                "TPURGENT" => Self::Tpurgent,
                _ => Self::UnknownValue(consumer_group::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConsumerGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::Low => serializer.serialize_i32(3),
                Self::Tp => serializer.serialize_i32(4),
                Self::Tpurgent => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConsumerGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConsumerGroup>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.ConsumerGroup",
            ))
        }
    }

    /// The host name format being used in the connection string.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HostFormat {
        /// Default unspecified value.
        Unspecified,
        /// FQDN
        Fqdn,
        /// IP
        Ip,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HostFormat::value] or
        /// [HostFormat::name].
        UnknownValue(host_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod host_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HostFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fqdn => std::option::Option::Some(1),
                Self::Ip => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HOST_FORMAT_UNSPECIFIED"),
                Self::Fqdn => std::option::Option::Some("FQDN"),
                Self::Ip => std::option::Option::Some("IP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HostFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HostFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HostFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fqdn,
                2 => Self::Ip,
                _ => Self::UnknownValue(host_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HostFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HOST_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "FQDN" => Self::Fqdn,
                "IP" => Self::Ip,
                _ => Self::UnknownValue(host_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HostFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fqdn => serializer.serialize_i32(1),
                Self::Ip => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HostFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HostFormat>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.HostFormat",
            ))
        }
    }

    /// The protocol being used by the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Default unspecified value.
        Unspecified,
        /// Tcp
        Tcp,
        /// Tcps
        Tcps,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tcp => std::option::Option::Some(1),
                Self::Tcps => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::Tcp => std::option::Option::Some("TCP"),
                Self::Tcps => std::option::Option::Some("TCPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tcp,
                2 => Self::Tcps,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "TCP" => Self::Tcp,
                "TCPS" => Self::Tcps,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tcp => serializer.serialize_i32(1),
                Self::Tcps => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.Protocol",
            ))
        }
    }

    /// The session mode of the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionMode {
        /// Default unspecified value.
        Unspecified,
        /// Direct
        Direct,
        /// Indirect
        Indirect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SessionMode::value] or
        /// [SessionMode::name].
        UnknownValue(session_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod session_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SessionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Direct => std::option::Option::Some(1),
                Self::Indirect => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SESSION_MODE_UNSPECIFIED"),
                Self::Direct => std::option::Option::Some("DIRECT"),
                Self::Indirect => std::option::Option::Some("INDIRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SessionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SessionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SessionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Direct,
                2 => Self::Indirect,
                _ => Self::UnknownValue(session_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SessionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SESSION_MODE_UNSPECIFIED" => Self::Unspecified,
                "DIRECT" => Self::Direct,
                "INDIRECT" => Self::Indirect,
                _ => Self::UnknownValue(session_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SessionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Direct => serializer.serialize_i32(1),
                Self::Indirect => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SessionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SessionMode>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.SessionMode",
            ))
        }
    }

    /// Specifies syntax of the connection string.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SyntaxFormat {
        /// Default unspecified value.
        Unspecified,
        /// Long
        Long,
        /// Ezconnect
        Ezconnect,
        /// Ezconnectplus
        Ezconnectplus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SyntaxFormat::value] or
        /// [SyntaxFormat::name].
        UnknownValue(syntax_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod syntax_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SyntaxFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Long => std::option::Option::Some(1),
                Self::Ezconnect => std::option::Option::Some(2),
                Self::Ezconnectplus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SYNTAX_FORMAT_UNSPECIFIED"),
                Self::Long => std::option::Option::Some("LONG"),
                Self::Ezconnect => std::option::Option::Some("EZCONNECT"),
                Self::Ezconnectplus => std::option::Option::Some("EZCONNECTPLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SyntaxFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SyntaxFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SyntaxFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Long,
                2 => Self::Ezconnect,
                3 => Self::Ezconnectplus,
                _ => Self::UnknownValue(syntax_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SyntaxFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SYNTAX_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "LONG" => Self::Long,
                "EZCONNECT" => Self::Ezconnect,
                "EZCONNECTPLUS" => Self::Ezconnectplus,
                _ => Self::UnknownValue(syntax_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SyntaxFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Long => serializer.serialize_i32(1),
                Self::Ezconnect => serializer.serialize_i32(2),
                Self::Ezconnectplus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SyntaxFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SyntaxFormat>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.SyntaxFormat",
            ))
        }
    }

    /// This field indicates the TLS authentication type of the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TLSAuthentication {
        /// Default unspecified value.
        Unspecified,
        /// Server
        Server,
        /// Mutual
        Mutual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TLSAuthentication::value] or
        /// [TLSAuthentication::name].
        UnknownValue(tls_authentication::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tls_authentication {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TLSAuthentication {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Server => std::option::Option::Some(1),
                Self::Mutual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TLS_AUTHENTICATION_UNSPECIFIED"),
                Self::Server => std::option::Option::Some("SERVER"),
                Self::Mutual => std::option::Option::Some("MUTUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TLSAuthentication {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TLSAuthentication {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TLSAuthentication {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Server,
                2 => Self::Mutual,
                _ => Self::UnknownValue(tls_authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TLSAuthentication {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TLS_AUTHENTICATION_UNSPECIFIED" => Self::Unspecified,
                "SERVER" => Self::Server,
                "MUTUAL" => Self::Mutual,
                _ => Self::UnknownValue(tls_authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TLSAuthentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Server => serializer.serialize_i32(1),
                Self::Mutual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TLSAuthentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TLSAuthentication>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.TLSAuthentication",
            ))
        }
    }
}

/// A list of all connection strings that can be used to connect to the
/// Autonomous Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AllConnectionStrings {
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    pub medium: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [high][crate::model::AllConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AllConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AllConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }
}

impl wkt::message::Message for AllConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AllConnectionStrings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllConnectionStrings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __high,
            __low,
            __medium,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllConnectionStrings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "high" => Ok(__FieldTag::__high),
                            "low" => Ok(__FieldTag::__low),
                            "medium" => Ok(__FieldTag::__medium),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllConnectionStrings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllConnectionStrings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__high => {
                            if !fields.insert(__FieldTag::__high) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for high",
                                ));
                            }
                            result.high = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__low => {
                            if !fields.insert(__FieldTag::__low) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for low",
                                ));
                            }
                            result.low = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__medium => {
                            if !fields.insert(__FieldTag::__medium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for medium",
                                ));
                            }
                            result.medium = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllConnectionStrings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.high.is_empty() {
            state.serialize_entry("high", &self.high)?;
        }
        if !self.low.is_empty() {
            state.serialize_entry("low", &self.low)?;
        }
        if !self.medium.is_empty() {
            state.serialize_entry("medium", &self.medium)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AllConnectionStrings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AllConnectionStrings");
        debug_struct.field("high", &self.high);
        debug_struct.field("low", &self.low);
        debug_struct.field("medium", &self.medium);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The URLs for accessing Oracle Application Express (APEX) and SQL Developer
/// Web with a browser from a Compute instance.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionUrls>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionUrls {
    /// Output only. Oracle Application Express (APEX) URL.
    pub apex_uri: std::string::String,

    /// Output only. The URL of the Database Transforms for the Autonomous
    /// Database.
    pub database_transforms_uri: std::string::String,

    /// Output only. The URL of the Graph Studio for the Autonomous Database.
    pub graph_studio_uri: std::string::String,

    /// Output only. The URL of the Oracle Machine Learning (OML) Notebook for the
    /// Autonomous Database.
    pub machine_learning_notebook_uri: std::string::String,

    /// Output only. The URL of Machine Learning user management the Autonomous
    /// Database.
    pub machine_learning_user_management_uri: std::string::String,

    /// Output only. The URL of the MongoDB API for the Autonomous Database.
    pub mongo_db_uri: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) URL of the Web Access for
    /// the Autonomous Database.
    pub ords_uri: std::string::String,

    /// Output only. The URL of the Oracle SQL Developer Web for the Autonomous
    /// Database.
    pub sql_dev_web_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseConnectionUrls {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_uri][crate::model::AutonomousDatabaseConnectionUrls::apex_uri].
    pub fn set_apex_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_uri = v.into();
        self
    }

    /// Sets the value of [database_transforms_uri][crate::model::AutonomousDatabaseConnectionUrls::database_transforms_uri].
    pub fn set_database_transforms_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_transforms_uri = v.into();
        self
    }

    /// Sets the value of [graph_studio_uri][crate::model::AutonomousDatabaseConnectionUrls::graph_studio_uri].
    pub fn set_graph_studio_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.graph_studio_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_notebook_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_notebook_uri].
    pub fn set_machine_learning_notebook_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_notebook_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_user_management_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_user_management_uri].
    pub fn set_machine_learning_user_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_user_management_uri = v.into();
        self
    }

    /// Sets the value of [mongo_db_uri][crate::model::AutonomousDatabaseConnectionUrls::mongo_db_uri].
    pub fn set_mongo_db_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mongo_db_uri = v.into();
        self
    }

    /// Sets the value of [ords_uri][crate::model::AutonomousDatabaseConnectionUrls::ords_uri].
    pub fn set_ords_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_uri = v.into();
        self
    }

    /// Sets the value of [sql_dev_web_uri][crate::model::AutonomousDatabaseConnectionUrls::sql_dev_web_uri].
    pub fn set_sql_dev_web_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_dev_web_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionUrls {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionUrls"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseConnectionUrls {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __apex_uri,
            __database_transforms_uri,
            __graph_studio_uri,
            __machine_learning_notebook_uri,
            __machine_learning_user_management_uri,
            __mongo_db_uri,
            __ords_uri,
            __sql_dev_web_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseConnectionUrls")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apexUri" => Ok(__FieldTag::__apex_uri),
                            "apex_uri" => Ok(__FieldTag::__apex_uri),
                            "databaseTransformsUri" => Ok(__FieldTag::__database_transforms_uri),
                            "database_transforms_uri" => Ok(__FieldTag::__database_transforms_uri),
                            "graphStudioUri" => Ok(__FieldTag::__graph_studio_uri),
                            "graph_studio_uri" => Ok(__FieldTag::__graph_studio_uri),
                            "machineLearningNotebookUri" => {
                                Ok(__FieldTag::__machine_learning_notebook_uri)
                            }
                            "machine_learning_notebook_uri" => {
                                Ok(__FieldTag::__machine_learning_notebook_uri)
                            }
                            "machineLearningUserManagementUri" => {
                                Ok(__FieldTag::__machine_learning_user_management_uri)
                            }
                            "machine_learning_user_management_uri" => {
                                Ok(__FieldTag::__machine_learning_user_management_uri)
                            }
                            "mongoDbUri" => Ok(__FieldTag::__mongo_db_uri),
                            "mongo_db_uri" => Ok(__FieldTag::__mongo_db_uri),
                            "ordsUri" => Ok(__FieldTag::__ords_uri),
                            "ords_uri" => Ok(__FieldTag::__ords_uri),
                            "sqlDevWebUri" => Ok(__FieldTag::__sql_dev_web_uri),
                            "sql_dev_web_uri" => Ok(__FieldTag::__sql_dev_web_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseConnectionUrls;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseConnectionUrls")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__apex_uri => {
                            if !fields.insert(__FieldTag::__apex_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apex_uri",
                                ));
                            }
                            result.apex_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_transforms_uri => {
                            if !fields.insert(__FieldTag::__database_transforms_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_transforms_uri",
                                ));
                            }
                            result.database_transforms_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__graph_studio_uri => {
                            if !fields.insert(__FieldTag::__graph_studio_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for graph_studio_uri",
                                ));
                            }
                            result.graph_studio_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_learning_notebook_uri => {
                            if !fields.insert(__FieldTag::__machine_learning_notebook_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_learning_notebook_uri",
                                ));
                            }
                            result.machine_learning_notebook_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_learning_user_management_uri => {
                            if !fields.insert(__FieldTag::__machine_learning_user_management_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_learning_user_management_uri",
                                ));
                            }
                            result.machine_learning_user_management_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mongo_db_uri => {
                            if !fields.insert(__FieldTag::__mongo_db_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mongo_db_uri",
                                ));
                            }
                            result.mongo_db_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ords_uri => {
                            if !fields.insert(__FieldTag::__ords_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ords_uri",
                                ));
                            }
                            result.ords_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_dev_web_uri => {
                            if !fields.insert(__FieldTag::__sql_dev_web_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_dev_web_uri",
                                ));
                            }
                            result.sql_dev_web_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseConnectionUrls {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.apex_uri.is_empty() {
            state.serialize_entry("apexUri", &self.apex_uri)?;
        }
        if !self.database_transforms_uri.is_empty() {
            state.serialize_entry("databaseTransformsUri", &self.database_transforms_uri)?;
        }
        if !self.graph_studio_uri.is_empty() {
            state.serialize_entry("graphStudioUri", &self.graph_studio_uri)?;
        }
        if !self.machine_learning_notebook_uri.is_empty() {
            state.serialize_entry(
                "machineLearningNotebookUri",
                &self.machine_learning_notebook_uri,
            )?;
        }
        if !self.machine_learning_user_management_uri.is_empty() {
            state.serialize_entry(
                "machineLearningUserManagementUri",
                &self.machine_learning_user_management_uri,
            )?;
        }
        if !self.mongo_db_uri.is_empty() {
            state.serialize_entry("mongoDbUri", &self.mongo_db_uri)?;
        }
        if !self.ords_uri.is_empty() {
            state.serialize_entry("ordsUri", &self.ords_uri)?;
        }
        if !self.sql_dev_web_uri.is_empty() {
            state.serialize_entry("sqlDevWebUri", &self.sql_dev_web_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseConnectionUrls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseConnectionUrls");
        debug_struct.field("apex_uri", &self.apex_uri);
        debug_struct.field("database_transforms_uri", &self.database_transforms_uri);
        debug_struct.field("graph_studio_uri", &self.graph_studio_uri);
        debug_struct.field(
            "machine_learning_notebook_uri",
            &self.machine_learning_notebook_uri,
        );
        debug_struct.field(
            "machine_learning_user_management_uri",
            &self.machine_learning_user_management_uri,
        );
        debug_struct.field("mongo_db_uri", &self.mongo_db_uri);
        debug_struct.field("ords_uri", &self.ords_uri);
        debug_struct.field("sql_dev_web_uri", &self.sql_dev_web_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Autonomous Data Guard standby database details.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseStandbySummary>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseStandbySummary {
    /// Output only. The amount of time, in seconds, that the data of the standby
    /// database lags in comparison to the data of the primary database.
    pub lag_time_duration: std::option::Option<wkt::Duration>,

    /// Output only. The additional details about the current lifecycle state of
    /// the Autonomous Database.
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    pub state: crate::model::State,

    /// Output only. The date and time the Autonomous Data Guard role was switched
    /// for the standby Autonomous Database.
    pub data_guard_role_changed_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the Disaster Recovery role was switched for
    /// the standby Autonomous Database.
    pub disaster_recovery_role_changed_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseStandbySummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lag_time_duration][crate::model::AutonomousDatabaseStandbySummary::lag_time_duration].
    pub fn set_lag_time_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_time_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lag_time_duration][crate::model::AutonomousDatabaseStandbySummary::lag_time_duration].
    pub fn set_or_clear_lag_time_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_time_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseStandbySummary::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseStandbySummary::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::data_guard_role_changed_time].
    pub fn set_data_guard_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::data_guard_role_changed_time].
    pub fn set_or_clear_data_guard_role_changed_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::disaster_recovery_role_changed_time].
    pub fn set_disaster_recovery_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::disaster_recovery_role_changed_time].
    pub fn set_or_clear_disaster_recovery_role_changed_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseStandbySummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseStandbySummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseStandbySummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lag_time_duration,
            __lifecycle_details,
            __state,
            __data_guard_role_changed_time,
            __disaster_recovery_role_changed_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseStandbySummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lagTimeDuration" => Ok(__FieldTag::__lag_time_duration),
                            "lag_time_duration" => Ok(__FieldTag::__lag_time_duration),
                            "lifecycleDetails" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycle_details" => Ok(__FieldTag::__lifecycle_details),
                            "state" => Ok(__FieldTag::__state),
                            "dataGuardRoleChangedTime" => {
                                Ok(__FieldTag::__data_guard_role_changed_time)
                            }
                            "data_guard_role_changed_time" => {
                                Ok(__FieldTag::__data_guard_role_changed_time)
                            }
                            "disasterRecoveryRoleChangedTime" => {
                                Ok(__FieldTag::__disaster_recovery_role_changed_time)
                            }
                            "disaster_recovery_role_changed_time" => {
                                Ok(__FieldTag::__disaster_recovery_role_changed_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseStandbySummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseStandbySummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lag_time_duration => {
                            if !fields.insert(__FieldTag::__lag_time_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lag_time_duration",
                                ));
                            }
                            result.lag_time_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__lifecycle_details => {
                            if !fields.insert(__FieldTag::__lifecycle_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_details",
                                ));
                            }
                            result.lifecycle_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_guard_role_changed_time => {
                            if !fields.insert(__FieldTag::__data_guard_role_changed_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_guard_role_changed_time",
                                ));
                            }
                            result.data_guard_role_changed_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__disaster_recovery_role_changed_time => {
                            if !fields.insert(__FieldTag::__disaster_recovery_role_changed_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disaster_recovery_role_changed_time",
                                ));
                            }
                            result.disaster_recovery_role_changed_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseStandbySummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.lag_time_duration.is_some() {
            state.serialize_entry("lagTimeDuration", &self.lag_time_duration)?;
        }
        if !self.lifecycle_details.is_empty() {
            state.serialize_entry("lifecycleDetails", &self.lifecycle_details)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.data_guard_role_changed_time.is_some() {
            state.serialize_entry(
                "dataGuardRoleChangedTime",
                &self.data_guard_role_changed_time,
            )?;
        }
        if self.disaster_recovery_role_changed_time.is_some() {
            state.serialize_entry(
                "disasterRecoveryRoleChangedTime",
                &self.disaster_recovery_role_changed_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseStandbySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseStandbySummary");
        debug_struct.field("lag_time_duration", &self.lag_time_duration);
        debug_struct.field("lifecycle_details", &self.lifecycle_details);
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "data_guard_role_changed_time",
            &self.data_guard_role_changed_time,
        );
        debug_struct.field(
            "disaster_recovery_role_changed_time",
            &self.disaster_recovery_role_changed_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of scheduled operation.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/ScheduledOperationDetails>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScheduledOperationDetails {
    /// Output only. Day of week.
    pub day_of_week: gtype::model::DayOfWeek,

    /// Output only. Auto start time.
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Output only. Auto stop time.
    pub stop_time: std::option::Option<gtype::model::TimeOfDay>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduledOperationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_week][crate::model::ScheduledOperationDetails::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScheduledOperationDetails::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ScheduledOperationDetails::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stop_time][crate::model::ScheduledOperationDetails::stop_time].
    pub fn set_stop_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.stop_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stop_time][crate::model::ScheduledOperationDetails::stop_time].
    pub fn set_or_clear_stop_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.stop_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ScheduledOperationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ScheduledOperationDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScheduledOperationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __day_of_week,
            __start_time,
            __stop_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScheduledOperationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "stopTime" => Ok(__FieldTag::__stop_time),
                            "stop_time" => Ok(__FieldTag::__stop_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScheduledOperationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScheduledOperationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__stop_time => {
                            if !fields.insert(__FieldTag::__stop_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stop_time",
                                ));
                            }
                            result.stop_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScheduledOperationDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.day_of_week) {
            state.serialize_entry("dayOfWeek", &self.day_of_week)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.stop_time.is_some() {
            state.serialize_entry("stopTime", &self.stop_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ScheduledOperationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScheduledOperationDetails");
        debug_struct.field("day_of_week", &self.day_of_week);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("stop_time", &self.stop_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of the Autonomous Database character set resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseCharacterSet {
    /// Identifier. The name of the Autonomous Database Character Set resource in
    /// the following format:
    /// projects/{project}/locations/{region}/autonomousDatabaseCharacterSets/{autonomous_database_character_set}
    pub name: std::string::String,

    /// Output only. The character set type for the Autonomous Database.
    pub character_set_type: crate::model::autonomous_database_character_set::CharacterSetType,

    /// Output only. The character set name for the Autonomous Database which is
    /// the ID in the resource name.
    pub character_set: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseCharacterSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseCharacterSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [character_set_type][crate::model::AutonomousDatabaseCharacterSet::character_set_type].
    pub fn set_character_set_type<
        T: std::convert::Into<crate::model::autonomous_database_character_set::CharacterSetType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.character_set_type = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseCharacterSet::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseCharacterSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseCharacterSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseCharacterSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __character_set_type,
            __character_set,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseCharacterSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "characterSetType" => Ok(__FieldTag::__character_set_type),
                            "character_set_type" => Ok(__FieldTag::__character_set_type),
                            "characterSet" => Ok(__FieldTag::__character_set),
                            "character_set" => Ok(__FieldTag::__character_set),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseCharacterSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseCharacterSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__character_set_type => {
                            if !fields.insert(__FieldTag::__character_set_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character_set_type",
                                ));
                            }
                            result.character_set_type = map.next_value::<std::option::Option<crate::model::autonomous_database_character_set::CharacterSetType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__character_set => {
                            if !fields.insert(__FieldTag::__character_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character_set",
                                ));
                            }
                            result.character_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseCharacterSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.character_set_type) {
            state.serialize_entry("characterSetType", &self.character_set_type)?;
        }
        if !self.character_set.is_empty() {
            state.serialize_entry("characterSet", &self.character_set)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseCharacterSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseCharacterSet");
        debug_struct.field("name", &self.name);
        debug_struct.field("character_set_type", &self.character_set_type);
        debug_struct.field("character_set", &self.character_set);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutonomousDatabaseCharacterSet].
pub mod autonomous_database_character_set {
    #[allow(unused_imports)]
    use super::*;

    /// The type of character set an Autonomous Database can have.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CharacterSetType {
        /// Character set type is not specified.
        Unspecified,
        /// Character set type is set to database.
        Database,
        /// Character set type is set to national.
        National,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CharacterSetType::value] or
        /// [CharacterSetType::name].
        UnknownValue(character_set_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod character_set_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CharacterSetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::National => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHARACTER_SET_TYPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::National => std::option::Option::Some("NATIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CharacterSetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CharacterSetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CharacterSetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CharacterSetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "NATIONAL" => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CharacterSetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::National => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CharacterSetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CharacterSetType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseCharacterSet.CharacterSetType",
            ))
        }
    }
}

/// Details of the Autonomous Database Backup resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseBackup/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseBackup {
    /// Identifier. The name of the Autonomous Database Backup resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabaseBackups/{autonomous_database_backup}
    pub name: std::string::String,

    /// Required. The name of the Autonomous Database resource for which the backup
    /// is being created. Format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    pub autonomous_database: std::string::String,

    /// Optional. User friendly name for the Backup. The name does not have to be
    /// unique.
    pub display_name: std::string::String,

    /// Optional. Various properties of the backup.
    pub properties: std::option::Option<crate::model::AutonomousDatabaseBackupProperties>,

    /// Optional. labels or tags associated with the resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseBackup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseBackup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::AutonomousDatabaseBackup::autonomous_database].
    pub fn set_autonomous_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabaseBackup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabaseBackup::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseBackupProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::AutonomousDatabaseBackup::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseBackupProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabaseBackup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseBackup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __autonomous_database,
            __display_name,
            __properties,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseBackup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "autonomousDatabase" => Ok(__FieldTag::__autonomous_database),
                            "autonomous_database" => Ok(__FieldTag::__autonomous_database),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseBackup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseBackup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_database => {
                            if !fields.insert(__FieldTag::__autonomous_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database",
                                ));
                            }
                            result.autonomous_database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<
                                crate::model::AutonomousDatabaseBackupProperties,
                            >>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseBackup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.autonomous_database.is_empty() {
            state.serialize_entry("autonomousDatabase", &self.autonomous_database)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseBackup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseBackup");
        debug_struct.field("name", &self.name);
        debug_struct.field("autonomous_database", &self.autonomous_database);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Properties of the Autonomous Database Backup resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseBackupProperties {
    /// Output only. OCID of the Autonomous Database backup.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    pub ocid: std::string::String,

    /// Optional. Retention period in days for the backup.
    pub retention_period_days: i32,

    /// Output only. The OCID of the compartment.
    pub compartment_id: std::string::String,

    /// Output only. The quantity of data in the database, in terabytes.
    pub database_size_tb: f32,

    /// Output only. A valid Oracle Database version for Autonomous Database.
    pub db_version: std::string::String,

    /// Output only. Indicates if the backup is long term backup.
    pub is_long_term_backup: bool,

    /// Output only. Indicates if the backup is automatic or user initiated.
    pub is_automatic_backup: bool,

    /// Output only. Indicates if the backup can be used to restore the Autonomous
    /// Database.
    pub is_restorable: bool,

    /// Optional. The OCID of the key store of Oracle Vault.
    pub key_store_id: std::string::String,

    /// Optional. The wallet name for Oracle Key Vault.
    pub key_store_wallet: std::string::String,

    /// Optional. The OCID of the key container that is used as the master
    /// encryption key in database transparent data encryption (TDE) operations.
    pub kms_key_id: std::string::String,

    /// Optional. The OCID of the key container version that is used in database
    /// transparent data encryption (TDE) operations KMS Key can have multiple key
    /// versions. If none is specified, the current key version (latest) of the Key
    /// Id is used for the operation. Autonomous Database Serverless does not use
    /// key versions, hence is not applicable for Autonomous Database Serverless
    /// instances.
    pub kms_key_version_id: std::string::String,

    /// Output only. Additional information about the current lifecycle state.
    pub lifecycle_details: std::string::String,

    /// Output only. The lifecycle state of the backup.
    pub lifecycle_state: crate::model::autonomous_database_backup_properties::State,

    /// Output only. The backup size in terabytes.
    pub size_tb: f32,

    /// Output only. Timestamp until when the backup will be available.
    pub available_till_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup completed.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The type of the backup.
    pub r#type: crate::model::autonomous_database_backup_properties::Type,

    /// Optional. The OCID of the vault.
    pub vault_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseBackupProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [retention_period_days][crate::model::AutonomousDatabaseBackupProperties::retention_period_days].
    pub fn set_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_period_days = v.into();
        self
    }

    /// Sets the value of [compartment_id][crate::model::AutonomousDatabaseBackupProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [database_size_tb][crate::model::AutonomousDatabaseBackupProperties::database_size_tb].
    pub fn set_database_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.database_size_tb = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseBackupProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_long_term_backup][crate::model::AutonomousDatabaseBackupProperties::is_long_term_backup].
    pub fn set_is_long_term_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_long_term_backup = v.into();
        self
    }

    /// Sets the value of [is_automatic_backup][crate::model::AutonomousDatabaseBackupProperties::is_automatic_backup].
    pub fn set_is_automatic_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_automatic_backup = v.into();
        self
    }

    /// Sets the value of [is_restorable][crate::model::AutonomousDatabaseBackupProperties::is_restorable].
    pub fn set_is_restorable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_restorable = v.into();
        self
    }

    /// Sets the value of [key_store_id][crate::model::AutonomousDatabaseBackupProperties::key_store_id].
    pub fn set_key_store_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_store_id = v.into();
        self
    }

    /// Sets the value of [key_store_wallet][crate::model::AutonomousDatabaseBackupProperties::key_store_wallet].
    pub fn set_key_store_wallet<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_store_wallet = v.into();
        self
    }

    /// Sets the value of [kms_key_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_id].
    pub fn set_kms_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_id = v.into();
        self
    }

    /// Sets the value of [kms_key_version_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_version_id].
    pub fn set_kms_key_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_id = v.into();
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseBackupProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::AutonomousDatabaseBackupProperties::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [size_tb][crate::model::AutonomousDatabaseBackupProperties::size_tb].
    pub fn set_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.size_tb = v.into();
        self
    }

    /// Sets the value of [available_till_time][crate::model::AutonomousDatabaseBackupProperties::available_till_time].
    pub fn set_available_till_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_till_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_till_time][crate::model::AutonomousDatabaseBackupProperties::available_till_time].
    pub fn set_or_clear_available_till_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_till_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::AutonomousDatabaseBackupProperties::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::AutonomousDatabaseBackupProperties::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::AutonomousDatabaseBackupProperties::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::AutonomousDatabaseBackupProperties::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AutonomousDatabaseBackupProperties::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseBackupProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDatabaseBackupProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __retention_period_days,
            __compartment_id,
            __database_size_tb,
            __db_version,
            __is_long_term_backup,
            __is_automatic_backup,
            __is_restorable,
            __key_store_id,
            __key_store_wallet,
            __kms_key_id,
            __kms_key_version_id,
            __lifecycle_details,
            __lifecycle_state,
            __size_tb,
            __available_till_time,
            __end_time,
            __start_time,
            __type,
            __vault_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDatabaseBackupProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "retentionPeriodDays" => Ok(__FieldTag::__retention_period_days),
                            "retention_period_days" => Ok(__FieldTag::__retention_period_days),
                            "compartmentId" => Ok(__FieldTag::__compartment_id),
                            "compartment_id" => Ok(__FieldTag::__compartment_id),
                            "databaseSizeTb" => Ok(__FieldTag::__database_size_tb),
                            "database_size_tb" => Ok(__FieldTag::__database_size_tb),
                            "dbVersion" => Ok(__FieldTag::__db_version),
                            "db_version" => Ok(__FieldTag::__db_version),
                            "isLongTermBackup" => Ok(__FieldTag::__is_long_term_backup),
                            "is_long_term_backup" => Ok(__FieldTag::__is_long_term_backup),
                            "isAutomaticBackup" => Ok(__FieldTag::__is_automatic_backup),
                            "is_automatic_backup" => Ok(__FieldTag::__is_automatic_backup),
                            "isRestorable" => Ok(__FieldTag::__is_restorable),
                            "is_restorable" => Ok(__FieldTag::__is_restorable),
                            "keyStoreId" => Ok(__FieldTag::__key_store_id),
                            "key_store_id" => Ok(__FieldTag::__key_store_id),
                            "keyStoreWallet" => Ok(__FieldTag::__key_store_wallet),
                            "key_store_wallet" => Ok(__FieldTag::__key_store_wallet),
                            "kmsKeyId" => Ok(__FieldTag::__kms_key_id),
                            "kms_key_id" => Ok(__FieldTag::__kms_key_id),
                            "kmsKeyVersionId" => Ok(__FieldTag::__kms_key_version_id),
                            "kms_key_version_id" => Ok(__FieldTag::__kms_key_version_id),
                            "lifecycleDetails" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycle_details" => Ok(__FieldTag::__lifecycle_details),
                            "lifecycleState" => Ok(__FieldTag::__lifecycle_state),
                            "lifecycle_state" => Ok(__FieldTag::__lifecycle_state),
                            "sizeTb" => Ok(__FieldTag::__size_tb),
                            "size_tb" => Ok(__FieldTag::__size_tb),
                            "availableTillTime" => Ok(__FieldTag::__available_till_time),
                            "available_till_time" => Ok(__FieldTag::__available_till_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "type" => Ok(__FieldTag::__type),
                            "vaultId" => Ok(__FieldTag::__vault_id),
                            "vault_id" => Ok(__FieldTag::__vault_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDatabaseBackupProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDatabaseBackupProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention_period_days => {
                            if !fields.insert(__FieldTag::__retention_period_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_period_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retention_period_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__compartment_id => {
                            if !fields.insert(__FieldTag::__compartment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compartment_id",
                                ));
                            }
                            result.compartment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_size_tb => {
                            if !fields.insert(__FieldTag::__database_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.database_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_version => {
                            if !fields.insert(__FieldTag::__db_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_version",
                                ));
                            }
                            result.db_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_long_term_backup => {
                            if !fields.insert(__FieldTag::__is_long_term_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_long_term_backup",
                                ));
                            }
                            result.is_long_term_backup = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_automatic_backup => {
                            if !fields.insert(__FieldTag::__is_automatic_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_automatic_backup",
                                ));
                            }
                            result.is_automatic_backup = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_restorable => {
                            if !fields.insert(__FieldTag::__is_restorable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_restorable",
                                ));
                            }
                            result.is_restorable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_store_id => {
                            if !fields.insert(__FieldTag::__key_store_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_store_id",
                                ));
                            }
                            result.key_store_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_store_wallet => {
                            if !fields.insert(__FieldTag::__key_store_wallet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_store_wallet",
                                ));
                            }
                            result.key_store_wallet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_id => {
                            if !fields.insert(__FieldTag::__kms_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_id",
                                ));
                            }
                            result.kms_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_id => {
                            if !fields.insert(__FieldTag::__kms_key_version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_id",
                                ));
                            }
                            result.kms_key_version_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifecycle_details => {
                            if !fields.insert(__FieldTag::__lifecycle_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_details",
                                ));
                            }
                            result.lifecycle_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifecycle_state => {
                            if !fields.insert(__FieldTag::__lifecycle_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_state",
                                ));
                            }
                            result.lifecycle_state = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_backup_properties::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_tb => {
                            if !fields.insert(__FieldTag::__size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_tb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_till_time => {
                            if !fields.insert(__FieldTag::__available_till_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_till_time",
                                ));
                            }
                            result.available_till_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::autonomous_database_backup_properties::Type,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vault_id => {
                            if !fields.insert(__FieldTag::__vault_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vault_id",
                                ));
                            }
                            result.vault_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDatabaseBackupProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ocid.is_empty() {
            state.serialize_entry("ocid", &self.ocid)?;
        }
        if !wkt::internal::is_default(&self.retention_period_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retentionPeriodDays", &__With(&self.retention_period_days))?;
        }
        if !self.compartment_id.is_empty() {
            state.serialize_entry("compartmentId", &self.compartment_id)?;
        }
        if !wkt::internal::is_default(&self.database_size_tb) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("databaseSizeTb", &__With(&self.database_size_tb))?;
        }
        if !self.db_version.is_empty() {
            state.serialize_entry("dbVersion", &self.db_version)?;
        }
        if !wkt::internal::is_default(&self.is_long_term_backup) {
            state.serialize_entry("isLongTermBackup", &self.is_long_term_backup)?;
        }
        if !wkt::internal::is_default(&self.is_automatic_backup) {
            state.serialize_entry("isAutomaticBackup", &self.is_automatic_backup)?;
        }
        if !wkt::internal::is_default(&self.is_restorable) {
            state.serialize_entry("isRestorable", &self.is_restorable)?;
        }
        if !self.key_store_id.is_empty() {
            state.serialize_entry("keyStoreId", &self.key_store_id)?;
        }
        if !self.key_store_wallet.is_empty() {
            state.serialize_entry("keyStoreWallet", &self.key_store_wallet)?;
        }
        if !self.kms_key_id.is_empty() {
            state.serialize_entry("kmsKeyId", &self.kms_key_id)?;
        }
        if !self.kms_key_version_id.is_empty() {
            state.serialize_entry("kmsKeyVersionId", &self.kms_key_version_id)?;
        }
        if !self.lifecycle_details.is_empty() {
            state.serialize_entry("lifecycleDetails", &self.lifecycle_details)?;
        }
        if !wkt::internal::is_default(&self.lifecycle_state) {
            state.serialize_entry("lifecycleState", &self.lifecycle_state)?;
        }
        if !wkt::internal::is_default(&self.size_tb) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeTb", &__With(&self.size_tb))?;
        }
        if self.available_till_time.is_some() {
            state.serialize_entry("availableTillTime", &self.available_till_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.vault_id.is_empty() {
            state.serialize_entry("vaultId", &self.vault_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDatabaseBackupProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDatabaseBackupProperties");
        debug_struct.field("ocid", &self.ocid);
        debug_struct.field("retention_period_days", &self.retention_period_days);
        debug_struct.field("compartment_id", &self.compartment_id);
        debug_struct.field("database_size_tb", &self.database_size_tb);
        debug_struct.field("db_version", &self.db_version);
        debug_struct.field("is_long_term_backup", &self.is_long_term_backup);
        debug_struct.field("is_automatic_backup", &self.is_automatic_backup);
        debug_struct.field("is_restorable", &self.is_restorable);
        debug_struct.field("key_store_id", &self.key_store_id);
        debug_struct.field("key_store_wallet", &self.key_store_wallet);
        debug_struct.field("kms_key_id", &self.kms_key_id);
        debug_struct.field("kms_key_version_id", &self.kms_key_version_id);
        debug_struct.field("lifecycle_details", &self.lifecycle_details);
        debug_struct.field("lifecycle_state", &self.lifecycle_state);
        debug_struct.field("size_tb", &self.size_tb);
        debug_struct.field("available_till_time", &self.available_till_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("vault_id", &self.vault_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutonomousDatabaseBackupProperties].
pub mod autonomous_database_backup_properties {
    #[allow(unused_imports)]
    use super::*;

    /// // The various lifecycle states of the Autonomous Database Backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in creating state.
        Creating,
        /// Indicates that the resource is in active state.
        Active,
        /// Indicates that the resource is in deleting state.
        Deleting,
        /// Indicates that the resource is in deleted state.
        Deleted,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource is in updating state.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Deleted => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(6),
                Self::Updating => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Deleted,
                6 => Self::Failed,
                7 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "FAILED" => Self::Failed,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Deleted => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(6),
                Self::Updating => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties.State",
            ))
        }
    }

    /// The type of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default unspecified value.
        Unspecified,
        /// Incremental backups.
        Incremental,
        /// Full backups.
        Full,
        /// Long term backups.
        LongTerm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incremental => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::LongTerm => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::LongTerm => std::option::Option::Some("LONG_TERM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incremental,
                2 => Self::Full,
                3 => Self::LongTerm,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INCREMENTAL" => Self::Incremental,
                "FULL" => Self::Full,
                "LONG_TERM" => Self::LongTerm,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incremental => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::LongTerm => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties.Type",
            ))
        }
    }
}

/// Details of the Autonomous Database version.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDbVersionSummary/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDbVersion {
    /// Identifier. The name of the Autonomous Database Version resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDbVersions/{autonomous_db_version}
    pub name: std::string::String,

    /// Output only. An Oracle Database version for Autonomous Database.
    pub version: std::string::String,

    /// Output only. The Autonomous Database workload type.
    pub db_workload: crate::model::DBWorkload,

    /// Output only. A URL that points to a detailed description of the Autonomous
    /// Database version.
    pub workload_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDbVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDbVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AutonomousDbVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDbVersion::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [workload_uri][crate::model::AutonomousDbVersion::workload_uri].
    pub fn set_workload_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDbVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDbVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutonomousDbVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __db_workload,
            __workload_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutonomousDbVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "dbWorkload" => Ok(__FieldTag::__db_workload),
                            "db_workload" => Ok(__FieldTag::__db_workload),
                            "workloadUri" => Ok(__FieldTag::__workload_uri),
                            "workload_uri" => Ok(__FieldTag::__workload_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutonomousDbVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutonomousDbVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_workload => {
                            if !fields.insert(__FieldTag::__db_workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_workload",
                                ));
                            }
                            result.db_workload = map
                                .next_value::<std::option::Option<crate::model::DBWorkload>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_uri => {
                            if !fields.insert(__FieldTag::__workload_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_uri",
                                ));
                            }
                            result.workload_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutonomousDbVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.db_workload) {
            state.serialize_entry("dbWorkload", &self.db_workload)?;
        }
        if !self.workload_uri.is_empty() {
            state.serialize_entry("workloadUri", &self.workload_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutonomousDbVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutonomousDbVersion");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        debug_struct.field("db_workload", &self.db_workload);
        debug_struct.field("workload_uri", &self.workload_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The CustomerContact reference as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/CustomerContact>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerContact {
    /// Required. The email address used by Oracle to send notifications regarding
    /// databases and infrastructure.
    pub email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerContact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::CustomerContact::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for CustomerContact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CustomerContact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomerContact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerContact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomerContact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerContact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomerContact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomerContact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomerContact");
        debug_struct.field("email", &self.email);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of the database node resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbNode/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbNode {
    /// Identifier. The name of the database node resource in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}/dbNodes/{db_node}
    pub name: std::string::String,

    /// Optional. Various properties of the database node.
    pub properties: std::option::Option<crate::model::DbNodeProperties>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbNode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbNode::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbNode::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbNodeProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbNode::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbNodeProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbNode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNode"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DbNode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbNode")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "properties" => Ok(__FieldTag::__properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DbNode;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbNode")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<crate::model::DbNodeProperties>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DbNode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DbNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DbNode");
        debug_struct.field("name", &self.name);
        debug_struct.field("properties", &self.properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Various properties and settings associated with Db node.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbNodeProperties {
    /// Output only. OCID of database node.
    pub ocid: std::string::String,

    /// Optional. OCPU count per database node.
    pub ocpu_count: i32,

    /// Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Local storage per database node.
    pub db_node_storage_size_gb: i32,

    /// Optional. Database server OCID.
    pub db_server_ocid: std::string::String,

    /// Optional. DNS
    pub hostname: std::string::String,

    /// Output only. State of the database node.
    pub state: crate::model::db_node_properties::State,

    /// Total CPU core count of the database node.
    pub total_cpu_core_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbNodeProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbNodeProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbNodeProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbNodeProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbNodeProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_server_ocid][crate::model::DbNodeProperties::db_server_ocid].
    pub fn set_db_server_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_server_ocid = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::DbNodeProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbNodeProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_node_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [total_cpu_core_count][crate::model::DbNodeProperties::total_cpu_core_count].
    pub fn set_total_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_cpu_core_count = v.into();
        self
    }
}

impl wkt::message::Message for DbNodeProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNodeProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DbNodeProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __ocpu_count,
            __memory_size_gb,
            __db_node_storage_size_gb,
            __db_server_ocid,
            __hostname,
            __state,
            __total_cpu_core_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbNodeProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "ocpuCount" => Ok(__FieldTag::__ocpu_count),
                            "ocpu_count" => Ok(__FieldTag::__ocpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "dbServerOcid" => Ok(__FieldTag::__db_server_ocid),
                            "db_server_ocid" => Ok(__FieldTag::__db_server_ocid),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "state" => Ok(__FieldTag::__state),
                            "totalCpuCoreCount" => Ok(__FieldTag::__total_cpu_core_count),
                            "total_cpu_core_count" => Ok(__FieldTag::__total_cpu_core_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DbNodeProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbNodeProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ocpu_count => {
                            if !fields.insert(__FieldTag::__ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ocpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_server_ocid => {
                            if !fields.insert(__FieldTag::__db_server_ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_server_ocid",
                                ));
                            }
                            result.db_server_ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::db_node_properties::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__total_cpu_core_count => {
                            if !fields.insert(__FieldTag::__total_cpu_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_cpu_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_cpu_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DbNodeProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ocid.is_empty() {
            state.serialize_entry("ocid", &self.ocid)?;
        }
        if !wkt::internal::is_default(&self.ocpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ocpuCount", &__With(&self.ocpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memorySizeGb", &__With(&self.memory_size_gb))?;
        }
        if !wkt::internal::is_default(&self.db_node_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "dbNodeStorageSizeGb",
                &__With(&self.db_node_storage_size_gb),
            )?;
        }
        if !self.db_server_ocid.is_empty() {
            state.serialize_entry("dbServerOcid", &self.db_server_ocid)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.total_cpu_core_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCpuCoreCount", &__With(&self.total_cpu_core_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DbNodeProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DbNodeProperties");
        debug_struct.field("ocid", &self.ocid);
        debug_struct.field("ocpu_count", &self.ocpu_count);
        debug_struct.field("memory_size_gb", &self.memory_size_gb);
        debug_struct.field("db_node_storage_size_gb", &self.db_node_storage_size_gb);
        debug_struct.field("db_server_ocid", &self.db_server_ocid);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("state", &self.state);
        debug_struct.field("total_cpu_core_count", &self.total_cpu_core_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DbNodeProperties].
pub mod db_node_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in stopping state.
        Stopping,
        /// Indicates that the resource is in stopped state.
        Stopped,
        /// Indicates that the resource is in starting state.
        Starting,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Stopped => std::option::Option::Some(5),
                Self::Starting => std::option::Option::Some(6),
                Self::Terminating => std::option::Option::Some(7),
                Self::Terminated => std::option::Option::Some(8),
                Self::Failed => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Stopping,
                5 => Self::Stopped,
                6 => Self::Starting,
                7 => Self::Terminating,
                8 => Self::Terminated,
                9 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "STARTING" => Self::Starting,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Stopped => serializer.serialize_i32(5),
                Self::Starting => serializer.serialize_i32(6),
                Self::Terminating => serializer.serialize_i32(7),
                Self::Terminated => serializer.serialize_i32(8),
                Self::Failed => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.DbNodeProperties.State",
            ))
        }
    }
}

/// Details of the database server resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbServer/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbServer {
    /// Identifier. The name of the database server resource with the format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}/dbServers/{db_server}
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    pub display_name: std::string::String,

    /// Optional. Various properties of the database server.
    pub properties: std::option::Option<crate::model::DbServerProperties>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbServer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbServer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DbServer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbServer::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbServerProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbServer::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbServerProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbServer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DbServer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbServer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "properties" => Ok(__FieldTag::__properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DbServer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbServer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<crate::model::DbServerProperties>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DbServer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DbServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DbServer");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("properties", &self.properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Various properties and settings associated with Exadata database server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbServerProperties {
    /// Output only. OCID of database server.
    pub ocid: std::string::String,

    /// Optional. OCPU count per database.
    pub ocpu_count: i32,

    /// Optional. Maximum OCPU count per database.
    pub max_ocpu_count: i32,

    /// Optional. Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Maximum memory allocated in GBs.
    pub max_memory_size_gb: i32,

    /// Optional. Local storage per VM.
    pub db_node_storage_size_gb: i32,

    /// Optional. Maximum local storage per VM.
    pub max_db_node_storage_size_gb: i32,

    /// Optional. Vm count per database.
    pub vm_count: i32,

    /// Output only. State of the database server.
    pub state: crate::model::db_server_properties::State,

    /// Output only. OCID of database nodes associated with the database server.
    pub db_node_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbServerProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbServerProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbServerProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [max_ocpu_count][crate::model::DbServerProperties::max_ocpu_count].
    pub fn set_max_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbServerProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_size_gb][crate::model::DbServerProperties::max_memory_size_gb].
    pub fn set_max_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbServerProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::DbServerProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [vm_count][crate::model::DbServerProperties::vm_count].
    pub fn set_vm_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbServerProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_server_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [db_node_ids][crate::model::DbServerProperties::db_node_ids].
    pub fn set_db_node_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_node_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DbServerProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServerProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DbServerProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __ocpu_count,
            __max_ocpu_count,
            __memory_size_gb,
            __max_memory_size_gb,
            __db_node_storage_size_gb,
            __max_db_node_storage_size_gb,
            __vm_count,
            __state,
            __db_node_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbServerProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "ocpuCount" => Ok(__FieldTag::__ocpu_count),
                            "ocpu_count" => Ok(__FieldTag::__ocpu_count),
                            "maxOcpuCount" => Ok(__FieldTag::__max_ocpu_count),
                            "max_ocpu_count" => Ok(__FieldTag::__max_ocpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "maxMemorySizeGb" => Ok(__FieldTag::__max_memory_size_gb),
                            "max_memory_size_gb" => Ok(__FieldTag::__max_memory_size_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "maxDbNodeStorageSizeGb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "max_db_node_storage_size_gb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "vmCount" => Ok(__FieldTag::__vm_count),
                            "vm_count" => Ok(__FieldTag::__vm_count),
                            "state" => Ok(__FieldTag::__state),
                            "dbNodeIds" => Ok(__FieldTag::__db_node_ids),
                            "db_node_ids" => Ok(__FieldTag::__db_node_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DbServerProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbServerProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ocpu_count => {
                            if !fields.insert(__FieldTag::__ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ocpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_ocpu_count => {
                            if !fields.insert(__FieldTag::__max_ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_ocpu_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_memory_size_gb => {
                            if !fields.insert(__FieldTag::__max_memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__max_db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vm_count => {
                            if !fields.insert(__FieldTag::__vm_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vm_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::db_server_properties::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__db_node_ids => {
                            if !fields.insert(__FieldTag::__db_node_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_ids",
                                ));
                            }
                            result.db_node_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DbServerProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ocid.is_empty() {
            state.serialize_entry("ocid", &self.ocid)?;
        }
        if !wkt::internal::is_default(&self.ocpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ocpuCount", &__With(&self.ocpu_count))?;
        }
        if !wkt::internal::is_default(&self.max_ocpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxOcpuCount", &__With(&self.max_ocpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memorySizeGb", &__With(&self.memory_size_gb))?;
        }
        if !wkt::internal::is_default(&self.max_memory_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxMemorySizeGb", &__With(&self.max_memory_size_gb))?;
        }
        if !wkt::internal::is_default(&self.db_node_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "dbNodeStorageSizeGb",
                &__With(&self.db_node_storage_size_gb),
            )?;
        }
        if !wkt::internal::is_default(&self.max_db_node_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxDbNodeStorageSizeGb",
                &__With(&self.max_db_node_storage_size_gb),
            )?;
        }
        if !wkt::internal::is_default(&self.vm_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vmCount", &__With(&self.vm_count))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.db_node_ids.is_empty() {
            state.serialize_entry("dbNodeIds", &self.db_node_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DbServerProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DbServerProperties");
        debug_struct.field("ocid", &self.ocid);
        debug_struct.field("ocpu_count", &self.ocpu_count);
        debug_struct.field("max_ocpu_count", &self.max_ocpu_count);
        debug_struct.field("memory_size_gb", &self.memory_size_gb);
        debug_struct.field("max_memory_size_gb", &self.max_memory_size_gb);
        debug_struct.field("db_node_storage_size_gb", &self.db_node_storage_size_gb);
        debug_struct.field(
            "max_db_node_storage_size_gb",
            &self.max_db_node_storage_size_gb,
        );
        debug_struct.field("vm_count", &self.vm_count);
        debug_struct.field("state", &self.state);
        debug_struct.field("db_node_ids", &self.db_node_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DbServerProperties].
pub mod db_server_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database server.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in creating state.
        Creating,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in unavailable state.
        Unavailable,
        /// Indicates that the resource is in deleting state.
        Deleting,
        /// Indicates that the resource is in deleted state.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Unavailable => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Deleted => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Available,
                3 => Self::Unavailable,
                4 => Self::Deleting,
                5 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "AVAILABLE" => Self::Available,
                "UNAVAILABLE" => Self::Unavailable,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Unavailable => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Deleted => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.DbServerProperties.State",
            ))
        }
    }
}

/// Details of the Database System Shapes resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystemShapeSummary/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbSystemShape {
    /// Identifier. The name of the Database System Shape resource with the format:
    /// projects/{project}/locations/{region}/dbSystemShapes/{db_system_shape}
    pub name: std::string::String,

    /// Optional. shape
    pub shape: std::string::String,

    /// Optional. Minimum number of database servers.
    pub min_node_count: i32,

    /// Optional. Maximum number of database servers.
    pub max_node_count: i32,

    /// Optional. Minimum number of storage servers.
    pub min_storage_count: i32,

    /// Optional. Maximum number of storage servers.
    pub max_storage_count: i32,

    /// Optional. Number of cores per node.
    pub available_core_count_per_node: i32,

    /// Optional. Memory per database server node in gigabytes.
    pub available_memory_per_node_gb: i32,

    /// Optional. Storage per storage server in terabytes.
    pub available_data_storage_tb: i32,

    /// Optional. Minimum core count per node.
    pub min_core_count_per_node: i32,

    /// Optional. Minimum memory per node in gigabytes.
    pub min_memory_per_node_gb: i32,

    /// Optional. Minimum node storage per database server in gigabytes.
    pub min_db_node_storage_per_node_gb: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystemShape {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbSystemShape::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::DbSystemShape::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [min_node_count][crate::model::DbSystemShape::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::DbSystemShape::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }

    /// Sets the value of [min_storage_count][crate::model::DbSystemShape::min_storage_count].
    pub fn set_min_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_storage_count = v.into();
        self
    }

    /// Sets the value of [max_storage_count][crate::model::DbSystemShape::max_storage_count].
    pub fn set_max_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_storage_count = v.into();
        self
    }

    /// Sets the value of [available_core_count_per_node][crate::model::DbSystemShape::available_core_count_per_node].
    pub fn set_available_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [available_memory_per_node_gb][crate::model::DbSystemShape::available_memory_per_node_gb].
    pub fn set_available_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [available_data_storage_tb][crate::model::DbSystemShape::available_data_storage_tb].
    pub fn set_available_data_storage_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [min_core_count_per_node][crate::model::DbSystemShape::min_core_count_per_node].
    pub fn set_min_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [min_memory_per_node_gb][crate::model::DbSystemShape::min_memory_per_node_gb].
    pub fn set_min_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [min_db_node_storage_per_node_gb][crate::model::DbSystemShape::min_db_node_storage_per_node_gb].
    pub fn set_min_db_node_storage_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_db_node_storage_per_node_gb = v.into();
        self
    }
}

impl wkt::message::Message for DbSystemShape {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemShape"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DbSystemShape {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __shape,
            __min_node_count,
            __max_node_count,
            __min_storage_count,
            __max_storage_count,
            __available_core_count_per_node,
            __available_memory_per_node_gb,
            __available_data_storage_tb,
            __min_core_count_per_node,
            __min_memory_per_node_gb,
            __min_db_node_storage_per_node_gb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DbSystemShape")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "shape" => Ok(__FieldTag::__shape),
                            "minNodeCount" => Ok(__FieldTag::__min_node_count),
                            "min_node_count" => Ok(__FieldTag::__min_node_count),
                            "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                            "max_node_count" => Ok(__FieldTag::__max_node_count),
                            "minStorageCount" => Ok(__FieldTag::__min_storage_count),
                            "min_storage_count" => Ok(__FieldTag::__min_storage_count),
                            "maxStorageCount" => Ok(__FieldTag::__max_storage_count),
                            "max_storage_count" => Ok(__FieldTag::__max_storage_count),
                            "availableCoreCountPerNode" => {
                                Ok(__FieldTag::__available_core_count_per_node)
                            }
                            "available_core_count_per_node" => {
                                Ok(__FieldTag::__available_core_count_per_node)
                            }
                            "availableMemoryPerNodeGb" => {
                                Ok(__FieldTag::__available_memory_per_node_gb)
                            }
                            "available_memory_per_node_gb" => {
                                Ok(__FieldTag::__available_memory_per_node_gb)
                            }
                            "availableDataStorageTb" => Ok(__FieldTag::__available_data_storage_tb),
                            "available_data_storage_tb" => {
                                Ok(__FieldTag::__available_data_storage_tb)
                            }
                            "minCoreCountPerNode" => Ok(__FieldTag::__min_core_count_per_node),
                            "min_core_count_per_node" => Ok(__FieldTag::__min_core_count_per_node),
                            "minMemoryPerNodeGb" => Ok(__FieldTag::__min_memory_per_node_gb),
                            "min_memory_per_node_gb" => Ok(__FieldTag::__min_memory_per_node_gb),
                            "minDbNodeStoragePerNodeGb" => {
                                Ok(__FieldTag::__min_db_node_storage_per_node_gb)
                            }
                            "min_db_node_storage_per_node_gb" => {
                                Ok(__FieldTag::__min_db_node_storage_per_node_gb)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DbSystemShape;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DbSystemShape")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shape => {
                            if !fields.insert(__FieldTag::__shape) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shape",
                                ));
                            }
                            result.shape = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_count => {
                            if !fields.insert(__FieldTag::__min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_node_count => {
                            if !fields.insert(__FieldTag::__max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_storage_count => {
                            if !fields.insert(__FieldTag::__min_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_storage_count => {
                            if !fields.insert(__FieldTag::__max_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_core_count_per_node => {
                            if !fields.insert(__FieldTag::__available_core_count_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_core_count_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_core_count_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_memory_per_node_gb => {
                            if !fields.insert(__FieldTag::__available_memory_per_node_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_memory_per_node_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_memory_per_node_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_data_storage_tb => {
                            if !fields.insert(__FieldTag::__available_data_storage_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_data_storage_tb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_data_storage_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_core_count_per_node => {
                            if !fields.insert(__FieldTag::__min_core_count_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_core_count_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_core_count_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_memory_per_node_gb => {
                            if !fields.insert(__FieldTag::__min_memory_per_node_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_memory_per_node_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_memory_per_node_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_db_node_storage_per_node_gb => {
                            if !fields.insert(__FieldTag::__min_db_node_storage_per_node_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_db_node_storage_per_node_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_db_node_storage_per_node_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DbSystemShape {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.shape.is_empty() {
            state.serialize_entry("shape", &self.shape)?;
        }
        if !wkt::internal::is_default(&self.min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCount", &__With(&self.min_node_count))?;
        }
        if !wkt::internal::is_default(&self.max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
        }
        if !wkt::internal::is_default(&self.min_storage_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minStorageCount", &__With(&self.min_storage_count))?;
        }
        if !wkt::internal::is_default(&self.max_storage_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxStorageCount", &__With(&self.max_storage_count))?;
        }
        if !wkt::internal::is_default(&self.available_core_count_per_node) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "availableCoreCountPerNode",
                &__With(&self.available_core_count_per_node),
            )?;
        }
        if !wkt::internal::is_default(&self.available_memory_per_node_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "availableMemoryPerNodeGb",
                &__With(&self.available_memory_per_node_gb),
            )?;
        }
        if !wkt::internal::is_default(&self.available_data_storage_tb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "availableDataStorageTb",
                &__With(&self.available_data_storage_tb),
            )?;
        }
        if !wkt::internal::is_default(&self.min_core_count_per_node) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "minCoreCountPerNode",
                &__With(&self.min_core_count_per_node),
            )?;
        }
        if !wkt::internal::is_default(&self.min_memory_per_node_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minMemoryPerNodeGb", &__With(&self.min_memory_per_node_gb))?;
        }
        if !wkt::internal::is_default(&self.min_db_node_storage_per_node_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "minDbNodeStoragePerNodeGb",
                &__With(&self.min_db_node_storage_per_node_gb),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DbSystemShape {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DbSystemShape");
        debug_struct.field("name", &self.name);
        debug_struct.field("shape", &self.shape);
        debug_struct.field("min_node_count", &self.min_node_count);
        debug_struct.field("max_node_count", &self.max_node_count);
        debug_struct.field("min_storage_count", &self.min_storage_count);
        debug_struct.field("max_storage_count", &self.max_storage_count);
        debug_struct.field(
            "available_core_count_per_node",
            &self.available_core_count_per_node,
        );
        debug_struct.field(
            "available_memory_per_node_gb",
            &self.available_memory_per_node_gb,
        );
        debug_struct.field("available_data_storage_tb", &self.available_data_storage_tb);
        debug_struct.field("min_core_count_per_node", &self.min_core_count_per_node);
        debug_struct.field("min_memory_per_node_gb", &self.min_memory_per_node_gb);
        debug_struct.field(
            "min_db_node_storage_per_node_gb",
            &self.min_db_node_storage_per_node_gb,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of the Entitlement resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Entitlement {
    /// Identifier. The name of the Entitlement resource with the format:
    /// projects/{project}/locations/{region}/entitlements/{entitlement}
    pub name: std::string::String,

    /// Details of the OCI Cloud Account.
    pub cloud_account_details: std::option::Option<crate::model::CloudAccountDetails>,

    /// Output only. Google Cloud Marketplace order ID (aka entitlement ID)
    pub entitlement_id: std::string::String,

    /// Output only. Entitlement State.
    pub state: crate::model::entitlement::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entitlement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entitlement::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cloud_account_details][crate::model::Entitlement::cloud_account_details].
    pub fn set_cloud_account_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudAccountDetails>,
    {
        self.cloud_account_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_account_details][crate::model::Entitlement::cloud_account_details].
    pub fn set_or_clear_cloud_account_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudAccountDetails>,
    {
        self.cloud_account_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entitlement_id][crate::model::Entitlement::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Entitlement::state].
    pub fn set_state<T: std::convert::Into<crate::model::entitlement::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Entitlement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.Entitlement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entitlement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cloud_account_details,
            __entitlement_id,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entitlement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cloudAccountDetails" => Ok(__FieldTag::__cloud_account_details),
                            "cloud_account_details" => Ok(__FieldTag::__cloud_account_details),
                            "entitlementId" => Ok(__FieldTag::__entitlement_id),
                            "entitlement_id" => Ok(__FieldTag::__entitlement_id),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entitlement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entitlement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_account_details => {
                            if !fields.insert(__FieldTag::__cloud_account_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_account_details",
                                ));
                            }
                            result.cloud_account_details = map.next_value::<std::option::Option<crate::model::CloudAccountDetails>>()?
                                ;
                        }
                        __FieldTag::__entitlement_id => {
                            if !fields.insert(__FieldTag::__entitlement_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement_id",
                                ));
                            }
                            result.entitlement_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::entitlement::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entitlement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.cloud_account_details.is_some() {
            state.serialize_entry("cloudAccountDetails", &self.cloud_account_details)?;
        }
        if !self.entitlement_id.is_empty() {
            state.serialize_entry("entitlementId", &self.entitlement_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Entitlement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entitlement");
        debug_struct.field("name", &self.name);
        debug_struct.field("cloud_account_details", &self.cloud_account_details);
        debug_struct.field("entitlement_id", &self.entitlement_id);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Entitlement].
pub mod entitlement {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Account not linked.
        AccountNotLinked,
        /// Account is linked but not active.
        AccountNotActive,
        /// Entitlement and Account are active.
        Active,
        /// Account is suspended.
        AccountSuspended,
        /// Entitlement is not approved in private marketplace.
        NotApprovedInPrivateMarketplace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AccountNotLinked => std::option::Option::Some(1),
                Self::AccountNotActive => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::AccountSuspended => std::option::Option::Some(4),
                Self::NotApprovedInPrivateMarketplace => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::AccountNotLinked => std::option::Option::Some("ACCOUNT_NOT_LINKED"),
                Self::AccountNotActive => std::option::Option::Some("ACCOUNT_NOT_ACTIVE"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::AccountSuspended => std::option::Option::Some("ACCOUNT_SUSPENDED"),
                Self::NotApprovedInPrivateMarketplace => {
                    std::option::Option::Some("NOT_APPROVED_IN_PRIVATE_MARKETPLACE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AccountNotLinked,
                2 => Self::AccountNotActive,
                3 => Self::Active,
                4 => Self::AccountSuspended,
                5 => Self::NotApprovedInPrivateMarketplace,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACCOUNT_NOT_LINKED" => Self::AccountNotLinked,
                "ACCOUNT_NOT_ACTIVE" => Self::AccountNotActive,
                "ACTIVE" => Self::Active,
                "ACCOUNT_SUSPENDED" => Self::AccountSuspended,
                "NOT_APPROVED_IN_PRIVATE_MARKETPLACE" => Self::NotApprovedInPrivateMarketplace,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AccountNotLinked => serializer.serialize_i32(1),
                Self::AccountNotActive => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::AccountSuspended => serializer.serialize_i32(4),
                Self::NotApprovedInPrivateMarketplace => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.Entitlement.State",
            ))
        }
    }
}

/// Details of the OCI Cloud Account.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudAccountDetails {
    /// Output only. OCI account name.
    pub cloud_account: std::string::String,

    /// Output only. OCI account home region.
    pub cloud_account_home_region: std::string::String,

    /// Output only. URL to link an existing account.
    pub link_existing_account_uri: std::option::Option<std::string::String>,

    /// Output only. URL to create a new account and link.
    pub account_creation_uri: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudAccountDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_account][crate::model::CloudAccountDetails::cloud_account].
    pub fn set_cloud_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_account = v.into();
        self
    }

    /// Sets the value of [cloud_account_home_region][crate::model::CloudAccountDetails::cloud_account_home_region].
    pub fn set_cloud_account_home_region<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_account_home_region = v.into();
        self
    }

    /// Sets the value of [link_existing_account_uri][crate::model::CloudAccountDetails::link_existing_account_uri].
    pub fn set_link_existing_account_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.link_existing_account_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [link_existing_account_uri][crate::model::CloudAccountDetails::link_existing_account_uri].
    pub fn set_or_clear_link_existing_account_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.link_existing_account_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_creation_uri][crate::model::CloudAccountDetails::account_creation_uri].
    pub fn set_account_creation_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.account_creation_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_creation_uri][crate::model::CloudAccountDetails::account_creation_uri].
    pub fn set_or_clear_account_creation_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.account_creation_uri = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudAccountDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudAccountDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudAccountDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_account,
            __cloud_account_home_region,
            __link_existing_account_uri,
            __account_creation_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudAccountDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudAccount" => Ok(__FieldTag::__cloud_account),
                            "cloud_account" => Ok(__FieldTag::__cloud_account),
                            "cloudAccountHomeRegion" => Ok(__FieldTag::__cloud_account_home_region),
                            "cloud_account_home_region" => {
                                Ok(__FieldTag::__cloud_account_home_region)
                            }
                            "linkExistingAccountUri" => Ok(__FieldTag::__link_existing_account_uri),
                            "link_existing_account_uri" => {
                                Ok(__FieldTag::__link_existing_account_uri)
                            }
                            "accountCreationUri" => Ok(__FieldTag::__account_creation_uri),
                            "account_creation_uri" => Ok(__FieldTag::__account_creation_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudAccountDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudAccountDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_account => {
                            if !fields.insert(__FieldTag::__cloud_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_account",
                                ));
                            }
                            result.cloud_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_account_home_region => {
                            if !fields.insert(__FieldTag::__cloud_account_home_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_account_home_region",
                                ));
                            }
                            result.cloud_account_home_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__link_existing_account_uri => {
                            if !fields.insert(__FieldTag::__link_existing_account_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for link_existing_account_uri",
                                ));
                            }
                            result.link_existing_account_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__account_creation_uri => {
                            if !fields.insert(__FieldTag::__account_creation_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_creation_uri",
                                ));
                            }
                            result.account_creation_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudAccountDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_account.is_empty() {
            state.serialize_entry("cloudAccount", &self.cloud_account)?;
        }
        if !self.cloud_account_home_region.is_empty() {
            state.serialize_entry("cloudAccountHomeRegion", &self.cloud_account_home_region)?;
        }
        if self.link_existing_account_uri.is_some() {
            state.serialize_entry("linkExistingAccountUri", &self.link_existing_account_uri)?;
        }
        if self.account_creation_uri.is_some() {
            state.serialize_entry("accountCreationUri", &self.account_creation_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudAccountDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudAccountDetails");
        debug_struct.field("cloud_account", &self.cloud_account);
        debug_struct.field("cloud_account_home_region", &self.cloud_account_home_region);
        debug_struct.field("link_existing_account_uri", &self.link_existing_account_uri);
        debug_struct.field("account_creation_uri", &self.account_creation_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents CloudExadataInfrastructure resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudExadataInfrastructure/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudExadataInfrastructure {
    /// Identifier. The name of the Exadata Infrastructure resource with the
    /// format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    pub display_name: std::string::String,

    /// Optional. Google Cloud Platform location where Oracle Exadata is hosted.
    pub gcp_oracle_zone: std::string::String,

    /// Output only. Entitlement ID of the private offer against which this
    /// infrastructure resource is provisioned.
    pub entitlement_id: std::string::String,

    /// Optional. Various properties of the infra.
    pub properties: std::option::Option<crate::model::CloudExadataInfrastructureProperties>,

    /// Optional. Labels or tags associated with the resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the Exadata Infrastructure was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudExadataInfrastructure {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudExadataInfrastructure::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudExadataInfrastructure::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudExadataInfrastructure::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::CloudExadataInfrastructure::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudExadataInfrastructure::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructureProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::CloudExadataInfrastructure::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructureProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CloudExadataInfrastructure::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudExadataInfrastructure::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudExadataInfrastructure::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructure {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructure"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudExadataInfrastructure {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __gcp_oracle_zone,
            __entitlement_id,
            __properties,
            __labels,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudExadataInfrastructure")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "gcpOracleZone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "gcp_oracle_zone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "entitlementId" => Ok(__FieldTag::__entitlement_id),
                            "entitlement_id" => Ok(__FieldTag::__entitlement_id),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudExadataInfrastructure;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudExadataInfrastructure")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_oracle_zone => {
                            if !fields.insert(__FieldTag::__gcp_oracle_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_oracle_zone",
                                ));
                            }
                            result.gcp_oracle_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entitlement_id => {
                            if !fields.insert(__FieldTag::__entitlement_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement_id",
                                ));
                            }
                            result.entitlement_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<
                                crate::model::CloudExadataInfrastructureProperties,
                            >>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudExadataInfrastructure {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.gcp_oracle_zone.is_empty() {
            state.serialize_entry("gcpOracleZone", &self.gcp_oracle_zone)?;
        }
        if !self.entitlement_id.is_empty() {
            state.serialize_entry("entitlementId", &self.entitlement_id)?;
        }
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudExadataInfrastructure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudExadataInfrastructure");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("gcp_oracle_zone", &self.gcp_oracle_zone);
        debug_struct.field("entitlement_id", &self.entitlement_id);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Various properties of Exadata Infrastructure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudExadataInfrastructureProperties {
    /// Output only. OCID of created infra.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Exadata Infrastructure.
    pub compute_count: i32,

    /// Optional. The number of Cloud Exadata storage servers for the Exadata
    /// Infrastructure.
    pub storage_count: i32,

    /// Optional. The total storage allocated to the Exadata Infrastructure
    /// resource, in gigabytes (GB).
    pub total_storage_size_gb: i32,

    /// Output only. The available storage can be allocated to the Exadata
    /// Infrastructure resource, in gigabytes (GB).
    pub available_storage_size_gb: i32,

    /// Optional. Maintenance window for repair.
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Output only. The current lifecycle state of the Exadata Infrastructure.
    pub state: crate::model::cloud_exadata_infrastructure_properties::State,

    /// Required. The shape of the Exadata Infrastructure. The shape determines the
    /// amount of CPU, storage, and memory resources allocated to the instance.
    pub shape: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    pub oci_url: std::string::String,

    /// Output only. The number of enabled CPU cores.
    pub cpu_count: i32,

    /// Output only. The total number of CPU cores available.
    pub max_cpu_count: i32,

    /// Output only. The memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Output only. The total memory available in GBs.
    pub max_memory_gb: i32,

    /// Output only. The local node storage allocated in GBs.
    pub db_node_storage_size_gb: i32,

    /// Output only. The total local node storage available in GBs.
    pub max_db_node_storage_size_gb: i32,

    /// Output only. Size, in terabytes, of the DATA disk group.
    pub data_storage_size_tb: f64,

    /// Output only. The total available DATA disk group size.
    pub max_data_storage_tb: f64,

    /// Output only. The requested number of additional storage servers activated
    /// for the Exadata Infrastructure.
    pub activated_storage_count: i32,

    /// Output only. The requested number of additional storage servers for the
    /// Exadata Infrastructure.
    pub additional_storage_count: i32,

    /// Output only. The software version of the database servers (dom0) in the
    /// Exadata Infrastructure.
    pub db_server_version: std::string::String,

    /// Output only. The software version of the storage servers (cells) in the
    /// Exadata Infrastructure.
    pub storage_server_version: std::string::String,

    /// Output only. The OCID of the next maintenance run.
    pub next_maintenance_run_id: std::string::String,

    /// Output only. The time when the next maintenance run will occur.
    pub next_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the next security maintenance run will occur.
    pub next_security_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of customer contacts.
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Output only. The monthly software version of the storage servers (cells)
    /// in the Exadata Infrastructure. Example: 20.1.15
    pub monthly_storage_server_version: std::string::String,

    /// Output only. The monthly software version of the database servers (dom0)
    /// in the Exadata Infrastructure. Example: 20.1.15
    pub monthly_db_server_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudExadataInfrastructureProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudExadataInfrastructureProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::CloudExadataInfrastructureProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [storage_count][crate::model::CloudExadataInfrastructureProperties::storage_count].
    pub fn set_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_count = v.into();
        self
    }

    /// Sets the value of [total_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::total_storage_size_gb].
    pub fn set_total_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [available_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::available_storage_size_gb].
    pub fn set_available_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::CloudExadataInfrastructureProperties::maintenance_window].
    pub fn set_maintenance_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_window][crate::model::CloudExadataInfrastructureProperties::maintenance_window].
    pub fn set_or_clear_maintenance_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CloudExadataInfrastructureProperties::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::cloud_exadata_infrastructure_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudExadataInfrastructureProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudExadataInfrastructureProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::CloudExadataInfrastructureProperties::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [max_cpu_count][crate::model::CloudExadataInfrastructureProperties::max_cpu_count].
    pub fn set_max_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudExadataInfrastructureProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_gb][crate::model::CloudExadataInfrastructureProperties::max_memory_gb].
    pub fn set_max_memory_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudExadataInfrastructureProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [max_data_storage_tb][crate::model::CloudExadataInfrastructureProperties::max_data_storage_tb].
    pub fn set_max_data_storage_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [activated_storage_count][crate::model::CloudExadataInfrastructureProperties::activated_storage_count].
    pub fn set_activated_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.activated_storage_count = v.into();
        self
    }

    /// Sets the value of [additional_storage_count][crate::model::CloudExadataInfrastructureProperties::additional_storage_count].
    pub fn set_additional_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.additional_storage_count = v.into();
        self
    }

    /// Sets the value of [db_server_version][crate::model::CloudExadataInfrastructureProperties::db_server_version].
    pub fn set_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_server_version = v.into();
        self
    }

    /// Sets the value of [storage_server_version][crate::model::CloudExadataInfrastructureProperties::storage_server_version].
    pub fn set_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_server_version = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_id][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_id].
    pub fn set_next_maintenance_run_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_maintenance_run_id = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_time].
    pub fn set_next_maintenance_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_maintenance_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_time].
    pub fn set_or_clear_next_maintenance_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_maintenance_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_security_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_security_maintenance_run_time].
    pub fn set_next_security_maintenance_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_security_maintenance_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_security_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_security_maintenance_run_time].
    pub fn set_or_clear_next_security_maintenance_run_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_security_maintenance_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_contacts][crate::model::CloudExadataInfrastructureProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [monthly_storage_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_storage_server_version].
    pub fn set_monthly_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_storage_server_version = v.into();
        self
    }

    /// Sets the value of [monthly_db_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_db_server_version].
    pub fn set_monthly_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_db_server_version = v.into();
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructureProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructureProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudExadataInfrastructureProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __compute_count,
            __storage_count,
            __total_storage_size_gb,
            __available_storage_size_gb,
            __maintenance_window,
            __state,
            __shape,
            __oci_url,
            __cpu_count,
            __max_cpu_count,
            __memory_size_gb,
            __max_memory_gb,
            __db_node_storage_size_gb,
            __max_db_node_storage_size_gb,
            __data_storage_size_tb,
            __max_data_storage_tb,
            __activated_storage_count,
            __additional_storage_count,
            __db_server_version,
            __storage_server_version,
            __next_maintenance_run_id,
            __next_maintenance_run_time,
            __next_security_maintenance_run_time,
            __customer_contacts,
            __monthly_storage_server_version,
            __monthly_db_server_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudExadataInfrastructureProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "computeCount" => Ok(__FieldTag::__compute_count),
                            "compute_count" => Ok(__FieldTag::__compute_count),
                            "storageCount" => Ok(__FieldTag::__storage_count),
                            "storage_count" => Ok(__FieldTag::__storage_count),
                            "totalStorageSizeGb" => Ok(__FieldTag::__total_storage_size_gb),
                            "total_storage_size_gb" => Ok(__FieldTag::__total_storage_size_gb),
                            "availableStorageSizeGb" => Ok(__FieldTag::__available_storage_size_gb),
                            "available_storage_size_gb" => {
                                Ok(__FieldTag::__available_storage_size_gb)
                            }
                            "maintenanceWindow" => Ok(__FieldTag::__maintenance_window),
                            "maintenance_window" => Ok(__FieldTag::__maintenance_window),
                            "state" => Ok(__FieldTag::__state),
                            "shape" => Ok(__FieldTag::__shape),
                            "ociUrl" => Ok(__FieldTag::__oci_url),
                            "oci_url" => Ok(__FieldTag::__oci_url),
                            "cpuCount" => Ok(__FieldTag::__cpu_count),
                            "cpu_count" => Ok(__FieldTag::__cpu_count),
                            "maxCpuCount" => Ok(__FieldTag::__max_cpu_count),
                            "max_cpu_count" => Ok(__FieldTag::__max_cpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "maxMemoryGb" => Ok(__FieldTag::__max_memory_gb),
                            "max_memory_gb" => Ok(__FieldTag::__max_memory_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "maxDbNodeStorageSizeGb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "max_db_node_storage_size_gb" => {
                                Ok(__FieldTag::__max_db_node_storage_size_gb)
                            }
                            "dataStorageSizeTb" => Ok(__FieldTag::__data_storage_size_tb),
                            "data_storage_size_tb" => Ok(__FieldTag::__data_storage_size_tb),
                            "maxDataStorageTb" => Ok(__FieldTag::__max_data_storage_tb),
                            "max_data_storage_tb" => Ok(__FieldTag::__max_data_storage_tb),
                            "activatedStorageCount" => Ok(__FieldTag::__activated_storage_count),
                            "activated_storage_count" => Ok(__FieldTag::__activated_storage_count),
                            "additionalStorageCount" => Ok(__FieldTag::__additional_storage_count),
                            "additional_storage_count" => {
                                Ok(__FieldTag::__additional_storage_count)
                            }
                            "dbServerVersion" => Ok(__FieldTag::__db_server_version),
                            "db_server_version" => Ok(__FieldTag::__db_server_version),
                            "storageServerVersion" => Ok(__FieldTag::__storage_server_version),
                            "storage_server_version" => Ok(__FieldTag::__storage_server_version),
                            "nextMaintenanceRunId" => Ok(__FieldTag::__next_maintenance_run_id),
                            "next_maintenance_run_id" => Ok(__FieldTag::__next_maintenance_run_id),
                            "nextMaintenanceRunTime" => Ok(__FieldTag::__next_maintenance_run_time),
                            "next_maintenance_run_time" => {
                                Ok(__FieldTag::__next_maintenance_run_time)
                            }
                            "nextSecurityMaintenanceRunTime" => {
                                Ok(__FieldTag::__next_security_maintenance_run_time)
                            }
                            "next_security_maintenance_run_time" => {
                                Ok(__FieldTag::__next_security_maintenance_run_time)
                            }
                            "customerContacts" => Ok(__FieldTag::__customer_contacts),
                            "customer_contacts" => Ok(__FieldTag::__customer_contacts),
                            "monthlyStorageServerVersion" => {
                                Ok(__FieldTag::__monthly_storage_server_version)
                            }
                            "monthly_storage_server_version" => {
                                Ok(__FieldTag::__monthly_storage_server_version)
                            }
                            "monthlyDbServerVersion" => Ok(__FieldTag::__monthly_db_server_version),
                            "monthly_db_server_version" => {
                                Ok(__FieldTag::__monthly_db_server_version)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudExadataInfrastructureProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudExadataInfrastructureProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_count => {
                            if !fields.insert(__FieldTag::__compute_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_count => {
                            if !fields.insert(__FieldTag::__storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_storage_size_gb => {
                            if !fields.insert(__FieldTag::__total_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__available_storage_size_gb => {
                            if !fields.insert(__FieldTag::__available_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__maintenance_window => {
                            if !fields.insert(__FieldTag::__maintenance_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_window",
                                ));
                            }
                            result.maintenance_window = map
                                .next_value::<std::option::Option<crate::model::MaintenanceWindow>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_exadata_infrastructure_properties::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shape => {
                            if !fields.insert(__FieldTag::__shape) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shape",
                                ));
                            }
                            result.shape = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oci_url => {
                            if !fields.insert(__FieldTag::__oci_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oci_url",
                                ));
                            }
                            result.oci_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_count => {
                            if !fields.insert(__FieldTag::__cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_cpu_count => {
                            if !fields.insert(__FieldTag::__max_cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_cpu_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_memory_gb => {
                            if !fields.insert(__FieldTag::__max_memory_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_memory_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_memory_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__max_db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_data_storage_tb => {
                            if !fields.insert(__FieldTag::__max_data_storage_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_data_storage_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_data_storage_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__activated_storage_count => {
                            if !fields.insert(__FieldTag::__activated_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activated_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.activated_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_storage_count => {
                            if !fields.insert(__FieldTag::__additional_storage_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_storage_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_storage_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_server_version => {
                            if !fields.insert(__FieldTag::__db_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_server_version",
                                ));
                            }
                            result.db_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_server_version => {
                            if !fields.insert(__FieldTag::__storage_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_server_version",
                                ));
                            }
                            result.storage_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_maintenance_run_id => {
                            if !fields.insert(__FieldTag::__next_maintenance_run_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_maintenance_run_id",
                                ));
                            }
                            result.next_maintenance_run_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_maintenance_run_time => {
                            if !fields.insert(__FieldTag::__next_maintenance_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_maintenance_run_time",
                                ));
                            }
                            result.next_maintenance_run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__next_security_maintenance_run_time => {
                            if !fields.insert(__FieldTag::__next_security_maintenance_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_security_maintenance_run_time",
                                ));
                            }
                            result.next_security_maintenance_run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__customer_contacts => {
                            if !fields.insert(__FieldTag::__customer_contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_contacts",
                                ));
                            }
                            result.customer_contacts =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomerContact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monthly_storage_server_version => {
                            if !fields.insert(__FieldTag::__monthly_storage_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly_storage_server_version",
                                ));
                            }
                            result.monthly_storage_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monthly_db_server_version => {
                            if !fields.insert(__FieldTag::__monthly_db_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly_db_server_version",
                                ));
                            }
                            result.monthly_db_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudExadataInfrastructureProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ocid.is_empty() {
            state.serialize_entry("ocid", &self.ocid)?;
        }
        if !wkt::internal::is_default(&self.compute_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("computeCount", &__With(&self.compute_count))?;
        }
        if !wkt::internal::is_default(&self.storage_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("storageCount", &__With(&self.storage_count))?;
        }
        if !wkt::internal::is_default(&self.total_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalStorageSizeGb", &__With(&self.total_storage_size_gb))?;
        }
        if !wkt::internal::is_default(&self.available_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "availableStorageSizeGb",
                &__With(&self.available_storage_size_gb),
            )?;
        }
        if self.maintenance_window.is_some() {
            state.serialize_entry("maintenanceWindow", &self.maintenance_window)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.shape.is_empty() {
            state.serialize_entry("shape", &self.shape)?;
        }
        if !self.oci_url.is_empty() {
            state.serialize_entry("ociUrl", &self.oci_url)?;
        }
        if !wkt::internal::is_default(&self.cpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
        }
        if !wkt::internal::is_default(&self.max_cpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxCpuCount", &__With(&self.max_cpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memorySizeGb", &__With(&self.memory_size_gb))?;
        }
        if !wkt::internal::is_default(&self.max_memory_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxMemoryGb", &__With(&self.max_memory_gb))?;
        }
        if !wkt::internal::is_default(&self.db_node_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "dbNodeStorageSizeGb",
                &__With(&self.db_node_storage_size_gb),
            )?;
        }
        if !wkt::internal::is_default(&self.max_db_node_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxDbNodeStorageSizeGb",
                &__With(&self.max_db_node_storage_size_gb),
            )?;
        }
        if !wkt::internal::is_default(&self.data_storage_size_tb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataStorageSizeTb", &__With(&self.data_storage_size_tb))?;
        }
        if !wkt::internal::is_default(&self.max_data_storage_tb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxDataStorageTb", &__With(&self.max_data_storage_tb))?;
        }
        if !wkt::internal::is_default(&self.activated_storage_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "activatedStorageCount",
                &__With(&self.activated_storage_count),
            )?;
        }
        if !wkt::internal::is_default(&self.additional_storage_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "additionalStorageCount",
                &__With(&self.additional_storage_count),
            )?;
        }
        if !self.db_server_version.is_empty() {
            state.serialize_entry("dbServerVersion", &self.db_server_version)?;
        }
        if !self.storage_server_version.is_empty() {
            state.serialize_entry("storageServerVersion", &self.storage_server_version)?;
        }
        if !self.next_maintenance_run_id.is_empty() {
            state.serialize_entry("nextMaintenanceRunId", &self.next_maintenance_run_id)?;
        }
        if self.next_maintenance_run_time.is_some() {
            state.serialize_entry("nextMaintenanceRunTime", &self.next_maintenance_run_time)?;
        }
        if self.next_security_maintenance_run_time.is_some() {
            state.serialize_entry(
                "nextSecurityMaintenanceRunTime",
                &self.next_security_maintenance_run_time,
            )?;
        }
        if !self.customer_contacts.is_empty() {
            state.serialize_entry("customerContacts", &self.customer_contacts)?;
        }
        if !self.monthly_storage_server_version.is_empty() {
            state.serialize_entry(
                "monthlyStorageServerVersion",
                &self.monthly_storage_server_version,
            )?;
        }
        if !self.monthly_db_server_version.is_empty() {
            state.serialize_entry("monthlyDbServerVersion", &self.monthly_db_server_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudExadataInfrastructureProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudExadataInfrastructureProperties");
        debug_struct.field("ocid", &self.ocid);
        debug_struct.field("compute_count", &self.compute_count);
        debug_struct.field("storage_count", &self.storage_count);
        debug_struct.field("total_storage_size_gb", &self.total_storage_size_gb);
        debug_struct.field("available_storage_size_gb", &self.available_storage_size_gb);
        debug_struct.field("maintenance_window", &self.maintenance_window);
        debug_struct.field("state", &self.state);
        debug_struct.field("shape", &self.shape);
        debug_struct.field("oci_url", &self.oci_url);
        debug_struct.field("cpu_count", &self.cpu_count);
        debug_struct.field("max_cpu_count", &self.max_cpu_count);
        debug_struct.field("memory_size_gb", &self.memory_size_gb);
        debug_struct.field("max_memory_gb", &self.max_memory_gb);
        debug_struct.field("db_node_storage_size_gb", &self.db_node_storage_size_gb);
        debug_struct.field(
            "max_db_node_storage_size_gb",
            &self.max_db_node_storage_size_gb,
        );
        debug_struct.field("data_storage_size_tb", &self.data_storage_size_tb);
        debug_struct.field("max_data_storage_tb", &self.max_data_storage_tb);
        debug_struct.field("activated_storage_count", &self.activated_storage_count);
        debug_struct.field("additional_storage_count", &self.additional_storage_count);
        debug_struct.field("db_server_version", &self.db_server_version);
        debug_struct.field("storage_server_version", &self.storage_server_version);
        debug_struct.field("next_maintenance_run_id", &self.next_maintenance_run_id);
        debug_struct.field("next_maintenance_run_time", &self.next_maintenance_run_time);
        debug_struct.field(
            "next_security_maintenance_run_time",
            &self.next_security_maintenance_run_time,
        );
        debug_struct.field("customer_contacts", &self.customer_contacts);
        debug_struct.field(
            "monthly_storage_server_version",
            &self.monthly_storage_server_version,
        );
        debug_struct.field("monthly_db_server_version", &self.monthly_db_server_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudExadataInfrastructureProperties].
pub mod cloud_exadata_infrastructure_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the Exadata Infrastructure.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// The Exadata Infrastructure is being provisioned.
        Provisioning,
        /// The Exadata Infrastructure is available for use.
        Available,
        /// The Exadata Infrastructure is being updated.
        Updating,
        /// The Exadata Infrastructure is being terminated.
        Terminating,
        /// The Exadata Infrastructure is terminated.
        Terminated,
        /// The Exadata Infrastructure is in failed state.
        Failed,
        /// The Exadata Infrastructure is in maintenance.
        MaintenanceInProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::MaintenanceInProgress => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::MaintenanceInProgress => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.CloudExadataInfrastructureProperties.State",
            ))
        }
    }
}

/// Maintenance window as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/MaintenanceWindow>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Optional. The maintenance window scheduling preference.
    pub preference: crate::model::maintenance_window::MaintenanceWindowPreference,

    /// Optional. Months during the year when maintenance should be performed.
    pub months: std::vec::Vec<gtype::model::Month>,

    /// Optional. Weeks during the month when maintenance should be performed.
    /// Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a
    /// duration of 7 days. Weeks start and end based on calendar dates, not days
    /// of the week.
    pub weeks_of_month: std::vec::Vec<i32>,

    /// Optional. Days during the week when maintenance should be performed.
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. The window of hours during the day when maintenance should be
    /// performed. The window is a 4 hour slot. Valid values are:
    /// 0 - represents time slot 0:00 - 3:59 UTC
    /// 4 - represents time slot 4:00 - 7:59 UTC
    /// 8 - represents time slot 8:00 - 11:59 UTC
    /// 12 - represents time slot 12:00 - 15:59 UTC
    /// 16 - represents time slot 16:00 - 19:59 UTC
    /// 20 - represents time slot 20:00 - 23:59 UTC
    pub hours_of_day: std::vec::Vec<i32>,

    /// Optional. Lead time window allows user to set a lead time to prepare for a
    /// down time. The lead time is in weeks and valid value is between 1 to 4.
    pub lead_time_week: i32,

    /// Optional. Cloud CloudExadataInfrastructure node patching method, either
    /// "ROLLING" or "NONROLLING". Default value is ROLLING.
    pub patching_mode: crate::model::maintenance_window::PatchingMode,

    /// Optional. Determines the amount of time the system will wait before the
    /// start of each database server patching operation. Custom action timeout is
    /// in minutes and valid value is between 15 to 120 (inclusive).
    pub custom_action_timeout_mins: i32,

    /// Optional. If true, enables the configuration of a custom action timeout
    /// (waiting period) between database server patching operations.
    pub is_custom_action_timeout_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preference][crate::model::MaintenanceWindow::preference].
    pub fn set_preference<
        T: std::convert::Into<crate::model::maintenance_window::MaintenanceWindowPreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preference = v.into();
        self
    }

    /// Sets the value of [months][crate::model::MaintenanceWindow::months].
    pub fn set_months<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::Month>,
    {
        use std::iter::Iterator;
        self.months = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [weeks_of_month][crate::model::MaintenanceWindow::weeks_of_month].
    pub fn set_weeks_of_month<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.weeks_of_month = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [days_of_week][crate::model::MaintenanceWindow::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hours_of_day][crate::model::MaintenanceWindow::hours_of_day].
    pub fn set_hours_of_day<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.hours_of_day = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [lead_time_week][crate::model::MaintenanceWindow::lead_time_week].
    pub fn set_lead_time_week<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lead_time_week = v.into();
        self
    }

    /// Sets the value of [patching_mode][crate::model::MaintenanceWindow::patching_mode].
    pub fn set_patching_mode<
        T: std::convert::Into<crate::model::maintenance_window::PatchingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patching_mode = v.into();
        self
    }

    /// Sets the value of [custom_action_timeout_mins][crate::model::MaintenanceWindow::custom_action_timeout_mins].
    pub fn set_custom_action_timeout_mins<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.custom_action_timeout_mins = v.into();
        self
    }

    /// Sets the value of [is_custom_action_timeout_enabled][crate::model::MaintenanceWindow::is_custom_action_timeout_enabled].
    pub fn set_is_custom_action_timeout_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_custom_action_timeout_enabled = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.MaintenanceWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __preference,
            __months,
            __weeks_of_month,
            __days_of_week,
            __hours_of_day,
            __lead_time_week,
            __patching_mode,
            __custom_action_timeout_mins,
            __is_custom_action_timeout_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "preference" => Ok(__FieldTag::__preference),
                            "months" => Ok(__FieldTag::__months),
                            "weeksOfMonth" => Ok(__FieldTag::__weeks_of_month),
                            "weeks_of_month" => Ok(__FieldTag::__weeks_of_month),
                            "daysOfWeek" => Ok(__FieldTag::__days_of_week),
                            "days_of_week" => Ok(__FieldTag::__days_of_week),
                            "hoursOfDay" => Ok(__FieldTag::__hours_of_day),
                            "hours_of_day" => Ok(__FieldTag::__hours_of_day),
                            "leadTimeWeek" => Ok(__FieldTag::__lead_time_week),
                            "lead_time_week" => Ok(__FieldTag::__lead_time_week),
                            "patchingMode" => Ok(__FieldTag::__patching_mode),
                            "patching_mode" => Ok(__FieldTag::__patching_mode),
                            "customActionTimeoutMins" => {
                                Ok(__FieldTag::__custom_action_timeout_mins)
                            }
                            "custom_action_timeout_mins" => {
                                Ok(__FieldTag::__custom_action_timeout_mins)
                            }
                            "isCustomActionTimeoutEnabled" => {
                                Ok(__FieldTag::__is_custom_action_timeout_enabled)
                            }
                            "is_custom_action_timeout_enabled" => {
                                Ok(__FieldTag::__is_custom_action_timeout_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__preference => {
                            if !fields.insert(__FieldTag::__preference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preference",
                                ));
                            }
                            result.preference = map
                                .next_value::<std::option::Option<
                                    crate::model::maintenance_window::MaintenanceWindowPreference,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__months => {
                            if !fields.insert(__FieldTag::__months) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for months",
                                ));
                            }
                            result.months = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::Month>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__weeks_of_month => {
                            if !fields.insert(__FieldTag::__weeks_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weeks_of_month",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.weeks_of_month =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__days_of_week => {
                            if !fields.insert(__FieldTag::__days_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for days_of_week",
                                ));
                            }
                            result.days_of_week = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::DayOfWeek>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hours_of_day => {
                            if !fields.insert(__FieldTag::__hours_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hours_of_day",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.hours_of_day = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__lead_time_week => {
                            if !fields.insert(__FieldTag::__lead_time_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lead_time_week",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.lead_time_week =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__patching_mode => {
                            if !fields.insert(__FieldTag::__patching_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patching_mode",
                                ));
                            }
                            result.patching_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::maintenance_window::PatchingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_action_timeout_mins => {
                            if !fields.insert(__FieldTag::__custom_action_timeout_mins) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_action_timeout_mins",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.custom_action_timeout_mins =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__is_custom_action_timeout_enabled => {
                            if !fields.insert(__FieldTag::__is_custom_action_timeout_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_custom_action_timeout_enabled",
                                ));
                            }
                            result.is_custom_action_timeout_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.preference) {
            state.serialize_entry("preference", &self.preference)?;
        }
        if !self.months.is_empty() {
            state.serialize_entry("months", &self.months)?;
        }
        if !self.weeks_of_month.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("weeksOfMonth", &__With(&self.weeks_of_month))?;
        }
        if !self.days_of_week.is_empty() {
            state.serialize_entry("daysOfWeek", &self.days_of_week)?;
        }
        if !self.hours_of_day.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hoursOfDay", &__With(&self.hours_of_day))?;
        }
        if !wkt::internal::is_default(&self.lead_time_week) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("leadTimeWeek", &__With(&self.lead_time_week))?;
        }
        if !wkt::internal::is_default(&self.patching_mode) {
            state.serialize_entry("patchingMode", &self.patching_mode)?;
        }
        if !wkt::internal::is_default(&self.custom_action_timeout_mins) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "customActionTimeoutMins",
                &__With(&self.custom_action_timeout_mins),
            )?;
        }
        if !wkt::internal::is_default(&self.is_custom_action_timeout_enabled) {
            state.serialize_entry(
                "isCustomActionTimeoutEnabled",
                &self.is_custom_action_timeout_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceWindow");
        debug_struct.field("preference", &self.preference);
        debug_struct.field("months", &self.months);
        debug_struct.field("weeks_of_month", &self.weeks_of_month);
        debug_struct.field("days_of_week", &self.days_of_week);
        debug_struct.field("hours_of_day", &self.hours_of_day);
        debug_struct.field("lead_time_week", &self.lead_time_week);
        debug_struct.field("patching_mode", &self.patching_mode);
        debug_struct.field(
            "custom_action_timeout_mins",
            &self.custom_action_timeout_mins,
        );
        debug_struct.field(
            "is_custom_action_timeout_enabled",
            &self.is_custom_action_timeout_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MaintenanceWindow].
pub mod maintenance_window {
    #[allow(unused_imports)]
    use super::*;

    /// Maintenance window preference.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceWindowPreference {
        /// Default unspecified value.
        Unspecified,
        /// Custom preference.
        CustomPreference,
        /// No preference.
        NoPreference,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceWindowPreference::value] or
        /// [MaintenanceWindowPreference::name].
        UnknownValue(maintenance_window_preference::UnknownValue),
    }

    #[doc(hidden)]
    pub mod maintenance_window_preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaintenanceWindowPreference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CustomPreference => std::option::Option::Some(1),
                Self::NoPreference => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED")
                }
                Self::CustomPreference => std::option::Option::Some("CUSTOM_PREFERENCE"),
                Self::NoPreference => std::option::Option::Some("NO_PREFERENCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaintenanceWindowPreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaintenanceWindowPreference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaintenanceWindowPreference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CustomPreference,
                2 => Self::NoPreference,
                _ => Self::UnknownValue(maintenance_window_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaintenanceWindowPreference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOM_PREFERENCE" => Self::CustomPreference,
                "NO_PREFERENCE" => Self::NoPreference,
                _ => Self::UnknownValue(maintenance_window_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaintenanceWindowPreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CustomPreference => serializer.serialize_i32(1),
                Self::NoPreference => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceWindowPreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<MaintenanceWindowPreference>::new(
                    ".google.cloud.oracledatabase.v1.MaintenanceWindow.MaintenanceWindowPreference",
                ),
            )
        }
    }

    /// Patching mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PatchingMode {
        /// Default unspecified value.
        Unspecified,
        /// Updates the Cloud Exadata database server hosts in a rolling fashion.
        Rolling,
        /// The non-rolling maintenance method first updates your storage servers at
        /// the same time, then your database servers at the same time.
        NonRolling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PatchingMode::value] or
        /// [PatchingMode::name].
        UnknownValue(patching_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod patching_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PatchingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rolling => std::option::Option::Some(1),
                Self::NonRolling => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PATCHING_MODE_UNSPECIFIED"),
                Self::Rolling => std::option::Option::Some("ROLLING"),
                Self::NonRolling => std::option::Option::Some("NON_ROLLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PatchingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PatchingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PatchingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rolling,
                2 => Self::NonRolling,
                _ => Self::UnknownValue(patching_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PatchingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PATCHING_MODE_UNSPECIFIED" => Self::Unspecified,
                "ROLLING" => Self::Rolling,
                "NON_ROLLING" => Self::NonRolling,
                _ => Self::UnknownValue(patching_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PatchingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rolling => serializer.serialize_i32(1),
                Self::NonRolling => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PatchingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PatchingMode>::new(
                ".google.cloud.oracledatabase.v1.MaintenanceWindow.PatchingMode",
            ))
        }
    }
}

/// Details of the Oracle Grid Infrastructure (GI) version resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiVersionSummary/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GiVersion {
    /// Identifier. The name of the Oracle Grid Infrastructure (GI) version
    /// resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_versions}
    pub name: std::string::String,

    /// Optional. version
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GiVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GiVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GiVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GiVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GiVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GiVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GiVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GiVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GiVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GiVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GiVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GiVersion");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for a given [Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Output only. Google Cloud Platform Oracle zones in a location.
    pub gcp_oracle_zones: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_oracle_zones][crate::model::LocationMetadata::gcp_oracle_zones].
    pub fn set_gcp_oracle_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.gcp_oracle_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcp_oracle_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcpOracleZones" => Ok(__FieldTag::__gcp_oracle_zones),
                            "gcp_oracle_zones" => Ok(__FieldTag::__gcp_oracle_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcp_oracle_zones => {
                            if !fields.insert(__FieldTag::__gcp_oracle_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_oracle_zones",
                                ));
                            }
                            result.gcp_oracle_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcp_oracle_zones.is_empty() {
            state.serialize_entry("gcpOracleZones", &self.gcp_oracle_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationMetadata");
        debug_struct.field("gcp_oracle_zones", &self.gcp_oracle_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudExadataInfrastructures.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Exadata infrastructures will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudExadataInfrastructuresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudExadataInfrastructuresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudExadataInfrastructuresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudExadataInfrastructuresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudExadataInfrastructuresRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCloudExadataInfrastructuresRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudExadataInfrastructuresRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudExadataInfrastructuresRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudExadataInfrastructuresRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudExadataInfrastructuresRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudExadataInfrastructuresRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `CloudExadataInfrastructures.list`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresResponse {
    /// The list of Exadata Infrastructures.
    pub cloud_exadata_infrastructures: std::vec::Vec<crate::model::CloudExadataInfrastructure>,

    /// A token for fetching next page of response.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudExadataInfrastructuresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_exadata_infrastructures][crate::model::ListCloudExadataInfrastructuresResponse::cloud_exadata_infrastructures].
    pub fn set_cloud_exadata_infrastructures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        use std::iter::Iterator;
        self.cloud_exadata_infrastructures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudExadataInfrastructuresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudExadataInfrastructuresResponse {
    type PageItem = crate::model::CloudExadataInfrastructure;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_exadata_infrastructures
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudExadataInfrastructuresResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_exadata_infrastructures,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCloudExadataInfrastructuresResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudExadataInfrastructures" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructures)
                            }
                            "cloud_exadata_infrastructures" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructures)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudExadataInfrastructuresResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudExadataInfrastructuresResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_exadata_infrastructures => {
                            if !fields.insert(__FieldTag::__cloud_exadata_infrastructures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_exadata_infrastructures",
                                ));
                            }
                            result.cloud_exadata_infrastructures = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudExadataInfrastructure>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudExadataInfrastructuresResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_exadata_infrastructures.is_empty() {
            state.serialize_entry(
                "cloudExadataInfrastructures",
                &self.cloud_exadata_infrastructures,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudExadataInfrastructuresResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudExadataInfrastructuresResponse");
        debug_struct.field(
            "cloud_exadata_infrastructures",
            &self.cloud_exadata_infrastructures,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudExadataInfrastructure.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudExadataInfrastructureRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCloudExadataInfrastructureRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloudExadataInfrastructureRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCloudExadataInfrastructureRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloudExadataInfrastructureRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCloudExadataInfrastructureRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCloudExadataInfrastructureRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCloudExadataInfrastructureRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudExadataInfrastructure.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCloudExadataInfrastructureRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the Exadata Infrastructure to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    pub cloud_exadata_infrastructure_id: std::string::String,

    /// Required. Details of the Exadata Infrastructure instance to create.
    pub cloud_exadata_infrastructure: std::option::Option<crate::model::CloudExadataInfrastructure>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudExadataInfrastructureRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure_id][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure_id].
    pub fn set_cloud_exadata_infrastructure_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_exadata_infrastructure_id = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure].
    pub fn set_cloud_exadata_infrastructure<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        self.cloud_exadata_infrastructure = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_exadata_infrastructure][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure].
    pub fn set_or_clear_cloud_exadata_infrastructure<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        self.cloud_exadata_infrastructure = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudExadataInfrastructureRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCloudExadataInfrastructureRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cloud_exadata_infrastructure_id,
            __cloud_exadata_infrastructure,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for CreateCloudExadataInfrastructureRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cloudExadataInfrastructureId" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure_id)
                            }
                            "cloud_exadata_infrastructure_id" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure_id)
                            }
                            "cloudExadataInfrastructure" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure)
                            }
                            "cloud_exadata_infrastructure" => {
                                Ok(__FieldTag::__cloud_exadata_infrastructure)
                            }
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCloudExadataInfrastructureRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCloudExadataInfrastructureRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_exadata_infrastructure_id => {
                            if !fields.insert(__FieldTag::__cloud_exadata_infrastructure_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_exadata_infrastructure_id",
                                ));
                            }
                            result.cloud_exadata_infrastructure_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_exadata_infrastructure => {
                            if !fields.insert(__FieldTag::__cloud_exadata_infrastructure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_exadata_infrastructure",
                                ));
                            }
                            result.cloud_exadata_infrastructure = map.next_value::<std::option::Option<crate::model::CloudExadataInfrastructure>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCloudExadataInfrastructureRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cloud_exadata_infrastructure_id.is_empty() {
            state.serialize_entry(
                "cloudExadataInfrastructureId",
                &self.cloud_exadata_infrastructure_id,
            )?;
        }
        if self.cloud_exadata_infrastructure.is_some() {
            state.serialize_entry(
                "cloudExadataInfrastructure",
                &self.cloud_exadata_infrastructure,
            )?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCloudExadataInfrastructureRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCloudExadataInfrastructureRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field(
            "cloud_exadata_infrastructure_id",
            &self.cloud_exadata_infrastructure_id,
        );
        debug_struct.field(
            "cloud_exadata_infrastructure",
            &self.cloud_exadata_infrastructure,
        );
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudExadataInfrastructure.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, all VM clusters for this Exadata Infrastructure
    /// will be deleted. An Exadata Infrastructure can only be deleted once all its
    /// VM clusters have been deleted.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudExadataInfrastructureRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudExadataInfrastructureRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCloudExadataInfrastructureRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DeleteCloudExadataInfrastructureRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCloudExadataInfrastructureRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCloudExadataInfrastructureRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCloudExadataInfrastructureRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteCloudExadataInfrastructureRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCloudExadataInfrastructureRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudVmCluster.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudVmClustersRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The number of VM clusters to return.
    /// If unspecified, at most 50 VM clusters will be returned.
    /// The maximum value is 1,000.
    pub page_size: i32,

    /// Optional. A token identifying the page of results the server returns.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudVmClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudVmClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudVmClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudVmClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloudVmClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudVmClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudVmClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudVmClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudVmClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudVmClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudVmClustersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudVmClustersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `CloudVmCluster.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudVmClustersResponse {
    /// The list of VM Clusters.
    pub cloud_vm_clusters: std::vec::Vec<crate::model::CloudVmCluster>,

    /// A token to fetch the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudVmClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_vm_clusters][crate::model::ListCloudVmClustersResponse::cloud_vm_clusters].
    pub fn set_cloud_vm_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudVmCluster>,
    {
        use std::iter::Iterator;
        self.cloud_vm_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudVmClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudVmClustersResponse {
    type PageItem = crate::model::CloudVmCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_vm_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudVmClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_vm_clusters,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudVmClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudVmClusters" => Ok(__FieldTag::__cloud_vm_clusters),
                            "cloud_vm_clusters" => Ok(__FieldTag::__cloud_vm_clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudVmClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudVmClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_vm_clusters => {
                            if !fields.insert(__FieldTag::__cloud_vm_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_vm_clusters",
                                ));
                            }
                            result.cloud_vm_clusters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudVmCluster>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudVmClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_vm_clusters.is_empty() {
            state.serialize_entry("cloudVmClusters", &self.cloud_vm_clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudVmClustersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudVmClustersResponse");
        debug_struct.field("cloud_vm_clusters", &self.cloud_vm_clusters);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudVmCluster.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudVmClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCloudVmClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloudVmClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCloudVmClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloudVmClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCloudVmClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCloudVmClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCloudVmClusterRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudVmCluster.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCloudVmClusterRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the VM Cluster to create. This value is restricted
    /// to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    pub cloud_vm_cluster_id: std::string::String,

    /// Required. The resource being created
    pub cloud_vm_cluster: std::option::Option<crate::model::CloudVmCluster>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudVmClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster_id][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster_id].
    pub fn set_cloud_vm_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_vm_cluster_id = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster].
    pub fn set_cloud_vm_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmCluster>,
    {
        self.cloud_vm_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_vm_cluster][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster].
    pub fn set_or_clear_cloud_vm_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmCluster>,
    {
        self.cloud_vm_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudVmClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCloudVmClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cloud_vm_cluster_id,
            __cloud_vm_cluster,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCloudVmClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cloudVmClusterId" => Ok(__FieldTag::__cloud_vm_cluster_id),
                            "cloud_vm_cluster_id" => Ok(__FieldTag::__cloud_vm_cluster_id),
                            "cloudVmCluster" => Ok(__FieldTag::__cloud_vm_cluster),
                            "cloud_vm_cluster" => Ok(__FieldTag::__cloud_vm_cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCloudVmClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCloudVmClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_vm_cluster_id => {
                            if !fields.insert(__FieldTag::__cloud_vm_cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_vm_cluster_id",
                                ));
                            }
                            result.cloud_vm_cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_vm_cluster => {
                            if !fields.insert(__FieldTag::__cloud_vm_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_vm_cluster",
                                ));
                            }
                            result.cloud_vm_cluster = map
                                .next_value::<std::option::Option<crate::model::CloudVmCluster>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCloudVmClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cloud_vm_cluster_id.is_empty() {
            state.serialize_entry("cloudVmClusterId", &self.cloud_vm_cluster_id)?;
        }
        if self.cloud_vm_cluster.is_some() {
            state.serialize_entry("cloudVmCluster", &self.cloud_vm_cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCloudVmClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCloudVmClusterRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("cloud_vm_cluster_id", &self.cloud_vm_cluster_id);
        debug_struct.field("cloud_vm_cluster", &self.cloud_vm_cluster);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `CloudVmCluster.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, all child resources for the VM Cluster will be
    /// deleted. A VM Cluster can only be deleted once all its child resources have
    /// been deleted.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudVmClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudVmClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCloudVmClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCloudVmClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCloudVmClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCloudVmClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCloudVmClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteCloudVmClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCloudVmClusterRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `Entitlement.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitlementsRequest {
    /// Required. The parent value for the entitlement in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 entitlements will be returned.
    /// The maximum value is 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntitlementsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitlementsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntitlementsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitlementsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntitlementsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEntitlementsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEntitlementsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `Entitlement.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitlementsResponse {
    /// The list of Entitlements
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitlements][crate::model::ListEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntitlementsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entitlements,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitlementsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entitlements" => Ok(__FieldTag::__entitlements),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntitlementsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitlementsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entitlements => {
                            if !fields.insert(__FieldTag::__entitlements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlements",
                                ));
                            }
                            result.entitlements = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entitlement>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntitlementsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entitlements.is_empty() {
            state.serialize_entry("entitlements", &self.entitlements)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEntitlementsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEntitlementsResponse");
        debug_struct.field("entitlements", &self.entitlements);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `DbServer.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbServersRequest {
    /// Required. The parent value for database server in the following format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloudExadataInfrastructure}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 db servers will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbServersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbServersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbServersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDbServersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbServersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDbServersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbServersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDbServersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDbServersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDbServersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `DbServer.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbServersResponse {
    /// The list of database servers.
    pub db_servers: std::vec::Vec<crate::model::DbServer>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_servers][crate::model::ListDbServersResponse::db_servers].
    pub fn set_db_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbServer>,
    {
        use std::iter::Iterator;
        self.db_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbServersResponse {
    type PageItem = crate::model::DbServer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_servers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDbServersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __db_servers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbServersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dbServers" => Ok(__FieldTag::__db_servers),
                            "db_servers" => Ok(__FieldTag::__db_servers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDbServersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbServersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__db_servers => {
                            if !fields.insert(__FieldTag::__db_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_servers",
                                ));
                            }
                            result.db_servers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DbServer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDbServersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.db_servers.is_empty() {
            state.serialize_entry("dbServers", &self.db_servers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDbServersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDbServersResponse");
        debug_struct.field("db_servers", &self.db_servers);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `DbNode.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbNodesRequest {
    /// Required. The parent value for database node in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloudVmCluster}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 db nodes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the node should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbNodesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbNodesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbNodesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbNodesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbNodesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDbNodesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbNodesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDbNodesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbNodesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDbNodesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDbNodesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDbNodesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `DbNode.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbNodesResponse {
    /// The list of DB Nodes
    pub db_nodes: std::vec::Vec<crate::model::DbNode>,

    /// A token identifying a page of results the node should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbNodesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_nodes][crate::model::ListDbNodesResponse::db_nodes].
    pub fn set_db_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbNode>,
    {
        use std::iter::Iterator;
        self.db_nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbNodesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbNodesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbNodesResponse {
    type PageItem = crate::model::DbNode;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_nodes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDbNodesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __db_nodes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbNodesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dbNodes" => Ok(__FieldTag::__db_nodes),
                            "db_nodes" => Ok(__FieldTag::__db_nodes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDbNodesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbNodesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__db_nodes => {
                            if !fields.insert(__FieldTag::__db_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_nodes",
                                ));
                            }
                            result.db_nodes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DbNode>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDbNodesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.db_nodes.is_empty() {
            state.serialize_entry("dbNodes", &self.db_nodes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDbNodesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDbNodesResponse");
        debug_struct.field("db_nodes", &self.db_nodes);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `GiVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGiVersionsRequest {
    /// Required. The parent value for Grid Infrastructure Version in the following
    /// format: Format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Oracle Grid Infrastructure (GI) versions
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGiVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGiVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGiVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGiVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGiVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGiVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGiVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGiVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGiVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGiVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGiVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGiVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `GiVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGiVersionsResponse {
    /// The list of Oracle Grid Infrastructure (GI) versions.
    pub gi_versions: std::vec::Vec<crate::model::GiVersion>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGiVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gi_versions][crate::model::ListGiVersionsResponse::gi_versions].
    pub fn set_gi_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GiVersion>,
    {
        use std::iter::Iterator;
        self.gi_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGiVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGiVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGiVersionsResponse {
    type PageItem = crate::model::GiVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.gi_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGiVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gi_versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGiVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "giVersions" => Ok(__FieldTag::__gi_versions),
                            "gi_versions" => Ok(__FieldTag::__gi_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGiVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGiVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gi_versions => {
                            if !fields.insert(__FieldTag::__gi_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gi_versions",
                                ));
                            }
                            result.gi_versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GiVersion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGiVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gi_versions.is_empty() {
            state.serialize_entry("giVersions", &self.gi_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGiVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGiVersionsResponse");
        debug_struct.field("gi_versions", &self.gi_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `DbSystemShape.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemShapesRequest {
    /// Required. The parent value for Database System Shapes in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 database system shapes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemShapesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbSystemShapesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbSystemShapesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbSystemShapesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDbSystemShapesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbSystemShapesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDbSystemShapesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbSystemShapesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDbSystemShapesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDbSystemShapesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDbSystemShapesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `DbSystemShape.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemShapesResponse {
    /// The list of Database System shapes.
    pub db_system_shapes: std::vec::Vec<crate::model::DbSystemShape>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemShapesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_system_shapes][crate::model::ListDbSystemShapesResponse::db_system_shapes].
    pub fn set_db_system_shapes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbSystemShape>,
    {
        use std::iter::Iterator;
        self.db_system_shapes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbSystemShapesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbSystemShapesResponse {
    type PageItem = crate::model::DbSystemShape;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_system_shapes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDbSystemShapesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __db_system_shapes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDbSystemShapesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dbSystemShapes" => Ok(__FieldTag::__db_system_shapes),
                            "db_system_shapes" => Ok(__FieldTag::__db_system_shapes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDbSystemShapesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDbSystemShapesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__db_system_shapes => {
                            if !fields.insert(__FieldTag::__db_system_shapes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_system_shapes",
                                ));
                            }
                            result.db_system_shapes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DbSystemShape>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDbSystemShapesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.db_system_shapes.is_empty() {
            state.serialize_entry("dbSystemShapes", &self.db_system_shapes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDbSystemShapesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDbSystemShapesResponse");
        debug_struct.field("db_system_shapes", &self.db_system_shapes);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. The status of the operation.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    /// Output only. An estimated percentage of the operation that has been
    /// completed at a given moment of time, between 0 and 100.
    pub percent_complete: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [percent_complete][crate::model::OperationMetadata::percent_complete].
    pub fn set_percent_complete<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.percent_complete = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            __percent_complete,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "percentComplete" => Ok(__FieldTag::__percent_complete),
                            "percent_complete" => Ok(__FieldTag::__percent_complete),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__percent_complete => {
                            if !fields.insert(__FieldTag::__percent_complete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent_complete",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent_complete =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !wkt::internal::is_default(&self.percent_complete) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("percentComplete", &__With(&self.percent_complete))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        debug_struct.field("percent_complete", &self.percent_complete);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabasesRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous Database will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutonomousDatabasesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDatabasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDatabasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDatabasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDatabasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDatabasesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDatabasesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `AutonomousDatabase.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabasesResponse {
    /// The list of Autonomous Databases.
    pub autonomous_databases: std::vec::Vec<crate::model::AutonomousDatabase>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_databases][crate::model::ListAutonomousDatabasesResponse::autonomous_databases].
    pub fn set_autonomous_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        use std::iter::Iterator;
        self.autonomous_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabasesResponse {
    type PageItem = crate::model::AutonomousDatabase;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDatabasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_databases,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDatabasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDatabases" => Ok(__FieldTag::__autonomous_databases),
                            "autonomous_databases" => Ok(__FieldTag::__autonomous_databases),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDatabasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_databases => {
                            if !fields.insert(__FieldTag::__autonomous_databases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_databases",
                                ));
                            }
                            result.autonomous_databases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDatabase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDatabasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.autonomous_databases.is_empty() {
            state.serialize_entry("autonomousDatabases", &self.autonomous_databases)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDatabasesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDatabasesResponse");
        debug_struct.field("autonomous_databases", &self.autonomous_databases);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetAutonomousDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAutonomousDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAutonomousDatabaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAutonomousDatabaseRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAutonomousDatabaseRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the Autonomous Database to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    pub autonomous_database_id: std::string::String,

    /// Required. The Autonomous Database being created.
    pub autonomous_database: std::option::Option<crate::model::AutonomousDatabase>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutonomousDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [autonomous_database_id][crate::model::CreateAutonomousDatabaseRequest::autonomous_database_id].
    pub fn set_autonomous_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database_id = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::CreateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_autonomous_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autonomous_database][crate::model::CreateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_or_clear_autonomous_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateAutonomousDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __autonomous_database_id,
            __autonomous_database,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "autonomousDatabaseId" => Ok(__FieldTag::__autonomous_database_id),
                            "autonomous_database_id" => Ok(__FieldTag::__autonomous_database_id),
                            "autonomousDatabase" => Ok(__FieldTag::__autonomous_database),
                            "autonomous_database" => Ok(__FieldTag::__autonomous_database),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_database_id => {
                            if !fields.insert(__FieldTag::__autonomous_database_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database_id",
                                ));
                            }
                            result.autonomous_database_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autonomous_database => {
                            if !fields.insert(__FieldTag::__autonomous_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database",
                                ));
                            }
                            result.autonomous_database = map.next_value::<std::option::Option<crate::model::AutonomousDatabase>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAutonomousDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.autonomous_database_id.is_empty() {
            state.serialize_entry("autonomousDatabaseId", &self.autonomous_database_id)?;
        }
        if self.autonomous_database.is_some() {
            state.serialize_entry("autonomousDatabase", &self.autonomous_database)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAutonomousDatabaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAutonomousDatabaseRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("autonomous_database_id", &self.autonomous_database_id);
        debug_struct.field("autonomous_database", &self.autonomous_database);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAutonomousDatabaseRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteAutonomousDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAutonomousDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAutonomousDatabaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAutonomousDatabaseRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.Restore`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Required. The time and date to restore the database to.
    pub restore_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [restore_time][crate::model::RestoreAutonomousDatabaseRequest::restore_time].
    pub fn set_restore_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.restore_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_time][crate::model::RestoreAutonomousDatabaseRequest::restore_time].
    pub fn set_or_clear_restore_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.restore_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RestoreAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RestoreAutonomousDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __restore_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "restoreTime" => Ok(__FieldTag::__restore_time),
                            "restore_time" => Ok(__FieldTag::__restore_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_time => {
                            if !fields.insert(__FieldTag::__restore_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_time",
                                ));
                            }
                            result.restore_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreAutonomousDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.restore_time.is_some() {
            state.serialize_entry("restoreTime", &self.restore_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RestoreAutonomousDatabaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreAutonomousDatabaseRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("restore_time", &self.restore_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.Stop`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.StopAutonomousDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopAutonomousDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StopAutonomousDatabaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopAutonomousDatabaseRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.Start`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.StartAutonomousDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartAutonomousDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartAutonomousDatabaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartAutonomousDatabaseRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.Restart`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RestartAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RestartAutonomousDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestartAutonomousDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestartAutonomousDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestartAutonomousDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestartAutonomousDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestartAutonomousDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RestartAutonomousDatabaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestartAutonomousDatabaseRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Optional. The type of wallet generation for the Autonomous Database. The
    /// default value is SINGLE.
    pub r#type: crate::model::GenerateType,

    /// Optional. True when requesting regional connection strings in PDB connect
    /// info, applicable to cross-region Data Guard only.
    pub is_regional: bool,

    /// Required. The password used to encrypt the keys inside the wallet. The
    /// password must be a minimum of 8 characters.
    pub password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAutonomousDatabaseWalletRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateAutonomousDatabaseWalletRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::GenerateAutonomousDatabaseWalletRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::GenerateType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::GenerateAutonomousDatabaseWalletRequest::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [password][crate::model::GenerateAutonomousDatabaseWalletRequest::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAutonomousDatabaseWalletRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __is_regional,
            __password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAutonomousDatabaseWalletRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "isRegional" => Ok(__FieldTag::__is_regional),
                            "is_regional" => Ok(__FieldTag::__is_regional),
                            "password" => Ok(__FieldTag::__password),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAutonomousDatabaseWalletRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAutonomousDatabaseWalletRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::GenerateType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_regional => {
                            if !fields.insert(__FieldTag::__is_regional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_regional",
                                ));
                            }
                            result.is_regional = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAutonomousDatabaseWalletRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.is_regional) {
            state.serialize_entry("isRegional", &self.is_regional)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateAutonomousDatabaseWalletRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateAutonomousDatabaseWalletRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("is_regional", &self.is_regional);
        debug_struct.field("password", &self.password);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletResponse {
    /// Output only. The base64 encoded wallet files.
    pub archive_content: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAutonomousDatabaseWalletResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [archive_content][crate::model::GenerateAutonomousDatabaseWalletResponse::archive_content].
    pub fn set_archive_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.archive_content = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAutonomousDatabaseWalletResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __archive_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAutonomousDatabaseWalletResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "archiveContent" => Ok(__FieldTag::__archive_content),
                            "archive_content" => Ok(__FieldTag::__archive_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAutonomousDatabaseWalletResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAutonomousDatabaseWalletResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__archive_content => {
                            if !fields.insert(__FieldTag::__archive_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.archive_content =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAutonomousDatabaseWalletResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.archive_content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("archiveContent", &__With(&self.archive_content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateAutonomousDatabaseWalletResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateAutonomousDatabaseWalletResponse");
        debug_struct.field("archive_content", &self.archive_content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDbVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDbVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDbVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDbVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDbVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDbVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDbVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDbVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDbVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDbVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDbVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDbVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `AutonomousDbVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsResponse {
    /// The list of Autonomous Database versions.
    pub autonomous_db_versions: std::vec::Vec<crate::model::AutonomousDbVersion>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDbVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_db_versions][crate::model::ListAutonomousDbVersionsResponse::autonomous_db_versions].
    pub fn set_autonomous_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDbVersion>,
    {
        use std::iter::Iterator;
        self.autonomous_db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDbVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDbVersionsResponse {
    type PageItem = crate::model::AutonomousDbVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_db_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDbVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_db_versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDbVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDbVersions" => Ok(__FieldTag::__autonomous_db_versions),
                            "autonomous_db_versions" => Ok(__FieldTag::__autonomous_db_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDbVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDbVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_db_versions => {
                            if !fields.insert(__FieldTag::__autonomous_db_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_db_versions",
                                ));
                            }
                            result.autonomous_db_versions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDbVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDbVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.autonomous_db_versions.is_empty() {
            state.serialize_entry("autonomousDbVersions", &self.autonomous_db_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDbVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDbVersionsResponse");
        debug_struct.field("autonomous_db_versions", &self.autonomous_db_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Character Sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseCharacterSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseCharacterSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseCharacterSetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDatabaseCharacterSetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ListAutonomousDatabaseCharacterSetsRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDatabaseCharacterSetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseCharacterSetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDatabaseCharacterSetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDatabaseCharacterSetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDatabaseCharacterSetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsResponse {
    /// The list of Autonomous Database Character Sets.
    pub autonomous_database_character_sets:
        std::vec::Vec<crate::model::AutonomousDatabaseCharacterSet>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseCharacterSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_database_character_sets][crate::model::ListAutonomousDatabaseCharacterSetsResponse::autonomous_database_character_sets].
    pub fn set_autonomous_database_character_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseCharacterSet>,
    {
        use std::iter::Iterator;
        self.autonomous_database_character_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseCharacterSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabaseCharacterSetsResponse {
    type PageItem = crate::model::AutonomousDatabaseCharacterSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_character_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDatabaseCharacterSetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_database_character_sets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ListAutonomousDatabaseCharacterSetsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDatabaseCharacterSets" => {
                                Ok(__FieldTag::__autonomous_database_character_sets)
                            }
                            "autonomous_database_character_sets" => {
                                Ok(__FieldTag::__autonomous_database_character_sets)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDatabaseCharacterSetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseCharacterSetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_database_character_sets => {
                            if !fields.insert(__FieldTag::__autonomous_database_character_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database_character_sets",
                                ));
                            }
                            result.autonomous_database_character_sets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDatabaseCharacterSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDatabaseCharacterSetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.autonomous_database_character_sets.is_empty() {
            state.serialize_entry(
                "autonomousDatabaseCharacterSets",
                &self.autonomous_database_character_sets,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDatabaseCharacterSetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDatabaseCharacterSetsResponse");
        debug_struct.field(
            "autonomous_database_character_sets",
            &self.autonomous_database_character_sets,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for `AutonomousDatabaseBackup.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsRequest {
    /// Required. The parent value for ListAutonomousDatabaseBackups in the
    /// following format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **autonomous_database_id** field is supported in the following format:
    /// `autonomous_database_id="{autonomous_database_id}"`. The accepted values
    /// must be a valid Autonomous Database ID, limited to the naming
    /// restrictions of the ID: ^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    /// The ID must start with a letter, end with a letter or a number, and be
    /// a maximum of 63 characters.
    pub filter: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Backups will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDatabaseBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutonomousDatabaseBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDatabaseBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDatabaseBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDatabaseBackupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDatabaseBackupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for `AutonomousDatabaseBackup.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsResponse {
    /// The list of Autonomous Database Backups.
    pub autonomous_database_backups: std::vec::Vec<crate::model::AutonomousDatabaseBackup>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_database_backups][crate::model::ListAutonomousDatabaseBackupsResponse::autonomous_database_backups].
    pub fn set_autonomous_database_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseBackup>,
    {
        use std::iter::Iterator;
        self.autonomous_database_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabaseBackupsResponse {
    type PageItem = crate::model::AutonomousDatabaseBackup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutonomousDatabaseBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autonomous_database_backups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListAutonomousDatabaseBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autonomousDatabaseBackups" => {
                                Ok(__FieldTag::__autonomous_database_backups)
                            }
                            "autonomous_database_backups" => {
                                Ok(__FieldTag::__autonomous_database_backups)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutonomousDatabaseBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutonomousDatabaseBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autonomous_database_backups => {
                            if !fields.insert(__FieldTag::__autonomous_database_backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autonomous_database_backups",
                                ));
                            }
                            result.autonomous_database_backups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutonomousDatabaseBackup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutonomousDatabaseBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.autonomous_database_backups.is_empty() {
            state.serialize_entry(
                "autonomousDatabaseBackups",
                &self.autonomous_database_backups,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutonomousDatabaseBackupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutonomousDatabaseBackupsResponse");
        debug_struct.field(
            "autonomous_database_backups",
            &self.autonomous_database_backups,
        );
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of the Cloud VM Cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudVmCluster/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudVmCluster {
    /// Identifier. The name of the VM Cluster resource with the format:
    /// projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}
    pub name: std::string::String,

    /// Required. The name of the Exadata Infrastructure resource on which VM
    /// cluster resource is created, in the following format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}
    pub exadata_infrastructure: std::string::String,

    /// Optional. User friendly name for this resource.
    pub display_name: std::string::String,

    /// Output only. Google Cloud Platform location where Oracle Exadata is hosted.
    /// It is same as Google Cloud Platform Oracle zone of Exadata infrastructure.
    pub gcp_oracle_zone: std::string::String,

    /// Optional. Various properties of the VM Cluster.
    pub properties: std::option::Option<crate::model::CloudVmClusterProperties>,

    /// Optional. Labels or tags associated with the VM Cluster.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the VM cluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Network settings. CIDR to use for cluster IP allocation.
    pub cidr: std::string::String,

    /// Required. CIDR range of the backup subnet.
    pub backup_subnet_cidr: std::string::String,

    /// Required. The name of the VPC network.
    /// Format: projects/{project}/global/networks/{network}
    pub network: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudVmCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudVmCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [exadata_infrastructure][crate::model::CloudVmCluster::exadata_infrastructure].
    pub fn set_exadata_infrastructure<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exadata_infrastructure = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudVmCluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudVmCluster::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudVmCluster::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmClusterProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::CloudVmCluster::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmClusterProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CloudVmCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudVmCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudVmCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cidr][crate::model::CloudVmCluster::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [backup_subnet_cidr][crate::model::CloudVmCluster::backup_subnet_cidr].
    pub fn set_backup_subnet_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_subnet_cidr = v.into();
        self
    }

    /// Sets the value of [network][crate::model::CloudVmCluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

impl wkt::message::Message for CloudVmCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudVmCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __exadata_infrastructure,
            __display_name,
            __gcp_oracle_zone,
            __properties,
            __labels,
            __create_time,
            __cidr,
            __backup_subnet_cidr,
            __network,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudVmCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "exadataInfrastructure" => Ok(__FieldTag::__exadata_infrastructure),
                            "exadata_infrastructure" => Ok(__FieldTag::__exadata_infrastructure),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "gcpOracleZone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "gcp_oracle_zone" => Ok(__FieldTag::__gcp_oracle_zone),
                            "properties" => Ok(__FieldTag::__properties),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "cidr" => Ok(__FieldTag::__cidr),
                            "backupSubnetCidr" => Ok(__FieldTag::__backup_subnet_cidr),
                            "backup_subnet_cidr" => Ok(__FieldTag::__backup_subnet_cidr),
                            "network" => Ok(__FieldTag::__network),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudVmCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudVmCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exadata_infrastructure => {
                            if !fields.insert(__FieldTag::__exadata_infrastructure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exadata_infrastructure",
                                ));
                            }
                            result.exadata_infrastructure = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_oracle_zone => {
                            if !fields.insert(__FieldTag::__gcp_oracle_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_oracle_zone",
                                ));
                            }
                            result.gcp_oracle_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<crate::model::CloudVmClusterProperties>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cidr => {
                            if !fields.insert(__FieldTag::__cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr",
                                ));
                            }
                            result.cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_subnet_cidr => {
                            if !fields.insert(__FieldTag::__backup_subnet_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_subnet_cidr",
                                ));
                            }
                            result.backup_subnet_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudVmCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.exadata_infrastructure.is_empty() {
            state.serialize_entry("exadataInfrastructure", &self.exadata_infrastructure)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.gcp_oracle_zone.is_empty() {
            state.serialize_entry("gcpOracleZone", &self.gcp_oracle_zone)?;
        }
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.cidr.is_empty() {
            state.serialize_entry("cidr", &self.cidr)?;
        }
        if !self.backup_subnet_cidr.is_empty() {
            state.serialize_entry("backupSubnetCidr", &self.backup_subnet_cidr)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudVmCluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudVmCluster");
        debug_struct.field("name", &self.name);
        debug_struct.field("exadata_infrastructure", &self.exadata_infrastructure);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("gcp_oracle_zone", &self.gcp_oracle_zone);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("cidr", &self.cidr);
        debug_struct.field("backup_subnet_cidr", &self.backup_subnet_cidr);
        debug_struct.field("network", &self.network);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Various properties and settings associated with Exadata VM cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudVmClusterProperties {
    /// Output only. Oracle Cloud Infrastructure ID of VM Cluster.
    pub ocid: std::string::String,

    /// Required. License type of VM Cluster.
    pub license_type: crate::model::cloud_vm_cluster_properties::LicenseType,

    /// Optional. Grid Infrastructure Version.
    pub gi_version: std::string::String,

    /// Optional. Time zone of VM Cluster to set. Defaults to UTC if not specified.
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Optional. SSH public keys to be stored with cluster.
    pub ssh_public_keys: std::vec::Vec<std::string::String>,

    /// Optional. Number of database servers.
    pub node_count: i32,

    /// Output only. Shape of VM Cluster.
    pub shape: std::string::String,

    /// Optional. OCPU count per VM. Minimum is 0.1.
    pub ocpu_count: f32,

    /// Optional. Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Local storage per VM.
    pub db_node_storage_size_gb: i32,

    /// Output only. The storage allocation for the disk group, in gigabytes (GB).
    pub storage_size_gb: i32,

    /// Optional. The data disk group size to be allocated in TBs.
    pub data_storage_size_tb: f64,

    /// Optional. The type of redundancy.
    pub disk_redundancy: crate::model::cloud_vm_cluster_properties::DiskRedundancy,

    /// Optional. Use exadata sparse snapshots.
    pub sparse_diskgroup_enabled: bool,

    /// Optional. Use local backup.
    pub local_backup_enabled: bool,

    /// Optional. Prefix for VM cluster host names.
    pub hostname_prefix: std::string::String,

    /// Optional. Data collection options for diagnostics.
    pub diagnostics_data_collection_options:
        std::option::Option<crate::model::DataCollectionOptions>,

    /// Output only. State of the cluster.
    pub state: crate::model::cloud_vm_cluster_properties::State,

    /// Output only. SCAN listener port - TCP
    pub scan_listener_port_tcp: i32,

    /// Output only. SCAN listener port - TLS
    pub scan_listener_port_tcp_ssl: i32,

    /// Output only. Parent DNS domain where SCAN DNS and hosts names are
    /// qualified. ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
    pub domain: std::string::String,

    /// Output only. SCAN DNS name.
    /// ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
    pub scan_dns: std::string::String,

    /// Output only. host name without domain.
    /// format: "<hostname_prefix>-" with some suffix.
    /// ex: sp2-yi0xq where "sp2" is the hostname_prefix.
    pub hostname: std::string::String,

    /// Required. Number of enabled CPU cores.
    pub cpu_core_count: i32,

    /// Optional. Operating system version of the image.
    pub system_version: std::string::String,

    /// Output only. OCIDs of scan IPs.
    pub scan_ip_ids: std::vec::Vec<std::string::String>,

    /// Output only. OCID of scan DNS record.
    pub scan_dns_record_id: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    pub oci_url: std::string::String,

    /// Optional. OCID of database servers.
    pub db_server_ocids: std::vec::Vec<std::string::String>,

    /// Output only. Compartment ID of cluster.
    pub compartment_id: std::string::String,

    /// Output only. DNS listener IP.
    pub dns_listener_ip: std::string::String,

    /// Optional. OCI Cluster name.
    pub cluster_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudVmClusterProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudVmClusterProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::CloudVmClusterProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [gi_version][crate::model::CloudVmClusterProperties::gi_version].
    pub fn set_gi_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gi_version = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::CloudVmClusterProperties::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::CloudVmClusterProperties::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssh_public_keys][crate::model::CloudVmClusterProperties::ssh_public_keys].
    pub fn set_ssh_public_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_public_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_count][crate::model::CloudVmClusterProperties::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudVmClusterProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::CloudVmClusterProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudVmClusterProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudVmClusterProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [storage_size_gb][crate::model::CloudVmClusterProperties::storage_size_gb].
    pub fn set_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudVmClusterProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [disk_redundancy][crate::model::CloudVmClusterProperties::disk_redundancy].
    pub fn set_disk_redundancy<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::DiskRedundancy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_redundancy = v.into();
        self
    }

    /// Sets the value of [sparse_diskgroup_enabled][crate::model::CloudVmClusterProperties::sparse_diskgroup_enabled].
    pub fn set_sparse_diskgroup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.sparse_diskgroup_enabled = v.into();
        self
    }

    /// Sets the value of [local_backup_enabled][crate::model::CloudVmClusterProperties::local_backup_enabled].
    pub fn set_local_backup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.local_backup_enabled = v.into();
        self
    }

    /// Sets the value of [hostname_prefix][crate::model::CloudVmClusterProperties::hostname_prefix].
    pub fn set_hostname_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname_prefix = v.into();
        self
    }

    /// Sets the value of [diagnostics_data_collection_options][crate::model::CloudVmClusterProperties::diagnostics_data_collection_options].
    pub fn set_diagnostics_data_collection_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptions>,
    {
        self.diagnostics_data_collection_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diagnostics_data_collection_options][crate::model::CloudVmClusterProperties::diagnostics_data_collection_options].
    pub fn set_or_clear_diagnostics_data_collection_options<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptions>,
    {
        self.diagnostics_data_collection_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CloudVmClusterProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::cloud_vm_cluster_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp][crate::model::CloudVmClusterProperties::scan_listener_port_tcp].
    pub fn set_scan_listener_port_tcp<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp_ssl][crate::model::CloudVmClusterProperties::scan_listener_port_tcp_ssl].
    pub fn set_scan_listener_port_tcp_ssl<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp_ssl = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::CloudVmClusterProperties::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [scan_dns][crate::model::CloudVmClusterProperties::scan_dns].
    pub fn set_scan_dns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scan_dns = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::CloudVmClusterProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::CloudVmClusterProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [system_version][crate::model::CloudVmClusterProperties::system_version].
    pub fn set_system_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system_version = v.into();
        self
    }

    /// Sets the value of [scan_ip_ids][crate::model::CloudVmClusterProperties::scan_ip_ids].
    pub fn set_scan_ip_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scan_ip_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scan_dns_record_id][crate::model::CloudVmClusterProperties::scan_dns_record_id].
    pub fn set_scan_dns_record_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_dns_record_id = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudVmClusterProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [db_server_ocids][crate::model::CloudVmClusterProperties::db_server_ocids].
    pub fn set_db_server_ocids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_server_ocids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [compartment_id][crate::model::CloudVmClusterProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [dns_listener_ip][crate::model::CloudVmClusterProperties::dns_listener_ip].
    pub fn set_dns_listener_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_listener_ip = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::CloudVmClusterProperties::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }
}

impl wkt::message::Message for CloudVmClusterProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmClusterProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudVmClusterProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ocid,
            __license_type,
            __gi_version,
            __time_zone,
            __ssh_public_keys,
            __node_count,
            __shape,
            __ocpu_count,
            __memory_size_gb,
            __db_node_storage_size_gb,
            __storage_size_gb,
            __data_storage_size_tb,
            __disk_redundancy,
            __sparse_diskgroup_enabled,
            __local_backup_enabled,
            __hostname_prefix,
            __diagnostics_data_collection_options,
            __state,
            __scan_listener_port_tcp,
            __scan_listener_port_tcp_ssl,
            __domain,
            __scan_dns,
            __hostname,
            __cpu_core_count,
            __system_version,
            __scan_ip_ids,
            __scan_dns_record_id,
            __oci_url,
            __db_server_ocids,
            __compartment_id,
            __dns_listener_ip,
            __cluster_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudVmClusterProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ocid" => Ok(__FieldTag::__ocid),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "giVersion" => Ok(__FieldTag::__gi_version),
                            "gi_version" => Ok(__FieldTag::__gi_version),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "sshPublicKeys" => Ok(__FieldTag::__ssh_public_keys),
                            "ssh_public_keys" => Ok(__FieldTag::__ssh_public_keys),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "shape" => Ok(__FieldTag::__shape),
                            "ocpuCount" => Ok(__FieldTag::__ocpu_count),
                            "ocpu_count" => Ok(__FieldTag::__ocpu_count),
                            "memorySizeGb" => Ok(__FieldTag::__memory_size_gb),
                            "memory_size_gb" => Ok(__FieldTag::__memory_size_gb),
                            "dbNodeStorageSizeGb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "db_node_storage_size_gb" => Ok(__FieldTag::__db_node_storage_size_gb),
                            "storageSizeGb" => Ok(__FieldTag::__storage_size_gb),
                            "storage_size_gb" => Ok(__FieldTag::__storage_size_gb),
                            "dataStorageSizeTb" => Ok(__FieldTag::__data_storage_size_tb),
                            "data_storage_size_tb" => Ok(__FieldTag::__data_storage_size_tb),
                            "diskRedundancy" => Ok(__FieldTag::__disk_redundancy),
                            "disk_redundancy" => Ok(__FieldTag::__disk_redundancy),
                            "sparseDiskgroupEnabled" => Ok(__FieldTag::__sparse_diskgroup_enabled),
                            "sparse_diskgroup_enabled" => {
                                Ok(__FieldTag::__sparse_diskgroup_enabled)
                            }
                            "localBackupEnabled" => Ok(__FieldTag::__local_backup_enabled),
                            "local_backup_enabled" => Ok(__FieldTag::__local_backup_enabled),
                            "hostnamePrefix" => Ok(__FieldTag::__hostname_prefix),
                            "hostname_prefix" => Ok(__FieldTag::__hostname_prefix),
                            "diagnosticsDataCollectionOptions" => {
                                Ok(__FieldTag::__diagnostics_data_collection_options)
                            }
                            "diagnostics_data_collection_options" => {
                                Ok(__FieldTag::__diagnostics_data_collection_options)
                            }
                            "state" => Ok(__FieldTag::__state),
                            "scanListenerPortTcp" => Ok(__FieldTag::__scan_listener_port_tcp),
                            "scan_listener_port_tcp" => Ok(__FieldTag::__scan_listener_port_tcp),
                            "scanListenerPortTcpSsl" => {
                                Ok(__FieldTag::__scan_listener_port_tcp_ssl)
                            }
                            "scan_listener_port_tcp_ssl" => {
                                Ok(__FieldTag::__scan_listener_port_tcp_ssl)
                            }
                            "domain" => Ok(__FieldTag::__domain),
                            "scanDns" => Ok(__FieldTag::__scan_dns),
                            "scan_dns" => Ok(__FieldTag::__scan_dns),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "cpuCoreCount" => Ok(__FieldTag::__cpu_core_count),
                            "cpu_core_count" => Ok(__FieldTag::__cpu_core_count),
                            "systemVersion" => Ok(__FieldTag::__system_version),
                            "system_version" => Ok(__FieldTag::__system_version),
                            "scanIpIds" => Ok(__FieldTag::__scan_ip_ids),
                            "scan_ip_ids" => Ok(__FieldTag::__scan_ip_ids),
                            "scanDnsRecordId" => Ok(__FieldTag::__scan_dns_record_id),
                            "scan_dns_record_id" => Ok(__FieldTag::__scan_dns_record_id),
                            "ociUrl" => Ok(__FieldTag::__oci_url),
                            "oci_url" => Ok(__FieldTag::__oci_url),
                            "dbServerOcids" => Ok(__FieldTag::__db_server_ocids),
                            "db_server_ocids" => Ok(__FieldTag::__db_server_ocids),
                            "compartmentId" => Ok(__FieldTag::__compartment_id),
                            "compartment_id" => Ok(__FieldTag::__compartment_id),
                            "dnsListenerIp" => Ok(__FieldTag::__dns_listener_ip),
                            "dns_listener_ip" => Ok(__FieldTag::__dns_listener_ip),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudVmClusterProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudVmClusterProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ocid => {
                            if !fields.insert(__FieldTag::__ocid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocid",
                                ));
                            }
                            result.ocid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_vm_cluster_properties::LicenseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gi_version => {
                            if !fields.insert(__FieldTag::__gi_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gi_version",
                                ));
                            }
                            result.gi_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone =
                                map.next_value::<std::option::Option<gtype::model::TimeZone>>()?;
                        }
                        __FieldTag::__ssh_public_keys => {
                            if !fields.insert(__FieldTag::__ssh_public_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_public_keys",
                                ));
                            }
                            result.ssh_public_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shape => {
                            if !fields.insert(__FieldTag::__shape) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shape",
                                ));
                            }
                            result.shape = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ocpu_count => {
                            if !fields.insert(__FieldTag::__ocpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocpu_count",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ocpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_size_gb => {
                            if !fields.insert(__FieldTag::__memory_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__db_node_storage_size_gb => {
                            if !fields.insert(__FieldTag::__db_node_storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_node_storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.db_node_storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_size_gb => {
                            if !fields.insert(__FieldTag::__storage_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_storage_size_tb => {
                            if !fields.insert(__FieldTag::__data_storage_size_tb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_size_tb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_storage_size_tb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_redundancy => {
                            if !fields.insert(__FieldTag::__disk_redundancy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_redundancy",
                                ));
                            }
                            result.disk_redundancy = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_vm_cluster_properties::DiskRedundancy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sparse_diskgroup_enabled => {
                            if !fields.insert(__FieldTag::__sparse_diskgroup_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sparse_diskgroup_enabled",
                                ));
                            }
                            result.sparse_diskgroup_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_backup_enabled => {
                            if !fields.insert(__FieldTag::__local_backup_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_backup_enabled",
                                ));
                            }
                            result.local_backup_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname_prefix => {
                            if !fields.insert(__FieldTag::__hostname_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname_prefix",
                                ));
                            }
                            result.hostname_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diagnostics_data_collection_options => {
                            if !fields.insert(__FieldTag::__diagnostics_data_collection_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostics_data_collection_options",
                                ));
                            }
                            result.diagnostics_data_collection_options = map.next_value::<std::option::Option<crate::model::DataCollectionOptions>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_vm_cluster_properties::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scan_listener_port_tcp => {
                            if !fields.insert(__FieldTag::__scan_listener_port_tcp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_listener_port_tcp",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scan_listener_port_tcp =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scan_listener_port_tcp_ssl => {
                            if !fields.insert(__FieldTag::__scan_listener_port_tcp_ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_listener_port_tcp_ssl",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scan_listener_port_tcp_ssl =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scan_dns => {
                            if !fields.insert(__FieldTag::__scan_dns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_dns",
                                ));
                            }
                            result.scan_dns = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_core_count => {
                            if !fields.insert(__FieldTag::__cpu_core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_core_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_core_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__system_version => {
                            if !fields.insert(__FieldTag::__system_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system_version",
                                ));
                            }
                            result.system_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scan_ip_ids => {
                            if !fields.insert(__FieldTag::__scan_ip_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_ip_ids",
                                ));
                            }
                            result.scan_ip_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scan_dns_record_id => {
                            if !fields.insert(__FieldTag::__scan_dns_record_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_dns_record_id",
                                ));
                            }
                            result.scan_dns_record_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oci_url => {
                            if !fields.insert(__FieldTag::__oci_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oci_url",
                                ));
                            }
                            result.oci_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_server_ocids => {
                            if !fields.insert(__FieldTag::__db_server_ocids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_server_ocids",
                                ));
                            }
                            result.db_server_ocids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compartment_id => {
                            if !fields.insert(__FieldTag::__compartment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compartment_id",
                                ));
                            }
                            result.compartment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dns_listener_ip => {
                            if !fields.insert(__FieldTag::__dns_listener_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_listener_ip",
                                ));
                            }
                            result.dns_listener_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudVmClusterProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ocid.is_empty() {
            state.serialize_entry("ocid", &self.ocid)?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if !self.gi_version.is_empty() {
            state.serialize_entry("giVersion", &self.gi_version)?;
        }
        if self.time_zone.is_some() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.ssh_public_keys.is_empty() {
            state.serialize_entry("sshPublicKeys", &self.ssh_public_keys)?;
        }
        if !wkt::internal::is_default(&self.node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(&self.node_count))?;
        }
        if !self.shape.is_empty() {
            state.serialize_entry("shape", &self.shape)?;
        }
        if !wkt::internal::is_default(&self.ocpu_count) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ocpuCount", &__With(&self.ocpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memorySizeGb", &__With(&self.memory_size_gb))?;
        }
        if !wkt::internal::is_default(&self.db_node_storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "dbNodeStorageSizeGb",
                &__With(&self.db_node_storage_size_gb),
            )?;
        }
        if !wkt::internal::is_default(&self.storage_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("storageSizeGb", &__With(&self.storage_size_gb))?;
        }
        if !wkt::internal::is_default(&self.data_storage_size_tb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataStorageSizeTb", &__With(&self.data_storage_size_tb))?;
        }
        if !wkt::internal::is_default(&self.disk_redundancy) {
            state.serialize_entry("diskRedundancy", &self.disk_redundancy)?;
        }
        if !wkt::internal::is_default(&self.sparse_diskgroup_enabled) {
            state.serialize_entry("sparseDiskgroupEnabled", &self.sparse_diskgroup_enabled)?;
        }
        if !wkt::internal::is_default(&self.local_backup_enabled) {
            state.serialize_entry("localBackupEnabled", &self.local_backup_enabled)?;
        }
        if !self.hostname_prefix.is_empty() {
            state.serialize_entry("hostnamePrefix", &self.hostname_prefix)?;
        }
        if self.diagnostics_data_collection_options.is_some() {
            state.serialize_entry(
                "diagnosticsDataCollectionOptions",
                &self.diagnostics_data_collection_options,
            )?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.scan_listener_port_tcp) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scanListenerPortTcp", &__With(&self.scan_listener_port_tcp))?;
        }
        if !wkt::internal::is_default(&self.scan_listener_port_tcp_ssl) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "scanListenerPortTcpSsl",
                &__With(&self.scan_listener_port_tcp_ssl),
            )?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.scan_dns.is_empty() {
            state.serialize_entry("scanDns", &self.scan_dns)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.cpu_core_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCoreCount", &__With(&self.cpu_core_count))?;
        }
        if !self.system_version.is_empty() {
            state.serialize_entry("systemVersion", &self.system_version)?;
        }
        if !self.scan_ip_ids.is_empty() {
            state.serialize_entry("scanIpIds", &self.scan_ip_ids)?;
        }
        if !self.scan_dns_record_id.is_empty() {
            state.serialize_entry("scanDnsRecordId", &self.scan_dns_record_id)?;
        }
        if !self.oci_url.is_empty() {
            state.serialize_entry("ociUrl", &self.oci_url)?;
        }
        if !self.db_server_ocids.is_empty() {
            state.serialize_entry("dbServerOcids", &self.db_server_ocids)?;
        }
        if !self.compartment_id.is_empty() {
            state.serialize_entry("compartmentId", &self.compartment_id)?;
        }
        if !self.dns_listener_ip.is_empty() {
            state.serialize_entry("dnsListenerIp", &self.dns_listener_ip)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudVmClusterProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudVmClusterProperties");
        debug_struct.field("ocid", &self.ocid);
        debug_struct.field("license_type", &self.license_type);
        debug_struct.field("gi_version", &self.gi_version);
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("ssh_public_keys", &self.ssh_public_keys);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("shape", &self.shape);
        debug_struct.field("ocpu_count", &self.ocpu_count);
        debug_struct.field("memory_size_gb", &self.memory_size_gb);
        debug_struct.field("db_node_storage_size_gb", &self.db_node_storage_size_gb);
        debug_struct.field("storage_size_gb", &self.storage_size_gb);
        debug_struct.field("data_storage_size_tb", &self.data_storage_size_tb);
        debug_struct.field("disk_redundancy", &self.disk_redundancy);
        debug_struct.field("sparse_diskgroup_enabled", &self.sparse_diskgroup_enabled);
        debug_struct.field("local_backup_enabled", &self.local_backup_enabled);
        debug_struct.field("hostname_prefix", &self.hostname_prefix);
        debug_struct.field(
            "diagnostics_data_collection_options",
            &self.diagnostics_data_collection_options,
        );
        debug_struct.field("state", &self.state);
        debug_struct.field("scan_listener_port_tcp", &self.scan_listener_port_tcp);
        debug_struct.field(
            "scan_listener_port_tcp_ssl",
            &self.scan_listener_port_tcp_ssl,
        );
        debug_struct.field("domain", &self.domain);
        debug_struct.field("scan_dns", &self.scan_dns);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("cpu_core_count", &self.cpu_core_count);
        debug_struct.field("system_version", &self.system_version);
        debug_struct.field("scan_ip_ids", &self.scan_ip_ids);
        debug_struct.field("scan_dns_record_id", &self.scan_dns_record_id);
        debug_struct.field("oci_url", &self.oci_url);
        debug_struct.field("db_server_ocids", &self.db_server_ocids);
        debug_struct.field("compartment_id", &self.compartment_id);
        debug_struct.field("dns_listener_ip", &self.dns_listener_ip);
        debug_struct.field("cluster_name", &self.cluster_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudVmClusterProperties].
pub mod cloud_vm_cluster_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Different licenses supported.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseType {
        /// Unspecified
        Unspecified,
        /// License included part of offer
        LicenseIncluded,
        /// Bring your own license
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseType::value] or
        /// [LicenseType::name].
        UnknownValue(license_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_TYPE_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseType>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.LicenseType",
            ))
        }
    }

    /// Types of disk redundancy provided by Oracle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskRedundancy {
        /// Unspecified.
        Unspecified,
        /// High -  3 way mirror.
        High,
        /// Normal - 2 way mirror.
        Normal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskRedundancy::value] or
        /// [DiskRedundancy::name].
        UnknownValue(disk_redundancy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_redundancy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskRedundancy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Normal => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_REDUNDANCY_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskRedundancy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskRedundancy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskRedundancy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Normal,
                _ => Self::UnknownValue(disk_redundancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskRedundancy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_REDUNDANCY_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "NORMAL" => Self::Normal,
                _ => Self::UnknownValue(disk_redundancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskRedundancy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Normal => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskRedundancy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskRedundancy>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.DiskRedundancy",
            ))
        }
    }

    /// The various lifecycle states of the VM cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::MaintenanceInProgress => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::MaintenanceInProgress => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.State",
            ))
        }
    }
}

/// Data collection options for diagnostics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataCollectionOptions {
    /// Optional. Indicates whether diagnostic collection is enabled for the VM
    /// cluster
    pub diagnostics_events_enabled: bool,

    /// Optional. Indicates whether health monitoring is enabled for the VM cluster
    pub health_monitoring_enabled: bool,

    /// Optional. Indicates whether incident logs and trace collection are enabled
    /// for the VM cluster
    pub incident_logs_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataCollectionOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [diagnostics_events_enabled][crate::model::DataCollectionOptions::diagnostics_events_enabled].
    pub fn set_diagnostics_events_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.diagnostics_events_enabled = v.into();
        self
    }

    /// Sets the value of [health_monitoring_enabled][crate::model::DataCollectionOptions::health_monitoring_enabled].
    pub fn set_health_monitoring_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.health_monitoring_enabled = v.into();
        self
    }

    /// Sets the value of [incident_logs_enabled][crate::model::DataCollectionOptions::incident_logs_enabled].
    pub fn set_incident_logs_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.incident_logs_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCollectionOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DataCollectionOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataCollectionOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __diagnostics_events_enabled,
            __health_monitoring_enabled,
            __incident_logs_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataCollectionOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diagnosticsEventsEnabled" => {
                                Ok(__FieldTag::__diagnostics_events_enabled)
                            }
                            "diagnostics_events_enabled" => {
                                Ok(__FieldTag::__diagnostics_events_enabled)
                            }
                            "healthMonitoringEnabled" => {
                                Ok(__FieldTag::__health_monitoring_enabled)
                            }
                            "health_monitoring_enabled" => {
                                Ok(__FieldTag::__health_monitoring_enabled)
                            }
                            "incidentLogsEnabled" => Ok(__FieldTag::__incident_logs_enabled),
                            "incident_logs_enabled" => Ok(__FieldTag::__incident_logs_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataCollectionOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataCollectionOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__diagnostics_events_enabled => {
                            if !fields.insert(__FieldTag::__diagnostics_events_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostics_events_enabled",
                                ));
                            }
                            result.diagnostics_events_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_monitoring_enabled => {
                            if !fields.insert(__FieldTag::__health_monitoring_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_monitoring_enabled",
                                ));
                            }
                            result.health_monitoring_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__incident_logs_enabled => {
                            if !fields.insert(__FieldTag::__incident_logs_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incident_logs_enabled",
                                ));
                            }
                            result.incident_logs_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataCollectionOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.diagnostics_events_enabled) {
            state.serialize_entry("diagnosticsEventsEnabled", &self.diagnostics_events_enabled)?;
        }
        if !wkt::internal::is_default(&self.health_monitoring_enabled) {
            state.serialize_entry("healthMonitoringEnabled", &self.health_monitoring_enabled)?;
        }
        if !wkt::internal::is_default(&self.incident_logs_enabled) {
            state.serialize_entry("incidentLogsEnabled", &self.incident_logs_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataCollectionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataCollectionOptions");
        debug_struct.field(
            "diagnostics_events_enabled",
            &self.diagnostics_events_enabled,
        );
        debug_struct.field("health_monitoring_enabled", &self.health_monitoring_enabled);
        debug_struct.field("incident_logs_enabled", &self.incident_logs_enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The type of wallet generation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum GenerateType {
    /// Default unspecified value.
    Unspecified,
    /// Used to generate wallet for all databases in the region.
    All,
    /// Used to generate wallet for a single database.
    Single,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [GenerateType::value] or
    /// [GenerateType::name].
    UnknownValue(generate_type::UnknownValue),
}

#[doc(hidden)]
pub mod generate_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl GenerateType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::All => std::option::Option::Some(1),
            Self::Single => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("GENERATE_TYPE_UNSPECIFIED"),
            Self::All => std::option::Option::Some("ALL"),
            Self::Single => std::option::Option::Some("SINGLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for GenerateType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for GenerateType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for GenerateType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::All,
            2 => Self::Single,
            _ => Self::UnknownValue(generate_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for GenerateType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "GENERATE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ALL" => Self::All,
            "SINGLE" => Self::Single,
            _ => Self::UnknownValue(generate_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for GenerateType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::All => serializer.serialize_i32(1),
            Self::Single => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for GenerateType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<GenerateType>::new(
            ".google.cloud.oracledatabase.v1.GenerateType",
        ))
    }
}

/// The various lifecycle states of the Autonomous Database.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum State {
    /// Default unspecified value.
    Unspecified,
    /// Indicates that the Autonomous Database is in provisioning state.
    Provisioning,
    /// Indicates that the Autonomous Database is in available state.
    Available,
    /// Indicates that the Autonomous Database is in stopping state.
    Stopping,
    /// Indicates that the Autonomous Database is in stopped state.
    Stopped,
    /// Indicates that the Autonomous Database is in starting state.
    Starting,
    /// Indicates that the Autonomous Database is in terminating state.
    Terminating,
    /// Indicates that the Autonomous Database is in terminated state.
    Terminated,
    /// Indicates that the Autonomous Database is in unavailable state.
    Unavailable,
    /// Indicates that the Autonomous Database restore is in progress.
    RestoreInProgress,
    /// Indicates that the Autonomous Database failed to restore.
    RestoreFailed,
    /// Indicates that the Autonomous Database backup is in progress.
    BackupInProgress,
    /// Indicates that the Autonomous Database scale is in progress.
    ScaleInProgress,
    /// Indicates that the Autonomous Database is available but needs attention
    /// state.
    AvailableNeedsAttention,
    /// Indicates that the Autonomous Database is in updating state.
    Updating,
    /// Indicates that the Autonomous Database's maintenance is in progress state.
    MaintenanceInProgress,
    /// Indicates that the Autonomous Database is in restarting state.
    Restarting,
    /// Indicates that the Autonomous Database is in recreating state.
    Recreating,
    /// Indicates that the Autonomous Database's role change is in progress state.
    RoleChangeInProgress,
    /// Indicates that the Autonomous Database is in upgrading state.
    Upgrading,
    /// Indicates that the Autonomous Database is in inaccessible state.
    Inaccessible,
    /// Indicates that the Autonomous Database is in standby state.
    Standby,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [State::value] or
    /// [State::name].
    UnknownValue(state::UnknownValue),
}

#[doc(hidden)]
pub mod state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl State {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Provisioning => std::option::Option::Some(1),
            Self::Available => std::option::Option::Some(2),
            Self::Stopping => std::option::Option::Some(3),
            Self::Stopped => std::option::Option::Some(4),
            Self::Starting => std::option::Option::Some(5),
            Self::Terminating => std::option::Option::Some(6),
            Self::Terminated => std::option::Option::Some(7),
            Self::Unavailable => std::option::Option::Some(8),
            Self::RestoreInProgress => std::option::Option::Some(9),
            Self::RestoreFailed => std::option::Option::Some(10),
            Self::BackupInProgress => std::option::Option::Some(11),
            Self::ScaleInProgress => std::option::Option::Some(12),
            Self::AvailableNeedsAttention => std::option::Option::Some(13),
            Self::Updating => std::option::Option::Some(14),
            Self::MaintenanceInProgress => std::option::Option::Some(15),
            Self::Restarting => std::option::Option::Some(16),
            Self::Recreating => std::option::Option::Some(17),
            Self::RoleChangeInProgress => std::option::Option::Some(18),
            Self::Upgrading => std::option::Option::Some(19),
            Self::Inaccessible => std::option::Option::Some(20),
            Self::Standby => std::option::Option::Some(21),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
            Self::Provisioning => std::option::Option::Some("PROVISIONING"),
            Self::Available => std::option::Option::Some("AVAILABLE"),
            Self::Stopping => std::option::Option::Some("STOPPING"),
            Self::Stopped => std::option::Option::Some("STOPPED"),
            Self::Starting => std::option::Option::Some("STARTING"),
            Self::Terminating => std::option::Option::Some("TERMINATING"),
            Self::Terminated => std::option::Option::Some("TERMINATED"),
            Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
            Self::RestoreInProgress => std::option::Option::Some("RESTORE_IN_PROGRESS"),
            Self::RestoreFailed => std::option::Option::Some("RESTORE_FAILED"),
            Self::BackupInProgress => std::option::Option::Some("BACKUP_IN_PROGRESS"),
            Self::ScaleInProgress => std::option::Option::Some("SCALE_IN_PROGRESS"),
            Self::AvailableNeedsAttention => std::option::Option::Some("AVAILABLE_NEEDS_ATTENTION"),
            Self::Updating => std::option::Option::Some("UPDATING"),
            Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
            Self::Restarting => std::option::Option::Some("RESTARTING"),
            Self::Recreating => std::option::Option::Some("RECREATING"),
            Self::RoleChangeInProgress => std::option::Option::Some("ROLE_CHANGE_IN_PROGRESS"),
            Self::Upgrading => std::option::Option::Some("UPGRADING"),
            Self::Inaccessible => std::option::Option::Some("INACCESSIBLE"),
            Self::Standby => std::option::Option::Some("STANDBY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Provisioning,
            2 => Self::Available,
            3 => Self::Stopping,
            4 => Self::Stopped,
            5 => Self::Starting,
            6 => Self::Terminating,
            7 => Self::Terminated,
            8 => Self::Unavailable,
            9 => Self::RestoreInProgress,
            10 => Self::RestoreFailed,
            11 => Self::BackupInProgress,
            12 => Self::ScaleInProgress,
            13 => Self::AvailableNeedsAttention,
            14 => Self::Updating,
            15 => Self::MaintenanceInProgress,
            16 => Self::Restarting,
            17 => Self::Recreating,
            18 => Self::RoleChangeInProgress,
            19 => Self::Upgrading,
            20 => Self::Inaccessible,
            21 => Self::Standby,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for State {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_UNSPECIFIED" => Self::Unspecified,
            "PROVISIONING" => Self::Provisioning,
            "AVAILABLE" => Self::Available,
            "STOPPING" => Self::Stopping,
            "STOPPED" => Self::Stopped,
            "STARTING" => Self::Starting,
            "TERMINATING" => Self::Terminating,
            "TERMINATED" => Self::Terminated,
            "UNAVAILABLE" => Self::Unavailable,
            "RESTORE_IN_PROGRESS" => Self::RestoreInProgress,
            "RESTORE_FAILED" => Self::RestoreFailed,
            "BACKUP_IN_PROGRESS" => Self::BackupInProgress,
            "SCALE_IN_PROGRESS" => Self::ScaleInProgress,
            "AVAILABLE_NEEDS_ATTENTION" => Self::AvailableNeedsAttention,
            "UPDATING" => Self::Updating,
            "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
            "RESTARTING" => Self::Restarting,
            "RECREATING" => Self::Recreating,
            "ROLE_CHANGE_IN_PROGRESS" => Self::RoleChangeInProgress,
            "UPGRADING" => Self::Upgrading,
            "INACCESSIBLE" => Self::Inaccessible,
            "STANDBY" => Self::Standby,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Provisioning => serializer.serialize_i32(1),
            Self::Available => serializer.serialize_i32(2),
            Self::Stopping => serializer.serialize_i32(3),
            Self::Stopped => serializer.serialize_i32(4),
            Self::Starting => serializer.serialize_i32(5),
            Self::Terminating => serializer.serialize_i32(6),
            Self::Terminated => serializer.serialize_i32(7),
            Self::Unavailable => serializer.serialize_i32(8),
            Self::RestoreInProgress => serializer.serialize_i32(9),
            Self::RestoreFailed => serializer.serialize_i32(10),
            Self::BackupInProgress => serializer.serialize_i32(11),
            Self::ScaleInProgress => serializer.serialize_i32(12),
            Self::AvailableNeedsAttention => serializer.serialize_i32(13),
            Self::Updating => serializer.serialize_i32(14),
            Self::MaintenanceInProgress => serializer.serialize_i32(15),
            Self::Restarting => serializer.serialize_i32(16),
            Self::Recreating => serializer.serialize_i32(17),
            Self::RoleChangeInProgress => serializer.serialize_i32(18),
            Self::Upgrading => serializer.serialize_i32(19),
            Self::Inaccessible => serializer.serialize_i32(20),
            Self::Standby => serializer.serialize_i32(21),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
            ".google.cloud.oracledatabase.v1.State",
        ))
    }
}

/// The state of the Operations Insights for this Autonomous Database.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationsInsightsState {
    /// Default unspecified value.
    Unspecified,
    /// Enabling status for operation insights.
    Enabling,
    /// Enabled status for operation insights.
    Enabled,
    /// Disabling status for operation insights.
    Disabling,
    /// Not Enabled status for operation insights.
    NotEnabled,
    /// Failed enabling status for operation insights.
    FailedEnabling,
    /// Failed disabling status for operation insights.
    FailedDisabling,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationsInsightsState::value] or
    /// [OperationsInsightsState::name].
    UnknownValue(operations_insights_state::UnknownValue),
}

#[doc(hidden)]
pub mod operations_insights_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationsInsightsState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enabling => std::option::Option::Some(1),
            Self::Enabled => std::option::Option::Some(2),
            Self::Disabling => std::option::Option::Some(3),
            Self::NotEnabled => std::option::Option::Some(4),
            Self::FailedEnabling => std::option::Option::Some(5),
            Self::FailedDisabling => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATIONS_INSIGHTS_STATE_UNSPECIFIED"),
            Self::Enabling => std::option::Option::Some("ENABLING"),
            Self::Enabled => std::option::Option::Some("ENABLED"),
            Self::Disabling => std::option::Option::Some("DISABLING"),
            Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
            Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
            Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationsInsightsState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationsInsightsState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationsInsightsState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enabling,
            2 => Self::Enabled,
            3 => Self::Disabling,
            4 => Self::NotEnabled,
            5 => Self::FailedEnabling,
            6 => Self::FailedDisabling,
            _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationsInsightsState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => Self::Unspecified,
            "ENABLING" => Self::Enabling,
            "ENABLED" => Self::Enabled,
            "DISABLING" => Self::Disabling,
            "NOT_ENABLED" => Self::NotEnabled,
            "FAILED_ENABLING" => Self::FailedEnabling,
            "FAILED_DISABLING" => Self::FailedDisabling,
            _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationsInsightsState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enabling => serializer.serialize_i32(1),
            Self::Enabled => serializer.serialize_i32(2),
            Self::Disabling => serializer.serialize_i32(3),
            Self::NotEnabled => serializer.serialize_i32(4),
            Self::FailedEnabling => serializer.serialize_i32(5),
            Self::FailedDisabling => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationsInsightsState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationsInsightsState>::new(
            ".google.cloud.oracledatabase.v1.OperationsInsightsState",
        ))
    }
}

/// The various states available for the Autonomous Database workload type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DBWorkload {
    /// Default unspecified value.
    Unspecified,
    /// Autonomous Transaction Processing database.
    Oltp,
    /// Autonomous Data Warehouse database.
    Dw,
    /// Autonomous JSON Database.
    Ajd,
    /// Autonomous Database with the Oracle APEX Application Development workload
    /// type.
    Apex,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DBWorkload::value] or
    /// [DBWorkload::name].
    UnknownValue(db_workload::UnknownValue),
}

#[doc(hidden)]
pub mod db_workload {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DBWorkload {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Oltp => std::option::Option::Some(1),
            Self::Dw => std::option::Option::Some(2),
            Self::Ajd => std::option::Option::Some(3),
            Self::Apex => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DB_WORKLOAD_UNSPECIFIED"),
            Self::Oltp => std::option::Option::Some("OLTP"),
            Self::Dw => std::option::Option::Some("DW"),
            Self::Ajd => std::option::Option::Some("AJD"),
            Self::Apex => std::option::Option::Some("APEX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DBWorkload {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DBWorkload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DBWorkload {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Oltp,
            2 => Self::Dw,
            3 => Self::Ajd,
            4 => Self::Apex,
            _ => Self::UnknownValue(db_workload::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DBWorkload {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DB_WORKLOAD_UNSPECIFIED" => Self::Unspecified,
            "OLTP" => Self::Oltp,
            "DW" => Self::Dw,
            "AJD" => Self::Ajd,
            "APEX" => Self::Apex,
            _ => Self::UnknownValue(db_workload::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DBWorkload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Oltp => serializer.serialize_i32(1),
            Self::Dw => serializer.serialize_i32(2),
            Self::Ajd => serializer.serialize_i32(3),
            Self::Apex => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DBWorkload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DBWorkload>::new(
            ".google.cloud.oracledatabase.v1.DBWorkload",
        ))
    }
}
