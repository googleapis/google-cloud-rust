// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Details of the Autonomous Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabase/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabase {
    /// Identifier. The name of the Autonomous Database resource in the following
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. The name of the Autonomous Database. The database name must be
    /// unique in the project. The name must begin with a letter and can contain a
    /// maximum of 30 alphanumeric characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub database: std::string::String,

    /// Optional. The display name for the Autonomous Database. The name does not
    /// have to be unique within your project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. The ID of the subscription entitlement associated with the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub entitlement_id: std::string::String,

    /// Optional. The password for the default ADMIN user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub admin_password: std::string::String,

    /// Optional. The properties of the Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::AutonomousDatabaseProperties>,

    /// Optional. The labels or tags associated with the Autonomous Database.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The name of the VPC network used by the Autonomous Database in
    /// the following format: projects/{project}/global/networks/{network}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub network: std::string::String,

    /// Optional. The subnet CIDR range for the Autonmous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cidr: std::string::String,

    /// Output only. The date and time that the Autonomous Database was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabase::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::AutonomousDatabase::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabase::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::AutonomousDatabase::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [admin_password][crate::model::AutonomousDatabase::admin_password].
    pub fn set_admin_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin_password = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabase::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::AutonomousDatabase::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabase::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network][crate::model::AutonomousDatabase::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::AutonomousDatabase::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AutonomousDatabase::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AutonomousDatabase::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutonomousDatabase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabase"
    }
}

/// The properties of an Autonomous Database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseProperties {
    /// Output only. OCID of the Autonomous Database.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub compute_count: f32,

    /// Optional. The number of CPU cores to be made available to the database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub cpu_core_count: i32,

    /// Optional. The size of the data stored in the database, in terabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub data_storage_size_tb: i32,

    /// Optional. The size of the data stored in the database, in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub data_storage_size_gb: i32,

    /// Required. The workload type of the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub db_workload: crate::model::DBWorkload,

    /// Optional. The edition of the Autonomous Databases.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub db_edition: crate::model::autonomous_database_properties::DatabaseEdition,

    /// Optional. The character set for the Autonomous Database. The default is
    /// AL32UTF8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub character_set: std::string::String,

    /// Optional. The national character set for the Autonomous Database. The
    /// default is AL16UTF16.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub n_character_set: std::string::String,

    /// Optional. The private endpoint IP address for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub private_endpoint_ip: std::string::String,

    /// Optional. The private endpoint label for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub private_endpoint_label: std::string::String,

    /// Optional. The Oracle Database version for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub db_version: std::string::String,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database CPU core count.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_auto_scaling_enabled: bool,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database storage.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_storage_auto_scaling_enabled: bool,

    /// Required. The license type used for the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub license_type: crate::model::autonomous_database_properties::LicenseType,

    /// Optional. The list of customer contacts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault secret.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub secret_id: std::string::String,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub vault_id: std::string::String,

    /// Optional. The maintenance schedule of the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub maintenance_schedule_type:
        crate::model::autonomous_database_properties::MaintenanceScheduleType,

    /// Optional. This field specifies if the Autonomous Database requires mTLS
    /// connections.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub mtls_connection_required: bool,

    /// Optional. The retention period for the Autonomous Database. This field is
    /// specified in days, can range from 1 day to 60 days, and has a default value
    /// of 60 days.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub backup_retention_period_days: i32,

    /// Output only. The amount of storage currently being used for user and system
    /// data, in terabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F64>")]
    pub actual_used_data_storage_size_tb: f64,

    /// Output only. The amount of storage currently allocated for the database
    /// tables and billed for, rounded up in terabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F64>")]
    pub allocated_storage_size_tb: f64,

    /// Output only. The details for the Oracle APEX Application Development.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub apex_details: std::option::Option<crate::model::AutonomousDatabaseApex>,

    /// Output only. This field indicates the status of Data Guard and Access
    /// control for the Autonomous Database. The field's value is null if Data
    /// Guard is disabled or Access Control is disabled. The field's value is TRUE
    /// if both Data Guard and Access Control are enabled, and the Autonomous
    /// Database is using primary IP access control list (ACL) for standby. The
    /// field's value is FALSE if both Data Guard and Access Control are enabled,
    /// and the Autonomous Database is using a different IP access control list
    /// (ACL) for standby compared to primary.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub are_primary_allowlisted_ips_used: std::option::Option<bool>,

    /// Output only. The details of the current lifestyle state of the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::State,

    /// Output only. The Autonomous Container Database OCID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub autonomous_container_database_id: std::string::String,

    /// Output only. The list of available Oracle Database upgrade versions for an
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub available_upgrade_versions: std::vec::Vec<std::string::String>,

    /// Output only. The connection strings used to connect to an Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_strings: std::option::Option<crate::model::AutonomousDatabaseConnectionStrings>,

    /// Output only. The Oracle Connection URLs for an Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_urls: std::option::Option<crate::model::AutonomousDatabaseConnectionUrls>,

    /// Output only. This field indicates the number of seconds of data loss during
    /// a Data Guard failover.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failed_data_recovery_duration: std::option::Option<wkt::Duration>,

    /// Output only. The memory assigned to in-memory tables in an Autonomous
    /// Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub memory_table_gbs: i32,

    /// Output only. This field indicates whether the Autonomous Database has local
    /// (in-region) Data Guard enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_local_data_guard_enabled: bool,

    /// Output only. This field indicates the maximum data loss limit for an
    /// Autonomous Database, in seconds.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub local_adg_auto_failover_max_data_loss_limit: i32,

    /// Output only. The details of the Autonomous Data Guard standby database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub local_standby_db: std::option::Option<crate::model::AutonomousDatabaseStandbySummary>,

    /// Output only. The amount of memory enabled per ECPU, in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub memory_per_oracle_compute_unit_gbs: i32,

    /// Output only. This field indicates the local disaster recovery (DR) type of
    /// an Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub local_disaster_recovery_type:
        crate::model::autonomous_database_properties::LocalDisasterRecoveryType,

    /// Output only. The current state of the Data Safe registration for the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub data_safe_state: crate::model::autonomous_database_properties::DataSafeState,

    /// Output only. The current state of database management for the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub database_management_state:
        crate::model::autonomous_database_properties::DatabaseManagementState,

    /// Output only. This field indicates the current mode of the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub open_mode: crate::model::autonomous_database_properties::OpenMode,

    /// Output only. This field indicates the state of Operations Insights for the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub operations_insights_state: crate::model::OperationsInsightsState,

    /// Output only. The list of OCIDs of standby databases located in Autonomous
    /// Data Guard remote regions that are associated with the source database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub peer_db_ids: std::vec::Vec<std::string::String>,

    /// Output only. The permission level of the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub permission_level: crate::model::autonomous_database_properties::PermissionLevel,

    /// Output only. The private endpoint for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub private_endpoint: std::string::String,

    /// Output only. The refresh mode of the cloned Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub refreshable_mode: crate::model::autonomous_database_properties::RefreshableMode,

    /// Output only. The refresh State of the clone.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub refreshable_state: crate::model::autonomous_database_properties::RefreshableState,

    /// Output only. The Data Guard role of the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub role: crate::model::autonomous_database_properties::Role,

    /// Output only. The list and details of the scheduled operations of the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub scheduled_operation_details: std::vec::Vec<crate::model::ScheduledOperationDetails>,

    /// Output only. The SQL Web Developer URL for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub sql_web_developer_url: std::string::String,

    /// Output only. The list of available regions that can be used to create a
    /// clone for the Autonomous Database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub supported_clone_regions: std::vec::Vec<std::string::String>,

    /// Output only. The storage space used by Autonomous Database, in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub used_data_storage_size_tbs: i32,

    /// Output only. The Oracle Cloud Infrastructure link for the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub oci_url: std::string::String,

    /// Output only. The storage space used by automatic backups of Autonomous
    /// Database, in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub total_auto_backup_storage_size_gbs: f32,

    /// Output only. The long term backup schedule of the Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_long_term_backup_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will begin.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will end.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::AutonomousDatabaseProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::AutonomousDatabaseProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::AutonomousDatabaseProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_gb][crate::model::AutonomousDatabaseProperties::data_storage_size_gb].
    pub fn set_data_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDatabaseProperties::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [db_edition][crate::model::AutonomousDatabaseProperties::db_edition].
    pub fn set_db_edition<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseEdition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.db_edition = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseProperties::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }

    /// Sets the value of [n_character_set][crate::model::AutonomousDatabaseProperties::n_character_set].
    pub fn set_n_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n_character_set = v.into();
        self
    }

    /// Sets the value of [private_endpoint_ip][crate::model::AutonomousDatabaseProperties::private_endpoint_ip].
    pub fn set_private_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [private_endpoint_label][crate::model::AutonomousDatabaseProperties::private_endpoint_label].
    pub fn set_private_endpoint_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_label = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_auto_scaling_enabled].
    pub fn set_is_auto_scaling_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [is_storage_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_storage_auto_scaling_enabled].
    pub fn set_is_storage_auto_scaling_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_storage_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::AutonomousDatabaseProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [customer_contacts][crate::model::AutonomousDatabaseProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_id][crate::model::AutonomousDatabaseProperties::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }

    /// Sets the value of [maintenance_schedule_type][crate::model::AutonomousDatabaseProperties::maintenance_schedule_type].
    pub fn set_maintenance_schedule_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::MaintenanceScheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_schedule_type = v.into();
        self
    }

    /// Sets the value of [mtls_connection_required][crate::model::AutonomousDatabaseProperties::mtls_connection_required].
    pub fn set_mtls_connection_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.mtls_connection_required = v.into();
        self
    }

    /// Sets the value of [backup_retention_period_days][crate::model::AutonomousDatabaseProperties::backup_retention_period_days].
    pub fn set_backup_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.backup_retention_period_days = v.into();
        self
    }

    /// Sets the value of [actual_used_data_storage_size_tb][crate::model::AutonomousDatabaseProperties::actual_used_data_storage_size_tb].
    pub fn set_actual_used_data_storage_size_tb<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.actual_used_data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [allocated_storage_size_tb][crate::model::AutonomousDatabaseProperties::allocated_storage_size_tb].
    pub fn set_allocated_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.allocated_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [apex_details][crate::model::AutonomousDatabaseProperties::apex_details].
    pub fn set_apex_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseApex>,
    {
        self.apex_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [apex_details][crate::model::AutonomousDatabaseProperties::apex_details].
    pub fn set_or_clear_apex_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseApex>,
    {
        self.apex_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [are_primary_allowlisted_ips_used][crate::model::AutonomousDatabaseProperties::are_primary_allowlisted_ips_used].
    pub fn set_are_primary_allowlisted_ips_used<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.are_primary_allowlisted_ips_used = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [are_primary_allowlisted_ips_used][crate::model::AutonomousDatabaseProperties::are_primary_allowlisted_ips_used].
    pub fn set_or_clear_are_primary_allowlisted_ips_used<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.are_primary_allowlisted_ips_used = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [autonomous_container_database_id][crate::model::AutonomousDatabaseProperties::autonomous_container_database_id].
    pub fn set_autonomous_container_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_container_database_id = v.into();
        self
    }

    /// Sets the value of [available_upgrade_versions][crate::model::AutonomousDatabaseProperties::available_upgrade_versions].
    pub fn set_available_upgrade_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_upgrade_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_strings][crate::model::AutonomousDatabaseProperties::connection_strings].
    pub fn set_connection_strings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionStrings>,
    {
        self.connection_strings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_strings][crate::model::AutonomousDatabaseProperties::connection_strings].
    pub fn set_or_clear_connection_strings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionStrings>,
    {
        self.connection_strings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_urls][crate::model::AutonomousDatabaseProperties::connection_urls].
    pub fn set_connection_urls<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionUrls>,
    {
        self.connection_urls = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_urls][crate::model::AutonomousDatabaseProperties::connection_urls].
    pub fn set_or_clear_connection_urls<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionUrls>,
    {
        self.connection_urls = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failed_data_recovery_duration][crate::model::AutonomousDatabaseProperties::failed_data_recovery_duration].
    pub fn set_failed_data_recovery_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.failed_data_recovery_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failed_data_recovery_duration][crate::model::AutonomousDatabaseProperties::failed_data_recovery_duration].
    pub fn set_or_clear_failed_data_recovery_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.failed_data_recovery_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_table_gbs][crate::model::AutonomousDatabaseProperties::memory_table_gbs].
    pub fn set_memory_table_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_table_gbs = v.into();
        self
    }

    /// Sets the value of [is_local_data_guard_enabled][crate::model::AutonomousDatabaseProperties::is_local_data_guard_enabled].
    pub fn set_is_local_data_guard_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_local_data_guard_enabled = v.into();
        self
    }

    /// Sets the value of [local_adg_auto_failover_max_data_loss_limit][crate::model::AutonomousDatabaseProperties::local_adg_auto_failover_max_data_loss_limit].
    pub fn set_local_adg_auto_failover_max_data_loss_limit<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_adg_auto_failover_max_data_loss_limit = v.into();
        self
    }

    /// Sets the value of [local_standby_db][crate::model::AutonomousDatabaseProperties::local_standby_db].
    pub fn set_local_standby_db<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseStandbySummary>,
    {
        self.local_standby_db = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_standby_db][crate::model::AutonomousDatabaseProperties::local_standby_db].
    pub fn set_or_clear_local_standby_db<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseStandbySummary>,
    {
        self.local_standby_db = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_per_oracle_compute_unit_gbs][crate::model::AutonomousDatabaseProperties::memory_per_oracle_compute_unit_gbs].
    pub fn set_memory_per_oracle_compute_unit_gbs<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.memory_per_oracle_compute_unit_gbs = v.into();
        self
    }

    /// Sets the value of [local_disaster_recovery_type][crate::model::AutonomousDatabaseProperties::local_disaster_recovery_type].
    pub fn set_local_disaster_recovery_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LocalDisasterRecoveryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_disaster_recovery_type = v.into();
        self
    }

    /// Sets the value of [data_safe_state][crate::model::AutonomousDatabaseProperties::data_safe_state].
    pub fn set_data_safe_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DataSafeState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_safe_state = v.into();
        self
    }

    /// Sets the value of [database_management_state][crate::model::AutonomousDatabaseProperties::database_management_state].
    pub fn set_database_management_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseManagementState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_management_state = v.into();
        self
    }

    /// Sets the value of [open_mode][crate::model::AutonomousDatabaseProperties::open_mode].
    pub fn set_open_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::OpenMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_mode = v.into();
        self
    }

    /// Sets the value of [operations_insights_state][crate::model::AutonomousDatabaseProperties::operations_insights_state].
    pub fn set_operations_insights_state<
        T: std::convert::Into<crate::model::OperationsInsightsState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operations_insights_state = v.into();
        self
    }

    /// Sets the value of [peer_db_ids][crate::model::AutonomousDatabaseProperties::peer_db_ids].
    pub fn set_peer_db_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_db_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [permission_level][crate::model::AutonomousDatabaseProperties::permission_level].
    pub fn set_permission_level<
        T: std::convert::Into<crate::model::autonomous_database_properties::PermissionLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.permission_level = v.into();
        self
    }

    /// Sets the value of [private_endpoint][crate::model::AutonomousDatabaseProperties::private_endpoint].
    pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint = v.into();
        self
    }

    /// Sets the value of [refreshable_mode][crate::model::AutonomousDatabaseProperties::refreshable_mode].
    pub fn set_refreshable_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_mode = v.into();
        self
    }

    /// Sets the value of [refreshable_state][crate::model::AutonomousDatabaseProperties::refreshable_state].
    pub fn set_refreshable_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_state = v.into();
        self
    }

    /// Sets the value of [role][crate::model::AutonomousDatabaseProperties::role].
    pub fn set_role<T: std::convert::Into<crate::model::autonomous_database_properties::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [scheduled_operation_details][crate::model::AutonomousDatabaseProperties::scheduled_operation_details].
    pub fn set_scheduled_operation_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScheduledOperationDetails>,
    {
        use std::iter::Iterator;
        self.scheduled_operation_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sql_web_developer_url][crate::model::AutonomousDatabaseProperties::sql_web_developer_url].
    pub fn set_sql_web_developer_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sql_web_developer_url = v.into();
        self
    }

    /// Sets the value of [supported_clone_regions][crate::model::AutonomousDatabaseProperties::supported_clone_regions].
    pub fn set_supported_clone_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_clone_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [used_data_storage_size_tbs][crate::model::AutonomousDatabaseProperties::used_data_storage_size_tbs].
    pub fn set_used_data_storage_size_tbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.used_data_storage_size_tbs = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::AutonomousDatabaseProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [total_auto_backup_storage_size_gbs][crate::model::AutonomousDatabaseProperties::total_auto_backup_storage_size_gbs].
    pub fn set_total_auto_backup_storage_size_gbs<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_auto_backup_storage_size_gbs = v.into();
        self
    }

    /// Sets the value of [next_long_term_backup_time][crate::model::AutonomousDatabaseProperties::next_long_term_backup_time].
    pub fn set_next_long_term_backup_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_long_term_backup_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_long_term_backup_time][crate::model::AutonomousDatabaseProperties::next_long_term_backup_time].
    pub fn set_or_clear_next_long_term_backup_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_long_term_backup_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_begin_time][crate::model::AutonomousDatabaseProperties::maintenance_begin_time].
    pub fn set_maintenance_begin_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_begin_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_begin_time][crate::model::AutonomousDatabaseProperties::maintenance_begin_time].
    pub fn set_or_clear_maintenance_begin_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_begin_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_end_time][crate::model::AutonomousDatabaseProperties::maintenance_end_time].
    pub fn set_maintenance_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_end_time][crate::model::AutonomousDatabaseProperties::maintenance_end_time].
    pub fn set_or_clear_maintenance_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseProperties"
    }
}

/// Defines additional types related to [AutonomousDatabaseProperties].
pub mod autonomous_database_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The editions available for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEdition {
        /// Default unspecified value.
        Unspecified,
        /// Standard Database Edition
        StandardEdition,
        /// Enterprise Database Edition
        EnterpriseEdition,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEdition::value] or
        /// [DatabaseEdition::name].
        UnknownValue(database_edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEdition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardEdition => std::option::Option::Some(1),
                Self::EnterpriseEdition => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_EDITION_UNSPECIFIED"),
                Self::StandardEdition => std::option::Option::Some("STANDARD_EDITION"),
                Self::EnterpriseEdition => std::option::Option::Some("ENTERPRISE_EDITION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEdition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEdition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEdition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardEdition,
                2 => Self::EnterpriseEdition,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEdition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_EDITION" => Self::StandardEdition,
                "ENTERPRISE_EDITION" => Self::EnterpriseEdition,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEdition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardEdition => serializer.serialize_i32(1),
                Self::EnterpriseEdition => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEdition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEdition>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DatabaseEdition",
            ))
        }
    }

    /// The license types available for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseType {
        /// Unspecified
        Unspecified,
        /// License included part of offer
        LicenseIncluded,
        /// Bring your own license
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseType::value] or
        /// [LicenseType::name].
        UnknownValue(license_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_TYPE_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.LicenseType",
            ))
        }
    }

    /// The available maintenance schedules for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceScheduleType {
        /// Default unspecified value.
        Unspecified,
        /// An EARLY maintenance schedule patches the database before
        /// the regular scheduled maintenance.
        Early,
        /// A REGULAR maintenance schedule follows the normal maintenance cycle.
        Regular,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceScheduleType::value] or
        /// [MaintenanceScheduleType::name].
        UnknownValue(maintenance_schedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod maintenance_schedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaintenanceScheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Early => std::option::Option::Some(1),
                Self::Regular => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED")
                }
                Self::Early => std::option::Option::Some("EARLY"),
                Self::Regular => std::option::Option::Some("REGULAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaintenanceScheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaintenanceScheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaintenanceScheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Early,
                2 => Self::Regular,
                _ => Self::UnknownValue(maintenance_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaintenanceScheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EARLY" => Self::Early,
                "REGULAR" => Self::Regular,
                _ => Self::UnknownValue(maintenance_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaintenanceScheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Early => serializer.serialize_i32(1),
                Self::Regular => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceScheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaintenanceScheduleType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.MaintenanceScheduleType"))
        }
    }

    /// The types of local disaster recovery available for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocalDisasterRecoveryType {
        /// Default unspecified value.
        Unspecified,
        /// Autonomous Data Guard recovery.
        Adg,
        /// Backup based recovery.
        BackupBased,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocalDisasterRecoveryType::value] or
        /// [LocalDisasterRecoveryType::name].
        UnknownValue(local_disaster_recovery_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod local_disaster_recovery_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocalDisasterRecoveryType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Adg => std::option::Option::Some(1),
                Self::BackupBased => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED")
                }
                Self::Adg => std::option::Option::Some("ADG"),
                Self::BackupBased => std::option::Option::Some("BACKUP_BASED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocalDisasterRecoveryType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocalDisasterRecoveryType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocalDisasterRecoveryType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Adg,
                2 => Self::BackupBased,
                _ => Self::UnknownValue(local_disaster_recovery_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocalDisasterRecoveryType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ADG" => Self::Adg,
                "BACKUP_BASED" => Self::BackupBased,
                _ => Self::UnknownValue(local_disaster_recovery_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocalDisasterRecoveryType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Adg => serializer.serialize_i32(1),
                Self::BackupBased => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocalDisasterRecoveryType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocalDisasterRecoveryType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.LocalDisasterRecoveryType"))
        }
    }

    /// Varies states of the Data Safe registration for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSafeState {
        /// Default unspecified value.
        Unspecified,
        /// Registering data safe state.
        Registering,
        /// Registered data safe state.
        Registered,
        /// Deregistering data safe state.
        Deregistering,
        /// Not registered data safe state.
        NotRegistered,
        /// Failed data safe state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataSafeState::value] or
        /// [DataSafeState::name].
        UnknownValue(data_safe_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_safe_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataSafeState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Registering => std::option::Option::Some(1),
                Self::Registered => std::option::Option::Some(2),
                Self::Deregistering => std::option::Option::Some(3),
                Self::NotRegistered => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SAFE_STATE_UNSPECIFIED"),
                Self::Registering => std::option::Option::Some("REGISTERING"),
                Self::Registered => std::option::Option::Some("REGISTERED"),
                Self::Deregistering => std::option::Option::Some("DEREGISTERING"),
                Self::NotRegistered => std::option::Option::Some("NOT_REGISTERED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataSafeState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataSafeState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataSafeState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Registering,
                2 => Self::Registered,
                3 => Self::Deregistering,
                4 => Self::NotRegistered,
                5 => Self::Failed,
                _ => Self::UnknownValue(data_safe_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataSafeState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SAFE_STATE_UNSPECIFIED" => Self::Unspecified,
                "REGISTERING" => Self::Registering,
                "REGISTERED" => Self::Registered,
                "DEREGISTERING" => Self::Deregistering,
                "NOT_REGISTERED" => Self::NotRegistered,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(data_safe_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataSafeState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Registering => serializer.serialize_i32(1),
                Self::Registered => serializer.serialize_i32(2),
                Self::Deregistering => serializer.serialize_i32(3),
                Self::NotRegistered => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataSafeState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataSafeState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DataSafeState",
            ))
        }
    }

    /// The different states of database management for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseManagementState {
        /// Default unspecified value.
        Unspecified,
        /// Enabling Database Management state
        Enabling,
        /// Enabled Database Management state
        Enabled,
        /// Disabling Database Management state
        Disabling,
        /// Not Enabled Database Management state
        NotEnabled,
        /// Failed enabling Database Management state
        FailedEnabling,
        /// Failed disabling Database Management state
        FailedDisabling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseManagementState::value] or
        /// [DatabaseManagementState::name].
        UnknownValue(database_management_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_management_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseManagementState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabling => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::Disabling => std::option::Option::Some(3),
                Self::NotEnabled => std::option::Option::Some(4),
                Self::FailedEnabling => std::option::Option::Some(5),
                Self::FailedDisabling => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DATABASE_MANAGEMENT_STATE_UNSPECIFIED")
                }
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
                Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
                Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseManagementState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseManagementState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseManagementState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabling,
                2 => Self::Enabled,
                3 => Self::Disabling,
                4 => Self::NotEnabled,
                5 => Self::FailedEnabling,
                6 => Self::FailedDisabling,
                _ => Self::UnknownValue(database_management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseManagementState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_MANAGEMENT_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLING" => Self::Enabling,
                "ENABLED" => Self::Enabled,
                "DISABLING" => Self::Disabling,
                "NOT_ENABLED" => Self::NotEnabled,
                "FAILED_ENABLING" => Self::FailedEnabling,
                "FAILED_DISABLING" => Self::FailedDisabling,
                _ => Self::UnknownValue(database_management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseManagementState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabling => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::Disabling => serializer.serialize_i32(3),
                Self::NotEnabled => serializer.serialize_i32(4),
                Self::FailedEnabling => serializer.serialize_i32(5),
                Self::FailedDisabling => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseManagementState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseManagementState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DatabaseManagementState"))
        }
    }

    /// This field indicates the modes of an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OpenMode {
        /// Default unspecified value.
        Unspecified,
        /// Read Only Mode
        ReadOnly,
        /// Read Write Mode
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OpenMode::value] or
        /// [OpenMode::name].
        UnknownValue(open_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod open_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OpenMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReadOnly => std::option::Option::Some(1),
                Self::ReadWrite => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPEN_MODE_UNSPECIFIED"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OpenMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OpenMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OpenMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReadOnly,
                2 => Self::ReadWrite,
                _ => Self::UnknownValue(open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OpenMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPEN_MODE_UNSPECIFIED" => Self::Unspecified,
                "READ_ONLY" => Self::ReadOnly,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OpenMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReadOnly => serializer.serialize_i32(1),
                Self::ReadWrite => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OpenMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OpenMode>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.OpenMode",
            ))
        }
    }

    /// The types of permission levels for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PermissionLevel {
        /// Default unspecified value.
        Unspecified,
        /// Restricted mode allows access only by admin users.
        Restricted,
        /// Normal access.
        Unrestricted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PermissionLevel::value] or
        /// [PermissionLevel::name].
        UnknownValue(permission_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod permission_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PermissionLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Restricted => std::option::Option::Some(1),
                Self::Unrestricted => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERMISSION_LEVEL_UNSPECIFIED"),
                Self::Restricted => std::option::Option::Some("RESTRICTED"),
                Self::Unrestricted => std::option::Option::Some("UNRESTRICTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PermissionLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PermissionLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PermissionLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Restricted,
                2 => Self::Unrestricted,
                _ => Self::UnknownValue(permission_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PermissionLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERMISSION_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "RESTRICTED" => Self::Restricted,
                "UNRESTRICTED" => Self::Unrestricted,
                _ => Self::UnknownValue(permission_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PermissionLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Restricted => serializer.serialize_i32(1),
                Self::Unrestricted => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PermissionLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PermissionLevel>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.PermissionLevel",
            ))
        }
    }

    /// The refresh mode of the cloned Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefreshableMode {
        /// The default unspecified value.
        Unspecified,
        /// AUTOMATIC indicates that the cloned database is automatically
        /// refreshed with data from the source Autonomous Database.
        Automatic,
        /// MANUAL indicates that the cloned database is manually refreshed with
        /// data from the source Autonomous Database.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefreshableMode::value] or
        /// [RefreshableMode::name].
        UnknownValue(refreshable_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod refreshable_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefreshableMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REFRESHABLE_MODE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefreshableMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefreshableMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefreshableMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(refreshable_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefreshableMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REFRESHABLE_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(refreshable_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefreshableMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefreshableMode>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.RefreshableMode",
            ))
        }
    }

    /// The refresh state of the cloned Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefreshableState {
        /// Default unspecified value.
        Unspecified,
        /// Refreshing
        Refreshing,
        /// Not refreshed
        NotRefreshing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefreshableState::value] or
        /// [RefreshableState::name].
        UnknownValue(refreshable_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod refreshable_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefreshableState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Refreshing => std::option::Option::Some(1),
                Self::NotRefreshing => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REFRESHABLE_STATE_UNSPECIFIED"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::NotRefreshing => std::option::Option::Some("NOT_REFRESHING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefreshableState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefreshableState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefreshableState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Refreshing,
                2 => Self::NotRefreshing,
                _ => Self::UnknownValue(refreshable_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefreshableState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REFRESHABLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "REFRESHING" => Self::Refreshing,
                "NOT_REFRESHING" => Self::NotRefreshing,
                _ => Self::UnknownValue(refreshable_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefreshableState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Refreshing => serializer.serialize_i32(1),
                Self::NotRefreshing => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefreshableState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.RefreshableState",
            ))
        }
    }

    /// The Data Guard role of the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Default unspecified value.
        Unspecified,
        /// Primary role
        Primary,
        /// Standby role
        Standby,
        /// Disabled standby role
        DisabledStandby,
        /// Backup copy role
        BackupCopy,
        /// Snapshot standby role
        SnapshotStandby,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::Standby => std::option::Option::Some(2),
                Self::DisabledStandby => std::option::Option::Some(3),
                Self::BackupCopy => std::option::Option::Some(4),
                Self::SnapshotStandby => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Standby => std::option::Option::Some("STANDBY"),
                Self::DisabledStandby => std::option::Option::Some("DISABLED_STANDBY"),
                Self::BackupCopy => std::option::Option::Some("BACKUP_COPY"),
                Self::SnapshotStandby => std::option::Option::Some("SNAPSHOT_STANDBY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::Standby,
                3 => Self::DisabledStandby,
                4 => Self::BackupCopy,
                5 => Self::SnapshotStandby,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "STANDBY" => Self::Standby,
                "DISABLED_STANDBY" => Self::DisabledStandby,
                "BACKUP_COPY" => Self::BackupCopy,
                "SNAPSHOT_STANDBY" => Self::SnapshotStandby,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::Standby => serializer.serialize_i32(2),
                Self::DisabledStandby => serializer.serialize_i32(3),
                Self::BackupCopy => serializer.serialize_i32(4),
                Self::SnapshotStandby => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.Role",
            ))
        }
    }
}

/// Oracle APEX Application Development.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseApex>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseApex {
    /// Output only. The Oracle APEX Application Development version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub apex_version: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ords_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseApex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_version][crate::model::AutonomousDatabaseApex::apex_version].
    pub fn set_apex_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_version = v.into();
        self
    }

    /// Sets the value of [ords_version][crate::model::AutonomousDatabaseApex::ords_version].
    pub fn set_ords_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_version = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseApex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseApex"
    }
}

/// The connection string used to connect to the Autonomous Database.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionStrings>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionStrings {
    /// Output only. Returns all connection strings that can be used to connect to
    /// the Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub all_connection_strings: std::option::Option<crate::model::AllConnectionStrings>,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement, but supports the most number of concurrent SQL
    /// statements.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub dedicated: std::string::String,

    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub medium: std::string::String,

    /// Output only. A list of connection string profiles to allow clients to
    /// group, filter, and select values based on the structured metadata.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub profiles: std::vec::Vec<crate::model::DatabaseConnectionStringProfile>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_connection_strings][crate::model::AutonomousDatabaseConnectionStrings::all_connection_strings].
    pub fn set_all_connection_strings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AllConnectionStrings>,
    {
        self.all_connection_strings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_connection_strings][crate::model::AutonomousDatabaseConnectionStrings::all_connection_strings].
    pub fn set_or_clear_all_connection_strings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AllConnectionStrings>,
    {
        self.all_connection_strings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dedicated][crate::model::AutonomousDatabaseConnectionStrings::dedicated].
    pub fn set_dedicated<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dedicated = v.into();
        self
    }

    /// Sets the value of [high][crate::model::AutonomousDatabaseConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AutonomousDatabaseConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AutonomousDatabaseConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [profiles][crate::model::AutonomousDatabaseConnectionStrings::profiles].
    pub fn set_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseConnectionStringProfile>,
    {
        use std::iter::Iterator;
        self.profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionStrings"
    }
}

/// The connection string profile to allow clients to group.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DatabaseConnectionStringProfile>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseConnectionStringProfile {
    /// Output only. The current consumer group being used by the connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub consumer_group: crate::model::database_connection_string_profile::ConsumerGroup,

    /// Output only. The display name for the database connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. The host name format being currently used in connection
    /// string.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub host_format: crate::model::database_connection_string_profile::HostFormat,

    /// Output only. This field indicates if the connection string is regional and
    /// is only applicable for cross-region Data Guard.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_regional: bool,

    /// Output only. The protocol being used by the connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub protocol: crate::model::database_connection_string_profile::Protocol,

    /// Output only. The current session mode of the connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub session_mode: crate::model::database_connection_string_profile::SessionMode,

    /// Output only. The syntax of the connection string.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub syntax_format: crate::model::database_connection_string_profile::SyntaxFormat,

    /// Output only. This field indicates the TLS authentication type of the
    /// connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub tls_authentication: crate::model::database_connection_string_profile::TLSAuthentication,

    /// Output only. The value of the connection string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseConnectionStringProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consumer_group][crate::model::DatabaseConnectionStringProfile::consumer_group].
    pub fn set_consumer_group<
        T: std::convert::Into<crate::model::database_connection_string_profile::ConsumerGroup>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consumer_group = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DatabaseConnectionStringProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [host_format][crate::model::DatabaseConnectionStringProfile::host_format].
    pub fn set_host_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::HostFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.host_format = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::DatabaseConnectionStringProfile::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::DatabaseConnectionStringProfile::protocol].
    pub fn set_protocol<
        T: std::convert::Into<crate::model::database_connection_string_profile::Protocol>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [session_mode][crate::model::DatabaseConnectionStringProfile::session_mode].
    pub fn set_session_mode<
        T: std::convert::Into<crate::model::database_connection_string_profile::SessionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_mode = v.into();
        self
    }

    /// Sets the value of [syntax_format][crate::model::DatabaseConnectionStringProfile::syntax_format].
    pub fn set_syntax_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::SyntaxFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.syntax_format = v.into();
        self
    }

    /// Sets the value of [tls_authentication][crate::model::DatabaseConnectionStringProfile::tls_authentication].
    pub fn set_tls_authentication<
        T: std::convert::Into<crate::model::database_connection_string_profile::TLSAuthentication>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tls_authentication = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DatabaseConnectionStringProfile::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseConnectionStringProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile"
    }
}

/// Defines additional types related to [DatabaseConnectionStringProfile].
pub mod database_connection_string_profile {
    #[allow(unused_imports)]
    use super::*;

    /// The various consumer groups available in the connection string profile.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConsumerGroup {
        /// Default unspecified value.
        Unspecified,
        /// High consumer group.
        High,
        /// Medium consumer group.
        Medium,
        /// Low consumer group.
        Low,
        /// TP consumer group.
        Tp,
        /// TPURGENT consumer group.
        Tpurgent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConsumerGroup::value] or
        /// [ConsumerGroup::name].
        UnknownValue(consumer_group::UnknownValue),
    }

    #[doc(hidden)]
    pub mod consumer_group {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConsumerGroup {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::Low => std::option::Option::Some(3),
                Self::Tp => std::option::Option::Some(4),
                Self::Tpurgent => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONSUMER_GROUP_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Tp => std::option::Option::Some("TP"),
                Self::Tpurgent => std::option::Option::Some("TPURGENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConsumerGroup {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConsumerGroup {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConsumerGroup {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Medium,
                3 => Self::Low,
                4 => Self::Tp,
                5 => Self::Tpurgent,
                _ => Self::UnknownValue(consumer_group::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConsumerGroup {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONSUMER_GROUP_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "MEDIUM" => Self::Medium,
                "LOW" => Self::Low,
                "TP" => Self::Tp,
                "TPURGENT" => Self::Tpurgent,
                _ => Self::UnknownValue(consumer_group::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConsumerGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::Low => serializer.serialize_i32(3),
                Self::Tp => serializer.serialize_i32(4),
                Self::Tpurgent => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConsumerGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConsumerGroup>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.ConsumerGroup",
            ))
        }
    }

    /// The host name format being used in the connection string.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HostFormat {
        /// Default unspecified value.
        Unspecified,
        /// FQDN
        Fqdn,
        /// IP
        Ip,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HostFormat::value] or
        /// [HostFormat::name].
        UnknownValue(host_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod host_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HostFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fqdn => std::option::Option::Some(1),
                Self::Ip => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HOST_FORMAT_UNSPECIFIED"),
                Self::Fqdn => std::option::Option::Some("FQDN"),
                Self::Ip => std::option::Option::Some("IP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HostFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HostFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HostFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fqdn,
                2 => Self::Ip,
                _ => Self::UnknownValue(host_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HostFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HOST_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "FQDN" => Self::Fqdn,
                "IP" => Self::Ip,
                _ => Self::UnknownValue(host_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HostFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fqdn => serializer.serialize_i32(1),
                Self::Ip => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HostFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HostFormat>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.HostFormat",
            ))
        }
    }

    /// The protocol being used by the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Default unspecified value.
        Unspecified,
        /// Tcp
        Tcp,
        /// Tcps
        Tcps,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tcp => std::option::Option::Some(1),
                Self::Tcps => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::Tcp => std::option::Option::Some("TCP"),
                Self::Tcps => std::option::Option::Some("TCPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tcp,
                2 => Self::Tcps,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "TCP" => Self::Tcp,
                "TCPS" => Self::Tcps,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tcp => serializer.serialize_i32(1),
                Self::Tcps => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.Protocol",
            ))
        }
    }

    /// The session mode of the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionMode {
        /// Default unspecified value.
        Unspecified,
        /// Direct
        Direct,
        /// Indirect
        Indirect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SessionMode::value] or
        /// [SessionMode::name].
        UnknownValue(session_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod session_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SessionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Direct => std::option::Option::Some(1),
                Self::Indirect => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SESSION_MODE_UNSPECIFIED"),
                Self::Direct => std::option::Option::Some("DIRECT"),
                Self::Indirect => std::option::Option::Some("INDIRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SessionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SessionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SessionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Direct,
                2 => Self::Indirect,
                _ => Self::UnknownValue(session_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SessionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SESSION_MODE_UNSPECIFIED" => Self::Unspecified,
                "DIRECT" => Self::Direct,
                "INDIRECT" => Self::Indirect,
                _ => Self::UnknownValue(session_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SessionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Direct => serializer.serialize_i32(1),
                Self::Indirect => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SessionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SessionMode>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.SessionMode",
            ))
        }
    }

    /// Specifies syntax of the connection string.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SyntaxFormat {
        /// Default unspecified value.
        Unspecified,
        /// Long
        Long,
        /// Ezconnect
        Ezconnect,
        /// Ezconnectplus
        Ezconnectplus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SyntaxFormat::value] or
        /// [SyntaxFormat::name].
        UnknownValue(syntax_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod syntax_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SyntaxFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Long => std::option::Option::Some(1),
                Self::Ezconnect => std::option::Option::Some(2),
                Self::Ezconnectplus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SYNTAX_FORMAT_UNSPECIFIED"),
                Self::Long => std::option::Option::Some("LONG"),
                Self::Ezconnect => std::option::Option::Some("EZCONNECT"),
                Self::Ezconnectplus => std::option::Option::Some("EZCONNECTPLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SyntaxFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SyntaxFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SyntaxFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Long,
                2 => Self::Ezconnect,
                3 => Self::Ezconnectplus,
                _ => Self::UnknownValue(syntax_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SyntaxFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SYNTAX_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "LONG" => Self::Long,
                "EZCONNECT" => Self::Ezconnect,
                "EZCONNECTPLUS" => Self::Ezconnectplus,
                _ => Self::UnknownValue(syntax_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SyntaxFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Long => serializer.serialize_i32(1),
                Self::Ezconnect => serializer.serialize_i32(2),
                Self::Ezconnectplus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SyntaxFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SyntaxFormat>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.SyntaxFormat",
            ))
        }
    }

    /// This field indicates the TLS authentication type of the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TLSAuthentication {
        /// Default unspecified value.
        Unspecified,
        /// Server
        Server,
        /// Mutual
        Mutual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TLSAuthentication::value] or
        /// [TLSAuthentication::name].
        UnknownValue(tls_authentication::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tls_authentication {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TLSAuthentication {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Server => std::option::Option::Some(1),
                Self::Mutual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TLS_AUTHENTICATION_UNSPECIFIED"),
                Self::Server => std::option::Option::Some("SERVER"),
                Self::Mutual => std::option::Option::Some("MUTUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TLSAuthentication {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TLSAuthentication {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TLSAuthentication {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Server,
                2 => Self::Mutual,
                _ => Self::UnknownValue(tls_authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TLSAuthentication {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TLS_AUTHENTICATION_UNSPECIFIED" => Self::Unspecified,
                "SERVER" => Self::Server,
                "MUTUAL" => Self::Mutual,
                _ => Self::UnknownValue(tls_authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TLSAuthentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Server => serializer.serialize_i32(1),
                Self::Mutual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TLSAuthentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TLSAuthentication>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.TLSAuthentication",
            ))
        }
    }
}

/// A list of all connection strings that can be used to connect to the
/// Autonomous Database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllConnectionStrings {
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub medium: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [high][crate::model::AllConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AllConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AllConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }
}

impl wkt::message::Message for AllConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AllConnectionStrings"
    }
}

/// The URLs for accessing Oracle Application Express (APEX) and SQL Developer
/// Web with a browser from a Compute instance.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionUrls>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionUrls {
    /// Output only. Oracle Application Express (APEX) URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub apex_uri: std::string::String,

    /// Output only. The URL of the Database Transforms for the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub database_transforms_uri: std::string::String,

    /// Output only. The URL of the Graph Studio for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub graph_studio_uri: std::string::String,

    /// Output only. The URL of the Oracle Machine Learning (OML) Notebook for the
    /// Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub machine_learning_notebook_uri: std::string::String,

    /// Output only. The URL of Machine Learning user management the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub machine_learning_user_management_uri: std::string::String,

    /// Output only. The URL of the MongoDB API for the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub mongo_db_uri: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) URL of the Web Access for
    /// the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ords_uri: std::string::String,

    /// Output only. The URL of the Oracle SQL Developer Web for the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub sql_dev_web_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseConnectionUrls {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_uri][crate::model::AutonomousDatabaseConnectionUrls::apex_uri].
    pub fn set_apex_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_uri = v.into();
        self
    }

    /// Sets the value of [database_transforms_uri][crate::model::AutonomousDatabaseConnectionUrls::database_transforms_uri].
    pub fn set_database_transforms_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_transforms_uri = v.into();
        self
    }

    /// Sets the value of [graph_studio_uri][crate::model::AutonomousDatabaseConnectionUrls::graph_studio_uri].
    pub fn set_graph_studio_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.graph_studio_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_notebook_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_notebook_uri].
    pub fn set_machine_learning_notebook_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_notebook_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_user_management_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_user_management_uri].
    pub fn set_machine_learning_user_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_user_management_uri = v.into();
        self
    }

    /// Sets the value of [mongo_db_uri][crate::model::AutonomousDatabaseConnectionUrls::mongo_db_uri].
    pub fn set_mongo_db_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mongo_db_uri = v.into();
        self
    }

    /// Sets the value of [ords_uri][crate::model::AutonomousDatabaseConnectionUrls::ords_uri].
    pub fn set_ords_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_uri = v.into();
        self
    }

    /// Sets the value of [sql_dev_web_uri][crate::model::AutonomousDatabaseConnectionUrls::sql_dev_web_uri].
    pub fn set_sql_dev_web_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_dev_web_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionUrls {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionUrls"
    }
}

/// Autonomous Data Guard standby database details.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseStandbySummary>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseStandbySummary {
    /// Output only. The amount of time, in seconds, that the data of the standby
    /// database lags in comparison to the data of the primary database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lag_time_duration: std::option::Option<wkt::Duration>,

    /// Output only. The additional details about the current lifecycle state of
    /// the Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::State,

    /// Output only. The date and time the Autonomous Data Guard role was switched
    /// for the standby Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_guard_role_changed_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the Disaster Recovery role was switched for
    /// the standby Autonomous Database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disaster_recovery_role_changed_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseStandbySummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lag_time_duration][crate::model::AutonomousDatabaseStandbySummary::lag_time_duration].
    pub fn set_lag_time_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_time_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lag_time_duration][crate::model::AutonomousDatabaseStandbySummary::lag_time_duration].
    pub fn set_or_clear_lag_time_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_time_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseStandbySummary::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseStandbySummary::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::data_guard_role_changed_time].
    pub fn set_data_guard_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::data_guard_role_changed_time].
    pub fn set_or_clear_data_guard_role_changed_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::disaster_recovery_role_changed_time].
    pub fn set_disaster_recovery_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::disaster_recovery_role_changed_time].
    pub fn set_or_clear_disaster_recovery_role_changed_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseStandbySummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseStandbySummary"
    }
}

/// Details of scheduled operation.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/ScheduledOperationDetails>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScheduledOperationDetails {
    /// Output only. Day of week.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub day_of_week: gtype::model::DayOfWeek,

    /// Output only. Auto start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Output only. Auto stop time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stop_time: std::option::Option<gtype::model::TimeOfDay>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduledOperationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_week][crate::model::ScheduledOperationDetails::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScheduledOperationDetails::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ScheduledOperationDetails::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stop_time][crate::model::ScheduledOperationDetails::stop_time].
    pub fn set_stop_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.stop_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stop_time][crate::model::ScheduledOperationDetails::stop_time].
    pub fn set_or_clear_stop_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.stop_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ScheduledOperationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ScheduledOperationDetails"
    }
}

/// Details of the Autonomous Database character set resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseCharacterSet {
    /// Identifier. The name of the Autonomous Database Character Set resource in
    /// the following format:
    /// projects/{project}/locations/{region}/autonomousDatabaseCharacterSets/{autonomous_database_character_set}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. The character set type for the Autonomous Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub character_set_type: crate::model::autonomous_database_character_set::CharacterSetType,

    /// Output only. The character set name for the Autonomous Database which is
    /// the ID in the resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub character_set: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseCharacterSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseCharacterSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [character_set_type][crate::model::AutonomousDatabaseCharacterSet::character_set_type].
    pub fn set_character_set_type<
        T: std::convert::Into<crate::model::autonomous_database_character_set::CharacterSetType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.character_set_type = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseCharacterSet::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseCharacterSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseCharacterSet"
    }
}

/// Defines additional types related to [AutonomousDatabaseCharacterSet].
pub mod autonomous_database_character_set {
    #[allow(unused_imports)]
    use super::*;

    /// The type of character set an Autonomous Database can have.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CharacterSetType {
        /// Character set type is not specified.
        Unspecified,
        /// Character set type is set to database.
        Database,
        /// Character set type is set to national.
        National,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CharacterSetType::value] or
        /// [CharacterSetType::name].
        UnknownValue(character_set_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod character_set_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CharacterSetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::National => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHARACTER_SET_TYPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::National => std::option::Option::Some("NATIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CharacterSetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CharacterSetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CharacterSetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CharacterSetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "NATIONAL" => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CharacterSetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::National => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CharacterSetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CharacterSetType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseCharacterSet.CharacterSetType",
            ))
        }
    }
}

/// Details of the Autonomous Database Backup resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseBackup/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseBackup {
    /// Identifier. The name of the Autonomous Database Backup resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabaseBackups/{autonomous_database_backup}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. The name of the Autonomous Database resource for which the backup
    /// is being created. Format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub autonomous_database: std::string::String,

    /// Optional. User friendly name for the Backup. The name does not have to be
    /// unique.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Optional. Various properties of the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::AutonomousDatabaseBackupProperties>,

    /// Optional. labels or tags associated with the resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseBackup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseBackup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::AutonomousDatabaseBackup::autonomous_database].
    pub fn set_autonomous_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabaseBackup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabaseBackup::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseBackupProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::AutonomousDatabaseBackup::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseBackupProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabaseBackup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackup"
    }
}

/// Properties of the Autonomous Database Backup resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDatabaseBackupProperties {
    /// Output only. OCID of the Autonomous Database backup.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ocid: std::string::String,

    /// Optional. Retention period in days for the backup.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub retention_period_days: i32,

    /// Output only. The OCID of the compartment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub compartment_id: std::string::String,

    /// Output only. The quantity of data in the database, in terabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub database_size_tb: f32,

    /// Output only. A valid Oracle Database version for Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub db_version: std::string::String,

    /// Output only. Indicates if the backup is long term backup.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_long_term_backup: bool,

    /// Output only. Indicates if the backup is automatic or user initiated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_automatic_backup: bool,

    /// Output only. Indicates if the backup can be used to restore the Autonomous
    /// Database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_restorable: bool,

    /// Optional. The OCID of the key store of Oracle Vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub key_store_id: std::string::String,

    /// Optional. The wallet name for Oracle Key Vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub key_store_wallet: std::string::String,

    /// Optional. The OCID of the key container that is used as the master
    /// encryption key in database transparent data encryption (TDE) operations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub kms_key_id: std::string::String,

    /// Optional. The OCID of the key container version that is used in database
    /// transparent data encryption (TDE) operations KMS Key can have multiple key
    /// versions. If none is specified, the current key version (latest) of the Key
    /// Id is used for the operation. Autonomous Database Serverless does not use
    /// key versions, hence is not applicable for Autonomous Database Serverless
    /// instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub kms_key_version_id: std::string::String,

    /// Output only. Additional information about the current lifecycle state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub lifecycle_details: std::string::String,

    /// Output only. The lifecycle state of the backup.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub lifecycle_state: crate::model::autonomous_database_backup_properties::State,

    /// Output only. The backup size in terabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub size_tb: f32,

    /// Output only. Timestamp until when the backup will be available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub available_till_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The type of the backup.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::autonomous_database_backup_properties::Type,

    /// Optional. The OCID of the vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub vault_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseBackupProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [retention_period_days][crate::model::AutonomousDatabaseBackupProperties::retention_period_days].
    pub fn set_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_period_days = v.into();
        self
    }

    /// Sets the value of [compartment_id][crate::model::AutonomousDatabaseBackupProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [database_size_tb][crate::model::AutonomousDatabaseBackupProperties::database_size_tb].
    pub fn set_database_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.database_size_tb = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseBackupProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_long_term_backup][crate::model::AutonomousDatabaseBackupProperties::is_long_term_backup].
    pub fn set_is_long_term_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_long_term_backup = v.into();
        self
    }

    /// Sets the value of [is_automatic_backup][crate::model::AutonomousDatabaseBackupProperties::is_automatic_backup].
    pub fn set_is_automatic_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_automatic_backup = v.into();
        self
    }

    /// Sets the value of [is_restorable][crate::model::AutonomousDatabaseBackupProperties::is_restorable].
    pub fn set_is_restorable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_restorable = v.into();
        self
    }

    /// Sets the value of [key_store_id][crate::model::AutonomousDatabaseBackupProperties::key_store_id].
    pub fn set_key_store_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_store_id = v.into();
        self
    }

    /// Sets the value of [key_store_wallet][crate::model::AutonomousDatabaseBackupProperties::key_store_wallet].
    pub fn set_key_store_wallet<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_store_wallet = v.into();
        self
    }

    /// Sets the value of [kms_key_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_id].
    pub fn set_kms_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_id = v.into();
        self
    }

    /// Sets the value of [kms_key_version_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_version_id].
    pub fn set_kms_key_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_id = v.into();
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseBackupProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::AutonomousDatabaseBackupProperties::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [size_tb][crate::model::AutonomousDatabaseBackupProperties::size_tb].
    pub fn set_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.size_tb = v.into();
        self
    }

    /// Sets the value of [available_till_time][crate::model::AutonomousDatabaseBackupProperties::available_till_time].
    pub fn set_available_till_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_till_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_till_time][crate::model::AutonomousDatabaseBackupProperties::available_till_time].
    pub fn set_or_clear_available_till_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_till_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::AutonomousDatabaseBackupProperties::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::AutonomousDatabaseBackupProperties::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::AutonomousDatabaseBackupProperties::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::AutonomousDatabaseBackupProperties::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AutonomousDatabaseBackupProperties::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseBackupProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties"
    }
}

/// Defines additional types related to [AutonomousDatabaseBackupProperties].
pub mod autonomous_database_backup_properties {
    #[allow(unused_imports)]
    use super::*;

    /// // The various lifecycle states of the Autonomous Database Backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in creating state.
        Creating,
        /// Indicates that the resource is in active state.
        Active,
        /// Indicates that the resource is in deleting state.
        Deleting,
        /// Indicates that the resource is in deleted state.
        Deleted,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource is in updating state.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Deleted => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(6),
                Self::Updating => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Deleted,
                6 => Self::Failed,
                7 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "FAILED" => Self::Failed,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Deleted => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(6),
                Self::Updating => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties.State",
            ))
        }
    }

    /// The type of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default unspecified value.
        Unspecified,
        /// Incremental backups.
        Incremental,
        /// Full backups.
        Full,
        /// Long term backups.
        LongTerm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incremental => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::LongTerm => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::LongTerm => std::option::Option::Some("LONG_TERM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incremental,
                2 => Self::Full,
                3 => Self::LongTerm,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INCREMENTAL" => Self::Incremental,
                "FULL" => Self::Full,
                "LONG_TERM" => Self::LongTerm,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incremental => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::LongTerm => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties.Type",
            ))
        }
    }
}

/// Details of the Autonomous Database version.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDbVersionSummary/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutonomousDbVersion {
    /// Identifier. The name of the Autonomous Database Version resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDbVersions/{autonomous_db_version}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. An Oracle Database version for Autonomous Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub version: std::string::String,

    /// Output only. The Autonomous Database workload type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub db_workload: crate::model::DBWorkload,

    /// Output only. A URL that points to a detailed description of the Autonomous
    /// Database version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub workload_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDbVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDbVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AutonomousDbVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDbVersion::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [workload_uri][crate::model::AutonomousDbVersion::workload_uri].
    pub fn set_workload_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDbVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDbVersion"
    }
}

/// The CustomerContact reference as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/CustomerContact>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerContact {
    /// Required. The email address used by Oracle to send notifications regarding
    /// databases and infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub email: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerContact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::CustomerContact::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for CustomerContact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CustomerContact"
    }
}

/// Details of the database node resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbNode/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbNode {
    /// Identifier. The name of the database node resource in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}/dbNodes/{db_node}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Various properties of the database node.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::DbNodeProperties>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbNode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbNode::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbNode::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbNodeProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbNode::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbNodeProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbNode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNode"
    }
}

/// Various properties and settings associated with Db node.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbNodeProperties {
    /// Output only. OCID of database node.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ocid: std::string::String,

    /// Optional. OCPU count per database node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub ocpu_count: i32,

    /// Memory allocated in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub memory_size_gb: i32,

    /// Optional. Local storage per database node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub db_node_storage_size_gb: i32,

    /// Optional. Database server OCID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub db_server_ocid: std::string::String,

    /// Optional. DNS
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub hostname: std::string::String,

    /// Output only. State of the database node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::db_node_properties::State,

    /// Total CPU core count of the database node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub total_cpu_core_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbNodeProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbNodeProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbNodeProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbNodeProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbNodeProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_server_ocid][crate::model::DbNodeProperties::db_server_ocid].
    pub fn set_db_server_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_server_ocid = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::DbNodeProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbNodeProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_node_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [total_cpu_core_count][crate::model::DbNodeProperties::total_cpu_core_count].
    pub fn set_total_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_cpu_core_count = v.into();
        self
    }
}

impl wkt::message::Message for DbNodeProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNodeProperties"
    }
}

/// Defines additional types related to [DbNodeProperties].
pub mod db_node_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in stopping state.
        Stopping,
        /// Indicates that the resource is in stopped state.
        Stopped,
        /// Indicates that the resource is in starting state.
        Starting,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Stopped => std::option::Option::Some(5),
                Self::Starting => std::option::Option::Some(6),
                Self::Terminating => std::option::Option::Some(7),
                Self::Terminated => std::option::Option::Some(8),
                Self::Failed => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Stopping,
                5 => Self::Stopped,
                6 => Self::Starting,
                7 => Self::Terminating,
                8 => Self::Terminated,
                9 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "STARTING" => Self::Starting,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Stopped => serializer.serialize_i32(5),
                Self::Starting => serializer.serialize_i32(6),
                Self::Terminating => serializer.serialize_i32(7),
                Self::Terminated => serializer.serialize_i32(8),
                Self::Failed => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.DbNodeProperties.State",
            ))
        }
    }
}

/// Details of the database server resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbServer/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbServer {
    /// Identifier. The name of the database server resource with the format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}/dbServers/{db_server}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Optional. Various properties of the database server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::DbServerProperties>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbServer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbServer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DbServer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbServer::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbServerProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbServer::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbServerProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbServer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServer"
    }
}

/// Various properties and settings associated with Exadata database server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbServerProperties {
    /// Output only. OCID of database server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ocid: std::string::String,

    /// Optional. OCPU count per database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub ocpu_count: i32,

    /// Optional. Maximum OCPU count per database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_ocpu_count: i32,

    /// Optional. Memory allocated in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub memory_size_gb: i32,

    /// Optional. Maximum memory allocated in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_memory_size_gb: i32,

    /// Optional. Local storage per VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub db_node_storage_size_gb: i32,

    /// Optional. Maximum local storage per VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_db_node_storage_size_gb: i32,

    /// Optional. Vm count per database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub vm_count: i32,

    /// Output only. State of the database server.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::db_server_properties::State,

    /// Output only. OCID of database nodes associated with the database server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub db_node_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbServerProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbServerProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbServerProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [max_ocpu_count][crate::model::DbServerProperties::max_ocpu_count].
    pub fn set_max_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbServerProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_size_gb][crate::model::DbServerProperties::max_memory_size_gb].
    pub fn set_max_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbServerProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::DbServerProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [vm_count][crate::model::DbServerProperties::vm_count].
    pub fn set_vm_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbServerProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_server_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [db_node_ids][crate::model::DbServerProperties::db_node_ids].
    pub fn set_db_node_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_node_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DbServerProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServerProperties"
    }
}

/// Defines additional types related to [DbServerProperties].
pub mod db_server_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database server.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in creating state.
        Creating,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in unavailable state.
        Unavailable,
        /// Indicates that the resource is in deleting state.
        Deleting,
        /// Indicates that the resource is in deleted state.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Unavailable => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Deleted => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Available,
                3 => Self::Unavailable,
                4 => Self::Deleting,
                5 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "AVAILABLE" => Self::Available,
                "UNAVAILABLE" => Self::Unavailable,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Unavailable => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Deleted => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.DbServerProperties.State",
            ))
        }
    }
}

/// Details of the Database System Shapes resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystemShapeSummary/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DbSystemShape {
    /// Identifier. The name of the Database System Shape resource with the format:
    /// projects/{project}/locations/{region}/dbSystemShapes/{db_system_shape}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. shape
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub shape: std::string::String,

    /// Optional. Minimum number of database servers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub min_node_count: i32,

    /// Optional. Maximum number of database servers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_node_count: i32,

    /// Optional. Minimum number of storage servers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub min_storage_count: i32,

    /// Optional. Maximum number of storage servers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_storage_count: i32,

    /// Optional. Number of cores per node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub available_core_count_per_node: i32,

    /// Optional. Memory per database server node in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub available_memory_per_node_gb: i32,

    /// Optional. Storage per storage server in terabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub available_data_storage_tb: i32,

    /// Optional. Minimum core count per node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub min_core_count_per_node: i32,

    /// Optional. Minimum memory per node in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub min_memory_per_node_gb: i32,

    /// Optional. Minimum node storage per database server in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub min_db_node_storage_per_node_gb: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystemShape {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbSystemShape::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::DbSystemShape::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [min_node_count][crate::model::DbSystemShape::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::DbSystemShape::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }

    /// Sets the value of [min_storage_count][crate::model::DbSystemShape::min_storage_count].
    pub fn set_min_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_storage_count = v.into();
        self
    }

    /// Sets the value of [max_storage_count][crate::model::DbSystemShape::max_storage_count].
    pub fn set_max_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_storage_count = v.into();
        self
    }

    /// Sets the value of [available_core_count_per_node][crate::model::DbSystemShape::available_core_count_per_node].
    pub fn set_available_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [available_memory_per_node_gb][crate::model::DbSystemShape::available_memory_per_node_gb].
    pub fn set_available_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [available_data_storage_tb][crate::model::DbSystemShape::available_data_storage_tb].
    pub fn set_available_data_storage_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [min_core_count_per_node][crate::model::DbSystemShape::min_core_count_per_node].
    pub fn set_min_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [min_memory_per_node_gb][crate::model::DbSystemShape::min_memory_per_node_gb].
    pub fn set_min_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [min_db_node_storage_per_node_gb][crate::model::DbSystemShape::min_db_node_storage_per_node_gb].
    pub fn set_min_db_node_storage_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_db_node_storage_per_node_gb = v.into();
        self
    }
}

impl wkt::message::Message for DbSystemShape {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemShape"
    }
}

/// Details of the Entitlement resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entitlement {
    /// Identifier. The name of the Entitlement resource with the format:
    /// projects/{project}/locations/{region}/entitlements/{entitlement}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Details of the OCI Cloud Account.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_account_details: std::option::Option<crate::model::CloudAccountDetails>,

    /// Output only. Google Cloud Marketplace order ID (aka entitlement ID)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub entitlement_id: std::string::String,

    /// Output only. Entitlement State.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::entitlement::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entitlement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entitlement::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cloud_account_details][crate::model::Entitlement::cloud_account_details].
    pub fn set_cloud_account_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudAccountDetails>,
    {
        self.cloud_account_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_account_details][crate::model::Entitlement::cloud_account_details].
    pub fn set_or_clear_cloud_account_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudAccountDetails>,
    {
        self.cloud_account_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entitlement_id][crate::model::Entitlement::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Entitlement::state].
    pub fn set_state<T: std::convert::Into<crate::model::entitlement::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Entitlement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.Entitlement"
    }
}

/// Defines additional types related to [Entitlement].
pub mod entitlement {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Account not linked.
        AccountNotLinked,
        /// Account is linked but not active.
        AccountNotActive,
        /// Entitlement and Account are active.
        Active,
        /// Account is suspended.
        AccountSuspended,
        /// Entitlement is not approved in private marketplace.
        NotApprovedInPrivateMarketplace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AccountNotLinked => std::option::Option::Some(1),
                Self::AccountNotActive => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::AccountSuspended => std::option::Option::Some(4),
                Self::NotApprovedInPrivateMarketplace => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::AccountNotLinked => std::option::Option::Some("ACCOUNT_NOT_LINKED"),
                Self::AccountNotActive => std::option::Option::Some("ACCOUNT_NOT_ACTIVE"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::AccountSuspended => std::option::Option::Some("ACCOUNT_SUSPENDED"),
                Self::NotApprovedInPrivateMarketplace => {
                    std::option::Option::Some("NOT_APPROVED_IN_PRIVATE_MARKETPLACE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AccountNotLinked,
                2 => Self::AccountNotActive,
                3 => Self::Active,
                4 => Self::AccountSuspended,
                5 => Self::NotApprovedInPrivateMarketplace,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACCOUNT_NOT_LINKED" => Self::AccountNotLinked,
                "ACCOUNT_NOT_ACTIVE" => Self::AccountNotActive,
                "ACTIVE" => Self::Active,
                "ACCOUNT_SUSPENDED" => Self::AccountSuspended,
                "NOT_APPROVED_IN_PRIVATE_MARKETPLACE" => Self::NotApprovedInPrivateMarketplace,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AccountNotLinked => serializer.serialize_i32(1),
                Self::AccountNotActive => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::AccountSuspended => serializer.serialize_i32(4),
                Self::NotApprovedInPrivateMarketplace => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.Entitlement.State",
            ))
        }
    }
}

/// Details of the OCI Cloud Account.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudAccountDetails {
    /// Output only. OCI account name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cloud_account: std::string::String,

    /// Output only. OCI account home region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cloud_account_home_region: std::string::String,

    /// Output only. URL to link an existing account.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub link_existing_account_uri: std::option::Option<std::string::String>,

    /// Output only. URL to create a new account and link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub account_creation_uri: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudAccountDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_account][crate::model::CloudAccountDetails::cloud_account].
    pub fn set_cloud_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_account = v.into();
        self
    }

    /// Sets the value of [cloud_account_home_region][crate::model::CloudAccountDetails::cloud_account_home_region].
    pub fn set_cloud_account_home_region<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_account_home_region = v.into();
        self
    }

    /// Sets the value of [link_existing_account_uri][crate::model::CloudAccountDetails::link_existing_account_uri].
    pub fn set_link_existing_account_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.link_existing_account_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [link_existing_account_uri][crate::model::CloudAccountDetails::link_existing_account_uri].
    pub fn set_or_clear_link_existing_account_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.link_existing_account_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_creation_uri][crate::model::CloudAccountDetails::account_creation_uri].
    pub fn set_account_creation_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.account_creation_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_creation_uri][crate::model::CloudAccountDetails::account_creation_uri].
    pub fn set_or_clear_account_creation_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.account_creation_uri = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudAccountDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudAccountDetails"
    }
}

/// Represents CloudExadataInfrastructure resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudExadataInfrastructure/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudExadataInfrastructure {
    /// Identifier. The name of the Exadata Infrastructure resource with the
    /// format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Optional. Google Cloud Platform location where Oracle Exadata is hosted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub gcp_oracle_zone: std::string::String,

    /// Output only. Entitlement ID of the private offer against which this
    /// infrastructure resource is provisioned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub entitlement_id: std::string::String,

    /// Optional. Various properties of the infra.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::CloudExadataInfrastructureProperties>,

    /// Optional. Labels or tags associated with the resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the Exadata Infrastructure was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudExadataInfrastructure {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudExadataInfrastructure::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudExadataInfrastructure::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudExadataInfrastructure::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::CloudExadataInfrastructure::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudExadataInfrastructure::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructureProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::CloudExadataInfrastructure::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructureProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CloudExadataInfrastructure::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudExadataInfrastructure::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudExadataInfrastructure::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructure {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructure"
    }
}

/// Various properties of Exadata Infrastructure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudExadataInfrastructureProperties {
    /// Output only. OCID of created infra.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Exadata Infrastructure.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub compute_count: i32,

    /// Optional. The number of Cloud Exadata storage servers for the Exadata
    /// Infrastructure.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub storage_count: i32,

    /// Optional. The total storage allocated to the Exadata Infrastructure
    /// resource, in gigabytes (GB).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub total_storage_size_gb: i32,

    /// Output only. The available storage can be allocated to the Exadata
    /// Infrastructure resource, in gigabytes (GB).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub available_storage_size_gb: i32,

    /// Optional. Maintenance window for repair.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Output only. The current lifecycle state of the Exadata Infrastructure.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::cloud_exadata_infrastructure_properties::State,

    /// Required. The shape of the Exadata Infrastructure. The shape determines the
    /// amount of CPU, storage, and memory resources allocated to the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub shape: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub oci_url: std::string::String,

    /// Output only. The number of enabled CPU cores.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub cpu_count: i32,

    /// Output only. The total number of CPU cores available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_cpu_count: i32,

    /// Output only. The memory allocated in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub memory_size_gb: i32,

    /// Output only. The total memory available in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_memory_gb: i32,

    /// Output only. The local node storage allocated in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub db_node_storage_size_gb: i32,

    /// Output only. The total local node storage available in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_db_node_storage_size_gb: i32,

    /// Output only. Size, in terabytes, of the DATA disk group.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F64>")]
    pub data_storage_size_tb: f64,

    /// Output only. The total available DATA disk group size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F64>")]
    pub max_data_storage_tb: f64,

    /// Output only. The requested number of additional storage servers activated
    /// for the Exadata Infrastructure.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub activated_storage_count: i32,

    /// Output only. The requested number of additional storage servers for the
    /// Exadata Infrastructure.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub additional_storage_count: i32,

    /// Output only. The software version of the database servers (dom0) in the
    /// Exadata Infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub db_server_version: std::string::String,

    /// Output only. The software version of the storage servers (cells) in the
    /// Exadata Infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub storage_server_version: std::string::String,

    /// Output only. The OCID of the next maintenance run.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_maintenance_run_id: std::string::String,

    /// Output only. The time when the next maintenance run will occur.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the next security maintenance run will occur.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_security_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of customer contacts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Output only. The monthly software version of the storage servers (cells)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub monthly_storage_server_version: std::string::String,

    /// Output only. The monthly software version of the database servers (dom0)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub monthly_db_server_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudExadataInfrastructureProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudExadataInfrastructureProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::CloudExadataInfrastructureProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [storage_count][crate::model::CloudExadataInfrastructureProperties::storage_count].
    pub fn set_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_count = v.into();
        self
    }

    /// Sets the value of [total_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::total_storage_size_gb].
    pub fn set_total_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [available_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::available_storage_size_gb].
    pub fn set_available_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::CloudExadataInfrastructureProperties::maintenance_window].
    pub fn set_maintenance_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_window][crate::model::CloudExadataInfrastructureProperties::maintenance_window].
    pub fn set_or_clear_maintenance_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CloudExadataInfrastructureProperties::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::cloud_exadata_infrastructure_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudExadataInfrastructureProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudExadataInfrastructureProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::CloudExadataInfrastructureProperties::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [max_cpu_count][crate::model::CloudExadataInfrastructureProperties::max_cpu_count].
    pub fn set_max_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudExadataInfrastructureProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_gb][crate::model::CloudExadataInfrastructureProperties::max_memory_gb].
    pub fn set_max_memory_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudExadataInfrastructureProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [max_data_storage_tb][crate::model::CloudExadataInfrastructureProperties::max_data_storage_tb].
    pub fn set_max_data_storage_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [activated_storage_count][crate::model::CloudExadataInfrastructureProperties::activated_storage_count].
    pub fn set_activated_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.activated_storage_count = v.into();
        self
    }

    /// Sets the value of [additional_storage_count][crate::model::CloudExadataInfrastructureProperties::additional_storage_count].
    pub fn set_additional_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.additional_storage_count = v.into();
        self
    }

    /// Sets the value of [db_server_version][crate::model::CloudExadataInfrastructureProperties::db_server_version].
    pub fn set_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_server_version = v.into();
        self
    }

    /// Sets the value of [storage_server_version][crate::model::CloudExadataInfrastructureProperties::storage_server_version].
    pub fn set_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_server_version = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_id][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_id].
    pub fn set_next_maintenance_run_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_maintenance_run_id = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_time].
    pub fn set_next_maintenance_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_maintenance_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_time].
    pub fn set_or_clear_next_maintenance_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_maintenance_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_security_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_security_maintenance_run_time].
    pub fn set_next_security_maintenance_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_security_maintenance_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_security_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_security_maintenance_run_time].
    pub fn set_or_clear_next_security_maintenance_run_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_security_maintenance_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_contacts][crate::model::CloudExadataInfrastructureProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [monthly_storage_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_storage_server_version].
    pub fn set_monthly_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_storage_server_version = v.into();
        self
    }

    /// Sets the value of [monthly_db_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_db_server_version].
    pub fn set_monthly_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_db_server_version = v.into();
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructureProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructureProperties"
    }
}

/// Defines additional types related to [CloudExadataInfrastructureProperties].
pub mod cloud_exadata_infrastructure_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the Exadata Infrastructure.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// The Exadata Infrastructure is being provisioned.
        Provisioning,
        /// The Exadata Infrastructure is available for use.
        Available,
        /// The Exadata Infrastructure is being updated.
        Updating,
        /// The Exadata Infrastructure is being terminated.
        Terminating,
        /// The Exadata Infrastructure is terminated.
        Terminated,
        /// The Exadata Infrastructure is in failed state.
        Failed,
        /// The Exadata Infrastructure is in maintenance.
        MaintenanceInProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::MaintenanceInProgress => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::MaintenanceInProgress => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.CloudExadataInfrastructureProperties.State",
            ))
        }
    }
}

/// Maintenance window as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/MaintenanceWindow>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Optional. The maintenance window scheduling preference.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub preference: crate::model::maintenance_window::MaintenanceWindowPreference,

    /// Optional. Months during the year when maintenance should be performed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub months: std::vec::Vec<gtype::model::Month>,

    /// Optional. Weeks during the month when maintenance should be performed.
    /// Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a
    /// duration of 7 days. Weeks start and end based on calendar dates, not days
    /// of the week.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<wkt::internal::I32>>")]
    pub weeks_of_month: std::vec::Vec<i32>,

    /// Optional. Days during the week when maintenance should be performed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. The window of hours during the day when maintenance should be
    /// performed. The window is a 4 hour slot. Valid values are:
    /// 0 - represents time slot 0:00 - 3:59 UTC
    /// 4 - represents time slot 4:00 - 7:59 UTC
    /// 8 - represents time slot 8:00 - 11:59 UTC
    /// 12 - represents time slot 12:00 - 15:59 UTC
    /// 16 - represents time slot 16:00 - 19:59 UTC
    /// 20 - represents time slot 20:00 - 23:59 UTC
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<wkt::internal::I32>>")]
    pub hours_of_day: std::vec::Vec<i32>,

    /// Optional. Lead time window allows user to set a lead time to prepare for a
    /// down time. The lead time is in weeks and valid value is between 1 to 4.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub lead_time_week: i32,

    /// Optional. Cloud CloudExadataInfrastructure node patching method, either
    /// "ROLLING" or "NONROLLING". Default value is ROLLING.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub patching_mode: crate::model::maintenance_window::PatchingMode,

    /// Optional. Determines the amount of time the system will wait before the
    /// start of each database server patching operation. Custom action timeout is
    /// in minutes and valid value is between 15 to 120 (inclusive).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub custom_action_timeout_mins: i32,

    /// Optional. If true, enables the configuration of a custom action timeout
    /// (waiting period) between database server patching operations.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_custom_action_timeout_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preference][crate::model::MaintenanceWindow::preference].
    pub fn set_preference<
        T: std::convert::Into<crate::model::maintenance_window::MaintenanceWindowPreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preference = v.into();
        self
    }

    /// Sets the value of [months][crate::model::MaintenanceWindow::months].
    pub fn set_months<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::Month>,
    {
        use std::iter::Iterator;
        self.months = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [weeks_of_month][crate::model::MaintenanceWindow::weeks_of_month].
    pub fn set_weeks_of_month<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.weeks_of_month = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [days_of_week][crate::model::MaintenanceWindow::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hours_of_day][crate::model::MaintenanceWindow::hours_of_day].
    pub fn set_hours_of_day<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.hours_of_day = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [lead_time_week][crate::model::MaintenanceWindow::lead_time_week].
    pub fn set_lead_time_week<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lead_time_week = v.into();
        self
    }

    /// Sets the value of [patching_mode][crate::model::MaintenanceWindow::patching_mode].
    pub fn set_patching_mode<
        T: std::convert::Into<crate::model::maintenance_window::PatchingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patching_mode = v.into();
        self
    }

    /// Sets the value of [custom_action_timeout_mins][crate::model::MaintenanceWindow::custom_action_timeout_mins].
    pub fn set_custom_action_timeout_mins<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.custom_action_timeout_mins = v.into();
        self
    }

    /// Sets the value of [is_custom_action_timeout_enabled][crate::model::MaintenanceWindow::is_custom_action_timeout_enabled].
    pub fn set_is_custom_action_timeout_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_custom_action_timeout_enabled = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.MaintenanceWindow"
    }
}

/// Defines additional types related to [MaintenanceWindow].
pub mod maintenance_window {
    #[allow(unused_imports)]
    use super::*;

    /// Maintenance window preference.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceWindowPreference {
        /// Default unspecified value.
        Unspecified,
        /// Custom preference.
        CustomPreference,
        /// No preference.
        NoPreference,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceWindowPreference::value] or
        /// [MaintenanceWindowPreference::name].
        UnknownValue(maintenance_window_preference::UnknownValue),
    }

    #[doc(hidden)]
    pub mod maintenance_window_preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaintenanceWindowPreference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CustomPreference => std::option::Option::Some(1),
                Self::NoPreference => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED")
                }
                Self::CustomPreference => std::option::Option::Some("CUSTOM_PREFERENCE"),
                Self::NoPreference => std::option::Option::Some("NO_PREFERENCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaintenanceWindowPreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaintenanceWindowPreference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaintenanceWindowPreference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CustomPreference,
                2 => Self::NoPreference,
                _ => Self::UnknownValue(maintenance_window_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaintenanceWindowPreference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOM_PREFERENCE" => Self::CustomPreference,
                "NO_PREFERENCE" => Self::NoPreference,
                _ => Self::UnknownValue(maintenance_window_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaintenanceWindowPreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CustomPreference => serializer.serialize_i32(1),
                Self::NoPreference => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceWindowPreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<MaintenanceWindowPreference>::new(
                    ".google.cloud.oracledatabase.v1.MaintenanceWindow.MaintenanceWindowPreference",
                ),
            )
        }
    }

    /// Patching mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PatchingMode {
        /// Default unspecified value.
        Unspecified,
        /// Updates the Cloud Exadata database server hosts in a rolling fashion.
        Rolling,
        /// The non-rolling maintenance method first updates your storage servers at
        /// the same time, then your database servers at the same time.
        NonRolling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PatchingMode::value] or
        /// [PatchingMode::name].
        UnknownValue(patching_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod patching_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PatchingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rolling => std::option::Option::Some(1),
                Self::NonRolling => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PATCHING_MODE_UNSPECIFIED"),
                Self::Rolling => std::option::Option::Some("ROLLING"),
                Self::NonRolling => std::option::Option::Some("NON_ROLLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PatchingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PatchingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PatchingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rolling,
                2 => Self::NonRolling,
                _ => Self::UnknownValue(patching_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PatchingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PATCHING_MODE_UNSPECIFIED" => Self::Unspecified,
                "ROLLING" => Self::Rolling,
                "NON_ROLLING" => Self::NonRolling,
                _ => Self::UnknownValue(patching_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PatchingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rolling => serializer.serialize_i32(1),
                Self::NonRolling => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PatchingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PatchingMode>::new(
                ".google.cloud.oracledatabase.v1.MaintenanceWindow.PatchingMode",
            ))
        }
    }
}

/// Details of the Oracle Grid Infrastructure (GI) version resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiVersionSummary/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GiVersion {
    /// Identifier. The name of the Oracle Grid Infrastructure (GI) version
    /// resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_versions}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GiVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GiVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GiVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GiVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GiVersion"
    }
}

/// Metadata for a given [Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Output only. Google Cloud Platform Oracle zones in a location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub gcp_oracle_zones: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_oracle_zones][crate::model::LocationMetadata::gcp_oracle_zones].
    pub fn set_gcp_oracle_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.gcp_oracle_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.LocationMetadata"
    }
}

/// The request for `CloudExadataInfrastructures.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Exadata infrastructures will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudExadataInfrastructuresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudExadataInfrastructuresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudExadataInfrastructuresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudExadataInfrastructuresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresRequest"
    }
}

/// The response for `CloudExadataInfrastructures.list`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresResponse {
    /// The list of Exadata Infrastructures.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub cloud_exadata_infrastructures: std::vec::Vec<crate::model::CloudExadataInfrastructure>,

    /// A token for fetching next page of response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudExadataInfrastructuresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_exadata_infrastructures][crate::model::ListCloudExadataInfrastructuresResponse::cloud_exadata_infrastructures].
    pub fn set_cloud_exadata_infrastructures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        use std::iter::Iterator;
        self.cloud_exadata_infrastructures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudExadataInfrastructuresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudExadataInfrastructuresResponse {
    type PageItem = crate::model::CloudExadataInfrastructure;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_exadata_infrastructures
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `CloudExadataInfrastructure.Get`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudExadataInfrastructure.Create`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCloudExadataInfrastructureRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID of the Exadata Infrastructure to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cloud_exadata_infrastructure_id: std::string::String,

    /// Required. Details of the Exadata Infrastructure instance to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_exadata_infrastructure: std::option::Option<crate::model::CloudExadataInfrastructure>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudExadataInfrastructureRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure_id][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure_id].
    pub fn set_cloud_exadata_infrastructure_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_exadata_infrastructure_id = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure].
    pub fn set_cloud_exadata_infrastructure<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        self.cloud_exadata_infrastructure = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_exadata_infrastructure][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure].
    pub fn set_or_clear_cloud_exadata_infrastructure<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        self.cloud_exadata_infrastructure = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudExadataInfrastructure.Delete`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, all VM clusters for this Exadata Infrastructure
    /// will be deleted. An Exadata Infrastructure can only be deleted once all its
    /// VM clusters have been deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudExadataInfrastructureRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudVmCluster.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudVmClustersRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The number of VM clusters to return.
    /// If unspecified, at most 50 VM clusters will be returned.
    /// The maximum value is 1,000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying the page of results the server returns.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudVmClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudVmClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudVmClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudVmClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloudVmClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersRequest"
    }
}

/// The response for `CloudVmCluster.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloudVmClustersResponse {
    /// The list of VM Clusters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub cloud_vm_clusters: std::vec::Vec<crate::model::CloudVmCluster>,

    /// A token to fetch the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudVmClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_vm_clusters][crate::model::ListCloudVmClustersResponse::cloud_vm_clusters].
    pub fn set_cloud_vm_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudVmCluster>,
    {
        use std::iter::Iterator;
        self.cloud_vm_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudVmClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudVmClustersResponse {
    type PageItem = crate::model::CloudVmCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_vm_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `CloudVmCluster.Get`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudVmClusterRequest"
    }
}

/// The request for `CloudVmCluster.Create`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCloudVmClusterRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID of the VM Cluster to create. This value is restricted
    /// to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cloud_vm_cluster_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_vm_cluster: std::option::Option<crate::model::CloudVmCluster>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudVmClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster_id][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster_id].
    pub fn set_cloud_vm_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_vm_cluster_id = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster].
    pub fn set_cloud_vm_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmCluster>,
    {
        self.cloud_vm_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_vm_cluster][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster].
    pub fn set_or_clear_cloud_vm_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmCluster>,
    {
        self.cloud_vm_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudVmClusterRequest"
    }
}

/// The request for `CloudVmCluster.Delete`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, all child resources for the VM Cluster will be
    /// deleted. A VM Cluster can only be deleted once all its child resources have
    /// been deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudVmClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudVmClusterRequest"
    }
}

/// The request for `Entitlement.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitlementsRequest {
    /// Required. The parent value for the entitlement in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 entitlements will be returned.
    /// The maximum value is 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsRequest"
    }
}

/// The response for `Entitlement.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitlementsResponse {
    /// The list of Entitlements
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitlements][crate::model::ListEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `DbServer.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbServersRequest {
    /// Required. The parent value for database server in the following format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloudExadataInfrastructure}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 db servers will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbServersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbServersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbServersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersRequest"
    }
}

/// The response for `DbServer.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbServersResponse {
    /// The list of database servers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub db_servers: std::vec::Vec<crate::model::DbServer>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_servers][crate::model::ListDbServersResponse::db_servers].
    pub fn set_db_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbServer>,
    {
        use std::iter::Iterator;
        self.db_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbServersResponse {
    type PageItem = crate::model::DbServer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_servers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `DbNode.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbNodesRequest {
    /// Required. The parent value for database node in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloudVmCluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 db nodes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the node should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbNodesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbNodesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbNodesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbNodesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbNodesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesRequest"
    }
}

/// The response for `DbNode.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbNodesResponse {
    /// The list of DB Nodes
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub db_nodes: std::vec::Vec<crate::model::DbNode>,

    /// A token identifying a page of results the node should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbNodesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_nodes][crate::model::ListDbNodesResponse::db_nodes].
    pub fn set_db_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbNode>,
    {
        use std::iter::Iterator;
        self.db_nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbNodesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbNodesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbNodesResponse {
    type PageItem = crate::model::DbNode;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_nodes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `GiVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGiVersionsRequest {
    /// Required. The parent value for Grid Infrastructure Version in the following
    /// format: Format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Oracle Grid Infrastructure (GI) versions
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// reset to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGiVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGiVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGiVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGiVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGiVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsRequest"
    }
}

/// The response for `GiVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGiVersionsResponse {
    /// The list of Oracle Grid Infrastructure (GI) versions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub gi_versions: std::vec::Vec<crate::model::GiVersion>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGiVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gi_versions][crate::model::ListGiVersionsResponse::gi_versions].
    pub fn set_gi_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GiVersion>,
    {
        use std::iter::Iterator;
        self.gi_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGiVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGiVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGiVersionsResponse {
    type PageItem = crate::model::GiVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.gi_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `DbSystemShape.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbSystemShapesRequest {
    /// Required. The parent value for Database System Shapes in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 database system shapes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemShapesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbSystemShapesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbSystemShapesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbSystemShapesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesRequest"
    }
}

/// The response for `DbSystemShape.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDbSystemShapesResponse {
    /// The list of Database System shapes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub db_system_shapes: std::vec::Vec<crate::model::DbSystemShape>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemShapesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_system_shapes][crate::model::ListDbSystemShapesResponse::db_system_shapes].
    pub fn set_db_system_shapes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbSystemShape>,
    {
        use std::iter::Iterator;
        self.db_system_shapes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbSystemShapesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbSystemShapesResponse {
    type PageItem = crate::model::DbSystemShape;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_system_shapes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verb: std::string::String,

    /// Output only. The status of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub api_version: std::string::String,

    /// Output only. An estimated percentage of the operation that has been
    /// completed at a given moment of time, between 0 and 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F64>")]
    pub percent_complete: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [percent_complete][crate::model::OperationMetadata::percent_complete].
    pub fn set_percent_complete<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.percent_complete = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.OperationMetadata"
    }
}

/// The request for `AutonomousDatabase.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabasesRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous Database will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutonomousDatabasesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesRequest"
    }
}

/// The response for `AutonomousDatabase.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabasesResponse {
    /// The list of Autonomous Databases.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub autonomous_databases: std::vec::Vec<crate::model::AutonomousDatabase>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_databases][crate::model::ListAutonomousDatabasesResponse::autonomous_databases].
    pub fn set_autonomous_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        use std::iter::Iterator;
        self.autonomous_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabasesResponse {
    type PageItem = crate::model::AutonomousDatabase;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `AutonomousDatabase.Get`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Create`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAutonomousDatabaseRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID of the Autonomous Database to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub autonomous_database_id: std::string::String,

    /// Required. The Autonomous Database being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autonomous_database: std::option::Option<crate::model::AutonomousDatabase>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutonomousDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [autonomous_database_id][crate::model::CreateAutonomousDatabaseRequest::autonomous_database_id].
    pub fn set_autonomous_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database_id = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::CreateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_autonomous_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autonomous_database][crate::model::CreateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_or_clear_autonomous_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Delete`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAutonomousDatabaseRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Restore`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. The time and date to restore the database to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restore_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [restore_time][crate::model::RestoreAutonomousDatabaseRequest::restore_time].
    pub fn set_restore_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.restore_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_time][crate::model::RestoreAutonomousDatabaseRequest::restore_time].
    pub fn set_or_clear_restore_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.restore_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RestoreAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RestoreAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Stop`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.StopAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Start`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.StartAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Restart`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RestartAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RestartAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.GenerateWallet`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. The type of wallet generation for the Autonomous Database. The
    /// default value is SINGLE.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::GenerateType,

    /// Optional. True when requesting regional connection strings in PDB connect
    /// info, applicable to cross-region Data Guard only.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_regional: bool,

    /// Required. The password used to encrypt the keys inside the wallet. The
    /// password must be a minimum of 8 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAutonomousDatabaseWalletRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateAutonomousDatabaseWalletRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::GenerateAutonomousDatabaseWalletRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::GenerateType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::GenerateAutonomousDatabaseWalletRequest::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [password][crate::model::GenerateAutonomousDatabaseWalletRequest::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletRequest"
    }
}

/// The response for `AutonomousDatabase.GenerateWallet`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletResponse {
    /// Output only. The base64 encoded wallet files.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<serde_with::base64::Base64>")]
    pub archive_content: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAutonomousDatabaseWalletResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [archive_content][crate::model::GenerateAutonomousDatabaseWalletResponse::archive_content].
    pub fn set_archive_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.archive_content = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletResponse"
    }
}

/// The request for `AutonomousDbVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDbVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDbVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDbVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDbVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsRequest"
    }
}

/// The response for `AutonomousDbVersion.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsResponse {
    /// The list of Autonomous Database versions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub autonomous_db_versions: std::vec::Vec<crate::model::AutonomousDbVersion>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDbVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_db_versions][crate::model::ListAutonomousDbVersionsResponse::autonomous_db_versions].
    pub fn set_autonomous_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDbVersion>,
    {
        use std::iter::Iterator;
        self.autonomous_db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDbVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDbVersionsResponse {
    type PageItem = crate::model::AutonomousDbVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_db_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `AutonomousDatabaseCharacterSet.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Character Sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseCharacterSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseCharacterSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseCharacterSetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsRequest"
    }
}

/// The response for `AutonomousDatabaseCharacterSet.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsResponse {
    /// The list of Autonomous Database Character Sets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub autonomous_database_character_sets:
        std::vec::Vec<crate::model::AutonomousDatabaseCharacterSet>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseCharacterSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_database_character_sets][crate::model::ListAutonomousDatabaseCharacterSetsResponse::autonomous_database_character_sets].
    pub fn set_autonomous_database_character_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseCharacterSet>,
    {
        use std::iter::Iterator;
        self.autonomous_database_character_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseCharacterSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabaseCharacterSetsResponse {
    type PageItem = crate::model::AutonomousDatabaseCharacterSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_character_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `AutonomousDatabaseBackup.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsRequest {
    /// Required. The parent value for ListAutonomousDatabaseBackups in the
    /// following format: projects/{project}/locations/{location}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **autonomous_database_id** field is supported in the following format:
    /// `autonomous_database_id="{autonomous_database_id}"`. The accepted values
    /// must be a valid Autonomous Database ID, limited to the naming
    /// restrictions of the ID: ^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    /// The ID must start with a letter, end with a letter or a number, and be
    /// a maximum of 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Backups will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsRequest"
    }
}

/// The response for `AutonomousDatabaseBackup.List`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsResponse {
    /// The list of Autonomous Database Backups.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub autonomous_database_backups: std::vec::Vec<crate::model::AutonomousDatabaseBackup>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_database_backups][crate::model::ListAutonomousDatabaseBackupsResponse::autonomous_database_backups].
    pub fn set_autonomous_database_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseBackup>,
    {
        use std::iter::Iterator;
        self.autonomous_database_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabaseBackupsResponse {
    type PageItem = crate::model::AutonomousDatabaseBackup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Details of the Cloud VM Cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudVmCluster/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudVmCluster {
    /// Identifier. The name of the VM Cluster resource with the format:
    /// projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. The name of the Exadata Infrastructure resource on which VM
    /// cluster resource is created, in the following format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub exadata_infrastructure: std::string::String,

    /// Optional. User friendly name for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. Google Cloud Platform location where Oracle Exadata is hosted.
    /// It is same as Google Cloud Platform Oracle zone of Exadata infrastructure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub gcp_oracle_zone: std::string::String,

    /// Optional. Various properties of the VM Cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::CloudVmClusterProperties>,

    /// Optional. Labels or tags associated with the VM Cluster.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the VM cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Network settings. CIDR to use for cluster IP allocation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cidr: std::string::String,

    /// Required. CIDR range of the backup subnet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub backup_subnet_cidr: std::string::String,

    /// Required. The name of the VPC network.
    /// Format: projects/{project}/global/networks/{network}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub network: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudVmCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudVmCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [exadata_infrastructure][crate::model::CloudVmCluster::exadata_infrastructure].
    pub fn set_exadata_infrastructure<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exadata_infrastructure = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudVmCluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudVmCluster::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudVmCluster::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmClusterProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::CloudVmCluster::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmClusterProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CloudVmCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudVmCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudVmCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cidr][crate::model::CloudVmCluster::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [backup_subnet_cidr][crate::model::CloudVmCluster::backup_subnet_cidr].
    pub fn set_backup_subnet_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_subnet_cidr = v.into();
        self
    }

    /// Sets the value of [network][crate::model::CloudVmCluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

impl wkt::message::Message for CloudVmCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmCluster"
    }
}

/// Various properties and settings associated with Exadata VM cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudVmClusterProperties {
    /// Output only. Oracle Cloud Infrastructure ID of VM Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ocid: std::string::String,

    /// Required. License type of VM Cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub license_type: crate::model::cloud_vm_cluster_properties::LicenseType,

    /// Optional. Grid Infrastructure Version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub gi_version: std::string::String,

    /// Optional. Time zone of VM Cluster to set. Defaults to UTC if not specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Optional. SSH public keys to be stored with cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub ssh_public_keys: std::vec::Vec<std::string::String>,

    /// Optional. Number of database servers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub node_count: i32,

    /// Output only. Shape of VM Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub shape: std::string::String,

    /// Optional. OCPU count per VM. Minimum is 0.1.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub ocpu_count: f32,

    /// Optional. Memory allocated in GBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub memory_size_gb: i32,

    /// Optional. Local storage per VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub db_node_storage_size_gb: i32,

    /// Output only. The storage allocation for the disk group, in gigabytes (GB).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub storage_size_gb: i32,

    /// Optional. The data disk group size to be allocated in TBs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F64>")]
    pub data_storage_size_tb: f64,

    /// Optional. The type of redundancy.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub disk_redundancy: crate::model::cloud_vm_cluster_properties::DiskRedundancy,

    /// Optional. Use exadata sparse snapshots.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub sparse_diskgroup_enabled: bool,

    /// Optional. Use local backup.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub local_backup_enabled: bool,

    /// Optional. Prefix for VM cluster host names.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub hostname_prefix: std::string::String,

    /// Optional. Data collection options for diagnostics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub diagnostics_data_collection_options:
        std::option::Option<crate::model::DataCollectionOptions>,

    /// Output only. State of the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::cloud_vm_cluster_properties::State,

    /// Output only. SCAN listener port - TCP
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub scan_listener_port_tcp: i32,

    /// Output only. SCAN listener port - TLS
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub scan_listener_port_tcp_ssl: i32,

    /// Output only. Parent DNS domain where SCAN DNS and hosts names are
    /// qualified. ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub domain: std::string::String,

    /// Output only. SCAN DNS name.
    /// ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub scan_dns: std::string::String,

    /// Output only. host name without domain.
    /// format: "<hostname_prefix>-" with some suffix.
    /// ex: sp2-yi0xq where "sp2" is the hostname_prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub hostname: std::string::String,

    /// Required. Number of enabled CPU cores.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub cpu_core_count: i32,

    /// Optional. Operating system version of the image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub system_version: std::string::String,

    /// Output only. OCIDs of scan IPs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub scan_ip_ids: std::vec::Vec<std::string::String>,

    /// Output only. OCID of scan DNS record.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub scan_dns_record_id: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub oci_url: std::string::String,

    /// Optional. OCID of database servers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub db_server_ocids: std::vec::Vec<std::string::String>,

    /// Output only. Compartment ID of cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub compartment_id: std::string::String,

    /// Output only. DNS listener IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub dns_listener_ip: std::string::String,

    /// Optional. OCI Cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cluster_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudVmClusterProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudVmClusterProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::CloudVmClusterProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [gi_version][crate::model::CloudVmClusterProperties::gi_version].
    pub fn set_gi_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gi_version = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::CloudVmClusterProperties::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::CloudVmClusterProperties::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssh_public_keys][crate::model::CloudVmClusterProperties::ssh_public_keys].
    pub fn set_ssh_public_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_public_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_count][crate::model::CloudVmClusterProperties::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudVmClusterProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::CloudVmClusterProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudVmClusterProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudVmClusterProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [storage_size_gb][crate::model::CloudVmClusterProperties::storage_size_gb].
    pub fn set_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudVmClusterProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [disk_redundancy][crate::model::CloudVmClusterProperties::disk_redundancy].
    pub fn set_disk_redundancy<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::DiskRedundancy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_redundancy = v.into();
        self
    }

    /// Sets the value of [sparse_diskgroup_enabled][crate::model::CloudVmClusterProperties::sparse_diskgroup_enabled].
    pub fn set_sparse_diskgroup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.sparse_diskgroup_enabled = v.into();
        self
    }

    /// Sets the value of [local_backup_enabled][crate::model::CloudVmClusterProperties::local_backup_enabled].
    pub fn set_local_backup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.local_backup_enabled = v.into();
        self
    }

    /// Sets the value of [hostname_prefix][crate::model::CloudVmClusterProperties::hostname_prefix].
    pub fn set_hostname_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname_prefix = v.into();
        self
    }

    /// Sets the value of [diagnostics_data_collection_options][crate::model::CloudVmClusterProperties::diagnostics_data_collection_options].
    pub fn set_diagnostics_data_collection_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptions>,
    {
        self.diagnostics_data_collection_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diagnostics_data_collection_options][crate::model::CloudVmClusterProperties::diagnostics_data_collection_options].
    pub fn set_or_clear_diagnostics_data_collection_options<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptions>,
    {
        self.diagnostics_data_collection_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CloudVmClusterProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::cloud_vm_cluster_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp][crate::model::CloudVmClusterProperties::scan_listener_port_tcp].
    pub fn set_scan_listener_port_tcp<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp_ssl][crate::model::CloudVmClusterProperties::scan_listener_port_tcp_ssl].
    pub fn set_scan_listener_port_tcp_ssl<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp_ssl = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::CloudVmClusterProperties::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [scan_dns][crate::model::CloudVmClusterProperties::scan_dns].
    pub fn set_scan_dns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scan_dns = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::CloudVmClusterProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::CloudVmClusterProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [system_version][crate::model::CloudVmClusterProperties::system_version].
    pub fn set_system_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system_version = v.into();
        self
    }

    /// Sets the value of [scan_ip_ids][crate::model::CloudVmClusterProperties::scan_ip_ids].
    pub fn set_scan_ip_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scan_ip_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scan_dns_record_id][crate::model::CloudVmClusterProperties::scan_dns_record_id].
    pub fn set_scan_dns_record_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_dns_record_id = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudVmClusterProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [db_server_ocids][crate::model::CloudVmClusterProperties::db_server_ocids].
    pub fn set_db_server_ocids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_server_ocids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [compartment_id][crate::model::CloudVmClusterProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [dns_listener_ip][crate::model::CloudVmClusterProperties::dns_listener_ip].
    pub fn set_dns_listener_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_listener_ip = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::CloudVmClusterProperties::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }
}

impl wkt::message::Message for CloudVmClusterProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmClusterProperties"
    }
}

/// Defines additional types related to [CloudVmClusterProperties].
pub mod cloud_vm_cluster_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Different licenses supported.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseType {
        /// Unspecified
        Unspecified,
        /// License included part of offer
        LicenseIncluded,
        /// Bring your own license
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseType::value] or
        /// [LicenseType::name].
        UnknownValue(license_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_TYPE_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseType>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.LicenseType",
            ))
        }
    }

    /// Types of disk redundancy provided by Oracle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskRedundancy {
        /// Unspecified.
        Unspecified,
        /// High -  3 way mirror.
        High,
        /// Normal - 2 way mirror.
        Normal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskRedundancy::value] or
        /// [DiskRedundancy::name].
        UnknownValue(disk_redundancy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_redundancy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskRedundancy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Normal => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_REDUNDANCY_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskRedundancy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskRedundancy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskRedundancy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Normal,
                _ => Self::UnknownValue(disk_redundancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskRedundancy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_REDUNDANCY_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "NORMAL" => Self::Normal,
                _ => Self::UnknownValue(disk_redundancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskRedundancy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Normal => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskRedundancy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskRedundancy>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.DiskRedundancy",
            ))
        }
    }

    /// The various lifecycle states of the VM cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::MaintenanceInProgress => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::MaintenanceInProgress => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.State",
            ))
        }
    }
}

/// Data collection options for diagnostics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataCollectionOptions {
    /// Optional. Indicates whether diagnostic collection is enabled for the VM
    /// cluster
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub diagnostics_events_enabled: bool,

    /// Optional. Indicates whether health monitoring is enabled for the VM cluster
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub health_monitoring_enabled: bool,

    /// Optional. Indicates whether incident logs and trace collection are enabled
    /// for the VM cluster
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub incident_logs_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataCollectionOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [diagnostics_events_enabled][crate::model::DataCollectionOptions::diagnostics_events_enabled].
    pub fn set_diagnostics_events_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.diagnostics_events_enabled = v.into();
        self
    }

    /// Sets the value of [health_monitoring_enabled][crate::model::DataCollectionOptions::health_monitoring_enabled].
    pub fn set_health_monitoring_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.health_monitoring_enabled = v.into();
        self
    }

    /// Sets the value of [incident_logs_enabled][crate::model::DataCollectionOptions::incident_logs_enabled].
    pub fn set_incident_logs_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.incident_logs_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCollectionOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DataCollectionOptions"
    }
}

/// The type of wallet generation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum GenerateType {
    /// Default unspecified value.
    Unspecified,
    /// Used to generate wallet for all databases in the region.
    All,
    /// Used to generate wallet for a single database.
    Single,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [GenerateType::value] or
    /// [GenerateType::name].
    UnknownValue(generate_type::UnknownValue),
}

#[doc(hidden)]
pub mod generate_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl GenerateType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::All => std::option::Option::Some(1),
            Self::Single => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("GENERATE_TYPE_UNSPECIFIED"),
            Self::All => std::option::Option::Some("ALL"),
            Self::Single => std::option::Option::Some("SINGLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for GenerateType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for GenerateType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for GenerateType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::All,
            2 => Self::Single,
            _ => Self::UnknownValue(generate_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for GenerateType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "GENERATE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ALL" => Self::All,
            "SINGLE" => Self::Single,
            _ => Self::UnknownValue(generate_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for GenerateType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::All => serializer.serialize_i32(1),
            Self::Single => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for GenerateType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<GenerateType>::new(
            ".google.cloud.oracledatabase.v1.GenerateType",
        ))
    }
}

/// The various lifecycle states of the Autonomous Database.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum State {
    /// Default unspecified value.
    Unspecified,
    /// Indicates that the Autonomous Database is in provisioning state.
    Provisioning,
    /// Indicates that the Autonomous Database is in available state.
    Available,
    /// Indicates that the Autonomous Database is in stopping state.
    Stopping,
    /// Indicates that the Autonomous Database is in stopped state.
    Stopped,
    /// Indicates that the Autonomous Database is in starting state.
    Starting,
    /// Indicates that the Autonomous Database is in terminating state.
    Terminating,
    /// Indicates that the Autonomous Database is in terminated state.
    Terminated,
    /// Indicates that the Autonomous Database is in unavailable state.
    Unavailable,
    /// Indicates that the Autonomous Database restore is in progress.
    RestoreInProgress,
    /// Indicates that the Autonomous Database failed to restore.
    RestoreFailed,
    /// Indicates that the Autonomous Database backup is in progress.
    BackupInProgress,
    /// Indicates that the Autonomous Database scale is in progress.
    ScaleInProgress,
    /// Indicates that the Autonomous Database is available but needs attention
    /// state.
    AvailableNeedsAttention,
    /// Indicates that the Autonomous Database is in updating state.
    Updating,
    /// Indicates that the Autonomous Database's maintenance is in progress state.
    MaintenanceInProgress,
    /// Indicates that the Autonomous Database is in restarting state.
    Restarting,
    /// Indicates that the Autonomous Database is in recreating state.
    Recreating,
    /// Indicates that the Autonomous Database's role change is in progress state.
    RoleChangeInProgress,
    /// Indicates that the Autonomous Database is in upgrading state.
    Upgrading,
    /// Indicates that the Autonomous Database is in inaccessible state.
    Inaccessible,
    /// Indicates that the Autonomous Database is in standby state.
    Standby,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [State::value] or
    /// [State::name].
    UnknownValue(state::UnknownValue),
}

#[doc(hidden)]
pub mod state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl State {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Provisioning => std::option::Option::Some(1),
            Self::Available => std::option::Option::Some(2),
            Self::Stopping => std::option::Option::Some(3),
            Self::Stopped => std::option::Option::Some(4),
            Self::Starting => std::option::Option::Some(5),
            Self::Terminating => std::option::Option::Some(6),
            Self::Terminated => std::option::Option::Some(7),
            Self::Unavailable => std::option::Option::Some(8),
            Self::RestoreInProgress => std::option::Option::Some(9),
            Self::RestoreFailed => std::option::Option::Some(10),
            Self::BackupInProgress => std::option::Option::Some(11),
            Self::ScaleInProgress => std::option::Option::Some(12),
            Self::AvailableNeedsAttention => std::option::Option::Some(13),
            Self::Updating => std::option::Option::Some(14),
            Self::MaintenanceInProgress => std::option::Option::Some(15),
            Self::Restarting => std::option::Option::Some(16),
            Self::Recreating => std::option::Option::Some(17),
            Self::RoleChangeInProgress => std::option::Option::Some(18),
            Self::Upgrading => std::option::Option::Some(19),
            Self::Inaccessible => std::option::Option::Some(20),
            Self::Standby => std::option::Option::Some(21),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
            Self::Provisioning => std::option::Option::Some("PROVISIONING"),
            Self::Available => std::option::Option::Some("AVAILABLE"),
            Self::Stopping => std::option::Option::Some("STOPPING"),
            Self::Stopped => std::option::Option::Some("STOPPED"),
            Self::Starting => std::option::Option::Some("STARTING"),
            Self::Terminating => std::option::Option::Some("TERMINATING"),
            Self::Terminated => std::option::Option::Some("TERMINATED"),
            Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
            Self::RestoreInProgress => std::option::Option::Some("RESTORE_IN_PROGRESS"),
            Self::RestoreFailed => std::option::Option::Some("RESTORE_FAILED"),
            Self::BackupInProgress => std::option::Option::Some("BACKUP_IN_PROGRESS"),
            Self::ScaleInProgress => std::option::Option::Some("SCALE_IN_PROGRESS"),
            Self::AvailableNeedsAttention => std::option::Option::Some("AVAILABLE_NEEDS_ATTENTION"),
            Self::Updating => std::option::Option::Some("UPDATING"),
            Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
            Self::Restarting => std::option::Option::Some("RESTARTING"),
            Self::Recreating => std::option::Option::Some("RECREATING"),
            Self::RoleChangeInProgress => std::option::Option::Some("ROLE_CHANGE_IN_PROGRESS"),
            Self::Upgrading => std::option::Option::Some("UPGRADING"),
            Self::Inaccessible => std::option::Option::Some("INACCESSIBLE"),
            Self::Standby => std::option::Option::Some("STANDBY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Provisioning,
            2 => Self::Available,
            3 => Self::Stopping,
            4 => Self::Stopped,
            5 => Self::Starting,
            6 => Self::Terminating,
            7 => Self::Terminated,
            8 => Self::Unavailable,
            9 => Self::RestoreInProgress,
            10 => Self::RestoreFailed,
            11 => Self::BackupInProgress,
            12 => Self::ScaleInProgress,
            13 => Self::AvailableNeedsAttention,
            14 => Self::Updating,
            15 => Self::MaintenanceInProgress,
            16 => Self::Restarting,
            17 => Self::Recreating,
            18 => Self::RoleChangeInProgress,
            19 => Self::Upgrading,
            20 => Self::Inaccessible,
            21 => Self::Standby,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for State {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_UNSPECIFIED" => Self::Unspecified,
            "PROVISIONING" => Self::Provisioning,
            "AVAILABLE" => Self::Available,
            "STOPPING" => Self::Stopping,
            "STOPPED" => Self::Stopped,
            "STARTING" => Self::Starting,
            "TERMINATING" => Self::Terminating,
            "TERMINATED" => Self::Terminated,
            "UNAVAILABLE" => Self::Unavailable,
            "RESTORE_IN_PROGRESS" => Self::RestoreInProgress,
            "RESTORE_FAILED" => Self::RestoreFailed,
            "BACKUP_IN_PROGRESS" => Self::BackupInProgress,
            "SCALE_IN_PROGRESS" => Self::ScaleInProgress,
            "AVAILABLE_NEEDS_ATTENTION" => Self::AvailableNeedsAttention,
            "UPDATING" => Self::Updating,
            "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
            "RESTARTING" => Self::Restarting,
            "RECREATING" => Self::Recreating,
            "ROLE_CHANGE_IN_PROGRESS" => Self::RoleChangeInProgress,
            "UPGRADING" => Self::Upgrading,
            "INACCESSIBLE" => Self::Inaccessible,
            "STANDBY" => Self::Standby,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Provisioning => serializer.serialize_i32(1),
            Self::Available => serializer.serialize_i32(2),
            Self::Stopping => serializer.serialize_i32(3),
            Self::Stopped => serializer.serialize_i32(4),
            Self::Starting => serializer.serialize_i32(5),
            Self::Terminating => serializer.serialize_i32(6),
            Self::Terminated => serializer.serialize_i32(7),
            Self::Unavailable => serializer.serialize_i32(8),
            Self::RestoreInProgress => serializer.serialize_i32(9),
            Self::RestoreFailed => serializer.serialize_i32(10),
            Self::BackupInProgress => serializer.serialize_i32(11),
            Self::ScaleInProgress => serializer.serialize_i32(12),
            Self::AvailableNeedsAttention => serializer.serialize_i32(13),
            Self::Updating => serializer.serialize_i32(14),
            Self::MaintenanceInProgress => serializer.serialize_i32(15),
            Self::Restarting => serializer.serialize_i32(16),
            Self::Recreating => serializer.serialize_i32(17),
            Self::RoleChangeInProgress => serializer.serialize_i32(18),
            Self::Upgrading => serializer.serialize_i32(19),
            Self::Inaccessible => serializer.serialize_i32(20),
            Self::Standby => serializer.serialize_i32(21),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
            ".google.cloud.oracledatabase.v1.State",
        ))
    }
}

/// The state of the Operations Insights for this Autonomous Database.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationsInsightsState {
    /// Default unspecified value.
    Unspecified,
    /// Enabling status for operation insights.
    Enabling,
    /// Enabled status for operation insights.
    Enabled,
    /// Disabling status for operation insights.
    Disabling,
    /// Not Enabled status for operation insights.
    NotEnabled,
    /// Failed enabling status for operation insights.
    FailedEnabling,
    /// Failed disabling status for operation insights.
    FailedDisabling,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationsInsightsState::value] or
    /// [OperationsInsightsState::name].
    UnknownValue(operations_insights_state::UnknownValue),
}

#[doc(hidden)]
pub mod operations_insights_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationsInsightsState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enabling => std::option::Option::Some(1),
            Self::Enabled => std::option::Option::Some(2),
            Self::Disabling => std::option::Option::Some(3),
            Self::NotEnabled => std::option::Option::Some(4),
            Self::FailedEnabling => std::option::Option::Some(5),
            Self::FailedDisabling => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATIONS_INSIGHTS_STATE_UNSPECIFIED"),
            Self::Enabling => std::option::Option::Some("ENABLING"),
            Self::Enabled => std::option::Option::Some("ENABLED"),
            Self::Disabling => std::option::Option::Some("DISABLING"),
            Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
            Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
            Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationsInsightsState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationsInsightsState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationsInsightsState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enabling,
            2 => Self::Enabled,
            3 => Self::Disabling,
            4 => Self::NotEnabled,
            5 => Self::FailedEnabling,
            6 => Self::FailedDisabling,
            _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationsInsightsState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => Self::Unspecified,
            "ENABLING" => Self::Enabling,
            "ENABLED" => Self::Enabled,
            "DISABLING" => Self::Disabling,
            "NOT_ENABLED" => Self::NotEnabled,
            "FAILED_ENABLING" => Self::FailedEnabling,
            "FAILED_DISABLING" => Self::FailedDisabling,
            _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationsInsightsState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enabling => serializer.serialize_i32(1),
            Self::Enabled => serializer.serialize_i32(2),
            Self::Disabling => serializer.serialize_i32(3),
            Self::NotEnabled => serializer.serialize_i32(4),
            Self::FailedEnabling => serializer.serialize_i32(5),
            Self::FailedDisabling => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationsInsightsState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationsInsightsState>::new(
            ".google.cloud.oracledatabase.v1.OperationsInsightsState",
        ))
    }
}

/// The various states available for the Autonomous Database workload type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DBWorkload {
    /// Default unspecified value.
    Unspecified,
    /// Autonomous Transaction Processing database.
    Oltp,
    /// Autonomous Data Warehouse database.
    Dw,
    /// Autonomous JSON Database.
    Ajd,
    /// Autonomous Database with the Oracle APEX Application Development workload
    /// type.
    Apex,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DBWorkload::value] or
    /// [DBWorkload::name].
    UnknownValue(db_workload::UnknownValue),
}

#[doc(hidden)]
pub mod db_workload {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DBWorkload {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Oltp => std::option::Option::Some(1),
            Self::Dw => std::option::Option::Some(2),
            Self::Ajd => std::option::Option::Some(3),
            Self::Apex => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DB_WORKLOAD_UNSPECIFIED"),
            Self::Oltp => std::option::Option::Some("OLTP"),
            Self::Dw => std::option::Option::Some("DW"),
            Self::Ajd => std::option::Option::Some("AJD"),
            Self::Apex => std::option::Option::Some("APEX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DBWorkload {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DBWorkload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DBWorkload {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Oltp,
            2 => Self::Dw,
            3 => Self::Ajd,
            4 => Self::Apex,
            _ => Self::UnknownValue(db_workload::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DBWorkload {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DB_WORKLOAD_UNSPECIFIED" => Self::Unspecified,
            "OLTP" => Self::Oltp,
            "DW" => Self::Dw,
            "AJD" => Self::Ajd,
            "APEX" => Self::Apex,
            _ => Self::UnknownValue(db_workload::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DBWorkload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Oltp => serializer.serialize_i32(1),
            Self::Dw => serializer.serialize_i32(2),
            Self::Ajd => serializer.serialize_i32(3),
            Self::Apex => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DBWorkload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DBWorkload>::new(
            ".google.cloud.oracledatabase.v1.DBWorkload",
        ))
    }
}
