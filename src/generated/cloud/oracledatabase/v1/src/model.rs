// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Details of the Autonomous Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabase/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabase {
    /// Identifier. The name of the Autonomous Database resource in the following
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    pub name: std::string::String,

    /// Optional. The name of the Autonomous Database. The database name must be
    /// unique in the project. The name must begin with a letter and can contain a
    /// maximum of 30 alphanumeric characters.
    pub database: std::string::String,

    /// Optional. The display name for the Autonomous Database. The name does not
    /// have to be unique within your project.
    pub display_name: std::string::String,

    /// Output only. The ID of the subscription entitlement associated with the
    /// Autonomous Database.
    pub entitlement_id: std::string::String,

    /// Optional. The password for the default ADMIN user.
    pub admin_password: std::string::String,

    /// Optional. The properties of the Autonomous Database.
    pub properties: std::option::Option<crate::model::AutonomousDatabaseProperties>,

    /// Optional. The labels or tags associated with the Autonomous Database.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The name of the VPC network used by the Autonomous Database in
    /// the following format: projects/{project}/global/networks/{network}
    pub network: std::string::String,

    /// Optional. The subnet CIDR range for the Autonomous Database.
    pub cidr: std::string::String,

    /// Optional. The name of the OdbNetwork associated with the Autonomous
    /// Database. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network} It is
    /// optional but if specified, this should match the parent ODBNetwork of the
    /// OdbSubnet.
    pub odb_network: std::string::String,

    /// Optional. The name of the OdbSubnet associated with the Autonomous
    /// Database. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    pub odb_subnet: std::string::String,

    /// Optional. The source Autonomous Database configuration for the standby
    /// Autonomous Database. The source Autonomous Database is configured while
    /// creating the Peer Autonomous Database and can't be updated after creation.
    pub source_config: std::option::Option<crate::model::SourceConfig>,

    /// Output only. The peer Autonomous Database names of the given Autonomous
    /// Database.
    pub peer_autonomous_databases: std::vec::Vec<std::string::String>,

    /// Output only. The date and time that the Autonomous Database was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. List of supported GCP region to clone the Autonomous Database
    /// for disaster recovery. Format: `project/{project}/locations/{location}`.
    pub disaster_recovery_supported_locations: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabase::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::AutonomousDatabase::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabase::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::AutonomousDatabase::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [admin_password][crate::model::AutonomousDatabase::admin_password].
    pub fn set_admin_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin_password = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabase::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::AutonomousDatabase::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabase::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network][crate::model::AutonomousDatabase::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::AutonomousDatabase::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [odb_network][crate::model::AutonomousDatabase::odb_network].
    pub fn set_odb_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_network = v.into();
        self
    }

    /// Sets the value of [odb_subnet][crate::model::AutonomousDatabase::odb_subnet].
    pub fn set_odb_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_subnet = v.into();
        self
    }

    /// Sets the value of [source_config][crate::model::AutonomousDatabase::source_config].
    pub fn set_source_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceConfig>,
    {
        self.source_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_config][crate::model::AutonomousDatabase::source_config].
    pub fn set_or_clear_source_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceConfig>,
    {
        self.source_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [peer_autonomous_databases][crate::model::AutonomousDatabase::peer_autonomous_databases].
    pub fn set_peer_autonomous_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_autonomous_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::AutonomousDatabase::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AutonomousDatabase::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disaster_recovery_supported_locations][crate::model::AutonomousDatabase::disaster_recovery_supported_locations].
    pub fn set_disaster_recovery_supported_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.disaster_recovery_supported_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabase"
    }
}

/// The source configuration for the standby Autonomous Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceConfig {
    /// Optional. The name of the primary Autonomous Database that is used to
    /// create a Peer Autonomous Database from a source.
    pub autonomous_database: std::string::String,

    /// Optional. This field specifies if the replication of automatic backups is
    /// enabled when creating a Data Guard.
    pub automatic_backups_replication_enabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_database][crate::model::SourceConfig::autonomous_database].
    pub fn set_autonomous_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database = v.into();
        self
    }

    /// Sets the value of [automatic_backups_replication_enabled][crate::model::SourceConfig::automatic_backups_replication_enabled].
    pub fn set_automatic_backups_replication_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.automatic_backups_replication_enabled = v.into();
        self
    }
}

impl wkt::message::Message for SourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.SourceConfig"
    }
}

/// The properties of an Autonomous Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseProperties {
    /// Output only. OCID of the Autonomous Database.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Autonomous Database.
    pub compute_count: f32,

    /// Optional. The number of CPU cores to be made available to the database.
    pub cpu_core_count: i32,

    /// Optional. The size of the data stored in the database, in terabytes.
    pub data_storage_size_tb: i32,

    /// Optional. The size of the data stored in the database, in gigabytes.
    pub data_storage_size_gb: i32,

    /// Required. The workload type of the Autonomous Database.
    pub db_workload: crate::model::DBWorkload,

    /// Optional. The edition of the Autonomous Databases.
    pub db_edition: crate::model::autonomous_database_properties::DatabaseEdition,

    /// Optional. The character set for the Autonomous Database. The default is
    /// AL32UTF8.
    pub character_set: std::string::String,

    /// Optional. The national character set for the Autonomous Database. The
    /// default is AL16UTF16.
    pub n_character_set: std::string::String,

    /// Optional. The private endpoint IP address for the Autonomous Database.
    pub private_endpoint_ip: std::string::String,

    /// Optional. The private endpoint label for the Autonomous Database.
    pub private_endpoint_label: std::string::String,

    /// Optional. The Oracle Database version for the Autonomous Database.
    pub db_version: std::string::String,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database CPU core count.
    pub is_auto_scaling_enabled: bool,

    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database storage.
    pub is_storage_auto_scaling_enabled: bool,

    /// Required. The license type used for the Autonomous Database.
    pub license_type: crate::model::autonomous_database_properties::LicenseType,

    /// Optional. The list of customer contacts.
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault secret.
    pub secret_id: std::string::String,

    /// Optional. The ID of the Oracle Cloud Infrastructure vault.
    pub vault_id: std::string::String,

    /// Optional. The maintenance schedule of the Autonomous Database.
    pub maintenance_schedule_type:
        crate::model::autonomous_database_properties::MaintenanceScheduleType,

    /// Optional. This field specifies if the Autonomous Database requires mTLS
    /// connections.
    pub mtls_connection_required: bool,

    /// Optional. The retention period for the Autonomous Database. This field is
    /// specified in days, can range from 1 day to 60 days, and has a default value
    /// of 60 days.
    pub backup_retention_period_days: i32,

    /// Output only. The amount of storage currently being used for user and system
    /// data, in terabytes.
    pub actual_used_data_storage_size_tb: f64,

    /// Output only. The amount of storage currently allocated for the database
    /// tables and billed for, rounded up in terabytes.
    pub allocated_storage_size_tb: f64,

    /// Output only. The details for the Oracle APEX Application Development.
    pub apex_details: std::option::Option<crate::model::AutonomousDatabaseApex>,

    /// Output only. This field indicates the status of Data Guard and Access
    /// control for the Autonomous Database. The field's value is null if Data
    /// Guard is disabled or Access Control is disabled. The field's value is TRUE
    /// if both Data Guard and Access Control are enabled, and the Autonomous
    /// Database is using primary IP access control list (ACL) for standby. The
    /// field's value is FALSE if both Data Guard and Access Control are enabled,
    /// and the Autonomous Database is using a different IP access control list
    /// (ACL) for standby compared to primary.
    pub are_primary_allowlisted_ips_used: std::option::Option<bool>,

    /// Output only. The details of the current lifestyle state of the Autonomous
    /// Database.
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    pub state: crate::model::State,

    /// Output only. The Autonomous Container Database OCID.
    pub autonomous_container_database_id: std::string::String,

    /// Output only. The list of available Oracle Database upgrade versions for an
    /// Autonomous Database.
    pub available_upgrade_versions: std::vec::Vec<std::string::String>,

    /// Output only. The connection strings used to connect to an Autonomous
    /// Database.
    pub connection_strings: std::option::Option<crate::model::AutonomousDatabaseConnectionStrings>,

    /// Output only. The Oracle Connection URLs for an Autonomous Database.
    pub connection_urls: std::option::Option<crate::model::AutonomousDatabaseConnectionUrls>,

    /// Output only. This field indicates the number of seconds of data loss during
    /// a Data Guard failover.
    pub failed_data_recovery_duration: std::option::Option<wkt::Duration>,

    /// Output only. The memory assigned to in-memory tables in an Autonomous
    /// Database.
    pub memory_table_gbs: i32,

    /// Output only. This field indicates whether the Autonomous Database has local
    /// (in-region) Data Guard enabled.
    pub is_local_data_guard_enabled: bool,

    /// Output only. This field indicates the maximum data loss limit for an
    /// Autonomous Database, in seconds.
    pub local_adg_auto_failover_max_data_loss_limit: i32,

    /// Output only. The details of the Autonomous Data Guard standby database.
    pub local_standby_db: std::option::Option<crate::model::AutonomousDatabaseStandbySummary>,

    /// Output only. The amount of memory enabled per ECPU, in gigabytes.
    pub memory_per_oracle_compute_unit_gbs: i32,

    /// Output only. This field indicates the local disaster recovery (DR) type of
    /// an Autonomous Database.
    pub local_disaster_recovery_type:
        crate::model::autonomous_database_properties::LocalDisasterRecoveryType,

    /// Output only. The current state of the Data Safe registration for the
    /// Autonomous Database.
    pub data_safe_state: crate::model::autonomous_database_properties::DataSafeState,

    /// Output only. The current state of database management for the Autonomous
    /// Database.
    pub database_management_state:
        crate::model::autonomous_database_properties::DatabaseManagementState,

    /// Output only. This field indicates the current mode of the Autonomous
    /// Database.
    pub open_mode: crate::model::autonomous_database_properties::OpenMode,

    /// Output only. This field indicates the state of Operations Insights for the
    /// Autonomous Database.
    pub operations_insights_state: crate::model::OperationsInsightsState,

    /// Output only. The list of OCIDs of standby databases located in Autonomous
    /// Data Guard remote regions that are associated with the source database.
    pub peer_db_ids: std::vec::Vec<std::string::String>,

    /// Output only. The permission level of the Autonomous Database.
    pub permission_level: crate::model::autonomous_database_properties::PermissionLevel,

    /// Output only. The private endpoint for the Autonomous Database.
    pub private_endpoint: std::string::String,

    /// Output only. The refresh mode of the cloned Autonomous Database.
    pub refreshable_mode: crate::model::autonomous_database_properties::RefreshableMode,

    /// Output only. The refresh State of the clone.
    pub refreshable_state: crate::model::autonomous_database_properties::RefreshableState,

    /// Output only. The Data Guard role of the Autonomous Database.
    pub role: crate::model::autonomous_database_properties::Role,

    /// Output only. The list and details of the scheduled operations of the
    /// Autonomous Database.
    pub scheduled_operation_details: std::vec::Vec<crate::model::ScheduledOperationDetails>,

    /// Output only. The SQL Web Developer URL for the Autonomous Database.
    pub sql_web_developer_url: std::string::String,

    /// Output only. The list of available regions that can be used to create a
    /// clone for the Autonomous Database.
    pub supported_clone_regions: std::vec::Vec<std::string::String>,

    /// Output only. The storage space used by Autonomous Database, in gigabytes.
    pub used_data_storage_size_tbs: i32,

    /// Output only. The Oracle Cloud Infrastructure link for the Autonomous
    /// Database.
    pub oci_url: std::string::String,

    /// Output only. The storage space used by automatic backups of Autonomous
    /// Database, in gigabytes.
    pub total_auto_backup_storage_size_gbs: f32,

    /// Output only. The long term backup schedule of the Autonomous Database.
    pub next_long_term_backup_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the Autonomous Data Guard role was changed
    /// for the standby Autonomous Database.
    pub data_guard_role_changed_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the Disaster Recovery role was changed for
    /// the standby Autonomous Database.
    pub disaster_recovery_role_changed_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will begin.
    pub maintenance_begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time when maintenance will end.
    pub maintenance_end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of allowlisted IP addresses for the Autonomous Database.
    pub allowlisted_ips: std::vec::Vec<std::string::String>,

    /// Optional. The encryption key used to encrypt the Autonomous Database.
    /// Updating this field will add a new entry in the
    /// `encryption_key_history_entries` field with the former version.
    pub encryption_key: std::option::Option<crate::model::EncryptionKey>,

    /// Output only. The history of the encryption keys used to encrypt the
    /// Autonomous Database.
    pub encryption_key_history_entries: std::vec::Vec<crate::model::EncryptionKeyHistoryEntry>,

    /// Output only. An Oracle-managed Google Cloud service account on which
    /// customers can grant roles to access resources in the customer project.
    pub service_agent_email: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::AutonomousDatabaseProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::AutonomousDatabaseProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::AutonomousDatabaseProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_gb][crate::model::AutonomousDatabaseProperties::data_storage_size_gb].
    pub fn set_data_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDatabaseProperties::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [db_edition][crate::model::AutonomousDatabaseProperties::db_edition].
    pub fn set_db_edition<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseEdition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.db_edition = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseProperties::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }

    /// Sets the value of [n_character_set][crate::model::AutonomousDatabaseProperties::n_character_set].
    pub fn set_n_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n_character_set = v.into();
        self
    }

    /// Sets the value of [private_endpoint_ip][crate::model::AutonomousDatabaseProperties::private_endpoint_ip].
    pub fn set_private_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [private_endpoint_label][crate::model::AutonomousDatabaseProperties::private_endpoint_label].
    pub fn set_private_endpoint_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_label = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_auto_scaling_enabled].
    pub fn set_is_auto_scaling_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [is_storage_auto_scaling_enabled][crate::model::AutonomousDatabaseProperties::is_storage_auto_scaling_enabled].
    pub fn set_is_storage_auto_scaling_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_storage_auto_scaling_enabled = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::AutonomousDatabaseProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [customer_contacts][crate::model::AutonomousDatabaseProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_id][crate::model::AutonomousDatabaseProperties::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }

    /// Sets the value of [maintenance_schedule_type][crate::model::AutonomousDatabaseProperties::maintenance_schedule_type].
    pub fn set_maintenance_schedule_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::MaintenanceScheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_schedule_type = v.into();
        self
    }

    /// Sets the value of [mtls_connection_required][crate::model::AutonomousDatabaseProperties::mtls_connection_required].
    pub fn set_mtls_connection_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.mtls_connection_required = v.into();
        self
    }

    /// Sets the value of [backup_retention_period_days][crate::model::AutonomousDatabaseProperties::backup_retention_period_days].
    pub fn set_backup_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.backup_retention_period_days = v.into();
        self
    }

    /// Sets the value of [actual_used_data_storage_size_tb][crate::model::AutonomousDatabaseProperties::actual_used_data_storage_size_tb].
    pub fn set_actual_used_data_storage_size_tb<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.actual_used_data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [allocated_storage_size_tb][crate::model::AutonomousDatabaseProperties::allocated_storage_size_tb].
    pub fn set_allocated_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.allocated_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [apex_details][crate::model::AutonomousDatabaseProperties::apex_details].
    pub fn set_apex_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseApex>,
    {
        self.apex_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [apex_details][crate::model::AutonomousDatabaseProperties::apex_details].
    pub fn set_or_clear_apex_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseApex>,
    {
        self.apex_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [are_primary_allowlisted_ips_used][crate::model::AutonomousDatabaseProperties::are_primary_allowlisted_ips_used].
    pub fn set_are_primary_allowlisted_ips_used<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.are_primary_allowlisted_ips_used = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [are_primary_allowlisted_ips_used][crate::model::AutonomousDatabaseProperties::are_primary_allowlisted_ips_used].
    pub fn set_or_clear_are_primary_allowlisted_ips_used<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.are_primary_allowlisted_ips_used = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [autonomous_container_database_id][crate::model::AutonomousDatabaseProperties::autonomous_container_database_id].
    pub fn set_autonomous_container_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_container_database_id = v.into();
        self
    }

    /// Sets the value of [available_upgrade_versions][crate::model::AutonomousDatabaseProperties::available_upgrade_versions].
    pub fn set_available_upgrade_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_upgrade_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_strings][crate::model::AutonomousDatabaseProperties::connection_strings].
    pub fn set_connection_strings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionStrings>,
    {
        self.connection_strings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_strings][crate::model::AutonomousDatabaseProperties::connection_strings].
    pub fn set_or_clear_connection_strings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionStrings>,
    {
        self.connection_strings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_urls][crate::model::AutonomousDatabaseProperties::connection_urls].
    pub fn set_connection_urls<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionUrls>,
    {
        self.connection_urls = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_urls][crate::model::AutonomousDatabaseProperties::connection_urls].
    pub fn set_or_clear_connection_urls<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseConnectionUrls>,
    {
        self.connection_urls = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failed_data_recovery_duration][crate::model::AutonomousDatabaseProperties::failed_data_recovery_duration].
    pub fn set_failed_data_recovery_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.failed_data_recovery_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failed_data_recovery_duration][crate::model::AutonomousDatabaseProperties::failed_data_recovery_duration].
    pub fn set_or_clear_failed_data_recovery_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.failed_data_recovery_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_table_gbs][crate::model::AutonomousDatabaseProperties::memory_table_gbs].
    pub fn set_memory_table_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_table_gbs = v.into();
        self
    }

    /// Sets the value of [is_local_data_guard_enabled][crate::model::AutonomousDatabaseProperties::is_local_data_guard_enabled].
    pub fn set_is_local_data_guard_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_local_data_guard_enabled = v.into();
        self
    }

    /// Sets the value of [local_adg_auto_failover_max_data_loss_limit][crate::model::AutonomousDatabaseProperties::local_adg_auto_failover_max_data_loss_limit].
    pub fn set_local_adg_auto_failover_max_data_loss_limit<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_adg_auto_failover_max_data_loss_limit = v.into();
        self
    }

    /// Sets the value of [local_standby_db][crate::model::AutonomousDatabaseProperties::local_standby_db].
    pub fn set_local_standby_db<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseStandbySummary>,
    {
        self.local_standby_db = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_standby_db][crate::model::AutonomousDatabaseProperties::local_standby_db].
    pub fn set_or_clear_local_standby_db<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseStandbySummary>,
    {
        self.local_standby_db = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_per_oracle_compute_unit_gbs][crate::model::AutonomousDatabaseProperties::memory_per_oracle_compute_unit_gbs].
    pub fn set_memory_per_oracle_compute_unit_gbs<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.memory_per_oracle_compute_unit_gbs = v.into();
        self
    }

    /// Sets the value of [local_disaster_recovery_type][crate::model::AutonomousDatabaseProperties::local_disaster_recovery_type].
    pub fn set_local_disaster_recovery_type<
        T: std::convert::Into<crate::model::autonomous_database_properties::LocalDisasterRecoveryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_disaster_recovery_type = v.into();
        self
    }

    /// Sets the value of [data_safe_state][crate::model::AutonomousDatabaseProperties::data_safe_state].
    pub fn set_data_safe_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DataSafeState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_safe_state = v.into();
        self
    }

    /// Sets the value of [database_management_state][crate::model::AutonomousDatabaseProperties::database_management_state].
    pub fn set_database_management_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::DatabaseManagementState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_management_state = v.into();
        self
    }

    /// Sets the value of [open_mode][crate::model::AutonomousDatabaseProperties::open_mode].
    pub fn set_open_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::OpenMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_mode = v.into();
        self
    }

    /// Sets the value of [operations_insights_state][crate::model::AutonomousDatabaseProperties::operations_insights_state].
    pub fn set_operations_insights_state<
        T: std::convert::Into<crate::model::OperationsInsightsState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operations_insights_state = v.into();
        self
    }

    /// Sets the value of [peer_db_ids][crate::model::AutonomousDatabaseProperties::peer_db_ids].
    pub fn set_peer_db_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_db_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [permission_level][crate::model::AutonomousDatabaseProperties::permission_level].
    pub fn set_permission_level<
        T: std::convert::Into<crate::model::autonomous_database_properties::PermissionLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.permission_level = v.into();
        self
    }

    /// Sets the value of [private_endpoint][crate::model::AutonomousDatabaseProperties::private_endpoint].
    pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint = v.into();
        self
    }

    /// Sets the value of [refreshable_mode][crate::model::AutonomousDatabaseProperties::refreshable_mode].
    pub fn set_refreshable_mode<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_mode = v.into();
        self
    }

    /// Sets the value of [refreshable_state][crate::model::AutonomousDatabaseProperties::refreshable_state].
    pub fn set_refreshable_state<
        T: std::convert::Into<crate::model::autonomous_database_properties::RefreshableState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refreshable_state = v.into();
        self
    }

    /// Sets the value of [role][crate::model::AutonomousDatabaseProperties::role].
    pub fn set_role<T: std::convert::Into<crate::model::autonomous_database_properties::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [scheduled_operation_details][crate::model::AutonomousDatabaseProperties::scheduled_operation_details].
    pub fn set_scheduled_operation_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScheduledOperationDetails>,
    {
        use std::iter::Iterator;
        self.scheduled_operation_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sql_web_developer_url][crate::model::AutonomousDatabaseProperties::sql_web_developer_url].
    pub fn set_sql_web_developer_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sql_web_developer_url = v.into();
        self
    }

    /// Sets the value of [supported_clone_regions][crate::model::AutonomousDatabaseProperties::supported_clone_regions].
    pub fn set_supported_clone_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_clone_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [used_data_storage_size_tbs][crate::model::AutonomousDatabaseProperties::used_data_storage_size_tbs].
    pub fn set_used_data_storage_size_tbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.used_data_storage_size_tbs = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::AutonomousDatabaseProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [total_auto_backup_storage_size_gbs][crate::model::AutonomousDatabaseProperties::total_auto_backup_storage_size_gbs].
    pub fn set_total_auto_backup_storage_size_gbs<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_auto_backup_storage_size_gbs = v.into();
        self
    }

    /// Sets the value of [next_long_term_backup_time][crate::model::AutonomousDatabaseProperties::next_long_term_backup_time].
    pub fn set_next_long_term_backup_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_long_term_backup_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_long_term_backup_time][crate::model::AutonomousDatabaseProperties::next_long_term_backup_time].
    pub fn set_or_clear_next_long_term_backup_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_long_term_backup_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseProperties::data_guard_role_changed_time].
    pub fn set_data_guard_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseProperties::data_guard_role_changed_time].
    pub fn set_or_clear_data_guard_role_changed_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseProperties::disaster_recovery_role_changed_time].
    pub fn set_disaster_recovery_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseProperties::disaster_recovery_role_changed_time].
    pub fn set_or_clear_disaster_recovery_role_changed_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_begin_time][crate::model::AutonomousDatabaseProperties::maintenance_begin_time].
    pub fn set_maintenance_begin_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_begin_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_begin_time][crate::model::AutonomousDatabaseProperties::maintenance_begin_time].
    pub fn set_or_clear_maintenance_begin_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_begin_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_end_time][crate::model::AutonomousDatabaseProperties::maintenance_end_time].
    pub fn set_maintenance_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_end_time][crate::model::AutonomousDatabaseProperties::maintenance_end_time].
    pub fn set_or_clear_maintenance_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allowlisted_ips][crate::model::AutonomousDatabaseProperties::allowlisted_ips].
    pub fn set_allowlisted_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowlisted_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [encryption_key][crate::model::AutonomousDatabaseProperties::encryption_key].
    pub fn set_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionKey>,
    {
        self.encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key][crate::model::AutonomousDatabaseProperties::encryption_key].
    pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionKey>,
    {
        self.encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_key_history_entries][crate::model::AutonomousDatabaseProperties::encryption_key_history_entries].
    pub fn set_encryption_key_history_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EncryptionKeyHistoryEntry>,
    {
        use std::iter::Iterator;
        self.encryption_key_history_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_agent_email][crate::model::AutonomousDatabaseProperties::service_agent_email].
    pub fn set_service_agent_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_agent_email = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseProperties"
    }
}

/// Defines additional types related to [AutonomousDatabaseProperties].
pub mod autonomous_database_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The editions available for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEdition {
        /// Default unspecified value.
        Unspecified,
        /// Standard Database Edition
        StandardEdition,
        /// Enterprise Database Edition
        EnterpriseEdition,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEdition::value] or
        /// [DatabaseEdition::name].
        UnknownValue(database_edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEdition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardEdition => std::option::Option::Some(1),
                Self::EnterpriseEdition => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_EDITION_UNSPECIFIED"),
                Self::StandardEdition => std::option::Option::Some("STANDARD_EDITION"),
                Self::EnterpriseEdition => std::option::Option::Some("ENTERPRISE_EDITION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEdition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEdition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEdition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardEdition,
                2 => Self::EnterpriseEdition,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEdition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_EDITION" => Self::StandardEdition,
                "ENTERPRISE_EDITION" => Self::EnterpriseEdition,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEdition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardEdition => serializer.serialize_i32(1),
                Self::EnterpriseEdition => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEdition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEdition>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DatabaseEdition",
            ))
        }
    }

    /// The license types available for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseType {
        /// Unspecified
        Unspecified,
        /// License included part of offer
        LicenseIncluded,
        /// Bring your own license
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseType::value] or
        /// [LicenseType::name].
        UnknownValue(license_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_TYPE_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.LicenseType",
            ))
        }
    }

    /// The available maintenance schedules for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceScheduleType {
        /// Default unspecified value.
        Unspecified,
        /// An EARLY maintenance schedule patches the database before
        /// the regular scheduled maintenance.
        Early,
        /// A REGULAR maintenance schedule follows the normal maintenance cycle.
        Regular,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceScheduleType::value] or
        /// [MaintenanceScheduleType::name].
        UnknownValue(maintenance_schedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod maintenance_schedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaintenanceScheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Early => std::option::Option::Some(1),
                Self::Regular => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED")
                }
                Self::Early => std::option::Option::Some("EARLY"),
                Self::Regular => std::option::Option::Some("REGULAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaintenanceScheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaintenanceScheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaintenanceScheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Early,
                2 => Self::Regular,
                _ => Self::UnknownValue(maintenance_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaintenanceScheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EARLY" => Self::Early,
                "REGULAR" => Self::Regular,
                _ => Self::UnknownValue(maintenance_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaintenanceScheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Early => serializer.serialize_i32(1),
                Self::Regular => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceScheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaintenanceScheduleType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.MaintenanceScheduleType"))
        }
    }

    /// The types of local disaster recovery available for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocalDisasterRecoveryType {
        /// Default unspecified value.
        Unspecified,
        /// Autonomous Data Guard recovery.
        Adg,
        /// Backup based recovery.
        BackupBased,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocalDisasterRecoveryType::value] or
        /// [LocalDisasterRecoveryType::name].
        UnknownValue(local_disaster_recovery_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod local_disaster_recovery_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocalDisasterRecoveryType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Adg => std::option::Option::Some(1),
                Self::BackupBased => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED")
                }
                Self::Adg => std::option::Option::Some("ADG"),
                Self::BackupBased => std::option::Option::Some("BACKUP_BASED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocalDisasterRecoveryType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocalDisasterRecoveryType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocalDisasterRecoveryType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Adg,
                2 => Self::BackupBased,
                _ => Self::UnknownValue(local_disaster_recovery_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocalDisasterRecoveryType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ADG" => Self::Adg,
                "BACKUP_BASED" => Self::BackupBased,
                _ => Self::UnknownValue(local_disaster_recovery_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocalDisasterRecoveryType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Adg => serializer.serialize_i32(1),
                Self::BackupBased => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocalDisasterRecoveryType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocalDisasterRecoveryType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.LocalDisasterRecoveryType"))
        }
    }

    /// Varies states of the Data Safe registration for the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSafeState {
        /// Default unspecified value.
        Unspecified,
        /// Registering data safe state.
        Registering,
        /// Registered data safe state.
        Registered,
        /// Deregistering data safe state.
        Deregistering,
        /// Not registered data safe state.
        NotRegistered,
        /// Failed data safe state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataSafeState::value] or
        /// [DataSafeState::name].
        UnknownValue(data_safe_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_safe_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataSafeState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Registering => std::option::Option::Some(1),
                Self::Registered => std::option::Option::Some(2),
                Self::Deregistering => std::option::Option::Some(3),
                Self::NotRegistered => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SAFE_STATE_UNSPECIFIED"),
                Self::Registering => std::option::Option::Some("REGISTERING"),
                Self::Registered => std::option::Option::Some("REGISTERED"),
                Self::Deregistering => std::option::Option::Some("DEREGISTERING"),
                Self::NotRegistered => std::option::Option::Some("NOT_REGISTERED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataSafeState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataSafeState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataSafeState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Registering,
                2 => Self::Registered,
                3 => Self::Deregistering,
                4 => Self::NotRegistered,
                5 => Self::Failed,
                _ => Self::UnknownValue(data_safe_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataSafeState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SAFE_STATE_UNSPECIFIED" => Self::Unspecified,
                "REGISTERING" => Self::Registering,
                "REGISTERED" => Self::Registered,
                "DEREGISTERING" => Self::Deregistering,
                "NOT_REGISTERED" => Self::NotRegistered,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(data_safe_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataSafeState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Registering => serializer.serialize_i32(1),
                Self::Registered => serializer.serialize_i32(2),
                Self::Deregistering => serializer.serialize_i32(3),
                Self::NotRegistered => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataSafeState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataSafeState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DataSafeState",
            ))
        }
    }

    /// The different states of database management for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseManagementState {
        /// Default unspecified value.
        Unspecified,
        /// Enabling Database Management state
        Enabling,
        /// Enabled Database Management state
        Enabled,
        /// Disabling Database Management state
        Disabling,
        /// Not Enabled Database Management state
        NotEnabled,
        /// Failed enabling Database Management state
        FailedEnabling,
        /// Failed disabling Database Management state
        FailedDisabling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseManagementState::value] or
        /// [DatabaseManagementState::name].
        UnknownValue(database_management_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_management_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseManagementState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabling => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::Disabling => std::option::Option::Some(3),
                Self::NotEnabled => std::option::Option::Some(4),
                Self::FailedEnabling => std::option::Option::Some(5),
                Self::FailedDisabling => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DATABASE_MANAGEMENT_STATE_UNSPECIFIED")
                }
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
                Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
                Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseManagementState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseManagementState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseManagementState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabling,
                2 => Self::Enabled,
                3 => Self::Disabling,
                4 => Self::NotEnabled,
                5 => Self::FailedEnabling,
                6 => Self::FailedDisabling,
                _ => Self::UnknownValue(database_management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseManagementState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_MANAGEMENT_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLING" => Self::Enabling,
                "ENABLED" => Self::Enabled,
                "DISABLING" => Self::Disabling,
                "NOT_ENABLED" => Self::NotEnabled,
                "FAILED_ENABLING" => Self::FailedEnabling,
                "FAILED_DISABLING" => Self::FailedDisabling,
                _ => Self::UnknownValue(database_management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseManagementState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabling => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::Disabling => serializer.serialize_i32(3),
                Self::NotEnabled => serializer.serialize_i32(4),
                Self::FailedEnabling => serializer.serialize_i32(5),
                Self::FailedDisabling => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseManagementState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseManagementState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.DatabaseManagementState"))
        }
    }

    /// This field indicates the modes of an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OpenMode {
        /// Default unspecified value.
        Unspecified,
        /// Read Only Mode
        ReadOnly,
        /// Read Write Mode
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OpenMode::value] or
        /// [OpenMode::name].
        UnknownValue(open_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod open_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OpenMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReadOnly => std::option::Option::Some(1),
                Self::ReadWrite => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPEN_MODE_UNSPECIFIED"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OpenMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OpenMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OpenMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReadOnly,
                2 => Self::ReadWrite,
                _ => Self::UnknownValue(open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OpenMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPEN_MODE_UNSPECIFIED" => Self::Unspecified,
                "READ_ONLY" => Self::ReadOnly,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OpenMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReadOnly => serializer.serialize_i32(1),
                Self::ReadWrite => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OpenMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OpenMode>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.OpenMode",
            ))
        }
    }

    /// The types of permission levels for an Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PermissionLevel {
        /// Default unspecified value.
        Unspecified,
        /// Restricted mode allows access only by admin users.
        Restricted,
        /// Normal access.
        Unrestricted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PermissionLevel::value] or
        /// [PermissionLevel::name].
        UnknownValue(permission_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod permission_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PermissionLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Restricted => std::option::Option::Some(1),
                Self::Unrestricted => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERMISSION_LEVEL_UNSPECIFIED"),
                Self::Restricted => std::option::Option::Some("RESTRICTED"),
                Self::Unrestricted => std::option::Option::Some("UNRESTRICTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PermissionLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PermissionLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PermissionLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Restricted,
                2 => Self::Unrestricted,
                _ => Self::UnknownValue(permission_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PermissionLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERMISSION_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "RESTRICTED" => Self::Restricted,
                "UNRESTRICTED" => Self::Unrestricted,
                _ => Self::UnknownValue(permission_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PermissionLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Restricted => serializer.serialize_i32(1),
                Self::Unrestricted => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PermissionLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PermissionLevel>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.PermissionLevel",
            ))
        }
    }

    /// The refresh mode of the cloned Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefreshableMode {
        /// The default unspecified value.
        Unspecified,
        /// AUTOMATIC indicates that the cloned database is automatically
        /// refreshed with data from the source Autonomous Database.
        Automatic,
        /// MANUAL indicates that the cloned database is manually refreshed with
        /// data from the source Autonomous Database.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefreshableMode::value] or
        /// [RefreshableMode::name].
        UnknownValue(refreshable_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod refreshable_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefreshableMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REFRESHABLE_MODE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefreshableMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefreshableMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefreshableMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(refreshable_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefreshableMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REFRESHABLE_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(refreshable_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefreshableMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefreshableMode>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.RefreshableMode",
            ))
        }
    }

    /// The refresh state of the cloned Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefreshableState {
        /// Default unspecified value.
        Unspecified,
        /// Refreshing
        Refreshing,
        /// Not refreshed
        NotRefreshing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefreshableState::value] or
        /// [RefreshableState::name].
        UnknownValue(refreshable_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod refreshable_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefreshableState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Refreshing => std::option::Option::Some(1),
                Self::NotRefreshing => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REFRESHABLE_STATE_UNSPECIFIED"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::NotRefreshing => std::option::Option::Some("NOT_REFRESHING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefreshableState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefreshableState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefreshableState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Refreshing,
                2 => Self::NotRefreshing,
                _ => Self::UnknownValue(refreshable_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefreshableState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REFRESHABLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "REFRESHING" => Self::Refreshing,
                "NOT_REFRESHING" => Self::NotRefreshing,
                _ => Self::UnknownValue(refreshable_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefreshableState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Refreshing => serializer.serialize_i32(1),
                Self::NotRefreshing => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefreshableState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefreshableState>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.RefreshableState",
            ))
        }
    }

    /// The Data Guard role of the Autonomous Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Default unspecified value.
        Unspecified,
        /// Primary role
        Primary,
        /// Standby role
        Standby,
        /// Disabled standby role
        DisabledStandby,
        /// Backup copy role
        BackupCopy,
        /// Snapshot standby role
        SnapshotStandby,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::Standby => std::option::Option::Some(2),
                Self::DisabledStandby => std::option::Option::Some(3),
                Self::BackupCopy => std::option::Option::Some(4),
                Self::SnapshotStandby => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Standby => std::option::Option::Some("STANDBY"),
                Self::DisabledStandby => std::option::Option::Some("DISABLED_STANDBY"),
                Self::BackupCopy => std::option::Option::Some("BACKUP_COPY"),
                Self::SnapshotStandby => std::option::Option::Some("SNAPSHOT_STANDBY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::Standby,
                3 => Self::DisabledStandby,
                4 => Self::BackupCopy,
                5 => Self::SnapshotStandby,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "STANDBY" => Self::Standby,
                "DISABLED_STANDBY" => Self::DisabledStandby,
                "BACKUP_COPY" => Self::BackupCopy,
                "SNAPSHOT_STANDBY" => Self::SnapshotStandby,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::Standby => serializer.serialize_i32(2),
                Self::DisabledStandby => serializer.serialize_i32(3),
                Self::BackupCopy => serializer.serialize_i32(4),
                Self::SnapshotStandby => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseProperties.Role",
            ))
        }
    }
}

/// The history of the encryption keys used to encrypt the Autonomous Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionKeyHistoryEntry {
    /// Output only. The encryption key used to encrypt the Autonomous Database.
    pub encryption_key: std::option::Option<crate::model::EncryptionKey>,

    /// Output only. The date and time when the encryption key was activated on the
    /// Autonomous Database..
    pub activation_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionKeyHistoryEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_key][crate::model::EncryptionKeyHistoryEntry::encryption_key].
    pub fn set_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionKey>,
    {
        self.encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key][crate::model::EncryptionKeyHistoryEntry::encryption_key].
    pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionKey>,
    {
        self.encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activation_time][crate::model::EncryptionKeyHistoryEntry::activation_time].
    pub fn set_activation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.activation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [activation_time][crate::model::EncryptionKeyHistoryEntry::activation_time].
    pub fn set_or_clear_activation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.activation_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EncryptionKeyHistoryEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.EncryptionKeyHistoryEntry"
    }
}

/// The encryption key used to encrypt the Autonomous Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionKey {
    /// Optional. The provider of the encryption key.
    pub provider: crate::model::encryption_key::Provider,

    /// Optional. The KMS key used to encrypt the Autonomous Database.
    /// This field is required if the provider is GOOGLE_MANAGED.
    /// The name of the KMS key resource in the following format:
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    pub kms_key: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provider][crate::model::EncryptionKey::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::encryption_key::Provider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::EncryptionKey::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.EncryptionKey"
    }
}

/// Defines additional types related to [EncryptionKey].
pub mod encryption_key {
    #[allow(unused_imports)]
    use super::*;

    /// The provider of the encryption key.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Provider {
        /// Default unspecified value.
        Unspecified,
        /// Google Managed KMS key, if selected, please provide the KMS key name.
        GoogleManaged,
        /// Oracle Managed.
        OracleManaged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Provider::value] or
        /// [Provider::name].
        UnknownValue(provider::UnknownValue),
    }

    #[doc(hidden)]
    pub mod provider {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Provider {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleManaged => std::option::Option::Some(1),
                Self::OracleManaged => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROVIDER_UNSPECIFIED"),
                Self::GoogleManaged => std::option::Option::Some("GOOGLE_MANAGED"),
                Self::OracleManaged => std::option::Option::Some("ORACLE_MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Provider {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Provider {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Provider {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleManaged,
                2 => Self::OracleManaged,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Provider {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROVIDER_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_MANAGED" => Self::GoogleManaged,
                "ORACLE_MANAGED" => Self::OracleManaged,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Provider {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleManaged => serializer.serialize_i32(1),
                Self::OracleManaged => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Provider {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Provider>::new(
                ".google.cloud.oracledatabase.v1.EncryptionKey.Provider",
            ))
        }
    }
}

/// Oracle APEX Application Development.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseApex>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseApex {
    /// Output only. The Oracle APEX Application Development version.
    pub apex_version: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) version.
    pub ords_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseApex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_version][crate::model::AutonomousDatabaseApex::apex_version].
    pub fn set_apex_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_version = v.into();
        self
    }

    /// Sets the value of [ords_version][crate::model::AutonomousDatabaseApex::ords_version].
    pub fn set_ords_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_version = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseApex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseApex"
    }
}

/// The connection string used to connect to the Autonomous Database.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionStrings>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionStrings {
    /// Output only. Returns all connection strings that can be used to connect to
    /// the Autonomous Database.
    pub all_connection_strings: std::option::Option<crate::model::AllConnectionStrings>,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement, but supports the most number of concurrent SQL
    /// statements.
    pub dedicated: std::string::String,

    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    pub medium: std::string::String,

    /// Output only. A list of connection string profiles to allow clients to
    /// group, filter, and select values based on the structured metadata.
    pub profiles: std::vec::Vec<crate::model::DatabaseConnectionStringProfile>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_connection_strings][crate::model::AutonomousDatabaseConnectionStrings::all_connection_strings].
    pub fn set_all_connection_strings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AllConnectionStrings>,
    {
        self.all_connection_strings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_connection_strings][crate::model::AutonomousDatabaseConnectionStrings::all_connection_strings].
    pub fn set_or_clear_all_connection_strings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AllConnectionStrings>,
    {
        self.all_connection_strings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dedicated][crate::model::AutonomousDatabaseConnectionStrings::dedicated].
    pub fn set_dedicated<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dedicated = v.into();
        self
    }

    /// Sets the value of [high][crate::model::AutonomousDatabaseConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AutonomousDatabaseConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AutonomousDatabaseConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [profiles][crate::model::AutonomousDatabaseConnectionStrings::profiles].
    pub fn set_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseConnectionStringProfile>,
    {
        use std::iter::Iterator;
        self.profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionStrings"
    }
}

/// The connection string profile to allow clients to group.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DatabaseConnectionStringProfile>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseConnectionStringProfile {
    /// Output only. The current consumer group being used by the connection.
    pub consumer_group: crate::model::database_connection_string_profile::ConsumerGroup,

    /// Output only. The display name for the database connection.
    pub display_name: std::string::String,

    /// Output only. The host name format being currently used in connection
    /// string.
    pub host_format: crate::model::database_connection_string_profile::HostFormat,

    /// Output only. This field indicates if the connection string is regional and
    /// is only applicable for cross-region Data Guard.
    pub is_regional: bool,

    /// Output only. The protocol being used by the connection.
    pub protocol: crate::model::database_connection_string_profile::Protocol,

    /// Output only. The current session mode of the connection.
    pub session_mode: crate::model::database_connection_string_profile::SessionMode,

    /// Output only. The syntax of the connection string.
    pub syntax_format: crate::model::database_connection_string_profile::SyntaxFormat,

    /// Output only. This field indicates the TLS authentication type of the
    /// connection.
    pub tls_authentication: crate::model::database_connection_string_profile::TLSAuthentication,

    /// Output only. The value of the connection string.
    pub value: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseConnectionStringProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consumer_group][crate::model::DatabaseConnectionStringProfile::consumer_group].
    pub fn set_consumer_group<
        T: std::convert::Into<crate::model::database_connection_string_profile::ConsumerGroup>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consumer_group = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DatabaseConnectionStringProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [host_format][crate::model::DatabaseConnectionStringProfile::host_format].
    pub fn set_host_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::HostFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.host_format = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::DatabaseConnectionStringProfile::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::DatabaseConnectionStringProfile::protocol].
    pub fn set_protocol<
        T: std::convert::Into<crate::model::database_connection_string_profile::Protocol>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [session_mode][crate::model::DatabaseConnectionStringProfile::session_mode].
    pub fn set_session_mode<
        T: std::convert::Into<crate::model::database_connection_string_profile::SessionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_mode = v.into();
        self
    }

    /// Sets the value of [syntax_format][crate::model::DatabaseConnectionStringProfile::syntax_format].
    pub fn set_syntax_format<
        T: std::convert::Into<crate::model::database_connection_string_profile::SyntaxFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.syntax_format = v.into();
        self
    }

    /// Sets the value of [tls_authentication][crate::model::DatabaseConnectionStringProfile::tls_authentication].
    pub fn set_tls_authentication<
        T: std::convert::Into<crate::model::database_connection_string_profile::TLSAuthentication>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tls_authentication = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DatabaseConnectionStringProfile::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseConnectionStringProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile"
    }
}

/// Defines additional types related to [DatabaseConnectionStringProfile].
pub mod database_connection_string_profile {
    #[allow(unused_imports)]
    use super::*;

    /// The various consumer groups available in the connection string profile.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConsumerGroup {
        /// Default unspecified value.
        Unspecified,
        /// High consumer group.
        High,
        /// Medium consumer group.
        Medium,
        /// Low consumer group.
        Low,
        /// TP consumer group.
        Tp,
        /// TPURGENT consumer group.
        Tpurgent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConsumerGroup::value] or
        /// [ConsumerGroup::name].
        UnknownValue(consumer_group::UnknownValue),
    }

    #[doc(hidden)]
    pub mod consumer_group {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConsumerGroup {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::Low => std::option::Option::Some(3),
                Self::Tp => std::option::Option::Some(4),
                Self::Tpurgent => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONSUMER_GROUP_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Tp => std::option::Option::Some("TP"),
                Self::Tpurgent => std::option::Option::Some("TPURGENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConsumerGroup {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConsumerGroup {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConsumerGroup {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Medium,
                3 => Self::Low,
                4 => Self::Tp,
                5 => Self::Tpurgent,
                _ => Self::UnknownValue(consumer_group::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConsumerGroup {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONSUMER_GROUP_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "MEDIUM" => Self::Medium,
                "LOW" => Self::Low,
                "TP" => Self::Tp,
                "TPURGENT" => Self::Tpurgent,
                _ => Self::UnknownValue(consumer_group::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConsumerGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::Low => serializer.serialize_i32(3),
                Self::Tp => serializer.serialize_i32(4),
                Self::Tpurgent => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConsumerGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConsumerGroup>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.ConsumerGroup",
            ))
        }
    }

    /// The host name format being used in the connection string.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HostFormat {
        /// Default unspecified value.
        Unspecified,
        /// FQDN
        Fqdn,
        /// IP
        Ip,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HostFormat::value] or
        /// [HostFormat::name].
        UnknownValue(host_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod host_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HostFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fqdn => std::option::Option::Some(1),
                Self::Ip => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HOST_FORMAT_UNSPECIFIED"),
                Self::Fqdn => std::option::Option::Some("FQDN"),
                Self::Ip => std::option::Option::Some("IP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HostFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HostFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HostFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fqdn,
                2 => Self::Ip,
                _ => Self::UnknownValue(host_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HostFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HOST_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "FQDN" => Self::Fqdn,
                "IP" => Self::Ip,
                _ => Self::UnknownValue(host_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HostFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fqdn => serializer.serialize_i32(1),
                Self::Ip => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HostFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HostFormat>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.HostFormat",
            ))
        }
    }

    /// The protocol being used by the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Default unspecified value.
        Unspecified,
        /// Tcp
        Tcp,
        /// Tcps
        Tcps,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tcp => std::option::Option::Some(1),
                Self::Tcps => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::Tcp => std::option::Option::Some("TCP"),
                Self::Tcps => std::option::Option::Some("TCPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tcp,
                2 => Self::Tcps,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "TCP" => Self::Tcp,
                "TCPS" => Self::Tcps,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tcp => serializer.serialize_i32(1),
                Self::Tcps => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.Protocol",
            ))
        }
    }

    /// The session mode of the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionMode {
        /// Default unspecified value.
        Unspecified,
        /// Direct
        Direct,
        /// Indirect
        Indirect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SessionMode::value] or
        /// [SessionMode::name].
        UnknownValue(session_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod session_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SessionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Direct => std::option::Option::Some(1),
                Self::Indirect => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SESSION_MODE_UNSPECIFIED"),
                Self::Direct => std::option::Option::Some("DIRECT"),
                Self::Indirect => std::option::Option::Some("INDIRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SessionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SessionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SessionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Direct,
                2 => Self::Indirect,
                _ => Self::UnknownValue(session_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SessionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SESSION_MODE_UNSPECIFIED" => Self::Unspecified,
                "DIRECT" => Self::Direct,
                "INDIRECT" => Self::Indirect,
                _ => Self::UnknownValue(session_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SessionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Direct => serializer.serialize_i32(1),
                Self::Indirect => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SessionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SessionMode>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.SessionMode",
            ))
        }
    }

    /// Specifies syntax of the connection string.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SyntaxFormat {
        /// Default unspecified value.
        Unspecified,
        /// Long
        Long,
        /// Ezconnect
        Ezconnect,
        /// Ezconnectplus
        Ezconnectplus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SyntaxFormat::value] or
        /// [SyntaxFormat::name].
        UnknownValue(syntax_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod syntax_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SyntaxFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Long => std::option::Option::Some(1),
                Self::Ezconnect => std::option::Option::Some(2),
                Self::Ezconnectplus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SYNTAX_FORMAT_UNSPECIFIED"),
                Self::Long => std::option::Option::Some("LONG"),
                Self::Ezconnect => std::option::Option::Some("EZCONNECT"),
                Self::Ezconnectplus => std::option::Option::Some("EZCONNECTPLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SyntaxFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SyntaxFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SyntaxFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Long,
                2 => Self::Ezconnect,
                3 => Self::Ezconnectplus,
                _ => Self::UnknownValue(syntax_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SyntaxFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SYNTAX_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "LONG" => Self::Long,
                "EZCONNECT" => Self::Ezconnect,
                "EZCONNECTPLUS" => Self::Ezconnectplus,
                _ => Self::UnknownValue(syntax_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SyntaxFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Long => serializer.serialize_i32(1),
                Self::Ezconnect => serializer.serialize_i32(2),
                Self::Ezconnectplus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SyntaxFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SyntaxFormat>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.SyntaxFormat",
            ))
        }
    }

    /// This field indicates the TLS authentication type of the connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TLSAuthentication {
        /// Default unspecified value.
        Unspecified,
        /// Server
        Server,
        /// Mutual
        Mutual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TLSAuthentication::value] or
        /// [TLSAuthentication::name].
        UnknownValue(tls_authentication::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tls_authentication {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TLSAuthentication {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Server => std::option::Option::Some(1),
                Self::Mutual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TLS_AUTHENTICATION_UNSPECIFIED"),
                Self::Server => std::option::Option::Some("SERVER"),
                Self::Mutual => std::option::Option::Some("MUTUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TLSAuthentication {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TLSAuthentication {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TLSAuthentication {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Server,
                2 => Self::Mutual,
                _ => Self::UnknownValue(tls_authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TLSAuthentication {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TLS_AUTHENTICATION_UNSPECIFIED" => Self::Unspecified,
                "SERVER" => Self::Server,
                "MUTUAL" => Self::Mutual,
                _ => Self::UnknownValue(tls_authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TLSAuthentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Server => serializer.serialize_i32(1),
                Self::Mutual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TLSAuthentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TLSAuthentication>::new(
                ".google.cloud.oracledatabase.v1.DatabaseConnectionStringProfile.TLSAuthentication",
            ))
        }
    }
}

/// A list of all connection strings that can be used to connect to the
/// Autonomous Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AllConnectionStrings {
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    pub high: std::string::String,

    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    pub low: std::string::String,

    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    pub medium: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [high][crate::model::AllConnectionStrings::high].
    pub fn set_high<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.high = v.into();
        self
    }

    /// Sets the value of [low][crate::model::AllConnectionStrings::low].
    pub fn set_low<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.low = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::AllConnectionStrings::medium].
    pub fn set_medium<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.medium = v.into();
        self
    }
}

impl wkt::message::Message for AllConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AllConnectionStrings"
    }
}

/// The URLs for accessing Oracle Application Express (APEX) and SQL Developer
/// Web with a browser from a Compute instance.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionUrls>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseConnectionUrls {
    /// Output only. Oracle Application Express (APEX) URL.
    pub apex_uri: std::string::String,

    /// Output only. The URL of the Database Transforms for the Autonomous
    /// Database.
    pub database_transforms_uri: std::string::String,

    /// Output only. The URL of the Graph Studio for the Autonomous Database.
    pub graph_studio_uri: std::string::String,

    /// Output only. The URL of the Oracle Machine Learning (OML) Notebook for the
    /// Autonomous Database.
    pub machine_learning_notebook_uri: std::string::String,

    /// Output only. The URL of Machine Learning user management the Autonomous
    /// Database.
    pub machine_learning_user_management_uri: std::string::String,

    /// Output only. The URL of the MongoDB API for the Autonomous Database.
    pub mongo_db_uri: std::string::String,

    /// Output only. The Oracle REST Data Services (ORDS) URL of the Web Access for
    /// the Autonomous Database.
    pub ords_uri: std::string::String,

    /// Output only. The URL of the Oracle SQL Developer Web for the Autonomous
    /// Database.
    pub sql_dev_web_uri: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseConnectionUrls {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apex_uri][crate::model::AutonomousDatabaseConnectionUrls::apex_uri].
    pub fn set_apex_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.apex_uri = v.into();
        self
    }

    /// Sets the value of [database_transforms_uri][crate::model::AutonomousDatabaseConnectionUrls::database_transforms_uri].
    pub fn set_database_transforms_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_transforms_uri = v.into();
        self
    }

    /// Sets the value of [graph_studio_uri][crate::model::AutonomousDatabaseConnectionUrls::graph_studio_uri].
    pub fn set_graph_studio_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.graph_studio_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_notebook_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_notebook_uri].
    pub fn set_machine_learning_notebook_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_notebook_uri = v.into();
        self
    }

    /// Sets the value of [machine_learning_user_management_uri][crate::model::AutonomousDatabaseConnectionUrls::machine_learning_user_management_uri].
    pub fn set_machine_learning_user_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_learning_user_management_uri = v.into();
        self
    }

    /// Sets the value of [mongo_db_uri][crate::model::AutonomousDatabaseConnectionUrls::mongo_db_uri].
    pub fn set_mongo_db_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mongo_db_uri = v.into();
        self
    }

    /// Sets the value of [ords_uri][crate::model::AutonomousDatabaseConnectionUrls::ords_uri].
    pub fn set_ords_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ords_uri = v.into();
        self
    }

    /// Sets the value of [sql_dev_web_uri][crate::model::AutonomousDatabaseConnectionUrls::sql_dev_web_uri].
    pub fn set_sql_dev_web_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_dev_web_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseConnectionUrls {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseConnectionUrls"
    }
}

/// Autonomous Data Guard standby database details.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseStandbySummary>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseStandbySummary {
    /// Output only. The amount of time, in seconds, that the data of the standby
    /// database lags in comparison to the data of the primary database.
    pub lag_time_duration: std::option::Option<wkt::Duration>,

    /// Output only. The additional details about the current lifecycle state of
    /// the Autonomous Database.
    pub lifecycle_details: std::string::String,

    /// Output only. The current lifecycle state of the Autonomous Database.
    pub state: crate::model::State,

    /// Output only. The date and time the Autonomous Data Guard role was switched
    /// for the standby Autonomous Database.
    pub data_guard_role_changed_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the Disaster Recovery role was switched for
    /// the standby Autonomous Database.
    pub disaster_recovery_role_changed_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseStandbySummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lag_time_duration][crate::model::AutonomousDatabaseStandbySummary::lag_time_duration].
    pub fn set_lag_time_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_time_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lag_time_duration][crate::model::AutonomousDatabaseStandbySummary::lag_time_duration].
    pub fn set_or_clear_lag_time_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_time_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseStandbySummary::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutonomousDatabaseStandbySummary::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::data_guard_role_changed_time].
    pub fn set_data_guard_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_guard_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::data_guard_role_changed_time].
    pub fn set_or_clear_data_guard_role_changed_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.data_guard_role_changed_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::disaster_recovery_role_changed_time].
    pub fn set_disaster_recovery_role_changed_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disaster_recovery_role_changed_time][crate::model::AutonomousDatabaseStandbySummary::disaster_recovery_role_changed_time].
    pub fn set_or_clear_disaster_recovery_role_changed_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.disaster_recovery_role_changed_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseStandbySummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseStandbySummary"
    }
}

/// Details of scheduled operation.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/ScheduledOperationDetails>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScheduledOperationDetails {
    /// Output only. Day of week.
    pub day_of_week: gtype::model::DayOfWeek,

    /// Output only. Auto start time.
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Output only. Auto stop time.
    pub stop_time: std::option::Option<gtype::model::TimeOfDay>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduledOperationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_week][crate::model::ScheduledOperationDetails::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScheduledOperationDetails::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ScheduledOperationDetails::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stop_time][crate::model::ScheduledOperationDetails::stop_time].
    pub fn set_stop_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.stop_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stop_time][crate::model::ScheduledOperationDetails::stop_time].
    pub fn set_or_clear_stop_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.stop_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ScheduledOperationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ScheduledOperationDetails"
    }
}

/// Details of the Autonomous Database character set resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseCharacterSet {
    /// Identifier. The name of the Autonomous Database Character Set resource in
    /// the following format:
    /// projects/{project}/locations/{region}/autonomousDatabaseCharacterSets/{autonomous_database_character_set}
    pub name: std::string::String,

    /// Output only. The character set type for the Autonomous Database.
    pub character_set_type: crate::model::autonomous_database_character_set::CharacterSetType,

    /// Output only. The character set name for the Autonomous Database which is
    /// the ID in the resource name.
    pub character_set: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseCharacterSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseCharacterSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [character_set_type][crate::model::AutonomousDatabaseCharacterSet::character_set_type].
    pub fn set_character_set_type<
        T: std::convert::Into<crate::model::autonomous_database_character_set::CharacterSetType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.character_set_type = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::AutonomousDatabaseCharacterSet::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseCharacterSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseCharacterSet"
    }
}

/// Defines additional types related to [AutonomousDatabaseCharacterSet].
pub mod autonomous_database_character_set {
    #[allow(unused_imports)]
    use super::*;

    /// The type of character set an Autonomous Database can have.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CharacterSetType {
        /// Character set type is not specified.
        Unspecified,
        /// Character set type is set to database.
        Database,
        /// Character set type is set to national.
        National,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CharacterSetType::value] or
        /// [CharacterSetType::name].
        UnknownValue(character_set_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod character_set_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CharacterSetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::National => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHARACTER_SET_TYPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::National => std::option::Option::Some("NATIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CharacterSetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CharacterSetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CharacterSetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CharacterSetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "NATIONAL" => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CharacterSetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::National => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CharacterSetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CharacterSetType>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseCharacterSet.CharacterSetType",
            ))
        }
    }
}

/// Details of the Autonomous Database Backup resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseBackup/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseBackup {
    /// Identifier. The name of the Autonomous Database Backup resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabaseBackups/{autonomous_database_backup}
    pub name: std::string::String,

    /// Required. The name of the Autonomous Database resource for which the backup
    /// is being created. Format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    pub autonomous_database: std::string::String,

    /// Optional. User friendly name for the Backup. The name does not have to be
    /// unique.
    pub display_name: std::string::String,

    /// Optional. Various properties of the backup.
    pub properties: std::option::Option<crate::model::AutonomousDatabaseBackupProperties>,

    /// Optional. labels or tags associated with the resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseBackup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDatabaseBackup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::AutonomousDatabaseBackup::autonomous_database].
    pub fn set_autonomous_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AutonomousDatabaseBackup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::AutonomousDatabaseBackup::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseBackupProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::AutonomousDatabaseBackup::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabaseBackupProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AutonomousDatabaseBackup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackup"
    }
}

/// Properties of the Autonomous Database Backup resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDatabaseBackupProperties {
    /// Output only. OCID of the Autonomous Database backup.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    pub ocid: std::string::String,

    /// Optional. Retention period in days for the backup.
    pub retention_period_days: i32,

    /// Output only. The OCID of the compartment.
    pub compartment_id: std::string::String,

    /// Output only. The quantity of data in the database, in terabytes.
    pub database_size_tb: f32,

    /// Output only. A valid Oracle Database version for Autonomous Database.
    pub db_version: std::string::String,

    /// Output only. Indicates if the backup is long term backup.
    pub is_long_term_backup: bool,

    /// Output only. Indicates if the backup is automatic or user initiated.
    pub is_automatic_backup: bool,

    /// Output only. Indicates if the backup can be used to restore the Autonomous
    /// Database.
    pub is_restorable: bool,

    /// Optional. The OCID of the key store of Oracle Vault.
    pub key_store_id: std::string::String,

    /// Optional. The wallet name for Oracle Key Vault.
    pub key_store_wallet: std::string::String,

    /// Optional. The OCID of the key container that is used as the master
    /// encryption key in database transparent data encryption (TDE) operations.
    pub kms_key_id: std::string::String,

    /// Optional. The OCID of the key container version that is used in database
    /// transparent data encryption (TDE) operations KMS Key can have multiple key
    /// versions. If none is specified, the current key version (latest) of the Key
    /// Id is used for the operation. Autonomous Database Serverless does not use
    /// key versions, hence is not applicable for Autonomous Database Serverless
    /// instances.
    pub kms_key_version_id: std::string::String,

    /// Output only. Additional information about the current lifecycle state.
    pub lifecycle_details: std::string::String,

    /// Output only. The lifecycle state of the backup.
    pub lifecycle_state: crate::model::autonomous_database_backup_properties::State,

    /// Output only. The backup size in terabytes.
    pub size_tb: f32,

    /// Output only. Timestamp until when the backup will be available.
    pub available_till_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup completed.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The date and time the backup started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The type of the backup.
    pub r#type: crate::model::autonomous_database_backup_properties::Type,

    /// Optional. The OCID of the vault.
    pub vault_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDatabaseBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::AutonomousDatabaseBackupProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [retention_period_days][crate::model::AutonomousDatabaseBackupProperties::retention_period_days].
    pub fn set_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_period_days = v.into();
        self
    }

    /// Sets the value of [compartment_id][crate::model::AutonomousDatabaseBackupProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [database_size_tb][crate::model::AutonomousDatabaseBackupProperties::database_size_tb].
    pub fn set_database_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.database_size_tb = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::AutonomousDatabaseBackupProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [is_long_term_backup][crate::model::AutonomousDatabaseBackupProperties::is_long_term_backup].
    pub fn set_is_long_term_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_long_term_backup = v.into();
        self
    }

    /// Sets the value of [is_automatic_backup][crate::model::AutonomousDatabaseBackupProperties::is_automatic_backup].
    pub fn set_is_automatic_backup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_automatic_backup = v.into();
        self
    }

    /// Sets the value of [is_restorable][crate::model::AutonomousDatabaseBackupProperties::is_restorable].
    pub fn set_is_restorable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_restorable = v.into();
        self
    }

    /// Sets the value of [key_store_id][crate::model::AutonomousDatabaseBackupProperties::key_store_id].
    pub fn set_key_store_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_store_id = v.into();
        self
    }

    /// Sets the value of [key_store_wallet][crate::model::AutonomousDatabaseBackupProperties::key_store_wallet].
    pub fn set_key_store_wallet<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_store_wallet = v.into();
        self
    }

    /// Sets the value of [kms_key_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_id].
    pub fn set_kms_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_id = v.into();
        self
    }

    /// Sets the value of [kms_key_version_id][crate::model::AutonomousDatabaseBackupProperties::kms_key_version_id].
    pub fn set_kms_key_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_id = v.into();
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::AutonomousDatabaseBackupProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::AutonomousDatabaseBackupProperties::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [size_tb][crate::model::AutonomousDatabaseBackupProperties::size_tb].
    pub fn set_size_tb<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.size_tb = v.into();
        self
    }

    /// Sets the value of [available_till_time][crate::model::AutonomousDatabaseBackupProperties::available_till_time].
    pub fn set_available_till_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_till_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_till_time][crate::model::AutonomousDatabaseBackupProperties::available_till_time].
    pub fn set_or_clear_available_till_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_till_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::AutonomousDatabaseBackupProperties::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::AutonomousDatabaseBackupProperties::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::AutonomousDatabaseBackupProperties::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::AutonomousDatabaseBackupProperties::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AutonomousDatabaseBackupProperties::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::autonomous_database_backup_properties::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [vault_id][crate::model::AutonomousDatabaseBackupProperties::vault_id].
    pub fn set_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vault_id = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDatabaseBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties"
    }
}

/// Defines additional types related to [AutonomousDatabaseBackupProperties].
pub mod autonomous_database_backup_properties {
    #[allow(unused_imports)]
    use super::*;

    /// // The various lifecycle states of the Autonomous Database Backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in creating state.
        Creating,
        /// Indicates that the resource is in active state.
        Active,
        /// Indicates that the resource is in deleting state.
        Deleting,
        /// Indicates that the resource is in deleted state.
        Deleted,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource is in updating state.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Deleted => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(6),
                Self::Updating => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Deleted,
                6 => Self::Failed,
                7 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "FAILED" => Self::Failed,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Deleted => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(6),
                Self::Updating => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties.State",
            ))
        }
    }

    /// The type of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default unspecified value.
        Unspecified,
        /// Incremental backups.
        Incremental,
        /// Full backups.
        Full,
        /// Long term backups.
        LongTerm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incremental => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::LongTerm => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::LongTerm => std::option::Option::Some("LONG_TERM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incremental,
                2 => Self::Full,
                3 => Self::LongTerm,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INCREMENTAL" => Self::Incremental,
                "FULL" => Self::Full,
                "LONG_TERM" => Self::LongTerm,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incremental => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::LongTerm => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.oracledatabase.v1.AutonomousDatabaseBackupProperties.Type",
            ))
        }
    }
}

/// Details of the Autonomous Database version.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDbVersionSummary/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutonomousDbVersion {
    /// Identifier. The name of the Autonomous Database Version resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDbVersions/{autonomous_db_version}
    pub name: std::string::String,

    /// Output only. An Oracle Database version for Autonomous Database.
    pub version: std::string::String,

    /// Output only. The Autonomous Database workload type.
    pub db_workload: crate::model::DBWorkload,

    /// Output only. A URL that points to a detailed description of the Autonomous
    /// Database version.
    pub workload_uri: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutonomousDbVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutonomousDbVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AutonomousDbVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [db_workload][crate::model::AutonomousDbVersion::db_workload].
    pub fn set_db_workload<T: std::convert::Into<crate::model::DBWorkload>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_workload = v.into();
        self
    }

    /// Sets the value of [workload_uri][crate::model::AutonomousDbVersion::workload_uri].
    pub fn set_workload_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutonomousDbVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.AutonomousDbVersion"
    }
}

/// The CustomerContact reference as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/CustomerContact>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerContact {
    /// Required. The email address used by Oracle to send notifications regarding
    /// databases and infrastructure.
    pub email: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerContact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::CustomerContact::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for CustomerContact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CustomerContact"
    }
}

/// The identity connector details which will allow OCI to securely access
/// the resources in the customer project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IdentityConnector {
    /// Output only. A google managed service account on which customers can grant
    /// roles to access resources in the customer project. Example:
    /// `p176944527254-55-75119d87fd8f@gcp-sa-oci.iam.gserviceaccount.com`
    pub service_agent_email: std::string::String,

    /// Output only. The connection state of the identity connector.
    pub connection_state: crate::model::identity_connector::ConnectionState,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IdentityConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_agent_email][crate::model::IdentityConnector::service_agent_email].
    pub fn set_service_agent_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_agent_email = v.into();
        self
    }

    /// Sets the value of [connection_state][crate::model::IdentityConnector::connection_state].
    pub fn set_connection_state<
        T: std::convert::Into<crate::model::identity_connector::ConnectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_state = v.into();
        self
    }
}

impl wkt::message::Message for IdentityConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.IdentityConnector"
    }
}

/// Defines additional types related to [IdentityConnector].
pub mod identity_connector {
    #[allow(unused_imports)]
    use super::*;

    /// The various connection states of the WorkloadIdentityPoolConnection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionState {
        /// Default unspecified value.
        Unspecified,
        /// The identity pool connection is connected.
        Connected,
        /// The identity pool connection is partially connected.
        PartiallyConnected,
        /// The identity pool connection is disconnected.
        Disconnected,
        /// The identity pool connection is in an unknown state.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectionState::value] or
        /// [ConnectionState::name].
        UnknownValue(connection_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connection_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Connected => std::option::Option::Some(1),
                Self::PartiallyConnected => std::option::Option::Some(2),
                Self::Disconnected => std::option::Option::Some(3),
                Self::Unknown => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTION_STATE_UNSPECIFIED"),
                Self::Connected => std::option::Option::Some("CONNECTED"),
                Self::PartiallyConnected => std::option::Option::Some("PARTIALLY_CONNECTED"),
                Self::Disconnected => std::option::Option::Some("DISCONNECTED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Connected,
                2 => Self::PartiallyConnected,
                3 => Self::Disconnected,
                4 => Self::Unknown,
                _ => Self::UnknownValue(connection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConnectionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "CONNECTED" => Self::Connected,
                "PARTIALLY_CONNECTED" => Self::PartiallyConnected,
                "DISCONNECTED" => Self::Disconnected,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(connection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConnectionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Connected => serializer.serialize_i32(1),
                Self::PartiallyConnected => serializer.serialize_i32(2),
                Self::Disconnected => serializer.serialize_i32(3),
                Self::Unknown => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionState>::new(
                ".google.cloud.oracledatabase.v1.IdentityConnector.ConnectionState",
            ))
        }
    }
}

/// Data collection options for diagnostics.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DataCollectionOptions>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataCollectionOptionsCommon {
    /// Optional. Indicates whether to enable data collection for diagnostics.
    pub is_diagnostics_events_enabled: bool,

    /// Optional. Indicates whether to enable health monitoring.
    pub is_health_monitoring_enabled: bool,

    /// Optional. Indicates whether to enable incident logs and trace collection.
    pub is_incident_logs_enabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataCollectionOptionsCommon {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_diagnostics_events_enabled][crate::model::DataCollectionOptionsCommon::is_diagnostics_events_enabled].
    pub fn set_is_diagnostics_events_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_diagnostics_events_enabled = v.into();
        self
    }

    /// Sets the value of [is_health_monitoring_enabled][crate::model::DataCollectionOptionsCommon::is_health_monitoring_enabled].
    pub fn set_is_health_monitoring_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_health_monitoring_enabled = v.into();
        self
    }

    /// Sets the value of [is_incident_logs_enabled][crate::model::DataCollectionOptionsCommon::is_incident_logs_enabled].
    pub fn set_is_incident_logs_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_incident_logs_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCollectionOptionsCommon {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DataCollectionOptionsCommon"
    }
}

/// Details of the Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/Database/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Database {
    /// Identifier. The name of the Database resource in the following format:
    /// projects/{project}/locations/{region}/databases/{database}
    pub name: std::string::String,

    /// Optional. The database name. The name must begin with an alphabetic
    /// character and can contain a maximum of eight alphanumeric characters.
    /// Special characters are not permitted.
    pub db_name: std::string::String,

    /// Optional. The DB_UNIQUE_NAME of the Oracle Database being backed up.
    pub db_unique_name: std::string::String,

    /// Required. The password for the default ADMIN user.
    pub admin_password: std::string::String,

    /// Optional. The TDE wallet password for the database.
    pub tde_wallet_password: std::string::String,

    /// Optional. The character set for the database. The default is AL32UTF8.
    pub character_set: std::string::String,

    /// Optional. The national character set for the database. The default is
    /// AL16UTF16.
    pub ncharacter_set: std::string::String,

    /// Output only. HTTPS link to OCI resources exposed to Customer via UI
    /// Interface.
    pub oci_url: std::string::String,

    /// Output only. The date and time that the Database was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The properties of the Database.
    pub properties: std::option::Option<crate::model::DatabaseProperties>,

    /// Optional. The database ID of the Database.
    pub database_id: std::string::String,

    /// Optional. The name of the DbHome resource associated with the Database.
    pub db_home_name: std::string::String,

    /// Output only. The GCP Oracle zone where the Database is created.
    pub gcp_oracle_zone: std::string::String,

    /// Output only. The Status of Operations Insights for this Database.
    pub ops_insights_status: crate::model::database::OperationsInsightsStatus,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [db_name][crate::model::Database::db_name].
    pub fn set_db_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_name = v.into();
        self
    }

    /// Sets the value of [db_unique_name][crate::model::Database::db_unique_name].
    pub fn set_db_unique_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_unique_name = v.into();
        self
    }

    /// Sets the value of [admin_password][crate::model::Database::admin_password].
    pub fn set_admin_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin_password = v.into();
        self
    }

    /// Sets the value of [tde_wallet_password][crate::model::Database::tde_wallet_password].
    pub fn set_tde_wallet_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tde_wallet_password = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::Database::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }

    /// Sets the value of [ncharacter_set][crate::model::Database::ncharacter_set].
    pub fn set_ncharacter_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ncharacter_set = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::Database::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Database::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Database::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [properties][crate::model::Database::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::Database::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_id][crate::model::Database::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [db_home_name][crate::model::Database::db_home_name].
    pub fn set_db_home_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_home_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::Database::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [ops_insights_status][crate::model::Database::ops_insights_status].
    pub fn set_ops_insights_status<
        T: std::convert::Into<crate::model::database::OperationsInsightsStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ops_insights_status = v.into();
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.Database"
    }
}

/// Defines additional types related to [Database].
pub mod database {
    #[allow(unused_imports)]
    use super::*;

    /// The Status of Operations Insights for this Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OperationsInsightsStatus {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the operations insights are being enabled.
        Enabling,
        /// Indicates that the operations insights are enabled.
        Enabled,
        /// Indicates that the operations insights are being disabled.
        Disabling,
        /// Indicates that the operations insights are not enabled.
        NotEnabled,
        /// Indicates that the operations insights failed to enable.
        FailedEnabling,
        /// Indicates that the operations insights failed to disable.
        FailedDisabling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OperationsInsightsStatus::value] or
        /// [OperationsInsightsStatus::name].
        UnknownValue(operations_insights_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operations_insights_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OperationsInsightsStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabling => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::Disabling => std::option::Option::Some(3),
                Self::NotEnabled => std::option::Option::Some(4),
                Self::FailedEnabling => std::option::Option::Some(5),
                Self::FailedDisabling => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("OPERATIONS_INSIGHTS_STATUS_UNSPECIFIED")
                }
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
                Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
                Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OperationsInsightsStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OperationsInsightsStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OperationsInsightsStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabling,
                2 => Self::Enabled,
                3 => Self::Disabling,
                4 => Self::NotEnabled,
                5 => Self::FailedEnabling,
                6 => Self::FailedDisabling,
                _ => Self::UnknownValue(operations_insights_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OperationsInsightsStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATIONS_INSIGHTS_STATUS_UNSPECIFIED" => Self::Unspecified,
                "ENABLING" => Self::Enabling,
                "ENABLED" => Self::Enabled,
                "DISABLING" => Self::Disabling,
                "NOT_ENABLED" => Self::NotEnabled,
                "FAILED_ENABLING" => Self::FailedEnabling,
                "FAILED_DISABLING" => Self::FailedDisabling,
                _ => Self::UnknownValue(operations_insights_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OperationsInsightsStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabling => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::Disabling => serializer.serialize_i32(3),
                Self::NotEnabled => serializer.serialize_i32(4),
                Self::FailedEnabling => serializer.serialize_i32(5),
                Self::FailedDisabling => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OperationsInsightsStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<OperationsInsightsStatus>::new(
                    ".google.cloud.oracledatabase.v1.Database.OperationsInsightsStatus",
                ),
            )
        }
    }
}

/// The properties of a Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseProperties {
    /// Output only. State of the Database.
    pub state: crate::model::database_properties::DatabaseLifecycleState,

    /// Required. The Oracle Database version.
    pub db_version: std::string::String,

    /// Optional. Backup options for the Database.
    pub db_backup_config: std::option::Option<crate::model::DbBackupConfig>,

    /// Output only. The Database Management config.
    pub database_management_config: std::option::Option<crate::model::DatabaseManagementConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::DatabaseProperties::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::database_properties::DatabaseLifecycleState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::DatabaseProperties::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [db_backup_config][crate::model::DatabaseProperties::db_backup_config].
    pub fn set_db_backup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbBackupConfig>,
    {
        self.db_backup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [db_backup_config][crate::model::DatabaseProperties::db_backup_config].
    pub fn set_or_clear_db_backup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbBackupConfig>,
    {
        self.db_backup_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_management_config][crate::model::DatabaseProperties::database_management_config].
    pub fn set_database_management_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseManagementConfig>,
    {
        self.database_management_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_management_config][crate::model::DatabaseProperties::database_management_config].
    pub fn set_or_clear_database_management_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseManagementConfig>,
    {
        self.database_management_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatabaseProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DatabaseProperties"
    }
}

/// Defines additional types related to [DatabaseProperties].
pub mod database_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseLifecycleState {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in backup in progress state.
        BackupInProgress,
        /// Indicates that the resource is in upgrading state.
        Upgrading,
        /// Indicates that the resource is in converting state.
        Converting,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in restore failed state.
        RestoreFailed,
        /// Indicates that the resource is in failed state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseLifecycleState::value] or
        /// [DatabaseLifecycleState::name].
        UnknownValue(database_lifecycle_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_lifecycle_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseLifecycleState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::BackupInProgress => std::option::Option::Some(4),
                Self::Upgrading => std::option::Option::Some(5),
                Self::Converting => std::option::Option::Some(6),
                Self::Terminating => std::option::Option::Some(7),
                Self::Terminated => std::option::Option::Some(8),
                Self::RestoreFailed => std::option::Option::Some(9),
                Self::Failed => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DATABASE_LIFECYCLE_STATE_UNSPECIFIED")
                }
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::BackupInProgress => std::option::Option::Some("BACKUP_IN_PROGRESS"),
                Self::Upgrading => std::option::Option::Some("UPGRADING"),
                Self::Converting => std::option::Option::Some("CONVERTING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::RestoreFailed => std::option::Option::Some("RESTORE_FAILED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseLifecycleState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseLifecycleState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseLifecycleState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::BackupInProgress,
                5 => Self::Upgrading,
                6 => Self::Converting,
                7 => Self::Terminating,
                8 => Self::Terminated,
                9 => Self::RestoreFailed,
                10 => Self::Failed,
                _ => Self::UnknownValue(database_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseLifecycleState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_LIFECYCLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "BACKUP_IN_PROGRESS" => Self::BackupInProgress,
                "UPGRADING" => Self::Upgrading,
                "CONVERTING" => Self::Converting,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "RESTORE_FAILED" => Self::RestoreFailed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(database_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseLifecycleState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::BackupInProgress => serializer.serialize_i32(4),
                Self::Upgrading => serializer.serialize_i32(5),
                Self::Converting => serializer.serialize_i32(6),
                Self::Terminating => serializer.serialize_i32(7),
                Self::Terminated => serializer.serialize_i32(8),
                Self::RestoreFailed => serializer.serialize_i32(9),
                Self::Failed => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseLifecycleState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseLifecycleState>::new(
                ".google.cloud.oracledatabase.v1.DatabaseProperties.DatabaseLifecycleState",
            ))
        }
    }
}

/// Backup Options for the Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbBackupConfig {
    /// Optional. If set to true, enables automatic backups on the database.
    pub auto_backup_enabled: bool,

    /// Optional. Details of the database backup destinations.
    pub backup_destination_details:
        std::vec::Vec<crate::model::db_backup_config::BackupDestinationDetails>,

    /// Optional. The number of days an automatic backup is retained before being
    /// automatically deleted. This value determines the earliest point in time to
    /// which a database can be restored. Min: 1, Max: 60.
    pub retention_period_days: i32,

    /// Optional. This defines when the backups will be deleted after Database
    /// termination.
    pub backup_deletion_policy: crate::model::db_backup_config::BackupDeletionPolicy,

    /// Optional. The day of the week on which the full backup should be performed
    /// on the database. If no value is provided, it will default to Sunday.
    pub auto_full_backup_day: gtype::model::DayOfWeek,

    /// Optional. The window in which the full backup should be performed on the
    /// database. If no value is provided, the default is anytime.
    pub auto_full_backup_window: crate::model::db_backup_config::BackupWindow,

    /// Optional. The window in which the incremental backup should be performed on
    /// the database. If no value is provided, the default is anytime except the
    /// auto full backup day.
    pub auto_incremental_backup_window: crate::model::db_backup_config::BackupWindow,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_backup_enabled][crate::model::DbBackupConfig::auto_backup_enabled].
    pub fn set_auto_backup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_backup_enabled = v.into();
        self
    }

    /// Sets the value of [backup_destination_details][crate::model::DbBackupConfig::backup_destination_details].
    pub fn set_backup_destination_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::db_backup_config::BackupDestinationDetails>,
    {
        use std::iter::Iterator;
        self.backup_destination_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [retention_period_days][crate::model::DbBackupConfig::retention_period_days].
    pub fn set_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_period_days = v.into();
        self
    }

    /// Sets the value of [backup_deletion_policy][crate::model::DbBackupConfig::backup_deletion_policy].
    pub fn set_backup_deletion_policy<
        T: std::convert::Into<crate::model::db_backup_config::BackupDeletionPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_deletion_policy = v.into();
        self
    }

    /// Sets the value of [auto_full_backup_day][crate::model::DbBackupConfig::auto_full_backup_day].
    pub fn set_auto_full_backup_day<T: std::convert::Into<gtype::model::DayOfWeek>>(
        mut self,
        v: T,
    ) -> Self {
        self.auto_full_backup_day = v.into();
        self
    }

    /// Sets the value of [auto_full_backup_window][crate::model::DbBackupConfig::auto_full_backup_window].
    pub fn set_auto_full_backup_window<
        T: std::convert::Into<crate::model::db_backup_config::BackupWindow>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auto_full_backup_window = v.into();
        self
    }

    /// Sets the value of [auto_incremental_backup_window][crate::model::DbBackupConfig::auto_incremental_backup_window].
    pub fn set_auto_incremental_backup_window<
        T: std::convert::Into<crate::model::db_backup_config::BackupWindow>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auto_incremental_backup_window = v.into();
        self
    }
}

impl wkt::message::Message for DbBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbBackupConfig"
    }
}

/// Defines additional types related to [DbBackupConfig].
pub mod db_backup_config {
    #[allow(unused_imports)]
    use super::*;

    /// The details of the database backup destination.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BackupDestinationDetails {
        /// Optional. The type of the database backup destination.
        pub r#type: crate::model::db_backup_config::BackupDestinationType,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackupDestinationDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::db_backup_config::BackupDestinationDetails::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::db_backup_config::BackupDestinationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for BackupDestinationDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.oracledatabase.v1.DbBackupConfig.BackupDestinationDetails"
        }
    }

    /// The type of the database backup destination.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupDestinationType {
        /// Default unspecified value.
        Unspecified,
        /// Backup destination type is NFS.
        Nfs,
        /// Backup destination type is Recovery Appliance.
        RecoveryAppliance,
        /// Backup destination type is Object Store.
        ObjectStore,
        /// Backup destination type is Local.
        Local,
        /// Backup destination type is DBRS.
        Dbrs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupDestinationType::value] or
        /// [BackupDestinationType::name].
        UnknownValue(backup_destination_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_destination_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupDestinationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Nfs => std::option::Option::Some(1),
                Self::RecoveryAppliance => std::option::Option::Some(2),
                Self::ObjectStore => std::option::Option::Some(3),
                Self::Local => std::option::Option::Some(4),
                Self::Dbrs => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("BACKUP_DESTINATION_TYPE_UNSPECIFIED")
                }
                Self::Nfs => std::option::Option::Some("NFS"),
                Self::RecoveryAppliance => std::option::Option::Some("RECOVERY_APPLIANCE"),
                Self::ObjectStore => std::option::Option::Some("OBJECT_STORE"),
                Self::Local => std::option::Option::Some("LOCAL"),
                Self::Dbrs => std::option::Option::Some("DBRS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupDestinationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupDestinationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupDestinationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Nfs,
                2 => Self::RecoveryAppliance,
                3 => Self::ObjectStore,
                4 => Self::Local,
                5 => Self::Dbrs,
                _ => Self::UnknownValue(backup_destination_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupDestinationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_DESTINATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NFS" => Self::Nfs,
                "RECOVERY_APPLIANCE" => Self::RecoveryAppliance,
                "OBJECT_STORE" => Self::ObjectStore,
                "LOCAL" => Self::Local,
                "DBRS" => Self::Dbrs,
                _ => Self::UnknownValue(backup_destination_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupDestinationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Nfs => serializer.serialize_i32(1),
                Self::RecoveryAppliance => serializer.serialize_i32(2),
                Self::ObjectStore => serializer.serialize_i32(3),
                Self::Local => serializer.serialize_i32(4),
                Self::Dbrs => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupDestinationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupDestinationType>::new(
                ".google.cloud.oracledatabase.v1.DbBackupConfig.BackupDestinationType",
            ))
        }
    }

    /// The 2 hour window in which the backup should be performed on the database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupWindow {
        /// Default unspecified value.
        Unspecified,
        /// 12:00 AM - 2:00 AM
        SlotOne,
        /// 2:00 AM - 4:00 AM
        SlotTwo,
        /// 4:00 AM - 6:00 AM
        SlotThree,
        /// 6:00 AM - 8:00 AM
        SlotFour,
        /// 8:00 AM - 10:00 AM
        SlotFive,
        /// 10:00 AM - 12:00 PM
        SlotSix,
        /// 12:00 PM - 2:00 PM
        SlotSeven,
        /// 2:00 PM - 4:00 PM
        SlotEight,
        /// 4:00 PM - 6:00 PM
        SlotNine,
        /// 6:00 PM - 8:00 PM
        SlotTen,
        /// 8:00 PM - 10:00 PM
        SlotEleven,
        /// 10:00 PM - 12:00 AM
        SlotTwelve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupWindow::value] or
        /// [BackupWindow::name].
        UnknownValue(backup_window::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_window {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupWindow {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SlotOne => std::option::Option::Some(1),
                Self::SlotTwo => std::option::Option::Some(2),
                Self::SlotThree => std::option::Option::Some(3),
                Self::SlotFour => std::option::Option::Some(4),
                Self::SlotFive => std::option::Option::Some(5),
                Self::SlotSix => std::option::Option::Some(6),
                Self::SlotSeven => std::option::Option::Some(7),
                Self::SlotEight => std::option::Option::Some(8),
                Self::SlotNine => std::option::Option::Some(9),
                Self::SlotTen => std::option::Option::Some(10),
                Self::SlotEleven => std::option::Option::Some(11),
                Self::SlotTwelve => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_WINDOW_UNSPECIFIED"),
                Self::SlotOne => std::option::Option::Some("SLOT_ONE"),
                Self::SlotTwo => std::option::Option::Some("SLOT_TWO"),
                Self::SlotThree => std::option::Option::Some("SLOT_THREE"),
                Self::SlotFour => std::option::Option::Some("SLOT_FOUR"),
                Self::SlotFive => std::option::Option::Some("SLOT_FIVE"),
                Self::SlotSix => std::option::Option::Some("SLOT_SIX"),
                Self::SlotSeven => std::option::Option::Some("SLOT_SEVEN"),
                Self::SlotEight => std::option::Option::Some("SLOT_EIGHT"),
                Self::SlotNine => std::option::Option::Some("SLOT_NINE"),
                Self::SlotTen => std::option::Option::Some("SLOT_TEN"),
                Self::SlotEleven => std::option::Option::Some("SLOT_ELEVEN"),
                Self::SlotTwelve => std::option::Option::Some("SLOT_TWELVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupWindow {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupWindow {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupWindow {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SlotOne,
                2 => Self::SlotTwo,
                3 => Self::SlotThree,
                4 => Self::SlotFour,
                5 => Self::SlotFive,
                6 => Self::SlotSix,
                7 => Self::SlotSeven,
                8 => Self::SlotEight,
                9 => Self::SlotNine,
                10 => Self::SlotTen,
                11 => Self::SlotEleven,
                12 => Self::SlotTwelve,
                _ => Self::UnknownValue(backup_window::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupWindow {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_WINDOW_UNSPECIFIED" => Self::Unspecified,
                "SLOT_ONE" => Self::SlotOne,
                "SLOT_TWO" => Self::SlotTwo,
                "SLOT_THREE" => Self::SlotThree,
                "SLOT_FOUR" => Self::SlotFour,
                "SLOT_FIVE" => Self::SlotFive,
                "SLOT_SIX" => Self::SlotSix,
                "SLOT_SEVEN" => Self::SlotSeven,
                "SLOT_EIGHT" => Self::SlotEight,
                "SLOT_NINE" => Self::SlotNine,
                "SLOT_TEN" => Self::SlotTen,
                "SLOT_ELEVEN" => Self::SlotEleven,
                "SLOT_TWELVE" => Self::SlotTwelve,
                _ => Self::UnknownValue(backup_window::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupWindow {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SlotOne => serializer.serialize_i32(1),
                Self::SlotTwo => serializer.serialize_i32(2),
                Self::SlotThree => serializer.serialize_i32(3),
                Self::SlotFour => serializer.serialize_i32(4),
                Self::SlotFive => serializer.serialize_i32(5),
                Self::SlotSix => serializer.serialize_i32(6),
                Self::SlotSeven => serializer.serialize_i32(7),
                Self::SlotEight => serializer.serialize_i32(8),
                Self::SlotNine => serializer.serialize_i32(9),
                Self::SlotTen => serializer.serialize_i32(10),
                Self::SlotEleven => serializer.serialize_i32(11),
                Self::SlotTwelve => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupWindow {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupWindow>::new(
                ".google.cloud.oracledatabase.v1.DbBackupConfig.BackupWindow",
            ))
        }
    }

    /// This defines when the backups will be deleted after Database termination.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupDeletionPolicy {
        /// Default unspecified value.
        Unspecified,
        /// Keeps the backup for predefined time
        /// i.e. 72 hours and then delete permanently.
        DeleteImmediately,
        /// Keeps the backups as per the policy defined
        /// for database backups.
        DeleteAfterRetentionPeriod,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupDeletionPolicy::value] or
        /// [BackupDeletionPolicy::name].
        UnknownValue(backup_deletion_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_deletion_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupDeletionPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DeleteImmediately => std::option::Option::Some(1),
                Self::DeleteAfterRetentionPeriod => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("BACKUP_DELETION_POLICY_UNSPECIFIED")
                }
                Self::DeleteImmediately => std::option::Option::Some("DELETE_IMMEDIATELY"),
                Self::DeleteAfterRetentionPeriod => {
                    std::option::Option::Some("DELETE_AFTER_RETENTION_PERIOD")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupDeletionPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupDeletionPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupDeletionPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DeleteImmediately,
                2 => Self::DeleteAfterRetentionPeriod,
                _ => Self::UnknownValue(backup_deletion_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupDeletionPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_DELETION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "DELETE_IMMEDIATELY" => Self::DeleteImmediately,
                "DELETE_AFTER_RETENTION_PERIOD" => Self::DeleteAfterRetentionPeriod,
                _ => Self::UnknownValue(backup_deletion_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupDeletionPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DeleteImmediately => serializer.serialize_i32(1),
                Self::DeleteAfterRetentionPeriod => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupDeletionPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupDeletionPolicy>::new(
                ".google.cloud.oracledatabase.v1.DbBackupConfig.BackupDeletionPolicy",
            ))
        }
    }
}

/// The request for `Database.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDatabaseRequest {
    /// Required. The name of the Database resource in the following format:
    /// projects/{project}/locations/{region}/databases/{database}
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetDatabaseRequest"
    }
}

/// The request for `Database.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesRequest {
    /// Required. The parent resource name in the following format:
    /// projects/{project}/locations/{region}
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Databases will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. list for
    /// container databases is supported only with a valid dbSystem (full resource
    /// name) filter in this format:
    /// `dbSystem="projects/{project}/locations/{location}/dbSystems/{dbSystemId}"`
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDatabasesRequest"
    }
}

/// The response for `Database.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesResponse {
    /// The list of Databases.
    pub databases: std::vec::Vec<crate::model::Database>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [databases][crate::model::ListDatabasesResponse::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatabasesResponse {
    type PageItem = crate::model::Database;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Details of the Database character set resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseCharacterSet {
    /// Identifier. The name of the Database Character Set resource in the
    /// following format:
    /// projects/{project}/locations/{region}/databaseCharacterSets/{database_character_set}
    pub name: std::string::String,

    /// Output only. The character set type for the Database.
    pub character_set_type: crate::model::database_character_set::CharacterSetType,

    /// Output only. The character set name for the Database which is the ID in the
    /// resource name.
    pub character_set: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseCharacterSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DatabaseCharacterSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [character_set_type][crate::model::DatabaseCharacterSet::character_set_type].
    pub fn set_character_set_type<
        T: std::convert::Into<crate::model::database_character_set::CharacterSetType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.character_set_type = v.into();
        self
    }

    /// Sets the value of [character_set][crate::model::DatabaseCharacterSet::character_set].
    pub fn set_character_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_set = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseCharacterSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DatabaseCharacterSet"
    }
}

/// Defines additional types related to [DatabaseCharacterSet].
pub mod database_character_set {
    #[allow(unused_imports)]
    use super::*;

    /// The type of character set a Database can have.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CharacterSetType {
        /// Character set type is not specified.
        Unspecified,
        /// Character set type is set to database.
        Database,
        /// Character set type is set to national.
        National,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CharacterSetType::value] or
        /// [CharacterSetType::name].
        UnknownValue(character_set_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod character_set_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CharacterSetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::National => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHARACTER_SET_TYPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::National => std::option::Option::Some("NATIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CharacterSetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CharacterSetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CharacterSetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CharacterSetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "NATIONAL" => Self::National,
                _ => Self::UnknownValue(character_set_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CharacterSetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::National => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CharacterSetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CharacterSetType>::new(
                ".google.cloud.oracledatabase.v1.DatabaseCharacterSet.CharacterSetType",
            ))
        }
    }
}

/// The request for `DatabaseCharacterSet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabaseCharacterSetsRequest {
    /// Required. The parent value for DatabaseCharacterSets in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of DatabaseCharacterSets to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// DatabaseCharacterSets will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListDatabaseCharacterSets` call. Provide this to retrieve the subsequent
    /// page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDatabaseCharacterSets` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabaseCharacterSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabaseCharacterSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatabaseCharacterSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatabaseCharacterSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatabaseCharacterSetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabaseCharacterSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDatabaseCharacterSetsRequest"
    }
}

/// The response for `DatabaseCharacterSet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabaseCharacterSetsResponse {
    /// The list of DatabaseCharacterSets.
    pub database_character_sets: std::vec::Vec<crate::model::DatabaseCharacterSet>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabaseCharacterSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_character_sets][crate::model::ListDatabaseCharacterSetsResponse::database_character_sets].
    pub fn set_database_character_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseCharacterSet>,
    {
        use std::iter::Iterator;
        self.database_character_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatabaseCharacterSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabaseCharacterSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDatabaseCharacterSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatabaseCharacterSetsResponse {
    type PageItem = crate::model::DatabaseCharacterSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.database_character_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Details of the database node resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbNode/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbNode {
    /// Identifier. The name of the database node resource in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}/dbNodes/{db_node}
    pub name: std::string::String,

    /// Optional. Various properties of the database node.
    pub properties: std::option::Option<crate::model::DbNodeProperties>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbNode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbNode::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbNode::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbNodeProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbNode::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbNodeProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbNode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNode"
    }
}

/// Various properties and settings associated with Db node.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbNodeProperties {
    /// Output only. OCID of database node.
    pub ocid: std::string::String,

    /// Optional. OCPU count per database node.
    pub ocpu_count: i32,

    /// Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Local storage per database node.
    pub db_node_storage_size_gb: i32,

    /// Optional. Database server OCID.
    pub db_server_ocid: std::string::String,

    /// Optional. DNS
    pub hostname: std::string::String,

    /// Output only. State of the database node.
    pub state: crate::model::db_node_properties::State,

    /// Total CPU core count of the database node.
    pub total_cpu_core_count: i32,

    /// Output only. The date and time that the database node was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbNodeProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbNodeProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbNodeProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbNodeProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbNodeProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [db_server_ocid][crate::model::DbNodeProperties::db_server_ocid].
    pub fn set_db_server_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_server_ocid = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::DbNodeProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbNodeProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_node_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [total_cpu_core_count][crate::model::DbNodeProperties::total_cpu_core_count].
    pub fn set_total_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_cpu_core_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DbNodeProperties::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DbNodeProperties::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbNodeProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbNodeProperties"
    }
}

/// Defines additional types related to [DbNodeProperties].
pub mod db_node_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in stopping state.
        Stopping,
        /// Indicates that the resource is in stopped state.
        Stopped,
        /// Indicates that the resource is in starting state.
        Starting,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Stopped => std::option::Option::Some(5),
                Self::Starting => std::option::Option::Some(6),
                Self::Terminating => std::option::Option::Some(7),
                Self::Terminated => std::option::Option::Some(8),
                Self::Failed => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Stopping,
                5 => Self::Stopped,
                6 => Self::Starting,
                7 => Self::Terminating,
                8 => Self::Terminated,
                9 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "STARTING" => Self::Starting,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Stopped => serializer.serialize_i32(5),
                Self::Starting => serializer.serialize_i32(6),
                Self::Terminating => serializer.serialize_i32(7),
                Self::Terminated => serializer.serialize_i32(8),
                Self::Failed => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.DbNodeProperties.State",
            ))
        }
    }
}

/// Details of the database server resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbServer/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbServer {
    /// Identifier. The name of the database server resource with the format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}/dbServers/{db_server}
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    pub display_name: std::string::String,

    /// Optional. Various properties of the database server.
    pub properties: std::option::Option<crate::model::DbServerProperties>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbServer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbServer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DbServer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbServer::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbServerProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbServer::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbServerProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbServer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServer"
    }
}

/// Various properties and settings associated with Exadata database server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbServerProperties {
    /// Output only. OCID of database server.
    pub ocid: std::string::String,

    /// Optional. OCPU count per database.
    pub ocpu_count: i32,

    /// Optional. Maximum OCPU count per database.
    pub max_ocpu_count: i32,

    /// Optional. Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Maximum memory allocated in GBs.
    pub max_memory_size_gb: i32,

    /// Optional. Local storage per VM.
    pub db_node_storage_size_gb: i32,

    /// Optional. Maximum local storage per VM.
    pub max_db_node_storage_size_gb: i32,

    /// Optional. Vm count per database.
    pub vm_count: i32,

    /// Output only. State of the database server.
    pub state: crate::model::db_server_properties::State,

    /// Output only. OCID of database nodes associated with the database server.
    pub db_node_ids: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbServerProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::DbServerProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::DbServerProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [max_ocpu_count][crate::model::DbServerProperties::max_ocpu_count].
    pub fn set_max_ocpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbServerProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_size_gb][crate::model::DbServerProperties::max_memory_size_gb].
    pub fn set_max_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::DbServerProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::DbServerProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [vm_count][crate::model::DbServerProperties::vm_count].
    pub fn set_vm_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DbServerProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::db_server_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [db_node_ids][crate::model::DbServerProperties::db_node_ids].
    pub fn set_db_node_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_node_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DbServerProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbServerProperties"
    }
}

/// Defines additional types related to [DbServerProperties].
pub mod db_server_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the database server.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in creating state.
        Creating,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in unavailable state.
        Unavailable,
        /// Indicates that the resource is in deleting state.
        Deleting,
        /// Indicates that the resource is in deleted state.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Unavailable => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Deleted => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Available,
                3 => Self::Unavailable,
                4 => Self::Deleting,
                5 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "AVAILABLE" => Self::Available,
                "UNAVAILABLE" => Self::Unavailable,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Unavailable => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Deleted => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.DbServerProperties.State",
            ))
        }
    }
}

/// Details of the DbSystem (BaseDB) resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystem/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbSystem {
    /// Identifier. The name of the DbSystem resource in the following format:
    /// projects/{project}/locations/{region}/dbSystems/{db_system}
    pub name: std::string::String,

    /// Optional. The properties of the DbSystem.
    pub properties: std::option::Option<crate::model::DbSystemProperties>,

    /// Optional. The GCP Oracle zone where Oracle DbSystem is hosted.
    /// Example: us-east4-b-r2.
    /// If not specified, the system will pick a zone based on availability.
    pub gcp_oracle_zone: std::string::String,

    /// Optional. The labels or tags associated with the DbSystem.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The name of the OdbNetwork associated with the DbSystem.
    /// Format: projects/{project}/locations/{location}/odbNetworks/{odb_network}
    /// It is optional but if specified, this should match the parent ODBNetwork of
    /// the OdbSubnet.
    pub odb_network: std::string::String,

    /// Required. The name of the OdbSubnet associated with the DbSystem for IP
    /// allocation. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    pub odb_subnet: std::string::String,

    /// Output only. The ID of the subscription entitlement associated with the
    /// DbSystem
    pub entitlement_id: std::string::String,

    /// Required. The display name for the System db. The name does not have to
    /// be unique within your project.
    pub display_name: std::string::String,

    /// Output only. The date and time that the DbSystem was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. HTTPS link to OCI resources exposed to Customer via UI
    /// Interface.
    pub oci_url: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbSystem::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbSystem::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbSystemProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbSystem::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbSystemProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::DbSystem::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DbSystem::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [odb_network][crate::model::DbSystem::odb_network].
    pub fn set_odb_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_network = v.into();
        self
    }

    /// Sets the value of [odb_subnet][crate::model::DbSystem::odb_subnet].
    pub fn set_odb_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_subnet = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::DbSystem::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DbSystem::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DbSystem::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DbSystem::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [oci_url][crate::model::DbSystem::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }
}

impl wkt::message::Message for DbSystem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystem"
    }
}

/// The properties of a DbSystem.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbSystemProperties {
    /// Required. Shape of DB System.
    pub shape: std::string::String,

    /// Required. The number of CPU cores to enable for the DbSystem.
    pub compute_count: i32,

    /// Required. The initial data storage size in GB.
    pub initial_data_storage_size_gb: i32,

    /// Required. The database edition of the DbSystem.
    pub database_edition: crate::model::db_system_properties::DbSystemDatabaseEdition,

    /// Required. The license model of the DbSystem.
    pub license_model: crate::model::db_system_properties::LicenseModel,

    /// Required. SSH public keys to be stored with the DbSystem.
    pub ssh_public_keys: std::vec::Vec<std::string::String>,

    /// Optional. Prefix for DB System host names.
    pub hostname_prefix: std::string::String,

    /// Output only. The hostname of the DbSystem.
    pub hostname: std::string::String,

    /// Optional. The private IP address of the DbSystem.
    pub private_ip: std::string::String,

    /// Optional. Data collection options for diagnostics.
    pub data_collection_options: std::option::Option<crate::model::DataCollectionOptionsDbSystem>,

    /// Optional. Time zone of the DbSystem.
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Output only. State of the DbSystem.
    pub lifecycle_state: crate::model::db_system_properties::DbSystemLifecycleState,

    /// Optional. Details for creating a Database Home.
    pub db_home: std::option::Option<crate::model::DbHome>,

    /// Output only. OCID of the DbSystem.
    pub ocid: std::string::String,

    /// Optional. The memory size in GB.
    pub memory_size_gb: i32,

    /// Optional. The compute model of the DbSystem.
    pub compute_model: crate::model::db_system_properties::ComputeModel,

    /// Optional. The data storage size in GB that is currently available to
    /// DbSystems.
    pub data_storage_size_gb: i32,

    /// Optional. The reco/redo storage size in GB.
    pub reco_storage_size_gb: i32,

    /// Optional. The host domain name of the DbSystem.
    pub domain: std::string::String,

    /// Optional. The number of nodes in the DbSystem.
    pub node_count: i32,

    /// Optional. The options for the DbSystem.
    pub db_system_options: std::option::Option<crate::model::DbSystemOptions>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystemProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shape][crate::model::DbSystemProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::DbSystemProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [initial_data_storage_size_gb][crate::model::DbSystemProperties::initial_data_storage_size_gb].
    pub fn set_initial_data_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_data_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [database_edition][crate::model::DbSystemProperties::database_edition].
    pub fn set_database_edition<
        T: std::convert::Into<crate::model::db_system_properties::DbSystemDatabaseEdition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_edition = v.into();
        self
    }

    /// Sets the value of [license_model][crate::model::DbSystemProperties::license_model].
    pub fn set_license_model<
        T: std::convert::Into<crate::model::db_system_properties::LicenseModel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_model = v.into();
        self
    }

    /// Sets the value of [ssh_public_keys][crate::model::DbSystemProperties::ssh_public_keys].
    pub fn set_ssh_public_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_public_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname_prefix][crate::model::DbSystemProperties::hostname_prefix].
    pub fn set_hostname_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname_prefix = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::DbSystemProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [private_ip][crate::model::DbSystemProperties::private_ip].
    pub fn set_private_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_ip = v.into();
        self
    }

    /// Sets the value of [data_collection_options][crate::model::DbSystemProperties::data_collection_options].
    pub fn set_data_collection_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptionsDbSystem>,
    {
        self.data_collection_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_collection_options][crate::model::DbSystemProperties::data_collection_options].
    pub fn set_or_clear_data_collection_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptionsDbSystem>,
    {
        self.data_collection_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_zone][crate::model::DbSystemProperties::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::DbSystemProperties::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::DbSystemProperties::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<crate::model::db_system_properties::DbSystemLifecycleState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [db_home][crate::model::DbSystemProperties::db_home].
    pub fn set_db_home<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbHome>,
    {
        self.db_home = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [db_home][crate::model::DbSystemProperties::db_home].
    pub fn set_or_clear_db_home<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbHome>,
    {
        self.db_home = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ocid][crate::model::DbSystemProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::DbSystemProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [compute_model][crate::model::DbSystemProperties::compute_model].
    pub fn set_compute_model<
        T: std::convert::Into<crate::model::db_system_properties::ComputeModel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_model = v.into();
        self
    }

    /// Sets the value of [data_storage_size_gb][crate::model::DbSystemProperties::data_storage_size_gb].
    pub fn set_data_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [reco_storage_size_gb][crate::model::DbSystemProperties::reco_storage_size_gb].
    pub fn set_reco_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.reco_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::DbSystemProperties::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::DbSystemProperties::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [db_system_options][crate::model::DbSystemProperties::db_system_options].
    pub fn set_db_system_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbSystemOptions>,
    {
        self.db_system_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [db_system_options][crate::model::DbSystemProperties::db_system_options].
    pub fn set_or_clear_db_system_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbSystemOptions>,
    {
        self.db_system_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbSystemProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemProperties"
    }
}

/// Defines additional types related to [DbSystemProperties].
pub mod db_system_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The editions available for DbSystem.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DbSystemDatabaseEdition {
        /// The database edition is unspecified.
        Unspecified,
        /// The database edition is Standard.
        StandardEdition,
        /// The database edition is Enterprise.
        EnterpriseEdition,
        /// The database edition is Enterprise Edition.
        EnterpriseEditionHighPerformance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DbSystemDatabaseEdition::value] or
        /// [DbSystemDatabaseEdition::name].
        UnknownValue(db_system_database_edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod db_system_database_edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DbSystemDatabaseEdition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardEdition => std::option::Option::Some(1),
                Self::EnterpriseEdition => std::option::Option::Some(2),
                Self::EnterpriseEditionHighPerformance => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DB_SYSTEM_DATABASE_EDITION_UNSPECIFIED")
                }
                Self::StandardEdition => std::option::Option::Some("STANDARD_EDITION"),
                Self::EnterpriseEdition => std::option::Option::Some("ENTERPRISE_EDITION"),
                Self::EnterpriseEditionHighPerformance => {
                    std::option::Option::Some("ENTERPRISE_EDITION_HIGH_PERFORMANCE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DbSystemDatabaseEdition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DbSystemDatabaseEdition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DbSystemDatabaseEdition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardEdition,
                2 => Self::EnterpriseEdition,
                3 => Self::EnterpriseEditionHighPerformance,
                _ => Self::UnknownValue(db_system_database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DbSystemDatabaseEdition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DB_SYSTEM_DATABASE_EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_EDITION" => Self::StandardEdition,
                "ENTERPRISE_EDITION" => Self::EnterpriseEdition,
                "ENTERPRISE_EDITION_HIGH_PERFORMANCE" => Self::EnterpriseEditionHighPerformance,
                _ => Self::UnknownValue(db_system_database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DbSystemDatabaseEdition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardEdition => serializer.serialize_i32(1),
                Self::EnterpriseEdition => serializer.serialize_i32(2),
                Self::EnterpriseEditionHighPerformance => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DbSystemDatabaseEdition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<DbSystemDatabaseEdition>::new(
                    ".google.cloud.oracledatabase.v1.DbSystemProperties.DbSystemDatabaseEdition",
                ),
            )
        }
    }

    /// The license model of the DbSystem.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseModel {
        /// The license model is unspecified.
        Unspecified,
        /// The license model is included.
        LicenseIncluded,
        /// The license model is bring your own license.
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseModel::value] or
        /// [LicenseModel::name].
        UnknownValue(license_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_MODEL_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_MODEL_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseModel>::new(
                ".google.cloud.oracledatabase.v1.DbSystemProperties.LicenseModel",
            ))
        }
    }

    /// The various lifecycle states of the DbSystem.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DbSystemLifecycleState {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource has been migrated.
        Migrated,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress,
        /// Indicates that the resource needs attention.
        NeedsAttention,
        /// Indicates that the resource is upgrading.
        Upgrading,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DbSystemLifecycleState::value] or
        /// [DbSystemLifecycleState::name].
        UnknownValue(db_system_lifecycle_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod db_system_lifecycle_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DbSystemLifecycleState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Migrated => std::option::Option::Some(7),
                Self::MaintenanceInProgress => std::option::Option::Some(8),
                Self::NeedsAttention => std::option::Option::Some(9),
                Self::Upgrading => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DB_SYSTEM_LIFECYCLE_STATE_UNSPECIFIED")
                }
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Migrated => std::option::Option::Some("MIGRATED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::NeedsAttention => std::option::Option::Some("NEEDS_ATTENTION"),
                Self::Upgrading => std::option::Option::Some("UPGRADING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DbSystemLifecycleState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DbSystemLifecycleState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DbSystemLifecycleState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::Migrated,
                8 => Self::MaintenanceInProgress,
                9 => Self::NeedsAttention,
                10 => Self::Upgrading,
                _ => Self::UnknownValue(db_system_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DbSystemLifecycleState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DB_SYSTEM_LIFECYCLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MIGRATED" => Self::Migrated,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                "NEEDS_ATTENTION" => Self::NeedsAttention,
                "UPGRADING" => Self::Upgrading,
                _ => Self::UnknownValue(db_system_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DbSystemLifecycleState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Migrated => serializer.serialize_i32(7),
                Self::MaintenanceInProgress => serializer.serialize_i32(8),
                Self::NeedsAttention => serializer.serialize_i32(9),
                Self::Upgrading => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DbSystemLifecycleState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DbSystemLifecycleState>::new(
                ".google.cloud.oracledatabase.v1.DbSystemProperties.DbSystemLifecycleState",
            ))
        }
    }

    /// The compute model of the DbSystem.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComputeModel {
        /// The compute model is unspecified.
        Unspecified,
        /// The compute model is virtual.
        Ecpu,
        /// The compute model is physical.
        Ocpu,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ComputeModel::value] or
        /// [ComputeModel::name].
        UnknownValue(compute_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod compute_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ComputeModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ecpu => std::option::Option::Some(1),
                Self::Ocpu => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPUTE_MODEL_UNSPECIFIED"),
                Self::Ecpu => std::option::Option::Some("ECPU"),
                Self::Ocpu => std::option::Option::Some("OCPU"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ComputeModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ComputeModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ComputeModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ecpu,
                2 => Self::Ocpu,
                _ => Self::UnknownValue(compute_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ComputeModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPUTE_MODEL_UNSPECIFIED" => Self::Unspecified,
                "ECPU" => Self::Ecpu,
                "OCPU" => Self::Ocpu,
                _ => Self::UnknownValue(compute_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ComputeModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ecpu => serializer.serialize_i32(1),
                Self::Ocpu => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ComputeModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeModel>::new(
                ".google.cloud.oracledatabase.v1.DbSystemProperties.ComputeModel",
            ))
        }
    }
}

/// Data collection options for DbSystem.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataCollectionOptionsDbSystem {
    /// Optional. Indicates whether to enable data collection for diagnostics.
    pub is_diagnostics_events_enabled: bool,

    /// Optional. Indicates whether to enable incident logs and trace collection.
    pub is_incident_logs_enabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataCollectionOptionsDbSystem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_diagnostics_events_enabled][crate::model::DataCollectionOptionsDbSystem::is_diagnostics_events_enabled].
    pub fn set_is_diagnostics_events_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_diagnostics_events_enabled = v.into();
        self
    }

    /// Sets the value of [is_incident_logs_enabled][crate::model::DataCollectionOptionsDbSystem::is_incident_logs_enabled].
    pub fn set_is_incident_logs_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_incident_logs_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCollectionOptionsDbSystem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DataCollectionOptionsDbSystem"
    }
}

/// Details of the DbSystem Options.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbSystemOptions {
    /// Optional. The storage option used in DB system.
    pub storage_management: crate::model::db_system_options::StorageManagement,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystemOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_management][crate::model::DbSystemOptions::storage_management].
    pub fn set_storage_management<
        T: std::convert::Into<crate::model::db_system_options::StorageManagement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_management = v.into();
        self
    }
}

impl wkt::message::Message for DbSystemOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemOptions"
    }
}

/// Defines additional types related to [DbSystemOptions].
pub mod db_system_options {
    #[allow(unused_imports)]
    use super::*;

    /// The storage option used in DB system.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageManagement {
        /// The storage management is unspecified.
        Unspecified,
        /// Automatic storage management.
        Asm,
        /// Logical Volume management.
        Lvm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageManagement::value] or
        /// [StorageManagement::name].
        UnknownValue(storage_management::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_management {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageManagement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Asm => std::option::Option::Some(1),
                Self::Lvm => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_MANAGEMENT_UNSPECIFIED"),
                Self::Asm => std::option::Option::Some("ASM"),
                Self::Lvm => std::option::Option::Some("LVM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageManagement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageManagement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageManagement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Asm,
                2 => Self::Lvm,
                _ => Self::UnknownValue(storage_management::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageManagement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_MANAGEMENT_UNSPECIFIED" => Self::Unspecified,
                "ASM" => Self::Asm,
                "LVM" => Self::Lvm,
                _ => Self::UnknownValue(storage_management::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageManagement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Asm => serializer.serialize_i32(1),
                Self::Lvm => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageManagement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageManagement>::new(
                ".google.cloud.oracledatabase.v1.DbSystemOptions.StorageManagement",
            ))
        }
    }
}

/// Details of the Database Home resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbHome {
    /// Optional. The display name for the Database Home. The name does not have to
    /// be unique within your project.
    pub display_name: std::string::String,

    /// Required. A valid Oracle Database version. For a list of supported
    /// versions, use the ListDbVersions operation.
    pub db_version: std::string::String,

    /// Required. The Database resource.
    pub database: std::option::Option<crate::model::Database>,

    /// Optional. Whether unified auditing is enabled for the Database Home.
    pub is_unified_auditing_enabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbHome {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::DbHome::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [db_version][crate::model::DbHome::db_version].
    pub fn set_db_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_version = v.into();
        self
    }

    /// Sets the value of [database][crate::model::DbHome::database].
    pub fn set_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database][crate::model::DbHome::database].
    pub fn set_or_clear_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_unified_auditing_enabled][crate::model::DbHome::is_unified_auditing_enabled].
    pub fn set_is_unified_auditing_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_unified_auditing_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DbHome {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbHome"
    }
}

/// The request for `DbSystem.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDbSystemRequest {
    /// Required. The value for parent of the DbSystem in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the DbSystem to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    pub db_system_id: std::string::String,

    /// Required. The resource being created.
    pub db_system: std::option::Option<crate::model::DbSystem>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDbSystemRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDbSystemRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [db_system_id][crate::model::CreateDbSystemRequest::db_system_id].
    pub fn set_db_system_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.db_system_id = v.into();
        self
    }

    /// Sets the value of [db_system][crate::model::CreateDbSystemRequest::db_system].
    pub fn set_db_system<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbSystem>,
    {
        self.db_system = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [db_system][crate::model::CreateDbSystemRequest::db_system].
    pub fn set_or_clear_db_system<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbSystem>,
    {
        self.db_system = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDbSystemRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDbSystemRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateDbSystemRequest"
    }
}

/// The request for `DbSystem.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDbSystemRequest {
    /// Required. The name of the DbSystem in the following format:
    /// projects/{project}/locations/{location}/dbSystems/{db_system}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDbSystemRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDbSystemRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDbSystemRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDbSystemRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteDbSystemRequest"
    }
}

/// The request for `DbSystem.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDbSystemRequest {
    /// Required. The name of the DbSystem in the following format:
    /// projects/{project}/locations/{location}/dbSystems/{db_system}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDbSystemRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDbSystemRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDbSystemRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetDbSystemRequest"
    }
}

/// The request for `DbSystem.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemsRequest {
    /// Required. The parent value for DbSystems in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 DbSystems will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbSystemsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbSystemsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbSystemsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDbSystemsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDbSystemsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemsRequest"
    }
}

/// The response for `DbSystem.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemsResponse {
    /// The list of DbSystems.
    pub db_systems: std::vec::Vec<crate::model::DbSystem>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_systems][crate::model::ListDbSystemsResponse::db_systems].
    pub fn set_db_systems<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbSystem>,
    {
        use std::iter::Iterator;
        self.db_systems = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbSystemsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbSystemsResponse {
    type PageItem = crate::model::DbSystem;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_systems
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Summary of the DbSystem initial storage size.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbSystemInitialStorageSize {
    /// Output only. The name of the resource.
    pub name: std::string::String,

    /// Output only. The properties of the DbSystem initial storage size summary.
    pub properties: std::option::Option<crate::model::DbSystemInitialStorageSizeProperties>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystemInitialStorageSize {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbSystemInitialStorageSize::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbSystemInitialStorageSize::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbSystemInitialStorageSizeProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbSystemInitialStorageSize::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbSystemInitialStorageSizeProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbSystemInitialStorageSize {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemInitialStorageSize"
    }
}

/// The properties of a DbSystem initial storage size summary.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbSystemInitialStorageSizeProperties {
    /// Output only. The storage option used in DB system.
    pub storage_management:
        crate::model::db_system_initial_storage_size_properties::StorageManagement,

    /// Output only. VM shape platform type
    pub shape_type: crate::model::db_system_initial_storage_size_properties::ShapeType,

    /// Output only. List of storage disk details.
    pub storage_size_details: std::vec::Vec<crate::model::StorageSizeDetails>,

    /// Output only. List of storage disk details available for launches from
    /// backup.
    pub launch_from_backup_storage_size_details: std::vec::Vec<crate::model::StorageSizeDetails>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystemInitialStorageSizeProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_management][crate::model::DbSystemInitialStorageSizeProperties::storage_management].
    pub fn set_storage_management<
        T: std::convert::Into<
                crate::model::db_system_initial_storage_size_properties::StorageManagement,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_management = v.into();
        self
    }

    /// Sets the value of [shape_type][crate::model::DbSystemInitialStorageSizeProperties::shape_type].
    pub fn set_shape_type<
        T: std::convert::Into<crate::model::db_system_initial_storage_size_properties::ShapeType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shape_type = v.into();
        self
    }

    /// Sets the value of [storage_size_details][crate::model::DbSystemInitialStorageSizeProperties::storage_size_details].
    pub fn set_storage_size_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StorageSizeDetails>,
    {
        use std::iter::Iterator;
        self.storage_size_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [launch_from_backup_storage_size_details][crate::model::DbSystemInitialStorageSizeProperties::launch_from_backup_storage_size_details].
    pub fn set_launch_from_backup_storage_size_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StorageSizeDetails>,
    {
        use std::iter::Iterator;
        self.launch_from_backup_storage_size_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DbSystemInitialStorageSizeProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemInitialStorageSizeProperties"
    }
}

/// Defines additional types related to [DbSystemInitialStorageSizeProperties].
pub mod db_system_initial_storage_size_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The storage option used in the DB system.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageManagement {
        /// Unspecified storage management.
        Unspecified,
        /// Automatic Storage Management.
        Asm,
        /// Logical Volume Management.
        Lvm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageManagement::value] or
        /// [StorageManagement::name].
        UnknownValue(storage_management::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_management {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageManagement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Asm => std::option::Option::Some(1),
                Self::Lvm => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_MANAGEMENT_UNSPECIFIED"),
                Self::Asm => std::option::Option::Some("ASM"),
                Self::Lvm => std::option::Option::Some("LVM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageManagement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageManagement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageManagement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Asm,
                2 => Self::Lvm,
                _ => Self::UnknownValue(storage_management::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageManagement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_MANAGEMENT_UNSPECIFIED" => Self::Unspecified,
                "ASM" => Self::Asm,
                "LVM" => Self::Lvm,
                _ => Self::UnknownValue(storage_management::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageManagement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Asm => serializer.serialize_i32(1),
                Self::Lvm => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageManagement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageManagement>::new(
                ".google.cloud.oracledatabase.v1.DbSystemInitialStorageSizeProperties.StorageManagement"))
        }
    }

    /// The shape type of the DB system.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ShapeType {
        /// Unspecified shape type.
        Unspecified,
        /// Standard X86.
        StandardX86,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ShapeType::value] or
        /// [ShapeType::name].
        UnknownValue(shape_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod shape_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ShapeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardX86 => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SHAPE_TYPE_UNSPECIFIED"),
                Self::StandardX86 => std::option::Option::Some("STANDARD_X86"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ShapeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ShapeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ShapeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardX86,
                _ => Self::UnknownValue(shape_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ShapeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SHAPE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_X86" => Self::StandardX86,
                _ => Self::UnknownValue(shape_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ShapeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardX86 => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ShapeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ShapeType>::new(
                ".google.cloud.oracledatabase.v1.DbSystemInitialStorageSizeProperties.ShapeType",
            ))
        }
    }
}

/// The initial storage size, in gigabytes, that is applicable for virtual
/// machine DBSystem.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageSizeDetails {
    /// Output only. The data storage size, in gigabytes, that is applicable for
    /// virtual machine DBSystem.
    pub data_storage_size_in_gbs: i32,

    /// Output only. The RECO/REDO storage size, in gigabytes, that is applicable
    /// for virtual machine DBSystem.
    pub reco_storage_size_in_gbs: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSizeDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_storage_size_in_gbs][crate::model::StorageSizeDetails::data_storage_size_in_gbs].
    pub fn set_data_storage_size_in_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_storage_size_in_gbs = v.into();
        self
    }

    /// Sets the value of [reco_storage_size_in_gbs][crate::model::StorageSizeDetails::reco_storage_size_in_gbs].
    pub fn set_reco_storage_size_in_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.reco_storage_size_in_gbs = v.into();
        self
    }
}

impl wkt::message::Message for StorageSizeDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.StorageSizeDetails"
    }
}

/// The request for `DbSystemInitialStorageSizes.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemInitialStorageSizesRequest {
    /// Required. The parent value for the DbSystemInitialStorageSize resource with
    /// the format: projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 DbSystemInitialStorageSizes will be
    /// returned. The maximum value is 1000; values above 1000 will be reset to
    /// 1000.
    pub page_size: i32,

    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemInitialStorageSizesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbSystemInitialStorageSizesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbSystemInitialStorageSizesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbSystemInitialStorageSizesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemInitialStorageSizesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemInitialStorageSizesRequest"
    }
}

/// The response for `DbSystemInitialStorageSizes.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemInitialStorageSizesResponse {
    /// The list of DbSystemInitialStorageSizes.
    pub db_system_initial_storage_sizes: std::vec::Vec<crate::model::DbSystemInitialStorageSize>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemInitialStorageSizesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_system_initial_storage_sizes][crate::model::ListDbSystemInitialStorageSizesResponse::db_system_initial_storage_sizes].
    pub fn set_db_system_initial_storage_sizes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbSystemInitialStorageSize>,
    {
        use std::iter::Iterator;
        self.db_system_initial_storage_sizes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbSystemInitialStorageSizesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemInitialStorageSizesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemInitialStorageSizesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbSystemInitialStorageSizesResponse {
    type PageItem = crate::model::DbSystemInitialStorageSize;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_system_initial_storage_sizes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Details of the Database System Shapes resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystemShapeSummary/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbSystemShape {
    /// Identifier. The name of the Database System Shape resource with the format:
    /// projects/{project}/locations/{region}/dbSystemShapes/{db_system_shape}
    pub name: std::string::String,

    /// Optional. shape
    pub shape: std::string::String,

    /// Optional. Minimum number of database servers.
    pub min_node_count: i32,

    /// Optional. Maximum number of database servers.
    pub max_node_count: i32,

    /// Optional. Minimum number of storage servers.
    pub min_storage_count: i32,

    /// Optional. Maximum number of storage servers.
    pub max_storage_count: i32,

    /// Optional. Number of cores per node.
    pub available_core_count_per_node: i32,

    /// Optional. Memory per database server node in gigabytes.
    pub available_memory_per_node_gb: i32,

    /// Optional. Storage per storage server in terabytes.
    pub available_data_storage_tb: i32,

    /// Optional. Minimum core count per node.
    pub min_core_count_per_node: i32,

    /// Optional. Minimum memory per node in gigabytes.
    pub min_memory_per_node_gb: i32,

    /// Optional. Minimum node storage per database server in gigabytes.
    pub min_db_node_storage_per_node_gb: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbSystemShape {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbSystemShape::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::DbSystemShape::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [min_node_count][crate::model::DbSystemShape::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::DbSystemShape::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }

    /// Sets the value of [min_storage_count][crate::model::DbSystemShape::min_storage_count].
    pub fn set_min_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_storage_count = v.into();
        self
    }

    /// Sets the value of [max_storage_count][crate::model::DbSystemShape::max_storage_count].
    pub fn set_max_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_storage_count = v.into();
        self
    }

    /// Sets the value of [available_core_count_per_node][crate::model::DbSystemShape::available_core_count_per_node].
    pub fn set_available_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [available_memory_per_node_gb][crate::model::DbSystemShape::available_memory_per_node_gb].
    pub fn set_available_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [available_data_storage_tb][crate::model::DbSystemShape::available_data_storage_tb].
    pub fn set_available_data_storage_tb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [min_core_count_per_node][crate::model::DbSystemShape::min_core_count_per_node].
    pub fn set_min_core_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_core_count_per_node = v.into();
        self
    }

    /// Sets the value of [min_memory_per_node_gb][crate::model::DbSystemShape::min_memory_per_node_gb].
    pub fn set_min_memory_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_memory_per_node_gb = v.into();
        self
    }

    /// Sets the value of [min_db_node_storage_per_node_gb][crate::model::DbSystemShape::min_db_node_storage_per_node_gb].
    pub fn set_min_db_node_storage_per_node_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_db_node_storage_per_node_gb = v.into();
        self
    }
}

impl wkt::message::Message for DbSystemShape {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbSystemShape"
    }
}

/// A valid Oracle Database version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbVersion {
    /// Output only. The name of the DbVersion resource in the following format:
    /// projects/{project}/locations/{region}/dbVersions/{db_version}
    pub name: std::string::String,

    /// Output only. The properties of the DbVersion.
    pub properties: std::option::Option<crate::model::DbVersionProperties>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DbVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DbVersion::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DbVersionProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::DbVersion::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DbVersionProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DbVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbVersion"
    }
}

/// The properties of a DbVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DbVersionProperties {
    /// Output only. A valid Oracle Database version.
    pub version: std::string::String,

    /// Output only. True if this version of the Oracle Database software is the
    /// latest version for a release.
    pub is_latest_for_major_version: bool,

    /// Output only. True if this version of the Oracle Database software supports
    /// pluggable databases.
    pub supports_pdb: bool,

    /// Output only. True if this version of the Oracle Database software is the
    /// preview version.
    pub is_preview_db_version: bool,

    /// Output only. True if this version of the Oracle Database software is
    /// supported for Upgrade.
    pub is_upgrade_supported: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DbVersionProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::DbVersionProperties::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [is_latest_for_major_version][crate::model::DbVersionProperties::is_latest_for_major_version].
    pub fn set_is_latest_for_major_version<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_latest_for_major_version = v.into();
        self
    }

    /// Sets the value of [supports_pdb][crate::model::DbVersionProperties::supports_pdb].
    pub fn set_supports_pdb<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_pdb = v.into();
        self
    }

    /// Sets the value of [is_preview_db_version][crate::model::DbVersionProperties::is_preview_db_version].
    pub fn set_is_preview_db_version<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_preview_db_version = v.into();
        self
    }

    /// Sets the value of [is_upgrade_supported][crate::model::DbVersionProperties::is_upgrade_supported].
    pub fn set_is_upgrade_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_upgrade_supported = v.into();
        self
    }
}

impl wkt::message::Message for DbVersionProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DbVersionProperties"
    }
}

/// The request for `DbVersions.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbVersionsRequest {
    /// Required. The parent value for the DbVersion resource with the
    /// format: projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 DbVersions will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    pub page_token: std::string::String,

    /// Optional. Filter expression that matches a subset of the DbVersions to
    /// show. The supported filter for dbSystem creation is `db_system_shape =
    /// {db_system_shape} AND storage_management = {storage_management}`. If no
    /// filter is provided, all DbVersions will be returned.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDbVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDbVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbVersionsRequest"
    }
}

/// The response for `DbVersions.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbVersionsResponse {
    /// The list of DbVersions.
    pub db_versions: std::vec::Vec<crate::model::DbVersion>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_versions][crate::model::ListDbVersionsResponse::db_versions].
    pub fn set_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbVersion>,
    {
        use std::iter::Iterator;
        self.db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbVersionsResponse {
    type PageItem = crate::model::DbVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Details of the Entitlement resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Entitlement {
    /// Identifier. The name of the Entitlement resource with the format:
    /// projects/{project}/locations/{region}/entitlements/{entitlement}
    pub name: std::string::String,

    /// Details of the OCI Cloud Account.
    pub cloud_account_details: std::option::Option<crate::model::CloudAccountDetails>,

    /// Output only. Google Cloud Marketplace order ID (aka entitlement ID)
    pub entitlement_id: std::string::String,

    /// Output only. Entitlement State.
    pub state: crate::model::entitlement::State,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entitlement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entitlement::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cloud_account_details][crate::model::Entitlement::cloud_account_details].
    pub fn set_cloud_account_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudAccountDetails>,
    {
        self.cloud_account_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_account_details][crate::model::Entitlement::cloud_account_details].
    pub fn set_or_clear_cloud_account_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudAccountDetails>,
    {
        self.cloud_account_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entitlement_id][crate::model::Entitlement::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Entitlement::state].
    pub fn set_state<T: std::convert::Into<crate::model::entitlement::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Entitlement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.Entitlement"
    }
}

/// Defines additional types related to [Entitlement].
pub mod entitlement {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Account not linked.
        AccountNotLinked,
        /// Account is linked but not active.
        AccountNotActive,
        /// Entitlement and Account are active.
        Active,
        /// Account is suspended.
        AccountSuspended,
        /// Entitlement is not approved in private marketplace.
        NotApprovedInPrivateMarketplace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AccountNotLinked => std::option::Option::Some(1),
                Self::AccountNotActive => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::AccountSuspended => std::option::Option::Some(4),
                Self::NotApprovedInPrivateMarketplace => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::AccountNotLinked => std::option::Option::Some("ACCOUNT_NOT_LINKED"),
                Self::AccountNotActive => std::option::Option::Some("ACCOUNT_NOT_ACTIVE"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::AccountSuspended => std::option::Option::Some("ACCOUNT_SUSPENDED"),
                Self::NotApprovedInPrivateMarketplace => {
                    std::option::Option::Some("NOT_APPROVED_IN_PRIVATE_MARKETPLACE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AccountNotLinked,
                2 => Self::AccountNotActive,
                3 => Self::Active,
                4 => Self::AccountSuspended,
                5 => Self::NotApprovedInPrivateMarketplace,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACCOUNT_NOT_LINKED" => Self::AccountNotLinked,
                "ACCOUNT_NOT_ACTIVE" => Self::AccountNotActive,
                "ACTIVE" => Self::Active,
                "ACCOUNT_SUSPENDED" => Self::AccountSuspended,
                "NOT_APPROVED_IN_PRIVATE_MARKETPLACE" => Self::NotApprovedInPrivateMarketplace,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AccountNotLinked => serializer.serialize_i32(1),
                Self::AccountNotActive => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::AccountSuspended => serializer.serialize_i32(4),
                Self::NotApprovedInPrivateMarketplace => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.Entitlement.State",
            ))
        }
    }
}

/// Details of the OCI Cloud Account.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudAccountDetails {
    /// Output only. OCI account name.
    pub cloud_account: std::string::String,

    /// Output only. OCI account home region.
    pub cloud_account_home_region: std::string::String,

    /// Output only. URL to link an existing account.
    pub link_existing_account_uri: std::option::Option<std::string::String>,

    /// Output only. URL to create a new account and link.
    pub account_creation_uri: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudAccountDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_account][crate::model::CloudAccountDetails::cloud_account].
    pub fn set_cloud_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_account = v.into();
        self
    }

    /// Sets the value of [cloud_account_home_region][crate::model::CloudAccountDetails::cloud_account_home_region].
    pub fn set_cloud_account_home_region<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_account_home_region = v.into();
        self
    }

    /// Sets the value of [link_existing_account_uri][crate::model::CloudAccountDetails::link_existing_account_uri].
    pub fn set_link_existing_account_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.link_existing_account_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [link_existing_account_uri][crate::model::CloudAccountDetails::link_existing_account_uri].
    pub fn set_or_clear_link_existing_account_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.link_existing_account_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_creation_uri][crate::model::CloudAccountDetails::account_creation_uri].
    pub fn set_account_creation_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.account_creation_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_creation_uri][crate::model::CloudAccountDetails::account_creation_uri].
    pub fn set_or_clear_account_creation_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.account_creation_uri = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudAccountDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudAccountDetails"
    }
}

/// Represents CloudExadataInfrastructure resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudExadataInfrastructure/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudExadataInfrastructure {
    /// Identifier. The name of the Exadata Infrastructure resource with the
    /// format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}
    pub name: std::string::String,

    /// Optional. User friendly name for this resource.
    pub display_name: std::string::String,

    /// Optional. The GCP Oracle zone where Oracle Exadata Infrastructure is
    /// hosted. Example: us-east4-b-r2. If not specified, the system will pick a
    /// zone based on availability.
    pub gcp_oracle_zone: std::string::String,

    /// Output only. Entitlement ID of the private offer against which this
    /// infrastructure resource is provisioned.
    pub entitlement_id: std::string::String,

    /// Optional. Various properties of the infra.
    pub properties: std::option::Option<crate::model::CloudExadataInfrastructureProperties>,

    /// Optional. Labels or tags associated with the resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the Exadata Infrastructure was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudExadataInfrastructure {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudExadataInfrastructure::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudExadataInfrastructure::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudExadataInfrastructure::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::CloudExadataInfrastructure::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudExadataInfrastructure::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructureProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::CloudExadataInfrastructure::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructureProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CloudExadataInfrastructure::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudExadataInfrastructure::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudExadataInfrastructure::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructure {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructure"
    }
}

/// Various properties of Exadata Infrastructure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudExadataInfrastructureProperties {
    /// Output only. OCID of created infra.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    pub ocid: std::string::String,

    /// Optional. The number of compute servers for the Exadata Infrastructure.
    pub compute_count: i32,

    /// Optional. The number of Cloud Exadata storage servers for the Exadata
    /// Infrastructure.
    pub storage_count: i32,

    /// Optional. The total storage allocated to the Exadata Infrastructure
    /// resource, in gigabytes (GB).
    pub total_storage_size_gb: i32,

    /// Output only. The available storage can be allocated to the Exadata
    /// Infrastructure resource, in gigabytes (GB).
    pub available_storage_size_gb: i32,

    /// Optional. Maintenance window for repair.
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Output only. The current lifecycle state of the Exadata Infrastructure.
    pub state: crate::model::cloud_exadata_infrastructure_properties::State,

    /// Required. The shape of the Exadata Infrastructure. The shape determines the
    /// amount of CPU, storage, and memory resources allocated to the instance.
    pub shape: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    pub oci_url: std::string::String,

    /// Output only. The number of enabled CPU cores.
    pub cpu_count: i32,

    /// Output only. The total number of CPU cores available.
    pub max_cpu_count: i32,

    /// Output only. The memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Output only. The total memory available in GBs.
    pub max_memory_gb: i32,

    /// Output only. The local node storage allocated in GBs.
    pub db_node_storage_size_gb: i32,

    /// Output only. The total local node storage available in GBs.
    pub max_db_node_storage_size_gb: i32,

    /// Output only. Size, in terabytes, of the DATA disk group.
    pub data_storage_size_tb: f64,

    /// Output only. The total available DATA disk group size.
    pub max_data_storage_tb: f64,

    /// Output only. The requested number of additional storage servers activated
    /// for the Exadata Infrastructure.
    pub activated_storage_count: i32,

    /// Output only. The requested number of additional storage servers for the
    /// Exadata Infrastructure.
    pub additional_storage_count: i32,

    /// Output only. The software version of the database servers (dom0) in the
    /// Exadata Infrastructure.
    pub db_server_version: std::string::String,

    /// Output only. The software version of the storage servers (cells) in the
    /// Exadata Infrastructure.
    pub storage_server_version: std::string::String,

    /// Output only. The OCID of the next maintenance run.
    pub next_maintenance_run_id: std::string::String,

    /// Output only. The time when the next maintenance run will occur.
    pub next_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the next security maintenance run will occur.
    pub next_security_maintenance_run_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The list of customer contacts.
    pub customer_contacts: std::vec::Vec<crate::model::CustomerContact>,

    /// Output only. The monthly software version of the storage servers (cells)
    /// in the Exadata Infrastructure. Example: 20.1.15
    pub monthly_storage_server_version: std::string::String,

    /// Output only. The monthly software version of the database servers (dom0)
    /// in the Exadata Infrastructure. Example: 20.1.15
    pub monthly_db_server_version: std::string::String,

    /// Output only. The compute model of the Exadata Infrastructure.
    pub compute_model: crate::model::ComputeModel,

    /// Output only. The database server type of the Exadata Infrastructure.
    pub database_server_type: std::string::String,

    /// Output only. The storage server type of the Exadata Infrastructure.
    pub storage_server_type: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudExadataInfrastructureProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudExadataInfrastructureProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [compute_count][crate::model::CloudExadataInfrastructureProperties::compute_count].
    pub fn set_compute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_count = v.into();
        self
    }

    /// Sets the value of [storage_count][crate::model::CloudExadataInfrastructureProperties::storage_count].
    pub fn set_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_count = v.into();
        self
    }

    /// Sets the value of [total_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::total_storage_size_gb].
    pub fn set_total_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [available_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::available_storage_size_gb].
    pub fn set_available_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::CloudExadataInfrastructureProperties::maintenance_window].
    pub fn set_maintenance_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_window][crate::model::CloudExadataInfrastructureProperties::maintenance_window].
    pub fn set_or_clear_maintenance_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CloudExadataInfrastructureProperties::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::cloud_exadata_infrastructure_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudExadataInfrastructureProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudExadataInfrastructureProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::CloudExadataInfrastructureProperties::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [max_cpu_count][crate::model::CloudExadataInfrastructureProperties::max_cpu_count].
    pub fn set_max_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudExadataInfrastructureProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [max_memory_gb][crate::model::CloudExadataInfrastructureProperties::max_memory_gb].
    pub fn set_max_memory_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_memory_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [max_db_node_storage_size_gb][crate::model::CloudExadataInfrastructureProperties::max_db_node_storage_size_gb].
    pub fn set_max_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudExadataInfrastructureProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [max_data_storage_tb][crate::model::CloudExadataInfrastructureProperties::max_data_storage_tb].
    pub fn set_max_data_storage_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max_data_storage_tb = v.into();
        self
    }

    /// Sets the value of [activated_storage_count][crate::model::CloudExadataInfrastructureProperties::activated_storage_count].
    pub fn set_activated_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.activated_storage_count = v.into();
        self
    }

    /// Sets the value of [additional_storage_count][crate::model::CloudExadataInfrastructureProperties::additional_storage_count].
    pub fn set_additional_storage_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.additional_storage_count = v.into();
        self
    }

    /// Sets the value of [db_server_version][crate::model::CloudExadataInfrastructureProperties::db_server_version].
    pub fn set_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.db_server_version = v.into();
        self
    }

    /// Sets the value of [storage_server_version][crate::model::CloudExadataInfrastructureProperties::storage_server_version].
    pub fn set_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_server_version = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_id][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_id].
    pub fn set_next_maintenance_run_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_maintenance_run_id = v.into();
        self
    }

    /// Sets the value of [next_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_time].
    pub fn set_next_maintenance_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_maintenance_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_maintenance_run_time].
    pub fn set_or_clear_next_maintenance_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_maintenance_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_security_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_security_maintenance_run_time].
    pub fn set_next_security_maintenance_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_security_maintenance_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_security_maintenance_run_time][crate::model::CloudExadataInfrastructureProperties::next_security_maintenance_run_time].
    pub fn set_or_clear_next_security_maintenance_run_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_security_maintenance_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_contacts][crate::model::CloudExadataInfrastructureProperties::customer_contacts].
    pub fn set_customer_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerContact>,
    {
        use std::iter::Iterator;
        self.customer_contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [monthly_storage_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_storage_server_version].
    pub fn set_monthly_storage_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_storage_server_version = v.into();
        self
    }

    /// Sets the value of [monthly_db_server_version][crate::model::CloudExadataInfrastructureProperties::monthly_db_server_version].
    pub fn set_monthly_db_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_db_server_version = v.into();
        self
    }

    /// Sets the value of [compute_model][crate::model::CloudExadataInfrastructureProperties::compute_model].
    pub fn set_compute_model<T: std::convert::Into<crate::model::ComputeModel>>(
        mut self,
        v: T,
    ) -> Self {
        self.compute_model = v.into();
        self
    }

    /// Sets the value of [database_server_type][crate::model::CloudExadataInfrastructureProperties::database_server_type].
    pub fn set_database_server_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_server_type = v.into();
        self
    }

    /// Sets the value of [storage_server_type][crate::model::CloudExadataInfrastructureProperties::storage_server_type].
    pub fn set_storage_server_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_server_type = v.into();
        self
    }
}

impl wkt::message::Message for CloudExadataInfrastructureProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudExadataInfrastructureProperties"
    }
}

/// Defines additional types related to [CloudExadataInfrastructureProperties].
pub mod cloud_exadata_infrastructure_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the Exadata Infrastructure.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// The Exadata Infrastructure is being provisioned.
        Provisioning,
        /// The Exadata Infrastructure is available for use.
        Available,
        /// The Exadata Infrastructure is being updated.
        Updating,
        /// The Exadata Infrastructure is being terminated.
        Terminating,
        /// The Exadata Infrastructure is terminated.
        Terminated,
        /// The Exadata Infrastructure is in failed state.
        Failed,
        /// The Exadata Infrastructure is in maintenance.
        MaintenanceInProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::MaintenanceInProgress => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::MaintenanceInProgress => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.CloudExadataInfrastructureProperties.State",
            ))
        }
    }
}

/// Maintenance window as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/MaintenanceWindow>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Optional. The maintenance window scheduling preference.
    pub preference: crate::model::maintenance_window::MaintenanceWindowPreference,

    /// Optional. Months during the year when maintenance should be performed.
    pub months: std::vec::Vec<gtype::model::Month>,

    /// Optional. Weeks during the month when maintenance should be performed.
    /// Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a
    /// duration of 7 days. Weeks start and end based on calendar dates, not days
    /// of the week.
    pub weeks_of_month: std::vec::Vec<i32>,

    /// Optional. Days during the week when maintenance should be performed.
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. The window of hours during the day when maintenance should be
    /// performed. The window is a 4 hour slot. Valid values are:
    /// 0 - represents time slot 0:00 - 3:59 UTC
    /// 4 - represents time slot 4:00 - 7:59 UTC
    /// 8 - represents time slot 8:00 - 11:59 UTC
    /// 12 - represents time slot 12:00 - 15:59 UTC
    /// 16 - represents time slot 16:00 - 19:59 UTC
    /// 20 - represents time slot 20:00 - 23:59 UTC
    pub hours_of_day: std::vec::Vec<i32>,

    /// Optional. Lead time window allows user to set a lead time to prepare for a
    /// down time. The lead time is in weeks and valid value is between 1 to 4.
    pub lead_time_week: i32,

    /// Optional. Cloud CloudExadataInfrastructure node patching method, either
    /// "ROLLING" or "NONROLLING". Default value is ROLLING.
    pub patching_mode: crate::model::maintenance_window::PatchingMode,

    /// Optional. Determines the amount of time the system will wait before the
    /// start of each database server patching operation. Custom action timeout is
    /// in minutes and valid value is between 15 to 120 (inclusive).
    pub custom_action_timeout_mins: i32,

    /// Optional. If true, enables the configuration of a custom action timeout
    /// (waiting period) between database server patching operations.
    pub is_custom_action_timeout_enabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preference][crate::model::MaintenanceWindow::preference].
    pub fn set_preference<
        T: std::convert::Into<crate::model::maintenance_window::MaintenanceWindowPreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preference = v.into();
        self
    }

    /// Sets the value of [months][crate::model::MaintenanceWindow::months].
    pub fn set_months<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::Month>,
    {
        use std::iter::Iterator;
        self.months = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [weeks_of_month][crate::model::MaintenanceWindow::weeks_of_month].
    pub fn set_weeks_of_month<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.weeks_of_month = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [days_of_week][crate::model::MaintenanceWindow::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hours_of_day][crate::model::MaintenanceWindow::hours_of_day].
    pub fn set_hours_of_day<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.hours_of_day = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [lead_time_week][crate::model::MaintenanceWindow::lead_time_week].
    pub fn set_lead_time_week<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lead_time_week = v.into();
        self
    }

    /// Sets the value of [patching_mode][crate::model::MaintenanceWindow::patching_mode].
    pub fn set_patching_mode<
        T: std::convert::Into<crate::model::maintenance_window::PatchingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patching_mode = v.into();
        self
    }

    /// Sets the value of [custom_action_timeout_mins][crate::model::MaintenanceWindow::custom_action_timeout_mins].
    pub fn set_custom_action_timeout_mins<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.custom_action_timeout_mins = v.into();
        self
    }

    /// Sets the value of [is_custom_action_timeout_enabled][crate::model::MaintenanceWindow::is_custom_action_timeout_enabled].
    pub fn set_is_custom_action_timeout_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_custom_action_timeout_enabled = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.MaintenanceWindow"
    }
}

/// Defines additional types related to [MaintenanceWindow].
pub mod maintenance_window {
    #[allow(unused_imports)]
    use super::*;

    /// Maintenance window preference.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceWindowPreference {
        /// Default unspecified value.
        Unspecified,
        /// Custom preference.
        CustomPreference,
        /// No preference.
        NoPreference,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceWindowPreference::value] or
        /// [MaintenanceWindowPreference::name].
        UnknownValue(maintenance_window_preference::UnknownValue),
    }

    #[doc(hidden)]
    pub mod maintenance_window_preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaintenanceWindowPreference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CustomPreference => std::option::Option::Some(1),
                Self::NoPreference => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED")
                }
                Self::CustomPreference => std::option::Option::Some("CUSTOM_PREFERENCE"),
                Self::NoPreference => std::option::Option::Some("NO_PREFERENCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaintenanceWindowPreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaintenanceWindowPreference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaintenanceWindowPreference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CustomPreference,
                2 => Self::NoPreference,
                _ => Self::UnknownValue(maintenance_window_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaintenanceWindowPreference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOM_PREFERENCE" => Self::CustomPreference,
                "NO_PREFERENCE" => Self::NoPreference,
                _ => Self::UnknownValue(maintenance_window_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaintenanceWindowPreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CustomPreference => serializer.serialize_i32(1),
                Self::NoPreference => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaintenanceWindowPreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<MaintenanceWindowPreference>::new(
                    ".google.cloud.oracledatabase.v1.MaintenanceWindow.MaintenanceWindowPreference",
                ),
            )
        }
    }

    /// Patching mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PatchingMode {
        /// Default unspecified value.
        Unspecified,
        /// Updates the Cloud Exadata database server hosts in a rolling fashion.
        Rolling,
        /// The non-rolling maintenance method first updates your storage servers at
        /// the same time, then your database servers at the same time.
        NonRolling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PatchingMode::value] or
        /// [PatchingMode::name].
        UnknownValue(patching_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod patching_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PatchingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rolling => std::option::Option::Some(1),
                Self::NonRolling => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PATCHING_MODE_UNSPECIFIED"),
                Self::Rolling => std::option::Option::Some("ROLLING"),
                Self::NonRolling => std::option::Option::Some("NON_ROLLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PatchingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PatchingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PatchingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rolling,
                2 => Self::NonRolling,
                _ => Self::UnknownValue(patching_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PatchingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PATCHING_MODE_UNSPECIFIED" => Self::Unspecified,
                "ROLLING" => Self::Rolling,
                "NON_ROLLING" => Self::NonRolling,
                _ => Self::UnknownValue(patching_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PatchingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rolling => serializer.serialize_i32(1),
                Self::NonRolling => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PatchingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PatchingMode>::new(
                ".google.cloud.oracledatabase.v1.MaintenanceWindow.PatchingMode",
            ))
        }
    }
}

/// ExadbVmCluster represents a cluster of VMs that are used to run Exadata
/// workloads.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/ExadbVmCluster/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExadbVmCluster {
    /// Identifier. The name of the ExadbVmCluster resource in the following
    /// format:
    /// projects/{project}/locations/{region}/exadbVmClusters/{exadb_vm_cluster}
    pub name: std::string::String,

    /// Required. The properties of the ExadbVmCluster.
    pub properties: std::option::Option<crate::model::ExadbVmClusterProperties>,

    /// Output only. Immutable. The GCP Oracle zone where Oracle ExadbVmCluster is
    /// hosted. Example: us-east4-b-r2. During creation, the system will pick the
    /// zone assigned to the ExascaleDbStorageVault.
    pub gcp_oracle_zone: std::string::String,

    /// Optional. The labels or tags associated with the ExadbVmCluster.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Immutable. The name of the OdbNetwork associated with the
    /// ExadbVmCluster. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network} It is
    /// optional but if specified, this should match the parent ODBNetwork of the
    /// OdbSubnet.
    pub odb_network: std::string::String,

    /// Required. Immutable. The name of the OdbSubnet associated with the
    /// ExadbVmCluster for IP allocation. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    pub odb_subnet: std::string::String,

    /// Required. Immutable. The name of the backup OdbSubnet associated with the
    /// ExadbVmCluster. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    pub backup_odb_subnet: std::string::String,

    /// Required. Immutable. The display name for the ExadbVmCluster. The name does
    /// not have to be unique within your project. The name must be 1-255
    /// characters long and can only contain alphanumeric characters.
    pub display_name: std::string::String,

    /// Output only. The date and time that the ExadbVmCluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The ID of the subscription entitlement associated with the
    /// ExadbVmCluster.
    pub entitlement_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExadbVmCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExadbVmCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::ExadbVmCluster::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmClusterProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::ExadbVmCluster::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmClusterProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::ExadbVmCluster::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ExadbVmCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [odb_network][crate::model::ExadbVmCluster::odb_network].
    pub fn set_odb_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_network = v.into();
        self
    }

    /// Sets the value of [odb_subnet][crate::model::ExadbVmCluster::odb_subnet].
    pub fn set_odb_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_subnet = v.into();
        self
    }

    /// Sets the value of [backup_odb_subnet][crate::model::ExadbVmCluster::backup_odb_subnet].
    pub fn set_backup_odb_subnet<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_odb_subnet = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ExadbVmCluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ExadbVmCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExadbVmCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entitlement_id][crate::model::ExadbVmCluster::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }
}

impl wkt::message::Message for ExadbVmCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ExadbVmCluster"
    }
}

/// The storage allocation for the exadbvmcluster, in gigabytes (GB).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExadbVmClusterStorageDetails {
    /// Required. The storage allocation for the exadbvmcluster per node, in
    /// gigabytes (GB). This field is used to calculate the total storage
    /// allocation for the exadbvmcluster.
    pub size_in_gbs_per_node: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExadbVmClusterStorageDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [size_in_gbs_per_node][crate::model::ExadbVmClusterStorageDetails::size_in_gbs_per_node].
    pub fn set_size_in_gbs_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_in_gbs_per_node = v.into();
        self
    }
}

impl wkt::message::Message for ExadbVmClusterStorageDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ExadbVmClusterStorageDetails"
    }
}

/// The properties of an ExadbVmCluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExadbVmClusterProperties {
    /// Optional. Immutable. The cluster name for Exascale vm cluster. The cluster
    /// name must begin with an alphabetic character and may contain hyphens(-) but
    /// can not contain underscores(_). It should be not more than 11 characters
    /// and is not case sensitive. OCI Cluster name.
    pub cluster_name: std::string::String,

    /// Required. Immutable. Grid Infrastructure Version.
    pub grid_image_id: std::string::String,

    /// Required. The number of nodes/VMs in the ExadbVmCluster.
    pub node_count: i32,

    /// Required. Immutable. The number of ECPUs enabled per node for an exadata vm
    /// cluster on exascale infrastructure.
    pub enabled_ecpu_count_per_node: i32,

    /// Optional. Immutable. The number of additional ECPUs per node for an Exadata
    /// VM cluster on exascale infrastructure.
    pub additional_ecpu_count_per_node: i32,

    /// Required. Immutable. Total storage details for the ExadbVmCluster.
    pub vm_file_system_storage: std::option::Option<crate::model::ExadbVmClusterStorageDetails>,

    /// Optional. Immutable. The license type of the ExadbVmCluster.
    pub license_model: crate::model::exadb_vm_cluster_properties::LicenseModel,

    /// Required. Immutable. The name of ExascaleDbStorageVault associated with the
    /// ExadbVmCluster. It can refer to an existing ExascaleDbStorageVault. Or a
    /// new one can be created during the ExadbVmCluster creation (requires
    /// storage_vault_properties to be set).
    /// Format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}
    pub exascale_db_storage_vault: std::string::String,

    /// Required. Immutable. Prefix for VM cluster host names.
    pub hostname_prefix: std::string::String,

    /// Output only. The hostname of the ExadbVmCluster.
    pub hostname: std::string::String,

    /// Required. Immutable. The SSH public keys for the ExadbVmCluster.
    pub ssh_public_keys: std::vec::Vec<std::string::String>,

    /// Optional. Immutable. Indicates user preference for data collection options.
    pub data_collection_options: std::option::Option<crate::model::DataCollectionOptionsCommon>,

    /// Optional. Immutable. The time zone of the ExadbVmCluster.
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Output only. State of the cluster.
    pub lifecycle_state: crate::model::exadb_vm_cluster_properties::ExadbVmClusterLifecycleState,

    /// Required. Immutable. The shape attribute of the VM cluster. The type of
    /// Exascale storage used for Exadata VM cluster. The default is SMART_STORAGE
    /// which supports Oracle Database 23ai and later
    pub shape_attribute: crate::model::exadb_vm_cluster_properties::ShapeAttribute,

    /// Output only. Memory per VM (GB) (Read-only): Shows the amount of memory
    /// allocated to each VM. Memory is calculated based on 2.75 GB per Total
    /// ECPUs.
    pub memory_size_gb: i32,

    /// Optional. Immutable. SCAN listener port - TCP
    pub scan_listener_port_tcp: i32,

    /// Output only. Deep link to the OCI console to view this resource.
    pub oci_uri: std::string::String,

    /// Output only. The Oracle Grid Infrastructure (GI) software version.
    pub gi_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExadbVmClusterProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::ExadbVmClusterProperties::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [grid_image_id][crate::model::ExadbVmClusterProperties::grid_image_id].
    pub fn set_grid_image_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grid_image_id = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::ExadbVmClusterProperties::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [enabled_ecpu_count_per_node][crate::model::ExadbVmClusterProperties::enabled_ecpu_count_per_node].
    pub fn set_enabled_ecpu_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.enabled_ecpu_count_per_node = v.into();
        self
    }

    /// Sets the value of [additional_ecpu_count_per_node][crate::model::ExadbVmClusterProperties::additional_ecpu_count_per_node].
    pub fn set_additional_ecpu_count_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.additional_ecpu_count_per_node = v.into();
        self
    }

    /// Sets the value of [vm_file_system_storage][crate::model::ExadbVmClusterProperties::vm_file_system_storage].
    pub fn set_vm_file_system_storage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmClusterStorageDetails>,
    {
        self.vm_file_system_storage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vm_file_system_storage][crate::model::ExadbVmClusterProperties::vm_file_system_storage].
    pub fn set_or_clear_vm_file_system_storage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmClusterStorageDetails>,
    {
        self.vm_file_system_storage = v.map(|x| x.into());
        self
    }

    /// Sets the value of [license_model][crate::model::ExadbVmClusterProperties::license_model].
    pub fn set_license_model<
        T: std::convert::Into<crate::model::exadb_vm_cluster_properties::LicenseModel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_model = v.into();
        self
    }

    /// Sets the value of [exascale_db_storage_vault][crate::model::ExadbVmClusterProperties::exascale_db_storage_vault].
    pub fn set_exascale_db_storage_vault<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exascale_db_storage_vault = v.into();
        self
    }

    /// Sets the value of [hostname_prefix][crate::model::ExadbVmClusterProperties::hostname_prefix].
    pub fn set_hostname_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname_prefix = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::ExadbVmClusterProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [ssh_public_keys][crate::model::ExadbVmClusterProperties::ssh_public_keys].
    pub fn set_ssh_public_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_public_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_collection_options][crate::model::ExadbVmClusterProperties::data_collection_options].
    pub fn set_data_collection_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptionsCommon>,
    {
        self.data_collection_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_collection_options][crate::model::ExadbVmClusterProperties::data_collection_options].
    pub fn set_or_clear_data_collection_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptionsCommon>,
    {
        self.data_collection_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_zone][crate::model::ExadbVmClusterProperties::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::ExadbVmClusterProperties::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::ExadbVmClusterProperties::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<crate::model::exadb_vm_cluster_properties::ExadbVmClusterLifecycleState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [shape_attribute][crate::model::ExadbVmClusterProperties::shape_attribute].
    pub fn set_shape_attribute<
        T: std::convert::Into<crate::model::exadb_vm_cluster_properties::ShapeAttribute>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shape_attribute = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::ExadbVmClusterProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp][crate::model::ExadbVmClusterProperties::scan_listener_port_tcp].
    pub fn set_scan_listener_port_tcp<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp = v.into();
        self
    }

    /// Sets the value of [oci_uri][crate::model::ExadbVmClusterProperties::oci_uri].
    pub fn set_oci_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_uri = v.into();
        self
    }

    /// Sets the value of [gi_version][crate::model::ExadbVmClusterProperties::gi_version].
    pub fn set_gi_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gi_version = v.into();
        self
    }
}

impl wkt::message::Message for ExadbVmClusterProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ExadbVmClusterProperties"
    }
}

/// Defines additional types related to [ExadbVmClusterProperties].
pub mod exadb_vm_cluster_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The Oracle license model that applies to the ExaScale VM cluster
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseModel {
        /// Unspecified.
        Unspecified,
        /// Default is license included.
        LicenseIncluded,
        /// Bring your own license.
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseModel::value] or
        /// [LicenseModel::name].
        UnknownValue(license_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_MODEL_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_MODEL_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseModel>::new(
                ".google.cloud.oracledatabase.v1.ExadbVmClusterProperties.LicenseModel",
            ))
        }
    }

    /// The various lifecycle states of the VM cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExadbVmClusterLifecycleState {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExadbVmClusterLifecycleState::value] or
        /// [ExadbVmClusterLifecycleState::name].
        UnknownValue(exadb_vm_cluster_lifecycle_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod exadb_vm_cluster_lifecycle_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExadbVmClusterLifecycleState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::MaintenanceInProgress => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("EXADB_VM_CLUSTER_LIFECYCLE_STATE_UNSPECIFIED")
                }
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExadbVmClusterLifecycleState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExadbVmClusterLifecycleState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExadbVmClusterLifecycleState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(exadb_vm_cluster_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExadbVmClusterLifecycleState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXADB_VM_CLUSTER_LIFECYCLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(exadb_vm_cluster_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExadbVmClusterLifecycleState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::MaintenanceInProgress => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExadbVmClusterLifecycleState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExadbVmClusterLifecycleState>::new(
                ".google.cloud.oracledatabase.v1.ExadbVmClusterProperties.ExadbVmClusterLifecycleState"))
        }
    }

    /// The shape attribute of the VM cluster. The type of Exascale storage used
    /// for Exadata VM cluster. The default is SMART_STORAGE which supports Oracle
    /// Database 23ai and later
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ShapeAttribute {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in smart storage.
        SmartStorage,
        /// Indicates that the resource is in block storage.
        BlockStorage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ShapeAttribute::value] or
        /// [ShapeAttribute::name].
        UnknownValue(shape_attribute::UnknownValue),
    }

    #[doc(hidden)]
    pub mod shape_attribute {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ShapeAttribute {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SmartStorage => std::option::Option::Some(1),
                Self::BlockStorage => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SHAPE_ATTRIBUTE_UNSPECIFIED"),
                Self::SmartStorage => std::option::Option::Some("SMART_STORAGE"),
                Self::BlockStorage => std::option::Option::Some("BLOCK_STORAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ShapeAttribute {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ShapeAttribute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ShapeAttribute {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SmartStorage,
                2 => Self::BlockStorage,
                _ => Self::UnknownValue(shape_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ShapeAttribute {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SHAPE_ATTRIBUTE_UNSPECIFIED" => Self::Unspecified,
                "SMART_STORAGE" => Self::SmartStorage,
                "BLOCK_STORAGE" => Self::BlockStorage,
                _ => Self::UnknownValue(shape_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ShapeAttribute {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SmartStorage => serializer.serialize_i32(1),
                Self::BlockStorage => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ShapeAttribute {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ShapeAttribute>::new(
                ".google.cloud.oracledatabase.v1.ExadbVmClusterProperties.ShapeAttribute",
            ))
        }
    }
}

/// ExascaleDbStorageVault represents a storage vault exadb vm cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/ExascaleDbStorageVault/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExascaleDbStorageVault {
    /// Identifier. The resource name of the ExascaleDbStorageVault.
    /// Format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}
    pub name: std::string::String,

    /// Required. The display name for the ExascaleDbStorageVault. The name does
    /// not have to be unique within your project. The name must be 1-255
    /// characters long and can only contain alphanumeric characters.
    pub display_name: std::string::String,

    /// Optional. The GCP Oracle zone where Oracle ExascaleDbStorageVault is
    /// hosted. Example: us-east4-b-r2. If not specified, the system will pick a
    /// zone based on availability.
    pub gcp_oracle_zone: std::string::String,

    /// Required. The properties of the ExascaleDbStorageVault.
    pub properties: std::option::Option<crate::model::ExascaleDbStorageVaultProperties>,

    /// Output only. The date and time when the ExascaleDbStorageVault was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The ID of the subscription entitlement associated with the
    /// ExascaleDbStorageVault.
    pub entitlement_id: std::string::String,

    /// Optional. The labels or tags associated with the ExascaleDbStorageVault.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExascaleDbStorageVault {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExascaleDbStorageVault::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ExascaleDbStorageVault::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::ExascaleDbStorageVault::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::ExascaleDbStorageVault::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExascaleDbStorageVaultProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::ExascaleDbStorageVault::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExascaleDbStorageVaultProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::ExascaleDbStorageVault::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExascaleDbStorageVault::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entitlement_id][crate::model::ExascaleDbStorageVault::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ExascaleDbStorageVault::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ExascaleDbStorageVault {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ExascaleDbStorageVault"
    }
}

/// The properties of the ExascaleDbStorageVault.
/// next ID: 12
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExascaleDbStorageVaultProperties {
    /// Output only. The OCID for the ExascaleDbStorageVault.
    pub ocid: std::string::String,

    /// Output only. The time zone of the ExascaleDbStorageVault.
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Required. The storage details of the ExascaleDbStorageVault.
    pub exascale_db_storage_details: std::option::Option<crate::model::ExascaleDbStorageDetails>,

    /// Output only. The state of the ExascaleDbStorageVault.
    pub state: crate::model::exascale_db_storage_vault_properties::State,

    /// Optional. The description of the ExascaleDbStorageVault.
    pub description: std::string::String,

    /// Output only. The list of VM cluster OCIDs associated with the
    /// ExascaleDbStorageVault.
    pub vm_cluster_ids: std::vec::Vec<std::string::String>,

    /// Output only. The number of VM clusters associated with the
    /// ExascaleDbStorageVault.
    pub vm_cluster_count: i32,

    /// Optional. The size of additional flash cache in percentage of high capacity
    /// database storage.
    pub additional_flash_cache_percent: i32,

    /// Output only. Deep link to the OCI console to view this resource.
    pub oci_uri: std::string::String,

    /// Output only. The shape attributes of the VM clusters attached to the
    /// ExascaleDbStorageVault.
    pub attached_shape_attributes:
        std::vec::Vec<crate::model::exascale_db_storage_vault_properties::ShapeAttribute>,

    /// Output only. The shape attributes available for the VM clusters to be
    /// attached to the ExascaleDbStorageVault.
    pub available_shape_attributes:
        std::vec::Vec<crate::model::exascale_db_storage_vault_properties::ShapeAttribute>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExascaleDbStorageVaultProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::ExascaleDbStorageVaultProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::ExascaleDbStorageVaultProperties::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::ExascaleDbStorageVaultProperties::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exascale_db_storage_details][crate::model::ExascaleDbStorageVaultProperties::exascale_db_storage_details].
    pub fn set_exascale_db_storage_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExascaleDbStorageDetails>,
    {
        self.exascale_db_storage_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exascale_db_storage_details][crate::model::ExascaleDbStorageVaultProperties::exascale_db_storage_details].
    pub fn set_or_clear_exascale_db_storage_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExascaleDbStorageDetails>,
    {
        self.exascale_db_storage_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ExascaleDbStorageVaultProperties::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::exascale_db_storage_vault_properties::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ExascaleDbStorageVaultProperties::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [vm_cluster_ids][crate::model::ExascaleDbStorageVaultProperties::vm_cluster_ids].
    pub fn set_vm_cluster_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.vm_cluster_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [vm_cluster_count][crate::model::ExascaleDbStorageVaultProperties::vm_cluster_count].
    pub fn set_vm_cluster_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_cluster_count = v.into();
        self
    }

    /// Sets the value of [additional_flash_cache_percent][crate::model::ExascaleDbStorageVaultProperties::additional_flash_cache_percent].
    pub fn set_additional_flash_cache_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.additional_flash_cache_percent = v.into();
        self
    }

    /// Sets the value of [oci_uri][crate::model::ExascaleDbStorageVaultProperties::oci_uri].
    pub fn set_oci_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_uri = v.into();
        self
    }

    /// Sets the value of [attached_shape_attributes][crate::model::ExascaleDbStorageVaultProperties::attached_shape_attributes].
    pub fn set_attached_shape_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::exascale_db_storage_vault_properties::ShapeAttribute>,
    {
        use std::iter::Iterator;
        self.attached_shape_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [available_shape_attributes][crate::model::ExascaleDbStorageVaultProperties::available_shape_attributes].
    pub fn set_available_shape_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::exascale_db_storage_vault_properties::ShapeAttribute>,
    {
        use std::iter::Iterator;
        self.available_shape_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExascaleDbStorageVaultProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ExascaleDbStorageVaultProperties"
    }
}

/// Defines additional types related to [ExascaleDbStorageVaultProperties].
pub mod exascale_db_storage_vault_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the ExascaleDbStorageVault.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the ExascaleDbStorageVault is unspecified.
        Unspecified,
        /// The ExascaleDbStorageVault is being provisioned.
        Provisioning,
        /// The ExascaleDbStorageVault is available.
        Available,
        /// The ExascaleDbStorageVault is being updated.
        Updating,
        /// The ExascaleDbStorageVault is being deleted.
        Terminating,
        /// The ExascaleDbStorageVault has been deleted.
        Terminated,
        /// The ExascaleDbStorageVault has failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.ExascaleDbStorageVaultProperties.State",
            ))
        }
    }

    /// The shape attribute of the VM clusters attached to the
    /// ExascaleDbStorageVault.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ShapeAttribute {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in smart storage.
        SmartStorage,
        /// Indicates that the resource is in block storage.
        BlockStorage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ShapeAttribute::value] or
        /// [ShapeAttribute::name].
        UnknownValue(shape_attribute::UnknownValue),
    }

    #[doc(hidden)]
    pub mod shape_attribute {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ShapeAttribute {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SmartStorage => std::option::Option::Some(1),
                Self::BlockStorage => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SHAPE_ATTRIBUTE_UNSPECIFIED"),
                Self::SmartStorage => std::option::Option::Some("SMART_STORAGE"),
                Self::BlockStorage => std::option::Option::Some("BLOCK_STORAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ShapeAttribute {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ShapeAttribute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ShapeAttribute {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SmartStorage,
                2 => Self::BlockStorage,
                _ => Self::UnknownValue(shape_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ShapeAttribute {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SHAPE_ATTRIBUTE_UNSPECIFIED" => Self::Unspecified,
                "SMART_STORAGE" => Self::SmartStorage,
                "BLOCK_STORAGE" => Self::BlockStorage,
                _ => Self::UnknownValue(shape_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ShapeAttribute {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SmartStorage => serializer.serialize_i32(1),
                Self::BlockStorage => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ShapeAttribute {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ShapeAttribute>::new(
                ".google.cloud.oracledatabase.v1.ExascaleDbStorageVaultProperties.ShapeAttribute",
            ))
        }
    }
}

/// The storage details of the ExascaleDbStorageVault.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExascaleDbStorageDetails {
    /// Output only. The available storage capacity for the ExascaleDbStorageVault,
    /// in gigabytes (GB).
    pub available_size_gbs: i32,

    /// Required. The total storage allocation for the ExascaleDbStorageVault, in
    /// gigabytes (GB).
    pub total_size_gbs: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExascaleDbStorageDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_size_gbs][crate::model::ExascaleDbStorageDetails::available_size_gbs].
    pub fn set_available_size_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_size_gbs = v.into();
        self
    }

    /// Sets the value of [total_size_gbs][crate::model::ExascaleDbStorageDetails::total_size_gbs].
    pub fn set_total_size_gbs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size_gbs = v.into();
        self
    }
}

impl wkt::message::Message for ExascaleDbStorageDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ExascaleDbStorageDetails"
    }
}

/// The request for `ExascaleDbStorageVault.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetExascaleDbStorageVaultRequest {
    /// Required. The name of the ExascaleDbStorageVault in the following format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExascaleDbStorageVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExascaleDbStorageVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExascaleDbStorageVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetExascaleDbStorageVaultRequest"
    }
}

/// The request for `ExascaleDbStorageVault.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExascaleDbStorageVaultsRequest {
    /// Required. The parent value for ExascaleDbStorageVault in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ExascaleDbStorageVaults will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// the list as specified in <https://google.aip.dev/160>.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request. Order
    /// results as specified in <https://google.aip.dev/132>.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExascaleDbStorageVaultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExascaleDbStorageVaultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExascaleDbStorageVaultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExascaleDbStorageVaultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExascaleDbStorageVaultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListExascaleDbStorageVaultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListExascaleDbStorageVaultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListExascaleDbStorageVaultsRequest"
    }
}

/// The response for `ExascaleDbStorageVault.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExascaleDbStorageVaultsResponse {
    /// The ExascaleDbStorageVaults.
    pub exascale_db_storage_vaults: std::vec::Vec<crate::model::ExascaleDbStorageVault>,

    /// A token identifying a page of results the server should return. If present,
    /// the next page token can be provided to a subsequent
    /// ListExascaleDbStorageVaults call to list the next page.
    /// If empty, there are no more pages.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExascaleDbStorageVaultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exascale_db_storage_vaults][crate::model::ListExascaleDbStorageVaultsResponse::exascale_db_storage_vaults].
    pub fn set_exascale_db_storage_vaults<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExascaleDbStorageVault>,
    {
        use std::iter::Iterator;
        self.exascale_db_storage_vaults = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExascaleDbStorageVaultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExascaleDbStorageVaultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListExascaleDbStorageVaultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExascaleDbStorageVaultsResponse {
    type PageItem = crate::model::ExascaleDbStorageVault;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.exascale_db_storage_vaults
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `ExascaleDbStorageVault.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateExascaleDbStorageVaultRequest {
    /// Required. The value for parent of the ExascaleDbStorageVault in the
    /// following format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the ExascaleDbStorageVault to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    pub exascale_db_storage_vault_id: std::string::String,

    /// Required. The resource being created.
    pub exascale_db_storage_vault: std::option::Option<crate::model::ExascaleDbStorageVault>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateExascaleDbStorageVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExascaleDbStorageVaultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [exascale_db_storage_vault_id][crate::model::CreateExascaleDbStorageVaultRequest::exascale_db_storage_vault_id].
    pub fn set_exascale_db_storage_vault_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exascale_db_storage_vault_id = v.into();
        self
    }

    /// Sets the value of [exascale_db_storage_vault][crate::model::CreateExascaleDbStorageVaultRequest::exascale_db_storage_vault].
    pub fn set_exascale_db_storage_vault<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExascaleDbStorageVault>,
    {
        self.exascale_db_storage_vault = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exascale_db_storage_vault][crate::model::CreateExascaleDbStorageVaultRequest::exascale_db_storage_vault].
    pub fn set_or_clear_exascale_db_storage_vault<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExascaleDbStorageVault>,
    {
        self.exascale_db_storage_vault = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateExascaleDbStorageVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateExascaleDbStorageVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateExascaleDbStorageVaultRequest"
    }
}

/// The request message for `ExascaleDbStorageVault.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteExascaleDbStorageVaultRequest {
    /// Required. The name of the ExascaleDbStorageVault in the following format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExascaleDbStorageVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExascaleDbStorageVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteExascaleDbStorageVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExascaleDbStorageVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteExascaleDbStorageVaultRequest"
    }
}

/// Details of the Oracle Grid Infrastructure (GI) version resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiVersionSummary/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GiVersion {
    /// Identifier. The name of the Oracle Grid Infrastructure (GI) version
    /// resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_versions}
    pub name: std::string::String,

    /// Optional. version
    pub version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GiVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GiVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GiVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GiVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GiVersion"
    }
}

/// Metadata for a given [Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Output only. Google Cloud Platform Oracle zones in a location.
    pub gcp_oracle_zones: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_oracle_zones][crate::model::LocationMetadata::gcp_oracle_zones].
    pub fn set_gcp_oracle_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.gcp_oracle_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.LocationMetadata"
    }
}

/// MinorVersion represents a minor version of a GI.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiMinorVersionSummary/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MinorVersion {
    /// Identifier. The name of the MinorVersion resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_version}/minorVersions/{minor_version}
    pub name: std::string::String,

    /// Optional. The ID of the Grid Image.
    pub grid_image_id: std::string::String,

    /// Optional. The valid Oracle grid infrastructure software version.
    pub version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MinorVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MinorVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [grid_image_id][crate::model::MinorVersion::grid_image_id].
    pub fn set_grid_image_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grid_image_id = v.into();
        self
    }

    /// Sets the value of [version][crate::model::MinorVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for MinorVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.MinorVersion"
    }
}

/// The request for `MinorVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMinorVersionsRequest {
    /// Required. The parent value for the MinorVersion resource with the format:
    /// projects/{project}/locations/{location}/giVersions/{gi_version}
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 System Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    /// Only shapeFamily and gcp_oracle_zone_id are supported in this format:
    /// `shape_family="{shapeFamily}" AND
    /// gcp_oracle_zone_id="{gcp_oracle_zone_id}"`.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMinorVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMinorVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMinorVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMinorVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMinorVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListMinorVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListMinorVersionsRequest"
    }
}

/// The response for `MinorVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMinorVersionsResponse {
    /// The list of MinorVersions.
    pub minor_versions: std::vec::Vec<crate::model::MinorVersion>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMinorVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [minor_versions][crate::model::ListMinorVersionsResponse::minor_versions].
    pub fn set_minor_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MinorVersion>,
    {
        use std::iter::Iterator;
        self.minor_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMinorVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMinorVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListMinorVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMinorVersionsResponse {
    type PageItem = crate::model::MinorVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.minor_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents OdbNetwork resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OdbNetwork {
    /// Identifier. The name of the OdbNetwork resource in the following format:
    /// projects/{project}/locations/{region}/odbNetworks/{odb_network}
    pub name: std::string::String,

    /// Required. The name of the VPC network in the following format:
    /// projects/{project}/global/networks/{network}
    pub network: std::string::String,

    /// Optional. Labels or tags associated with the resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the OdbNetwork was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the ODB Network.
    pub state: crate::model::odb_network::State,

    /// Output only. The ID of the subscription entitlement associated with the
    /// OdbNetwork.
    pub entitlement_id: std::string::String,

    /// Optional. The GCP Oracle zone where OdbNetwork is hosted.
    /// Example: us-east4-b-r2.
    /// If not specified, the system will pick a zone based on availability.
    pub gcp_oracle_zone: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OdbNetwork {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OdbNetwork::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [network][crate::model::OdbNetwork::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::OdbNetwork::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::OdbNetwork::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OdbNetwork::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::OdbNetwork::state].
    pub fn set_state<T: std::convert::Into<crate::model::odb_network::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::OdbNetwork::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::OdbNetwork::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }
}

impl wkt::message::Message for OdbNetwork {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.OdbNetwork"
    }
}

/// Defines additional types related to [OdbNetwork].
pub mod odb_network {
    #[allow(unused_imports)]
    use super::*;

    /// The various lifecycle states of the ODB Network.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in failed state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Terminating => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Terminating,
                4 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "TERMINATING" => Self::Terminating,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Terminating => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.OdbNetwork.State",
            ))
        }
    }
}

/// The request for `OdbNetwork.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateOdbNetworkRequest {
    /// Required. The parent value for the OdbNetwork in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the OdbNetwork to create. This value is restricted
    /// to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    pub odb_network_id: std::string::String,

    /// Required. Details of the OdbNetwork instance to create.
    pub odb_network: std::option::Option<crate::model::OdbNetwork>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOdbNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOdbNetworkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [odb_network_id][crate::model::CreateOdbNetworkRequest::odb_network_id].
    pub fn set_odb_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_network_id = v.into();
        self
    }

    /// Sets the value of [odb_network][crate::model::CreateOdbNetworkRequest::odb_network].
    pub fn set_odb_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OdbNetwork>,
    {
        self.odb_network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [odb_network][crate::model::CreateOdbNetworkRequest::odb_network].
    pub fn set_or_clear_odb_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OdbNetwork>,
    {
        self.odb_network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateOdbNetworkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateOdbNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateOdbNetworkRequest"
    }
}

/// The request for `OdbNetwork.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteOdbNetworkRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOdbNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOdbNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteOdbNetworkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOdbNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteOdbNetworkRequest"
    }
}

/// The request for `OdbNetwork.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOdbNetworksRequest {
    /// Required. The parent value for the ODB Network in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ODB Networks will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOdbNetworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOdbNetworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOdbNetworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOdbNetworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOdbNetworksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListOdbNetworksRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListOdbNetworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListOdbNetworksRequest"
    }
}

/// The response for `OdbNetwork.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOdbNetworksResponse {
    /// The list of ODB Networks.
    pub odb_networks: std::vec::Vec<crate::model::OdbNetwork>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Unreachable locations when listing resources across all locations using
    /// wildcard location '-'.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOdbNetworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [odb_networks][crate::model::ListOdbNetworksResponse::odb_networks].
    pub fn set_odb_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OdbNetwork>,
    {
        use std::iter::Iterator;
        self.odb_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOdbNetworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListOdbNetworksResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOdbNetworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListOdbNetworksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOdbNetworksResponse {
    type PageItem = crate::model::OdbNetwork;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.odb_networks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `OdbNetwork.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOdbNetworkRequest {
    /// Required. The name of the OdbNetwork in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOdbNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOdbNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOdbNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetOdbNetworkRequest"
    }
}

/// Represents OdbSubnet resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OdbSubnet {
    /// Identifier. The name of the OdbSubnet resource in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    pub name: std::string::String,

    /// Required. The CIDR range of the subnet.
    pub cidr_range: std::string::String,

    /// Required. Purpose of the subnet.
    pub purpose: crate::model::odb_subnet::Purpose,

    /// Optional. Labels or tags associated with the resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the OdbNetwork was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the ODB Subnet.
    pub state: crate::model::odb_subnet::State,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OdbSubnet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OdbSubnet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cidr_range][crate::model::OdbSubnet::cidr_range].
    pub fn set_cidr_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr_range = v.into();
        self
    }

    /// Sets the value of [purpose][crate::model::OdbSubnet::purpose].
    pub fn set_purpose<T: std::convert::Into<crate::model::odb_subnet::Purpose>>(
        mut self,
        v: T,
    ) -> Self {
        self.purpose = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::OdbSubnet::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::OdbSubnet::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OdbSubnet::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::OdbSubnet::state].
    pub fn set_state<T: std::convert::Into<crate::model::odb_subnet::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for OdbSubnet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.OdbSubnet"
    }
}

/// Defines additional types related to [OdbSubnet].
pub mod odb_subnet {
    #[allow(unused_imports)]
    use super::*;

    /// Purpose available for the subnet.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Purpose {
        /// Default unspecified value.
        Unspecified,
        /// Subnet to be used for client connections.
        ClientSubnet,
        /// Subnet to be used for backup.
        BackupSubnet,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Purpose::value] or
        /// [Purpose::name].
        UnknownValue(purpose::UnknownValue),
    }

    #[doc(hidden)]
    pub mod purpose {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Purpose {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ClientSubnet => std::option::Option::Some(1),
                Self::BackupSubnet => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PURPOSE_UNSPECIFIED"),
                Self::ClientSubnet => std::option::Option::Some("CLIENT_SUBNET"),
                Self::BackupSubnet => std::option::Option::Some("BACKUP_SUBNET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Purpose {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Purpose {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Purpose {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ClientSubnet,
                2 => Self::BackupSubnet,
                _ => Self::UnknownValue(purpose::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Purpose {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PURPOSE_UNSPECIFIED" => Self::Unspecified,
                "CLIENT_SUBNET" => Self::ClientSubnet,
                "BACKUP_SUBNET" => Self::BackupSubnet,
                _ => Self::UnknownValue(purpose::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Purpose {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ClientSubnet => serializer.serialize_i32(1),
                Self::BackupSubnet => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Purpose {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Purpose>::new(
                ".google.cloud.oracledatabase.v1.OdbSubnet.Purpose",
            ))
        }
    }

    /// The various lifecycle states of the ODB Subnet.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in failed state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Terminating => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Terminating,
                4 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "TERMINATING" => Self::Terminating,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Terminating => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.OdbSubnet.State",
            ))
        }
    }
}

/// The request for `OdbSubnet.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateOdbSubnetRequest {
    /// Required. The parent value for the OdbSubnet in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    pub parent: std::string::String,

    /// Required. The ID of the OdbSubnet to create. This value is restricted
    /// to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    pub odb_subnet_id: std::string::String,

    /// Required. Details of the OdbSubnet instance to create.
    pub odb_subnet: std::option::Option<crate::model::OdbSubnet>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOdbSubnetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOdbSubnetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [odb_subnet_id][crate::model::CreateOdbSubnetRequest::odb_subnet_id].
    pub fn set_odb_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_subnet_id = v.into();
        self
    }

    /// Sets the value of [odb_subnet][crate::model::CreateOdbSubnetRequest::odb_subnet].
    pub fn set_odb_subnet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OdbSubnet>,
    {
        self.odb_subnet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [odb_subnet][crate::model::CreateOdbSubnetRequest::odb_subnet].
    pub fn set_or_clear_odb_subnet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OdbSubnet>,
    {
        self.odb_subnet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateOdbSubnetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateOdbSubnetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateOdbSubnetRequest"
    }
}

/// The request for `OdbSubnet.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteOdbSubnetRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{region}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOdbSubnetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOdbSubnetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteOdbSubnetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOdbSubnetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteOdbSubnetRequest"
    }
}

/// The request for `OdbSubnet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOdbSubnetsRequest {
    /// Required. The parent value for the OdbSubnet in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ODB Networks will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOdbSubnetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOdbSubnetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOdbSubnetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOdbSubnetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOdbSubnetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListOdbSubnetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListOdbSubnetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListOdbSubnetsRequest"
    }
}

/// The response for `OdbSubnet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOdbSubnetsResponse {
    /// The list of ODB Subnets.
    pub odb_subnets: std::vec::Vec<crate::model::OdbSubnet>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Unreachable locations when listing resources across all locations using
    /// wildcard location '-'.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOdbSubnetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [odb_subnets][crate::model::ListOdbSubnetsResponse::odb_subnets].
    pub fn set_odb_subnets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OdbSubnet>,
    {
        use std::iter::Iterator;
        self.odb_subnets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOdbSubnetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListOdbSubnetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOdbSubnetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListOdbSubnetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOdbSubnetsResponse {
    type PageItem = crate::model::OdbSubnet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.odb_subnets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `OdbSubnet.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOdbSubnetRequest {
    /// Required. The name of the OdbSubnet in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOdbSubnetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOdbSubnetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOdbSubnetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetOdbSubnetRequest"
    }
}

/// The request for `CloudExadataInfrastructures.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Exadata infrastructures will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudExadataInfrastructuresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudExadataInfrastructuresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudExadataInfrastructuresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudExadataInfrastructuresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloudExadataInfrastructuresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCloudExadataInfrastructuresRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresRequest"
    }
}

/// The response for `CloudExadataInfrastructures.list`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudExadataInfrastructuresResponse {
    /// The list of Exadata Infrastructures.
    pub cloud_exadata_infrastructures: std::vec::Vec<crate::model::CloudExadataInfrastructure>,

    /// A token for fetching next page of response.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudExadataInfrastructuresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_exadata_infrastructures][crate::model::ListCloudExadataInfrastructuresResponse::cloud_exadata_infrastructures].
    pub fn set_cloud_exadata_infrastructures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        use std::iter::Iterator;
        self.cloud_exadata_infrastructures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudExadataInfrastructuresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudExadataInfrastructuresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudExadataInfrastructuresResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudExadataInfrastructuresResponse {
    type PageItem = crate::model::CloudExadataInfrastructure;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_exadata_infrastructures
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `CloudExadataInfrastructure.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudExadataInfrastructure.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCloudExadataInfrastructureRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the Exadata Infrastructure to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    pub cloud_exadata_infrastructure_id: std::string::String,

    /// Required. Details of the Exadata Infrastructure instance to create.
    pub cloud_exadata_infrastructure: std::option::Option<crate::model::CloudExadataInfrastructure>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudExadataInfrastructureRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure_id][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure_id].
    pub fn set_cloud_exadata_infrastructure_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_exadata_infrastructure_id = v.into();
        self
    }

    /// Sets the value of [cloud_exadata_infrastructure][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure].
    pub fn set_cloud_exadata_infrastructure<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        self.cloud_exadata_infrastructure = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_exadata_infrastructure][crate::model::CreateCloudExadataInfrastructureRequest::cloud_exadata_infrastructure].
    pub fn set_or_clear_cloud_exadata_infrastructure<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudExadataInfrastructure>,
    {
        self.cloud_exadata_infrastructure = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudExadataInfrastructure.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, all VM clusters for this Exadata Infrastructure
    /// will be deleted. An Exadata Infrastructure can only be deleted once all its
    /// VM clusters have been deleted.
    pub force: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCloudExadataInfrastructureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudExadataInfrastructureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudExadataInfrastructureRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudExadataInfrastructureRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudExadataInfrastructureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudExadataInfrastructureRequest"
    }
}

/// The request for `CloudVmCluster.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudVmClustersRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The number of VM clusters to return.
    /// If unspecified, at most 50 VM clusters will be returned.
    /// The maximum value is 1,000.
    pub page_size: i32,

    /// Optional. A token identifying the page of results the server returns.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudVmClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudVmClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudVmClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudVmClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloudVmClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersRequest"
    }
}

/// The response for `CloudVmCluster.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudVmClustersResponse {
    /// The list of VM Clusters.
    pub cloud_vm_clusters: std::vec::Vec<crate::model::CloudVmCluster>,

    /// A token to fetch the next page of results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudVmClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_vm_clusters][crate::model::ListCloudVmClustersResponse::cloud_vm_clusters].
    pub fn set_cloud_vm_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudVmCluster>,
    {
        use std::iter::Iterator;
        self.cloud_vm_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudVmClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudVmClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListCloudVmClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudVmClustersResponse {
    type PageItem = crate::model::CloudVmCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_vm_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `CloudVmCluster.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetCloudVmClusterRequest"
    }
}

/// The request for `CloudVmCluster.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCloudVmClusterRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the VM Cluster to create. This value is restricted
    /// to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    pub cloud_vm_cluster_id: std::string::String,

    /// Required. The resource being created
    pub cloud_vm_cluster: std::option::Option<crate::model::CloudVmCluster>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudVmClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster_id][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster_id].
    pub fn set_cloud_vm_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_vm_cluster_id = v.into();
        self
    }

    /// Sets the value of [cloud_vm_cluster][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster].
    pub fn set_cloud_vm_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmCluster>,
    {
        self.cloud_vm_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_vm_cluster][crate::model::CreateCloudVmClusterRequest::cloud_vm_cluster].
    pub fn set_or_clear_cloud_vm_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmCluster>,
    {
        self.cloud_vm_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateCloudVmClusterRequest"
    }
}

/// The request for `CloudVmCluster.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, all child resources for the VM Cluster will be
    /// deleted. A VM Cluster can only be deleted once all its child resources have
    /// been deleted.
    pub force: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCloudVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCloudVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCloudVmClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteCloudVmClusterRequest"
    }
}

/// The request for `Entitlement.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitlementsRequest {
    /// Required. The parent value for the entitlement in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 entitlements will be returned.
    /// The maximum value is 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsRequest"
    }
}

/// The response for `Entitlement.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitlementsResponse {
    /// The list of Entitlements
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitlements][crate::model::ListEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListEntitlementsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `DbServer.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbServersRequest {
    /// Required. The parent value for database server in the following format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloudExadataInfrastructure}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 db servers will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbServersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbServersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbServersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersRequest"
    }
}

/// The response for `DbServer.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbServersResponse {
    /// The list of database servers.
    pub db_servers: std::vec::Vec<crate::model::DbServer>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_servers][crate::model::ListDbServersResponse::db_servers].
    pub fn set_db_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbServer>,
    {
        use std::iter::Iterator;
        self.db_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbServersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbServersResponse {
    type PageItem = crate::model::DbServer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_servers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `DbNode.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbNodesRequest {
    /// Required. The parent value for database node in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloudVmCluster}.
    /// .
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 db nodes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the node should return.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbNodesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbNodesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbNodesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbNodesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbNodesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesRequest"
    }
}

/// The response for `DbNode.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbNodesResponse {
    /// The list of DB Nodes
    pub db_nodes: std::vec::Vec<crate::model::DbNode>,

    /// A token identifying a page of results the node should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbNodesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_nodes][crate::model::ListDbNodesResponse::db_nodes].
    pub fn set_db_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbNode>,
    {
        use std::iter::Iterator;
        self.db_nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbNodesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbNodesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbNodesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbNodesResponse {
    type PageItem = crate::model::DbNode;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_nodes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `GiVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGiVersionsRequest {
    /// Required. The parent value for Grid Infrastructure Version in the following
    /// format: Format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Oracle Grid Infrastructure (GI) versions
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// reset to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// shape, gcp_oracle_zone and gi_version fields are supported in this format:
    /// `shape="{shape}"`.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGiVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGiVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGiVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGiVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGiVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListGiVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsRequest"
    }
}

/// The response for `GiVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGiVersionsResponse {
    /// The list of Oracle Grid Infrastructure (GI) versions.
    pub gi_versions: std::vec::Vec<crate::model::GiVersion>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGiVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gi_versions][crate::model::ListGiVersionsResponse::gi_versions].
    pub fn set_gi_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GiVersion>,
    {
        use std::iter::Iterator;
        self.gi_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGiVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGiVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListGiVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGiVersionsResponse {
    type PageItem = crate::model::GiVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.gi_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `DbSystemShape.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemShapesRequest {
    /// Required. The parent value for Database System Shapes in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 database system shapes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// gcp_oracle_zone_id field is supported in this format:
    /// `gcp_oracle_zone_id="{gcp_oracle_zone_id}"`.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemShapesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDbSystemShapesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDbSystemShapesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDbSystemShapesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDbSystemShapesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesRequest"
    }
}

/// The response for `DbSystemShape.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDbSystemShapesResponse {
    /// The list of Database System shapes.
    pub db_system_shapes: std::vec::Vec<crate::model::DbSystemShape>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDbSystemShapesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [db_system_shapes][crate::model::ListDbSystemShapesResponse::db_system_shapes].
    pub fn set_db_system_shapes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DbSystemShape>,
    {
        use std::iter::Iterator;
        self.db_system_shapes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDbSystemShapesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDbSystemShapesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListDbSystemShapesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDbSystemShapesResponse {
    type PageItem = crate::model::DbSystemShape;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.db_system_shapes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. The status of the operation.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    /// Output only. An estimated percentage of the operation that has been
    /// completed at a given moment of time, between 0 and 100.
    pub percent_complete: f64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [percent_complete][crate::model::OperationMetadata::percent_complete].
    pub fn set_percent_complete<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.percent_complete = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.OperationMetadata"
    }
}

/// The request for `AutonomousDatabase.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabasesRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous Database will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutonomousDatabasesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesRequest"
    }
}

/// The response for `AutonomousDatabase.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabasesResponse {
    /// The list of Autonomous Databases.
    pub autonomous_databases: std::vec::Vec<crate::model::AutonomousDatabase>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_databases][crate::model::ListAutonomousDatabasesResponse::autonomous_databases].
    pub fn set_autonomous_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        use std::iter::Iterator;
        self.autonomous_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabasesResponse {
    type PageItem = crate::model::AutonomousDatabase;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `AutonomousDatabase.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAutonomousDatabaseRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the Autonomous Database to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    pub autonomous_database_id: std::string::String,

    /// Required. The Autonomous Database being created.
    pub autonomous_database: std::option::Option<crate::model::AutonomousDatabase>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutonomousDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [autonomous_database_id][crate::model::CreateAutonomousDatabaseRequest::autonomous_database_id].
    pub fn set_autonomous_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.autonomous_database_id = v.into();
        self
    }

    /// Sets the value of [autonomous_database][crate::model::CreateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_autonomous_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autonomous_database][crate::model::CreateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_or_clear_autonomous_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Update`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAutonomousDatabaseRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Exadata resource by the update. The fields specified in the update_mask are
    /// relative to the resource, not the full request. A field will be overwritten
    /// if it is in the mask. If the user does not provide a mask then all fields
    /// will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub autonomous_database: std::option::Option<crate::model::AutonomousDatabase>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAutonomousDatabaseRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAutonomousDatabaseRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autonomous_database][crate::model::UpdateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_autonomous_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autonomous_database][crate::model::UpdateAutonomousDatabaseRequest::autonomous_database].
    pub fn set_or_clear_autonomous_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutonomousDatabase>,
    {
        self.autonomous_database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.UpdateAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAutonomousDatabaseRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAutonomousDatabaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Restore`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Required. The time and date to restore the database to.
    pub restore_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [restore_time][crate::model::RestoreAutonomousDatabaseRequest::restore_time].
    pub fn set_restore_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.restore_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_time][crate::model::RestoreAutonomousDatabaseRequest::restore_time].
    pub fn set_or_clear_restore_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.restore_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RestoreAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RestoreAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Stop`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.StopAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Start`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.StartAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.Restart`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RestartAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RestartAutonomousDatabaseRequest"
    }
}

/// The request for `OracleDatabase.SwitchoverAutonomousDatabase`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SwitchoverAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Required. The peer database name to switch over to.
    pub peer_autonomous_database: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SwitchoverAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SwitchoverAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [peer_autonomous_database][crate::model::SwitchoverAutonomousDatabaseRequest::peer_autonomous_database].
    pub fn set_peer_autonomous_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_autonomous_database = v.into();
        self
    }
}

impl wkt::message::Message for SwitchoverAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.SwitchoverAutonomousDatabaseRequest"
    }
}

/// The request for `OracleDatabase.FailoverAutonomousDatabase`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FailoverAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Required. The peer database name to fail over to.
    pub peer_autonomous_database: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailoverAutonomousDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FailoverAutonomousDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [peer_autonomous_database][crate::model::FailoverAutonomousDatabaseRequest::peer_autonomous_database].
    pub fn set_peer_autonomous_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_autonomous_database = v.into();
        self
    }
}

impl wkt::message::Message for FailoverAutonomousDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.FailoverAutonomousDatabaseRequest"
    }
}

/// The request for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    pub name: std::string::String,

    /// Optional. The type of wallet generation for the Autonomous Database. The
    /// default value is SINGLE.
    pub r#type: crate::model::GenerateType,

    /// Optional. True when requesting regional connection strings in PDB connect
    /// info, applicable to cross-region Data Guard only.
    pub is_regional: bool,

    /// Required. The password used to encrypt the keys inside the wallet. The
    /// password must be a minimum of 8 characters.
    pub password: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAutonomousDatabaseWalletRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateAutonomousDatabaseWalletRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::GenerateAutonomousDatabaseWalletRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::GenerateType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [is_regional][crate::model::GenerateAutonomousDatabaseWalletRequest::is_regional].
    pub fn set_is_regional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_regional = v.into();
        self
    }

    /// Sets the value of [password][crate::model::GenerateAutonomousDatabaseWalletRequest::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletRequest"
    }
}

/// The response for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAutonomousDatabaseWalletResponse {
    /// Output only. The base64 encoded wallet files.
    pub archive_content: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAutonomousDatabaseWalletResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [archive_content][crate::model::GenerateAutonomousDatabaseWalletResponse::archive_content].
    pub fn set_archive_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.archive_content = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAutonomousDatabaseWalletResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GenerateAutonomousDatabaseWalletResponse"
    }
}

/// The request for `AutonomousDbVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDbVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDbVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDbVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDbVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsRequest"
    }
}

/// The response for `AutonomousDbVersion.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDbVersionsResponse {
    /// The list of Autonomous Database versions.
    pub autonomous_db_versions: std::vec::Vec<crate::model::AutonomousDbVersion>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDbVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_db_versions][crate::model::ListAutonomousDbVersionsResponse::autonomous_db_versions].
    pub fn set_autonomous_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDbVersion>,
    {
        use std::iter::Iterator;
        self.autonomous_db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDbVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDbVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDbVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDbVersionsResponse {
    type PageItem = crate::model::AutonomousDbVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_db_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Character Sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseCharacterSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseCharacterSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseCharacterSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseCharacterSetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsRequest"
    }
}

/// The response for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseCharacterSetsResponse {
    /// The list of Autonomous Database Character Sets.
    pub autonomous_database_character_sets:
        std::vec::Vec<crate::model::AutonomousDatabaseCharacterSet>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseCharacterSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_database_character_sets][crate::model::ListAutonomousDatabaseCharacterSetsResponse::autonomous_database_character_sets].
    pub fn set_autonomous_database_character_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseCharacterSet>,
    {
        use std::iter::Iterator;
        self.autonomous_database_character_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseCharacterSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseCharacterSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseCharacterSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabaseCharacterSetsResponse {
    type PageItem = crate::model::AutonomousDatabaseCharacterSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_character_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `AutonomousDatabaseBackup.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsRequest {
    /// Required. The parent value for ListAutonomousDatabaseBackups in the
    /// following format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. Only the
    /// **autonomous_database_id** field is supported in the following format:
    /// `autonomous_database_id="{autonomous_database_id}"`. The accepted values
    /// must be a valid Autonomous Database ID, limited to the naming
    /// restrictions of the ID: ^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    /// The ID must start with a letter, end with a letter or a number, and be
    /// a maximum of 63 characters.
    pub filter: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Backups will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutonomousDatabaseBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutonomousDatabaseBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutonomousDatabaseBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutonomousDatabaseBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsRequest"
    }
}

/// The response for `AutonomousDatabaseBackup.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutonomousDatabaseBackupsResponse {
    /// The list of Autonomous Database Backups.
    pub autonomous_database_backups: std::vec::Vec<crate::model::AutonomousDatabaseBackup>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutonomousDatabaseBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autonomous_database_backups][crate::model::ListAutonomousDatabaseBackupsResponse::autonomous_database_backups].
    pub fn set_autonomous_database_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutonomousDatabaseBackup>,
    {
        use std::iter::Iterator;
        self.autonomous_database_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutonomousDatabaseBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutonomousDatabaseBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListAutonomousDatabaseBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutonomousDatabaseBackupsResponse {
    type PageItem = crate::model::AutonomousDatabaseBackup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.autonomous_database_backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `ExadbVmCluster.Create`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateExadbVmClusterRequest {
    /// Required. The value for parent of the ExadbVmCluster in the following
    /// format: projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Required. The ID of the ExadbVmCluster to create. This value is
    /// restricted to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    pub exadb_vm_cluster_id: std::string::String,

    /// Required. The resource being created.
    pub exadb_vm_cluster: std::option::Option<crate::model::ExadbVmCluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateExadbVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExadbVmClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [exadb_vm_cluster_id][crate::model::CreateExadbVmClusterRequest::exadb_vm_cluster_id].
    pub fn set_exadb_vm_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exadb_vm_cluster_id = v.into();
        self
    }

    /// Sets the value of [exadb_vm_cluster][crate::model::CreateExadbVmClusterRequest::exadb_vm_cluster].
    pub fn set_exadb_vm_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmCluster>,
    {
        self.exadb_vm_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exadb_vm_cluster][crate::model::CreateExadbVmClusterRequest::exadb_vm_cluster].
    pub fn set_or_clear_exadb_vm_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmCluster>,
    {
        self.exadb_vm_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateExadbVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateExadbVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CreateExadbVmClusterRequest"
    }
}

/// The request for `ExadbVmCluster.Delete`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteExadbVmClusterRequest {
    /// Required. The name of the ExadbVmCluster in the following format:
    /// projects/{project}/locations/{location}/exadbVmClusters/{exadb_vm_cluster}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExadbVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExadbVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteExadbVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExadbVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DeleteExadbVmClusterRequest"
    }
}

/// The request for `ExadbVmCluster.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetExadbVmClusterRequest {
    /// Required. The name of the ExadbVmCluster in the following format:
    /// projects/{project}/locations/{location}/exadbVmClusters/{exadb_vm_cluster}.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExadbVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExadbVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExadbVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetExadbVmClusterRequest"
    }
}

/// The request for `ExadbVmCluster.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExadbVmClustersRequest {
    /// Required. The parent value for ExadbVmClusters in the following format:
    /// projects/{project}/locations/{location}.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ExadbVmClusters will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    pub filter: std::string::String,

    /// Optional. An expression for ordering the results of the request.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExadbVmClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExadbVmClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExadbVmClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExadbVmClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExadbVmClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListExadbVmClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListExadbVmClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListExadbVmClustersRequest"
    }
}

/// The response for `ExadbVmCluster.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExadbVmClustersResponse {
    /// The list of ExadbVmClusters.
    pub exadb_vm_clusters: std::vec::Vec<crate::model::ExadbVmCluster>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExadbVmClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exadb_vm_clusters][crate::model::ListExadbVmClustersResponse::exadb_vm_clusters].
    pub fn set_exadb_vm_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExadbVmCluster>,
    {
        use std::iter::Iterator;
        self.exadb_vm_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExadbVmClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExadbVmClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListExadbVmClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExadbVmClustersResponse {
    type PageItem = crate::model::ExadbVmCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.exadb_vm_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for `ExadbVmCluster.Update`. We only support adding the
/// Virtual Machine to the ExadbVmCluster. Rest of the fields in ExadbVmCluster
/// are immutable.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateExadbVmClusterRequest {
    /// Optional. A mask specifying which fields in th VM Cluster should be
    /// updated. A field specified in the mask is overwritten. If a mask isn't
    /// provided then all the fields in the VM Cluster are overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated.
    pub exadb_vm_cluster: std::option::Option<crate::model::ExadbVmCluster>,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateExadbVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateExadbVmClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExadbVmClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exadb_vm_cluster][crate::model::UpdateExadbVmClusterRequest::exadb_vm_cluster].
    pub fn set_exadb_vm_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmCluster>,
    {
        self.exadb_vm_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exadb_vm_cluster][crate::model::UpdateExadbVmClusterRequest::exadb_vm_cluster].
    pub fn set_or_clear_exadb_vm_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExadbVmCluster>,
    {
        self.exadb_vm_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateExadbVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateExadbVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.UpdateExadbVmClusterRequest"
    }
}

/// The request for `ExadbVmCluster.RemoveVirtualMachine`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveVirtualMachineExadbVmClusterRequest {
    /// Required. The name of the ExadbVmCluster in the following format:
    /// projects/{project}/locations/{location}/exadbVmClusters/{exadb_vm_cluster}.
    pub name: std::string::String,

    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Required. The list of host names of db nodes to be removed from the
    /// ExadbVmCluster.
    pub hostnames: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveVirtualMachineExadbVmClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveVirtualMachineExadbVmClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RemoveVirtualMachineExadbVmClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [hostnames][crate::model::RemoveVirtualMachineExadbVmClusterRequest::hostnames].
    pub fn set_hostnames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.hostnames = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RemoveVirtualMachineExadbVmClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.RemoveVirtualMachineExadbVmClusterRequest"
    }
}

/// The PluggableDatabase resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/PluggableDatabase/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PluggableDatabase {
    /// Identifier. The name of the PluggableDatabase resource in the following
    /// format:
    /// projects/{project}/locations/{region}/pluggableDatabases/{pluggable_database}
    pub name: std::string::String,

    /// Optional. The properties of the PluggableDatabase.
    pub properties: std::option::Option<crate::model::PluggableDatabaseProperties>,

    /// Output only. HTTPS link to OCI resources exposed to Customer via UI
    /// Interface.
    pub oci_url: std::string::String,

    /// Output only. The date and time that the PluggableDatabase was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PluggableDatabase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PluggableDatabase::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::PluggableDatabase::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PluggableDatabaseProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::PluggableDatabase::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PluggableDatabaseProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [oci_url][crate::model::PluggableDatabase::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PluggableDatabase::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PluggableDatabase::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PluggableDatabase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.PluggableDatabase"
    }
}

/// The properties of a PluggableDatabase.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PluggableDatabaseProperties {
    /// Required. The OCID of the compartment.
    pub compartment_id: std::string::String,

    /// Optional. The Connection strings used to connect to the Oracle Database.
    pub connection_strings: std::option::Option<crate::model::PluggableDatabaseConnectionStrings>,

    /// Required. The OCID of the CDB.
    pub container_database_ocid: std::string::String,

    /// Optional. Defined tags for this resource. Each key is predefined and scoped
    /// to a namespace.
    pub defined_tags: std::collections::HashMap<
        std::string::String,
        crate::model::pluggable_database_properties::DefinedTagValue,
    >,

    /// Optional. Free-form tags for this resource. Each tag is a simple key-value
    /// pair with no predefined name, type, or namespace.
    pub freeform_tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The OCID of the pluggable database.
    pub ocid: std::string::String,

    /// Optional. The restricted mode of the pluggable database. If a pluggable
    /// database is opened in restricted mode, the user needs both create a session
    /// and have restricted session privileges to connect to it.
    pub is_restricted: bool,

    /// Output only. Additional information about the current lifecycle state.
    pub lifecycle_details: std::string::String,

    /// Output only. The current state of the pluggable database.
    pub lifecycle_state:
        crate::model::pluggable_database_properties::PluggableDatabaseLifecycleState,

    /// Required. The database name.
    pub pdb_name: std::string::String,

    /// Optional. Pluggable Database Node Level Details
    pub pdb_node_level_details: std::vec::Vec<crate::model::PluggableDatabaseNodeLevelDetails>,

    /// Output only. The configuration of the Database Management service.
    pub database_management_config: std::option::Option<crate::model::DatabaseManagementConfig>,

    /// Output only. The status of Operations Insights for this Database.
    pub operations_insights_state:
        crate::model::pluggable_database_properties::OperationsInsightsState,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PluggableDatabaseProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compartment_id][crate::model::PluggableDatabaseProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [connection_strings][crate::model::PluggableDatabaseProperties::connection_strings].
    pub fn set_connection_strings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PluggableDatabaseConnectionStrings>,
    {
        self.connection_strings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_strings][crate::model::PluggableDatabaseProperties::connection_strings].
    pub fn set_or_clear_connection_strings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PluggableDatabaseConnectionStrings>,
    {
        self.connection_strings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container_database_ocid][crate::model::PluggableDatabaseProperties::container_database_ocid].
    pub fn set_container_database_ocid<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_database_ocid = v.into();
        self
    }

    /// Sets the value of [defined_tags][crate::model::PluggableDatabaseProperties::defined_tags].
    pub fn set_defined_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::pluggable_database_properties::DefinedTagValue>,
    {
        use std::iter::Iterator;
        self.defined_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [freeform_tags][crate::model::PluggableDatabaseProperties::freeform_tags].
    pub fn set_freeform_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.freeform_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [ocid][crate::model::PluggableDatabaseProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [is_restricted][crate::model::PluggableDatabaseProperties::is_restricted].
    pub fn set_is_restricted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_restricted = v.into();
        self
    }

    /// Sets the value of [lifecycle_details][crate::model::PluggableDatabaseProperties::lifecycle_details].
    pub fn set_lifecycle_details<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_details = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::PluggableDatabaseProperties::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<
                crate::model::pluggable_database_properties::PluggableDatabaseLifecycleState,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [pdb_name][crate::model::PluggableDatabaseProperties::pdb_name].
    pub fn set_pdb_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pdb_name = v.into();
        self
    }

    /// Sets the value of [pdb_node_level_details][crate::model::PluggableDatabaseProperties::pdb_node_level_details].
    pub fn set_pdb_node_level_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PluggableDatabaseNodeLevelDetails>,
    {
        use std::iter::Iterator;
        self.pdb_node_level_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [database_management_config][crate::model::PluggableDatabaseProperties::database_management_config].
    pub fn set_database_management_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseManagementConfig>,
    {
        self.database_management_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_management_config][crate::model::PluggableDatabaseProperties::database_management_config].
    pub fn set_or_clear_database_management_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseManagementConfig>,
    {
        self.database_management_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operations_insights_state][crate::model::PluggableDatabaseProperties::operations_insights_state].
    pub fn set_operations_insights_state<
        T: std::convert::Into<crate::model::pluggable_database_properties::OperationsInsightsState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operations_insights_state = v.into();
        self
    }
}

impl wkt::message::Message for PluggableDatabaseProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.PluggableDatabaseProperties"
    }
}

/// Defines additional types related to [PluggableDatabaseProperties].
pub mod pluggable_database_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Wrapper message for the value of a defined tag.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DefinedTagValue {
        /// The tags within the namespace.
        pub tags: std::collections::HashMap<std::string::String, std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DefinedTagValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tags][crate::model::pluggable_database_properties::DefinedTagValue::tags].
        pub fn set_tags<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for DefinedTagValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.oracledatabase.v1.PluggableDatabaseProperties.DefinedTagValue"
        }
    }

    /// The various lifecycle states of the PluggableDatabase.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PluggableDatabaseLifecycleState {
        /// The lifecycle state is unspecified.
        Unspecified,
        /// The pluggable database is provisioning.
        Provisioning,
        /// The pluggable database is available.
        Available,
        /// The pluggable database is terminating.
        Terminating,
        /// The pluggable database is terminated.
        Terminated,
        /// The pluggable database is updating.
        Updating,
        /// The pluggable database is in a failed state.
        Failed,
        /// The pluggable database is relocating.
        Relocating,
        /// The pluggable database is relocated.
        Relocated,
        /// The pluggable database is refreshing.
        Refreshing,
        /// The pluggable database is restoring.
        RestoreInProgress,
        /// The pluggable database restore failed.
        RestoreFailed,
        /// The pluggable database is backing up.
        BackupInProgress,
        /// The pluggable database is disabled.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PluggableDatabaseLifecycleState::value] or
        /// [PluggableDatabaseLifecycleState::name].
        UnknownValue(pluggable_database_lifecycle_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod pluggable_database_lifecycle_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PluggableDatabaseLifecycleState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Terminating => std::option::Option::Some(3),
                Self::Terminated => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Relocating => std::option::Option::Some(7),
                Self::Relocated => std::option::Option::Some(8),
                Self::Refreshing => std::option::Option::Some(9),
                Self::RestoreInProgress => std::option::Option::Some(10),
                Self::RestoreFailed => std::option::Option::Some(11),
                Self::BackupInProgress => std::option::Option::Some(12),
                Self::Disabled => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PLUGGABLE_DATABASE_LIFECYCLE_STATE_UNSPECIFIED")
                }
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Relocating => std::option::Option::Some("RELOCATING"),
                Self::Relocated => std::option::Option::Some("RELOCATED"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::RestoreInProgress => std::option::Option::Some("RESTORE_IN_PROGRESS"),
                Self::RestoreFailed => std::option::Option::Some("RESTORE_FAILED"),
                Self::BackupInProgress => std::option::Option::Some("BACKUP_IN_PROGRESS"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PluggableDatabaseLifecycleState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PluggableDatabaseLifecycleState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PluggableDatabaseLifecycleState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Terminating,
                4 => Self::Terminated,
                5 => Self::Updating,
                6 => Self::Failed,
                7 => Self::Relocating,
                8 => Self::Relocated,
                9 => Self::Refreshing,
                10 => Self::RestoreInProgress,
                11 => Self::RestoreFailed,
                12 => Self::BackupInProgress,
                13 => Self::Disabled,
                _ => Self::UnknownValue(pluggable_database_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PluggableDatabaseLifecycleState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLUGGABLE_DATABASE_LIFECYCLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "UPDATING" => Self::Updating,
                "FAILED" => Self::Failed,
                "RELOCATING" => Self::Relocating,
                "RELOCATED" => Self::Relocated,
                "REFRESHING" => Self::Refreshing,
                "RESTORE_IN_PROGRESS" => Self::RestoreInProgress,
                "RESTORE_FAILED" => Self::RestoreFailed,
                "BACKUP_IN_PROGRESS" => Self::BackupInProgress,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(pluggable_database_lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PluggableDatabaseLifecycleState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Terminating => serializer.serialize_i32(3),
                Self::Terminated => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Relocating => serializer.serialize_i32(7),
                Self::Relocated => serializer.serialize_i32(8),
                Self::Refreshing => serializer.serialize_i32(9),
                Self::RestoreInProgress => serializer.serialize_i32(10),
                Self::RestoreFailed => serializer.serialize_i32(11),
                Self::BackupInProgress => serializer.serialize_i32(12),
                Self::Disabled => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PluggableDatabaseLifecycleState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PluggableDatabaseLifecycleState>::new(
                ".google.cloud.oracledatabase.v1.PluggableDatabaseProperties.PluggableDatabaseLifecycleState"))
        }
    }

    /// The status of Operations Insights for this Database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OperationsInsightsState {
        /// The status is not specified.
        Unspecified,
        /// Operations Insights is enabling.
        Enabling,
        /// Operations Insights is enabled.
        Enabled,
        /// Operations Insights is disabling.
        Disabling,
        /// Operations Insights is not enabled.
        NotEnabled,
        /// Operations Insights failed to enable.
        FailedEnabling,
        /// Operations Insights failed to disable.
        FailedDisabling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OperationsInsightsState::value] or
        /// [OperationsInsightsState::name].
        UnknownValue(operations_insights_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operations_insights_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OperationsInsightsState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabling => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::Disabling => std::option::Option::Some(3),
                Self::NotEnabled => std::option::Option::Some(4),
                Self::FailedEnabling => std::option::Option::Some(5),
                Self::FailedDisabling => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("OPERATIONS_INSIGHTS_STATE_UNSPECIFIED")
                }
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
                Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
                Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OperationsInsightsState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OperationsInsightsState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OperationsInsightsState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabling,
                2 => Self::Enabled,
                3 => Self::Disabling,
                4 => Self::NotEnabled,
                5 => Self::FailedEnabling,
                6 => Self::FailedDisabling,
                _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OperationsInsightsState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLING" => Self::Enabling,
                "ENABLED" => Self::Enabled,
                "DISABLING" => Self::Disabling,
                "NOT_ENABLED" => Self::NotEnabled,
                "FAILED_ENABLING" => Self::FailedEnabling,
                "FAILED_DISABLING" => Self::FailedDisabling,
                _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OperationsInsightsState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabling => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::Disabling => serializer.serialize_i32(3),
                Self::NotEnabled => serializer.serialize_i32(4),
                Self::FailedEnabling => serializer.serialize_i32(5),
                Self::FailedDisabling => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OperationsInsightsState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationsInsightsState>::new(
                ".google.cloud.oracledatabase.v1.PluggableDatabaseProperties.OperationsInsightsState"))
        }
    }
}

/// The connection strings used to connect to the Oracle Database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PluggableDatabaseConnectionStrings {
    /// Optional. All connection strings to use to connect to the pluggable
    /// database.
    pub all_connection_strings: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The default connection string to use to connect to the pluggable
    /// database.
    pub pdb_default: std::string::String,

    /// Optional. The default connection string to use to connect to the pluggable
    /// database using IP.
    pub pdb_ip_default: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PluggableDatabaseConnectionStrings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_connection_strings][crate::model::PluggableDatabaseConnectionStrings::all_connection_strings].
    pub fn set_all_connection_strings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.all_connection_strings = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [pdb_default][crate::model::PluggableDatabaseConnectionStrings::pdb_default].
    pub fn set_pdb_default<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pdb_default = v.into();
        self
    }

    /// Sets the value of [pdb_ip_default][crate::model::PluggableDatabaseConnectionStrings::pdb_ip_default].
    pub fn set_pdb_ip_default<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pdb_ip_default = v.into();
        self
    }
}

impl wkt::message::Message for PluggableDatabaseConnectionStrings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.PluggableDatabaseConnectionStrings"
    }
}

/// The Pluggable Database Node Level Details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PluggableDatabaseNodeLevelDetails {
    /// Required. The Node name of the Database home.
    pub node_name: std::string::String,

    /// Required. The mode that the pluggable database is in to open it.
    pub open_mode: crate::model::pluggable_database_node_level_details::PluggableDatabaseOpenMode,

    /// Required. The OCID of the Pluggable Database.
    pub pluggable_database_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PluggableDatabaseNodeLevelDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_name][crate::model::PluggableDatabaseNodeLevelDetails::node_name].
    pub fn set_node_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_name = v.into();
        self
    }

    /// Sets the value of [open_mode][crate::model::PluggableDatabaseNodeLevelDetails::open_mode].
    pub fn set_open_mode<
        T: std::convert::Into<
                crate::model::pluggable_database_node_level_details::PluggableDatabaseOpenMode,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_mode = v.into();
        self
    }

    /// Sets the value of [pluggable_database_id][crate::model::PluggableDatabaseNodeLevelDetails::pluggable_database_id].
    pub fn set_pluggable_database_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pluggable_database_id = v.into();
        self
    }
}

impl wkt::message::Message for PluggableDatabaseNodeLevelDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.PluggableDatabaseNodeLevelDetails"
    }
}

/// Defines additional types related to [PluggableDatabaseNodeLevelDetails].
pub mod pluggable_database_node_level_details {
    #[allow(unused_imports)]
    use super::*;

    /// The mode that the pluggable database is in to open it.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PluggableDatabaseOpenMode {
        /// The open mode is unspecified.
        Unspecified,
        /// The pluggable database is opened in read-only mode.
        ReadOnly,
        /// The pluggable database is opened in read-write mode.
        ReadWrite,
        /// The pluggable database is mounted.
        Mounted,
        /// The pluggable database is migrated.
        Migrate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PluggableDatabaseOpenMode::value] or
        /// [PluggableDatabaseOpenMode::name].
        UnknownValue(pluggable_database_open_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod pluggable_database_open_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PluggableDatabaseOpenMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReadOnly => std::option::Option::Some(1),
                Self::ReadWrite => std::option::Option::Some(2),
                Self::Mounted => std::option::Option::Some(3),
                Self::Migrate => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PLUGGABLE_DATABASE_OPEN_MODE_UNSPECIFIED")
                }
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::Mounted => std::option::Option::Some("MOUNTED"),
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PluggableDatabaseOpenMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PluggableDatabaseOpenMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PluggableDatabaseOpenMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReadOnly,
                2 => Self::ReadWrite,
                3 => Self::Mounted,
                4 => Self::Migrate,
                _ => Self::UnknownValue(pluggable_database_open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PluggableDatabaseOpenMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLUGGABLE_DATABASE_OPEN_MODE_UNSPECIFIED" => Self::Unspecified,
                "READ_ONLY" => Self::ReadOnly,
                "READ_WRITE" => Self::ReadWrite,
                "MOUNTED" => Self::Mounted,
                "MIGRATE" => Self::Migrate,
                _ => Self::UnknownValue(pluggable_database_open_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PluggableDatabaseOpenMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReadOnly => serializer.serialize_i32(1),
                Self::ReadWrite => serializer.serialize_i32(2),
                Self::Mounted => serializer.serialize_i32(3),
                Self::Migrate => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PluggableDatabaseOpenMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PluggableDatabaseOpenMode>::new(
                ".google.cloud.oracledatabase.v1.PluggableDatabaseNodeLevelDetails.PluggableDatabaseOpenMode"))
        }
    }
}

/// The configuration of the Database Management service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseManagementConfig {
    /// Output only. The status of the Database Management service.
    pub management_state: crate::model::database_management_config::ManagementState,

    /// Output only. The Database Management type.
    pub management_type: crate::model::database_management_config::ManagementType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [management_state][crate::model::DatabaseManagementConfig::management_state].
    pub fn set_management_state<
        T: std::convert::Into<crate::model::database_management_config::ManagementState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management_state = v.into();
        self
    }

    /// Sets the value of [management_type][crate::model::DatabaseManagementConfig::management_type].
    pub fn set_management_type<
        T: std::convert::Into<crate::model::database_management_config::ManagementType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management_type = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DatabaseManagementConfig"
    }
}

/// Defines additional types related to [DatabaseManagementConfig].
pub mod database_management_config {
    #[allow(unused_imports)]
    use super::*;

    /// The status of the Database Management service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ManagementState {
        /// The status is not specified.
        Unspecified,
        /// The Database Management service is enabling.
        Enabling,
        /// The Database Management service is enabled.
        Enabled,
        /// The Database Management service is disabling.
        Disabling,
        /// The Database Management service is disabled.
        Disabled,
        /// The Database Management service is updating.
        Updating,
        /// The Database Management service failed to enable.
        FailedEnabling,
        /// The Database Management service failed to disable.
        FailedDisabling,
        /// The Database Management service failed to update.
        FailedUpdating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ManagementState::value] or
        /// [ManagementState::name].
        UnknownValue(management_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod management_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ManagementState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabling => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::Disabling => std::option::Option::Some(3),
                Self::Disabled => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::FailedEnabling => std::option::Option::Some(6),
                Self::FailedDisabling => std::option::Option::Some(7),
                Self::FailedUpdating => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MANAGEMENT_STATE_UNSPECIFIED"),
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
                Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
                Self::FailedUpdating => std::option::Option::Some("FAILED_UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ManagementState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ManagementState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ManagementState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabling,
                2 => Self::Enabled,
                3 => Self::Disabling,
                4 => Self::Disabled,
                5 => Self::Updating,
                6 => Self::FailedEnabling,
                7 => Self::FailedDisabling,
                8 => Self::FailedUpdating,
                _ => Self::UnknownValue(management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ManagementState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MANAGEMENT_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLING" => Self::Enabling,
                "ENABLED" => Self::Enabled,
                "DISABLING" => Self::Disabling,
                "DISABLED" => Self::Disabled,
                "UPDATING" => Self::Updating,
                "FAILED_ENABLING" => Self::FailedEnabling,
                "FAILED_DISABLING" => Self::FailedDisabling,
                "FAILED_UPDATING" => Self::FailedUpdating,
                _ => Self::UnknownValue(management_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ManagementState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabling => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::Disabling => serializer.serialize_i32(3),
                Self::Disabled => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::FailedEnabling => serializer.serialize_i32(6),
                Self::FailedDisabling => serializer.serialize_i32(7),
                Self::FailedUpdating => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ManagementState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManagementState>::new(
                ".google.cloud.oracledatabase.v1.DatabaseManagementConfig.ManagementState",
            ))
        }
    }

    /// The Database Management type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ManagementType {
        /// The type is not specified.
        Unspecified,
        /// Basic Database Management.
        Basic,
        /// Advanced Database Management.
        Advanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ManagementType::value] or
        /// [ManagementType::name].
        UnknownValue(management_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod management_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ManagementType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Advanced => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MANAGEMENT_TYPE_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Advanced => std::option::Option::Some("ADVANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ManagementType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ManagementType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ManagementType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::Advanced,
                _ => Self::UnknownValue(management_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ManagementType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MANAGEMENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "ADVANCED" => Self::Advanced,
                _ => Self::UnknownValue(management_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ManagementType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Advanced => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ManagementType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManagementType>::new(
                ".google.cloud.oracledatabase.v1.DatabaseManagementConfig.ManagementType",
            ))
        }
    }
}

/// The request for `PluggableDatabase.Get`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPluggableDatabaseRequest {
    /// Required. The name of the PluggableDatabase resource in the following
    /// format:
    /// projects/{project}/locations/{region}/pluggableDatabases/{pluggable_database}
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPluggableDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPluggableDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPluggableDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.GetPluggableDatabaseRequest"
    }
}

/// The request for `PluggableDatabase.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPluggableDatabasesRequest {
    /// Required. The parent, which owns this collection of PluggableDatabases.
    /// Format: projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Optional. The maximum number of PluggableDatabases to return. The service
    /// may return fewer than this value.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListPluggableDatabases`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListPluggableDatabases`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. List for
    /// pluggable databases is supported only with a valid container database (full
    /// resource name) filter in this format:
    /// `database="projects/{project}/locations/{location}/databases/{database}"`
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPluggableDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPluggableDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPluggableDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPluggableDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPluggableDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPluggableDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListPluggableDatabasesRequest"
    }
}

/// The response for `PluggableDatabase.List`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPluggableDatabasesResponse {
    /// The list of PluggableDatabases.
    pub pluggable_databases: std::vec::Vec<crate::model::PluggableDatabase>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPluggableDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pluggable_databases][crate::model::ListPluggableDatabasesResponse::pluggable_databases].
    pub fn set_pluggable_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PluggableDatabase>,
    {
        use std::iter::Iterator;
        self.pluggable_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPluggableDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPluggableDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.ListPluggableDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPluggableDatabasesResponse {
    type PageItem = crate::model::PluggableDatabase;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.pluggable_databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Details of the Cloud VM Cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudVmCluster/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudVmCluster {
    /// Identifier. The name of the VM Cluster resource with the format:
    /// projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}
    pub name: std::string::String,

    /// Required. The name of the Exadata Infrastructure resource on which VM
    /// cluster resource is created, in the following format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}
    pub exadata_infrastructure: std::string::String,

    /// Optional. User friendly name for this resource.
    pub display_name: std::string::String,

    /// Optional. Various properties of the VM Cluster.
    pub properties: std::option::Option<crate::model::CloudVmClusterProperties>,

    /// Optional. Labels or tags associated with the VM Cluster.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The date and time that the VM cluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Network settings. CIDR to use for cluster IP allocation.
    pub cidr: std::string::String,

    /// Optional. CIDR range of the backup subnet.
    pub backup_subnet_cidr: std::string::String,

    /// Optional. The name of the VPC network.
    /// Format: projects/{project}/global/networks/{network}
    pub network: std::string::String,

    /// Output only. The GCP Oracle zone where Oracle CloudVmCluster is hosted.
    /// This will be the same as the gcp_oracle_zone of the
    /// CloudExadataInfrastructure. Example: us-east4-b-r2.
    pub gcp_oracle_zone: std::string::String,

    /// Optional. The name of the OdbNetwork associated with the VM Cluster.
    /// Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}
    /// It is optional but if specified, this should match the parent ODBNetwork of
    /// the odb_subnet and backup_odb_subnet.
    pub odb_network: std::string::String,

    /// Optional. The name of the OdbSubnet associated with the VM Cluster for
    /// IP allocation. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    pub odb_subnet: std::string::String,

    /// Optional. The name of the backup OdbSubnet associated with the VM Cluster.
    /// Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    pub backup_odb_subnet: std::string::String,

    /// Output only. The identity connector details which will allow OCI to
    /// securely access the resources in the customer project.
    pub identity_connector: std::option::Option<crate::model::IdentityConnector>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudVmCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudVmCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [exadata_infrastructure][crate::model::CloudVmCluster::exadata_infrastructure].
    pub fn set_exadata_infrastructure<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exadata_infrastructure = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudVmCluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::CloudVmCluster::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmClusterProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::CloudVmCluster::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudVmClusterProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CloudVmCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudVmCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudVmCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cidr][crate::model::CloudVmCluster::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [backup_subnet_cidr][crate::model::CloudVmCluster::backup_subnet_cidr].
    pub fn set_backup_subnet_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_subnet_cidr = v.into();
        self
    }

    /// Sets the value of [network][crate::model::CloudVmCluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [gcp_oracle_zone][crate::model::CloudVmCluster::gcp_oracle_zone].
    pub fn set_gcp_oracle_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_oracle_zone = v.into();
        self
    }

    /// Sets the value of [odb_network][crate::model::CloudVmCluster::odb_network].
    pub fn set_odb_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_network = v.into();
        self
    }

    /// Sets the value of [odb_subnet][crate::model::CloudVmCluster::odb_subnet].
    pub fn set_odb_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.odb_subnet = v.into();
        self
    }

    /// Sets the value of [backup_odb_subnet][crate::model::CloudVmCluster::backup_odb_subnet].
    pub fn set_backup_odb_subnet<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_odb_subnet = v.into();
        self
    }

    /// Sets the value of [identity_connector][crate::model::CloudVmCluster::identity_connector].
    pub fn set_identity_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IdentityConnector>,
    {
        self.identity_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity_connector][crate::model::CloudVmCluster::identity_connector].
    pub fn set_or_clear_identity_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IdentityConnector>,
    {
        self.identity_connector = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudVmCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmCluster"
    }
}

/// Various properties and settings associated with Exadata VM cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudVmClusterProperties {
    /// Output only. Oracle Cloud Infrastructure ID of VM Cluster.
    pub ocid: std::string::String,

    /// Required. License type of VM Cluster.
    pub license_type: crate::model::cloud_vm_cluster_properties::LicenseType,

    /// Optional. Grid Infrastructure Version.
    pub gi_version: std::string::String,

    /// Optional. Time zone of VM Cluster to set. Defaults to UTC if not specified.
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Optional. SSH public keys to be stored with cluster.
    pub ssh_public_keys: std::vec::Vec<std::string::String>,

    /// Optional. Number of database servers.
    pub node_count: i32,

    /// Output only. Shape of VM Cluster.
    pub shape: std::string::String,

    /// Optional. OCPU count per VM. Minimum is 0.1.
    pub ocpu_count: f32,

    /// Optional. Memory allocated in GBs.
    pub memory_size_gb: i32,

    /// Optional. Local storage per VM.
    pub db_node_storage_size_gb: i32,

    /// Output only. The storage allocation for the disk group, in gigabytes (GB).
    pub storage_size_gb: i32,

    /// Optional. The data disk group size to be allocated in TBs.
    pub data_storage_size_tb: f64,

    /// Optional. The type of redundancy.
    pub disk_redundancy: crate::model::cloud_vm_cluster_properties::DiskRedundancy,

    /// Optional. Use exadata sparse snapshots.
    pub sparse_diskgroup_enabled: bool,

    /// Optional. Use local backup.
    pub local_backup_enabled: bool,

    /// Optional. Prefix for VM cluster host names.
    pub hostname_prefix: std::string::String,

    /// Optional. Data collection options for diagnostics.
    pub diagnostics_data_collection_options:
        std::option::Option<crate::model::DataCollectionOptions>,

    /// Output only. State of the cluster.
    pub state: crate::model::cloud_vm_cluster_properties::State,

    /// Output only. SCAN listener port - TCP
    pub scan_listener_port_tcp: i32,

    /// Output only. SCAN listener port - TLS
    pub scan_listener_port_tcp_ssl: i32,

    /// Output only. Parent DNS domain where SCAN DNS and hosts names are
    /// qualified. ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
    pub domain: std::string::String,

    /// Output only. SCAN DNS name.
    /// ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
    pub scan_dns: std::string::String,

    /// Output only. host name without domain.
    /// format: "<hostname_prefix>-" with some suffix.
    /// ex: sp2-yi0xq where "sp2" is the hostname_prefix.
    pub hostname: std::string::String,

    /// Required. Number of enabled CPU cores.
    pub cpu_core_count: i32,

    /// Optional. Operating system version of the image.
    pub system_version: std::string::String,

    /// Output only. OCIDs of scan IPs.
    pub scan_ip_ids: std::vec::Vec<std::string::String>,

    /// Output only. OCID of scan DNS record.
    pub scan_dns_record_id: std::string::String,

    /// Output only. Deep link to the OCI console to view this resource.
    pub oci_url: std::string::String,

    /// Optional. OCID of database servers.
    pub db_server_ocids: std::vec::Vec<std::string::String>,

    /// Output only. Compartment ID of cluster.
    pub compartment_id: std::string::String,

    /// Output only. DNS listener IP.
    pub dns_listener_ip: std::string::String,

    /// Optional. OCI Cluster name.
    pub cluster_name: std::string::String,

    /// Output only. The compute model of the VM Cluster.
    pub compute_model: crate::model::ComputeModel,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudVmClusterProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocid][crate::model::CloudVmClusterProperties::ocid].
    pub fn set_ocid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ocid = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::CloudVmClusterProperties::license_type].
    pub fn set_license_type<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::LicenseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [gi_version][crate::model::CloudVmClusterProperties::gi_version].
    pub fn set_gi_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gi_version = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::CloudVmClusterProperties::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::CloudVmClusterProperties::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssh_public_keys][crate::model::CloudVmClusterProperties::ssh_public_keys].
    pub fn set_ssh_public_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_public_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_count][crate::model::CloudVmClusterProperties::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::CloudVmClusterProperties::shape].
    pub fn set_shape<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.shape = v.into();
        self
    }

    /// Sets the value of [ocpu_count][crate::model::CloudVmClusterProperties::ocpu_count].
    pub fn set_ocpu_count<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.ocpu_count = v.into();
        self
    }

    /// Sets the value of [memory_size_gb][crate::model::CloudVmClusterProperties::memory_size_gb].
    pub fn set_memory_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_size_gb = v.into();
        self
    }

    /// Sets the value of [db_node_storage_size_gb][crate::model::CloudVmClusterProperties::db_node_storage_size_gb].
    pub fn set_db_node_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.db_node_storage_size_gb = v.into();
        self
    }

    /// Sets the value of [storage_size_gb][crate::model::CloudVmClusterProperties::storage_size_gb].
    pub fn set_storage_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.storage_size_gb = v.into();
        self
    }

    /// Sets the value of [data_storage_size_tb][crate::model::CloudVmClusterProperties::data_storage_size_tb].
    pub fn set_data_storage_size_tb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.data_storage_size_tb = v.into();
        self
    }

    /// Sets the value of [disk_redundancy][crate::model::CloudVmClusterProperties::disk_redundancy].
    pub fn set_disk_redundancy<
        T: std::convert::Into<crate::model::cloud_vm_cluster_properties::DiskRedundancy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_redundancy = v.into();
        self
    }

    /// Sets the value of [sparse_diskgroup_enabled][crate::model::CloudVmClusterProperties::sparse_diskgroup_enabled].
    pub fn set_sparse_diskgroup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.sparse_diskgroup_enabled = v.into();
        self
    }

    /// Sets the value of [local_backup_enabled][crate::model::CloudVmClusterProperties::local_backup_enabled].
    pub fn set_local_backup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.local_backup_enabled = v.into();
        self
    }

    /// Sets the value of [hostname_prefix][crate::model::CloudVmClusterProperties::hostname_prefix].
    pub fn set_hostname_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname_prefix = v.into();
        self
    }

    /// Sets the value of [diagnostics_data_collection_options][crate::model::CloudVmClusterProperties::diagnostics_data_collection_options].
    pub fn set_diagnostics_data_collection_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptions>,
    {
        self.diagnostics_data_collection_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diagnostics_data_collection_options][crate::model::CloudVmClusterProperties::diagnostics_data_collection_options].
    pub fn set_or_clear_diagnostics_data_collection_options<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DataCollectionOptions>,
    {
        self.diagnostics_data_collection_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CloudVmClusterProperties::state].
    pub fn set_state<T: std::convert::Into<crate::model::cloud_vm_cluster_properties::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp][crate::model::CloudVmClusterProperties::scan_listener_port_tcp].
    pub fn set_scan_listener_port_tcp<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp = v.into();
        self
    }

    /// Sets the value of [scan_listener_port_tcp_ssl][crate::model::CloudVmClusterProperties::scan_listener_port_tcp_ssl].
    pub fn set_scan_listener_port_tcp_ssl<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scan_listener_port_tcp_ssl = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::CloudVmClusterProperties::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [scan_dns][crate::model::CloudVmClusterProperties::scan_dns].
    pub fn set_scan_dns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scan_dns = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::CloudVmClusterProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [cpu_core_count][crate::model::CloudVmClusterProperties::cpu_core_count].
    pub fn set_cpu_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_core_count = v.into();
        self
    }

    /// Sets the value of [system_version][crate::model::CloudVmClusterProperties::system_version].
    pub fn set_system_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system_version = v.into();
        self
    }

    /// Sets the value of [scan_ip_ids][crate::model::CloudVmClusterProperties::scan_ip_ids].
    pub fn set_scan_ip_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scan_ip_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scan_dns_record_id][crate::model::CloudVmClusterProperties::scan_dns_record_id].
    pub fn set_scan_dns_record_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_dns_record_id = v.into();
        self
    }

    /// Sets the value of [oci_url][crate::model::CloudVmClusterProperties::oci_url].
    pub fn set_oci_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oci_url = v.into();
        self
    }

    /// Sets the value of [db_server_ocids][crate::model::CloudVmClusterProperties::db_server_ocids].
    pub fn set_db_server_ocids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.db_server_ocids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [compartment_id][crate::model::CloudVmClusterProperties::compartment_id].
    pub fn set_compartment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compartment_id = v.into();
        self
    }

    /// Sets the value of [dns_listener_ip][crate::model::CloudVmClusterProperties::dns_listener_ip].
    pub fn set_dns_listener_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_listener_ip = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::CloudVmClusterProperties::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [compute_model][crate::model::CloudVmClusterProperties::compute_model].
    pub fn set_compute_model<T: std::convert::Into<crate::model::ComputeModel>>(
        mut self,
        v: T,
    ) -> Self {
        self.compute_model = v.into();
        self
    }
}

impl wkt::message::Message for CloudVmClusterProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.CloudVmClusterProperties"
    }
}

/// Defines additional types related to [CloudVmClusterProperties].
pub mod cloud_vm_cluster_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Different licenses supported.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LicenseType {
        /// Unspecified
        Unspecified,
        /// License included part of offer
        LicenseIncluded,
        /// Bring your own license
        BringYourOwnLicense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LicenseType::value] or
        /// [LicenseType::name].
        UnknownValue(license_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod license_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LicenseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LicenseIncluded => std::option::Option::Some(1),
                Self::BringYourOwnLicense => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LICENSE_TYPE_UNSPECIFIED"),
                Self::LicenseIncluded => std::option::Option::Some("LICENSE_INCLUDED"),
                Self::BringYourOwnLicense => std::option::Option::Some("BRING_YOUR_OWN_LICENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LicenseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LicenseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LicenseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LicenseIncluded,
                2 => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LicenseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LICENSE_INCLUDED" => Self::LicenseIncluded,
                "BRING_YOUR_OWN_LICENSE" => Self::BringYourOwnLicense,
                _ => Self::UnknownValue(license_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LicenseIncluded => serializer.serialize_i32(1),
                Self::BringYourOwnLicense => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LicenseType>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.LicenseType",
            ))
        }
    }

    /// Types of disk redundancy provided by Oracle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskRedundancy {
        /// Unspecified.
        Unspecified,
        /// High -  3 way mirror.
        High,
        /// Normal - 2 way mirror.
        Normal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskRedundancy::value] or
        /// [DiskRedundancy::name].
        UnknownValue(disk_redundancy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_redundancy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskRedundancy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Normal => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_REDUNDANCY_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskRedundancy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskRedundancy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskRedundancy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Normal,
                _ => Self::UnknownValue(disk_redundancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskRedundancy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_REDUNDANCY_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "NORMAL" => Self::Normal,
                _ => Self::UnknownValue(disk_redundancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskRedundancy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Normal => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskRedundancy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskRedundancy>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.DiskRedundancy",
            ))
        }
    }

    /// The various lifecycle states of the VM cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default unspecified value.
        Unspecified,
        /// Indicates that the resource is in provisioning state.
        Provisioning,
        /// Indicates that the resource is in available state.
        Available,
        /// Indicates that the resource is in updating state.
        Updating,
        /// Indicates that the resource is in terminating state.
        Terminating,
        /// Indicates that the resource is in terminated state.
        Terminated,
        /// Indicates that the resource is in failed state.
        Failed,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::MaintenanceInProgress => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Available,
                3 => Self::Updating,
                4 => Self::Terminating,
                5 => Self::Terminated,
                6 => Self::Failed,
                7 => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "AVAILABLE" => Self::Available,
                "UPDATING" => Self::Updating,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::MaintenanceInProgress => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.oracledatabase.v1.CloudVmClusterProperties.State",
            ))
        }
    }
}

/// Data collection options for diagnostics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataCollectionOptions {
    /// Optional. Indicates whether diagnostic collection is enabled for the VM
    /// cluster
    pub diagnostics_events_enabled: bool,

    /// Optional. Indicates whether health monitoring is enabled for the VM cluster
    pub health_monitoring_enabled: bool,

    /// Optional. Indicates whether incident logs and trace collection are enabled
    /// for the VM cluster
    pub incident_logs_enabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataCollectionOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [diagnostics_events_enabled][crate::model::DataCollectionOptions::diagnostics_events_enabled].
    pub fn set_diagnostics_events_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.diagnostics_events_enabled = v.into();
        self
    }

    /// Sets the value of [health_monitoring_enabled][crate::model::DataCollectionOptions::health_monitoring_enabled].
    pub fn set_health_monitoring_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.health_monitoring_enabled = v.into();
        self
    }

    /// Sets the value of [incident_logs_enabled][crate::model::DataCollectionOptions::incident_logs_enabled].
    pub fn set_incident_logs_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.incident_logs_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCollectionOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.oracledatabase.v1.DataCollectionOptions"
    }
}

/// The type of wallet generation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum GenerateType {
    /// Default unspecified value.
    Unspecified,
    /// Used to generate wallet for all databases in the region.
    All,
    /// Used to generate wallet for a single database.
    Single,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [GenerateType::value] or
    /// [GenerateType::name].
    UnknownValue(generate_type::UnknownValue),
}

#[doc(hidden)]
pub mod generate_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl GenerateType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::All => std::option::Option::Some(1),
            Self::Single => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("GENERATE_TYPE_UNSPECIFIED"),
            Self::All => std::option::Option::Some("ALL"),
            Self::Single => std::option::Option::Some("SINGLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for GenerateType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for GenerateType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for GenerateType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::All,
            2 => Self::Single,
            _ => Self::UnknownValue(generate_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for GenerateType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "GENERATE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ALL" => Self::All,
            "SINGLE" => Self::Single,
            _ => Self::UnknownValue(generate_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for GenerateType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::All => serializer.serialize_i32(1),
            Self::Single => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for GenerateType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<GenerateType>::new(
            ".google.cloud.oracledatabase.v1.GenerateType",
        ))
    }
}

/// The various lifecycle states of the Autonomous Database.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum State {
    /// Default unspecified value.
    Unspecified,
    /// Indicates that the Autonomous Database is in provisioning state.
    Provisioning,
    /// Indicates that the Autonomous Database is in available state.
    Available,
    /// Indicates that the Autonomous Database is in stopping state.
    Stopping,
    /// Indicates that the Autonomous Database is in stopped state.
    Stopped,
    /// Indicates that the Autonomous Database is in starting state.
    Starting,
    /// Indicates that the Autonomous Database is in terminating state.
    Terminating,
    /// Indicates that the Autonomous Database is in terminated state.
    Terminated,
    /// Indicates that the Autonomous Database is in unavailable state.
    Unavailable,
    /// Indicates that the Autonomous Database restore is in progress.
    RestoreInProgress,
    /// Indicates that the Autonomous Database failed to restore.
    RestoreFailed,
    /// Indicates that the Autonomous Database backup is in progress.
    BackupInProgress,
    /// Indicates that the Autonomous Database scale is in progress.
    ScaleInProgress,
    /// Indicates that the Autonomous Database is available but needs attention
    /// state.
    AvailableNeedsAttention,
    /// Indicates that the Autonomous Database is in updating state.
    Updating,
    /// Indicates that the Autonomous Database's maintenance is in progress state.
    MaintenanceInProgress,
    /// Indicates that the Autonomous Database is in restarting state.
    Restarting,
    /// Indicates that the Autonomous Database is in recreating state.
    Recreating,
    /// Indicates that the Autonomous Database's role change is in progress state.
    RoleChangeInProgress,
    /// Indicates that the Autonomous Database is in upgrading state.
    Upgrading,
    /// Indicates that the Autonomous Database is in inaccessible state.
    Inaccessible,
    /// Indicates that the Autonomous Database is in standby state.
    Standby,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [State::value] or
    /// [State::name].
    UnknownValue(state::UnknownValue),
}

#[doc(hidden)]
pub mod state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl State {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Provisioning => std::option::Option::Some(1),
            Self::Available => std::option::Option::Some(2),
            Self::Stopping => std::option::Option::Some(3),
            Self::Stopped => std::option::Option::Some(4),
            Self::Starting => std::option::Option::Some(5),
            Self::Terminating => std::option::Option::Some(6),
            Self::Terminated => std::option::Option::Some(7),
            Self::Unavailable => std::option::Option::Some(8),
            Self::RestoreInProgress => std::option::Option::Some(9),
            Self::RestoreFailed => std::option::Option::Some(10),
            Self::BackupInProgress => std::option::Option::Some(11),
            Self::ScaleInProgress => std::option::Option::Some(12),
            Self::AvailableNeedsAttention => std::option::Option::Some(13),
            Self::Updating => std::option::Option::Some(14),
            Self::MaintenanceInProgress => std::option::Option::Some(15),
            Self::Restarting => std::option::Option::Some(16),
            Self::Recreating => std::option::Option::Some(17),
            Self::RoleChangeInProgress => std::option::Option::Some(18),
            Self::Upgrading => std::option::Option::Some(19),
            Self::Inaccessible => std::option::Option::Some(20),
            Self::Standby => std::option::Option::Some(21),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
            Self::Provisioning => std::option::Option::Some("PROVISIONING"),
            Self::Available => std::option::Option::Some("AVAILABLE"),
            Self::Stopping => std::option::Option::Some("STOPPING"),
            Self::Stopped => std::option::Option::Some("STOPPED"),
            Self::Starting => std::option::Option::Some("STARTING"),
            Self::Terminating => std::option::Option::Some("TERMINATING"),
            Self::Terminated => std::option::Option::Some("TERMINATED"),
            Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
            Self::RestoreInProgress => std::option::Option::Some("RESTORE_IN_PROGRESS"),
            Self::RestoreFailed => std::option::Option::Some("RESTORE_FAILED"),
            Self::BackupInProgress => std::option::Option::Some("BACKUP_IN_PROGRESS"),
            Self::ScaleInProgress => std::option::Option::Some("SCALE_IN_PROGRESS"),
            Self::AvailableNeedsAttention => std::option::Option::Some("AVAILABLE_NEEDS_ATTENTION"),
            Self::Updating => std::option::Option::Some("UPDATING"),
            Self::MaintenanceInProgress => std::option::Option::Some("MAINTENANCE_IN_PROGRESS"),
            Self::Restarting => std::option::Option::Some("RESTARTING"),
            Self::Recreating => std::option::Option::Some("RECREATING"),
            Self::RoleChangeInProgress => std::option::Option::Some("ROLE_CHANGE_IN_PROGRESS"),
            Self::Upgrading => std::option::Option::Some("UPGRADING"),
            Self::Inaccessible => std::option::Option::Some("INACCESSIBLE"),
            Self::Standby => std::option::Option::Some("STANDBY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Provisioning,
            2 => Self::Available,
            3 => Self::Stopping,
            4 => Self::Stopped,
            5 => Self::Starting,
            6 => Self::Terminating,
            7 => Self::Terminated,
            8 => Self::Unavailable,
            9 => Self::RestoreInProgress,
            10 => Self::RestoreFailed,
            11 => Self::BackupInProgress,
            12 => Self::ScaleInProgress,
            13 => Self::AvailableNeedsAttention,
            14 => Self::Updating,
            15 => Self::MaintenanceInProgress,
            16 => Self::Restarting,
            17 => Self::Recreating,
            18 => Self::RoleChangeInProgress,
            19 => Self::Upgrading,
            20 => Self::Inaccessible,
            21 => Self::Standby,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for State {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_UNSPECIFIED" => Self::Unspecified,
            "PROVISIONING" => Self::Provisioning,
            "AVAILABLE" => Self::Available,
            "STOPPING" => Self::Stopping,
            "STOPPED" => Self::Stopped,
            "STARTING" => Self::Starting,
            "TERMINATING" => Self::Terminating,
            "TERMINATED" => Self::Terminated,
            "UNAVAILABLE" => Self::Unavailable,
            "RESTORE_IN_PROGRESS" => Self::RestoreInProgress,
            "RESTORE_FAILED" => Self::RestoreFailed,
            "BACKUP_IN_PROGRESS" => Self::BackupInProgress,
            "SCALE_IN_PROGRESS" => Self::ScaleInProgress,
            "AVAILABLE_NEEDS_ATTENTION" => Self::AvailableNeedsAttention,
            "UPDATING" => Self::Updating,
            "MAINTENANCE_IN_PROGRESS" => Self::MaintenanceInProgress,
            "RESTARTING" => Self::Restarting,
            "RECREATING" => Self::Recreating,
            "ROLE_CHANGE_IN_PROGRESS" => Self::RoleChangeInProgress,
            "UPGRADING" => Self::Upgrading,
            "INACCESSIBLE" => Self::Inaccessible,
            "STANDBY" => Self::Standby,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Provisioning => serializer.serialize_i32(1),
            Self::Available => serializer.serialize_i32(2),
            Self::Stopping => serializer.serialize_i32(3),
            Self::Stopped => serializer.serialize_i32(4),
            Self::Starting => serializer.serialize_i32(5),
            Self::Terminating => serializer.serialize_i32(6),
            Self::Terminated => serializer.serialize_i32(7),
            Self::Unavailable => serializer.serialize_i32(8),
            Self::RestoreInProgress => serializer.serialize_i32(9),
            Self::RestoreFailed => serializer.serialize_i32(10),
            Self::BackupInProgress => serializer.serialize_i32(11),
            Self::ScaleInProgress => serializer.serialize_i32(12),
            Self::AvailableNeedsAttention => serializer.serialize_i32(13),
            Self::Updating => serializer.serialize_i32(14),
            Self::MaintenanceInProgress => serializer.serialize_i32(15),
            Self::Restarting => serializer.serialize_i32(16),
            Self::Recreating => serializer.serialize_i32(17),
            Self::RoleChangeInProgress => serializer.serialize_i32(18),
            Self::Upgrading => serializer.serialize_i32(19),
            Self::Inaccessible => serializer.serialize_i32(20),
            Self::Standby => serializer.serialize_i32(21),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
            ".google.cloud.oracledatabase.v1.State",
        ))
    }
}

/// The state of the Operations Insights for this Autonomous Database.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationsInsightsState {
    /// Default unspecified value.
    Unspecified,
    /// Enabling status for operation insights.
    Enabling,
    /// Enabled status for operation insights.
    Enabled,
    /// Disabling status for operation insights.
    Disabling,
    /// Not Enabled status for operation insights.
    NotEnabled,
    /// Failed enabling status for operation insights.
    FailedEnabling,
    /// Failed disabling status for operation insights.
    FailedDisabling,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationsInsightsState::value] or
    /// [OperationsInsightsState::name].
    UnknownValue(operations_insights_state::UnknownValue),
}

#[doc(hidden)]
pub mod operations_insights_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationsInsightsState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enabling => std::option::Option::Some(1),
            Self::Enabled => std::option::Option::Some(2),
            Self::Disabling => std::option::Option::Some(3),
            Self::NotEnabled => std::option::Option::Some(4),
            Self::FailedEnabling => std::option::Option::Some(5),
            Self::FailedDisabling => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATIONS_INSIGHTS_STATE_UNSPECIFIED"),
            Self::Enabling => std::option::Option::Some("ENABLING"),
            Self::Enabled => std::option::Option::Some("ENABLED"),
            Self::Disabling => std::option::Option::Some("DISABLING"),
            Self::NotEnabled => std::option::Option::Some("NOT_ENABLED"),
            Self::FailedEnabling => std::option::Option::Some("FAILED_ENABLING"),
            Self::FailedDisabling => std::option::Option::Some("FAILED_DISABLING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationsInsightsState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationsInsightsState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationsInsightsState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enabling,
            2 => Self::Enabled,
            3 => Self::Disabling,
            4 => Self::NotEnabled,
            5 => Self::FailedEnabling,
            6 => Self::FailedDisabling,
            _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationsInsightsState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => Self::Unspecified,
            "ENABLING" => Self::Enabling,
            "ENABLED" => Self::Enabled,
            "DISABLING" => Self::Disabling,
            "NOT_ENABLED" => Self::NotEnabled,
            "FAILED_ENABLING" => Self::FailedEnabling,
            "FAILED_DISABLING" => Self::FailedDisabling,
            _ => Self::UnknownValue(operations_insights_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationsInsightsState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enabling => serializer.serialize_i32(1),
            Self::Enabled => serializer.serialize_i32(2),
            Self::Disabling => serializer.serialize_i32(3),
            Self::NotEnabled => serializer.serialize_i32(4),
            Self::FailedEnabling => serializer.serialize_i32(5),
            Self::FailedDisabling => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationsInsightsState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationsInsightsState>::new(
            ".google.cloud.oracledatabase.v1.OperationsInsightsState",
        ))
    }
}

/// The various states available for the Autonomous Database workload type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DBWorkload {
    /// Default unspecified value.
    Unspecified,
    /// Autonomous Transaction Processing database.
    Oltp,
    /// Autonomous Data Warehouse database.
    Dw,
    /// Autonomous JSON Database.
    Ajd,
    /// Autonomous Database with the Oracle APEX Application Development workload
    /// type.
    Apex,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DBWorkload::value] or
    /// [DBWorkload::name].
    UnknownValue(db_workload::UnknownValue),
}

#[doc(hidden)]
pub mod db_workload {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DBWorkload {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Oltp => std::option::Option::Some(1),
            Self::Dw => std::option::Option::Some(2),
            Self::Ajd => std::option::Option::Some(3),
            Self::Apex => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DB_WORKLOAD_UNSPECIFIED"),
            Self::Oltp => std::option::Option::Some("OLTP"),
            Self::Dw => std::option::Option::Some("DW"),
            Self::Ajd => std::option::Option::Some("AJD"),
            Self::Apex => std::option::Option::Some("APEX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DBWorkload {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DBWorkload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DBWorkload {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Oltp,
            2 => Self::Dw,
            3 => Self::Ajd,
            4 => Self::Apex,
            _ => Self::UnknownValue(db_workload::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DBWorkload {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DB_WORKLOAD_UNSPECIFIED" => Self::Unspecified,
            "OLTP" => Self::Oltp,
            "DW" => Self::Dw,
            "AJD" => Self::Ajd,
            "APEX" => Self::Apex,
            _ => Self::UnknownValue(db_workload::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DBWorkload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Oltp => serializer.serialize_i32(1),
            Self::Dw => serializer.serialize_i32(2),
            Self::Ajd => serializer.serialize_i32(3),
            Self::Apex => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DBWorkload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DBWorkload>::new(
            ".google.cloud.oracledatabase.v1.DBWorkload",
        ))
    }
}

/// The compute model of the Exadata Infrastructure, VM Cluster and Autonomous
/// Database.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeModel {
    /// Unspecified compute model.
    Unspecified,
    /// Abstract measure of compute resources. ECPUs are based on the number of
    /// cores elastically allocated from a pool of compute and storage servers.
    Ecpu,
    /// Physical measure of compute resources. OCPUs are based on the physical
    /// core of a processor.
    Ocpu,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeModel::value] or
    /// [ComputeModel::name].
    UnknownValue(compute_model::UnknownValue),
}

#[doc(hidden)]
pub mod compute_model {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeModel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ecpu => std::option::Option::Some(1),
            Self::Ocpu => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPUTE_MODEL_UNSPECIFIED"),
            Self::Ecpu => std::option::Option::Some("COMPUTE_MODEL_ECPU"),
            Self::Ocpu => std::option::Option::Some("COMPUTE_MODEL_OCPU"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeModel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeModel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ecpu,
            2 => Self::Ocpu,
            _ => Self::UnknownValue(compute_model::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeModel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_MODEL_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_MODEL_ECPU" => Self::Ecpu,
            "COMPUTE_MODEL_OCPU" => Self::Ocpu,
            _ => Self::UnknownValue(compute_model::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeModel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ecpu => serializer.serialize_i32(1),
            Self::Ocpu => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeModel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeModel>::new(
            ".google.cloud.oracledatabase.v1.ComputeModel",
        ))
    }
}
