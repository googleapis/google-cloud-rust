// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message describing Template resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Template {
    /// Identifier. name of resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. [Output only] Create time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. filter configuration for this template
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter_config: std::option::Option<crate::model::FilterConfig>,

    /// Optional. metadata for this template
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template_metadata: std::option::Option<crate::model::template::TemplateMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Template {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Template::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Template::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Template::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Template::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [filter_config][crate::model::Template::filter_config].
    pub fn set_filter_config<
        T: std::convert::Into<std::option::Option<crate::model::FilterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_config = v.into();
        self
    }

    /// Sets the value of [template_metadata][crate::model::Template::template_metadata].
    pub fn set_template_metadata<
        T: std::convert::Into<std::option::Option<crate::model::template::TemplateMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template_metadata = v.into();
        self
    }
}

impl wkt::message::Message for Template {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.Template"
    }
}

/// Defines additional types related to [Template].
pub mod template {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing TemplateMetadata
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TemplateMetadata {
        /// Optional. If true, partial detector failures should be ignored.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub ignore_partial_invocation_failures: bool,

        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user by the service extension if the prompt trips Model Armor
        /// filters.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub custom_prompt_safety_error_code: i32,

        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the prompt trips Model Armor filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub custom_prompt_safety_error_message: std::string::String,

        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user if the LLM response trips Model Armor filters.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub custom_llm_response_safety_error_code: i32,

        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the LLM response trips Model Armor filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub custom_llm_response_safety_error_message: std::string::String,

        /// Optional. If true, log template crud operations.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub log_template_operations: bool,

        /// Optional. If true, log sanitize operations.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub log_sanitize_operations: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TemplateMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ignore_partial_invocation_failures][crate::model::template::TemplateMetadata::ignore_partial_invocation_failures].
        pub fn set_ignore_partial_invocation_failures<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.ignore_partial_invocation_failures = v.into();
            self
        }

        /// Sets the value of [custom_prompt_safety_error_code][crate::model::template::TemplateMetadata::custom_prompt_safety_error_code].
        pub fn set_custom_prompt_safety_error_code<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_prompt_safety_error_code = v.into();
            self
        }

        /// Sets the value of [custom_prompt_safety_error_message][crate::model::template::TemplateMetadata::custom_prompt_safety_error_message].
        pub fn set_custom_prompt_safety_error_message<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.custom_prompt_safety_error_message = v.into();
            self
        }

        /// Sets the value of [custom_llm_response_safety_error_code][crate::model::template::TemplateMetadata::custom_llm_response_safety_error_code].
        pub fn set_custom_llm_response_safety_error_code<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_llm_response_safety_error_code = v.into();
            self
        }

        /// Sets the value of [custom_llm_response_safety_error_message][crate::model::template::TemplateMetadata::custom_llm_response_safety_error_message].
        pub fn set_custom_llm_response_safety_error_message<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.custom_llm_response_safety_error_message = v.into();
            self
        }

        /// Sets the value of [log_template_operations][crate::model::template::TemplateMetadata::log_template_operations].
        pub fn set_log_template_operations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.log_template_operations = v.into();
            self
        }

        /// Sets the value of [log_sanitize_operations][crate::model::template::TemplateMetadata::log_sanitize_operations].
        pub fn set_log_sanitize_operations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.log_sanitize_operations = v.into();
            self
        }
    }

    impl wkt::message::Message for TemplateMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.Template.TemplateMetadata"
        }
    }
}

/// Message describing FloorSetting resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FloorSetting {
    /// Identifier. The resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. [Output only] Create timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. ModelArmor filter configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter_config: std::option::Option<crate::model::FilterConfig>,

    /// Optional. Floor Settings enforcement status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_floor_setting_enforcement: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FloorSetting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FloorSetting::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FloorSetting::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FloorSetting::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [filter_config][crate::model::FloorSetting::filter_config].
    pub fn set_filter_config<
        T: std::convert::Into<std::option::Option<crate::model::FilterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_config = v.into();
        self
    }

    /// Sets the value of [enable_floor_setting_enforcement][crate::model::FloorSetting::enable_floor_setting_enforcement].
    pub fn set_enable_floor_setting_enforcement<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enable_floor_setting_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for FloorSetting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FloorSetting"
    }
}

/// Message for requesting list of Templates
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTemplatesRequest {
    /// Required. Parent value for ListTemplatesRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ListTemplatesRequest"
    }
}

/// Message for response to listing Templates
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTemplatesResponse {
    /// The list of Template
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub templates: std::vec::Vec<crate::model::Template>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [templates][crate::model::ListTemplatesResponse::templates].
    pub fn set_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Template>,
    {
        use std::iter::Iterator;
        self.templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTemplatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ListTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTemplatesResponse {
    type PageItem = crate::model::Template;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTemplateRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.GetTemplateRequest"
    }
}

/// Message for creating a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTemplateRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// template_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::Template>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [template_id][crate::model::CreateTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [template][crate::model::CreateTemplateRequest::template].
    pub fn set_template<T: std::convert::Into<std::option::Option<crate::model::Template>>>(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.CreateTemplateRequest"
    }
}

/// Message for updating a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTemplateRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Template resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::Template>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [template][crate::model::UpdateTemplateRequest::template].
    pub fn set_template<T: std::convert::Into<std::option::Option<crate::model::Template>>>(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.UpdateTemplateRequest"
    }
}

/// Message for deleting a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTemplateRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.DeleteTemplateRequest"
    }
}

/// Message for getting a Floor Setting
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFloorSettingRequest {
    /// Required. The name of the floor setting to get, example
    /// projects/123/floorsetting.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFloorSettingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFloorSettingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFloorSettingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.GetFloorSettingRequest"
    }
}

/// Message for Updating a Floor Setting
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFloorSettingRequest {
    /// Required. The floor setting being updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub floor_setting: std::option::Option<crate::model::FloorSetting>,

    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// FloorSetting resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFloorSettingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [floor_setting][crate::model::UpdateFloorSettingRequest::floor_setting].
    pub fn set_floor_setting<
        T: std::convert::Into<std::option::Option<crate::model::FloorSetting>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.floor_setting = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFloorSettingRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFloorSettingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.UpdateFloorSettingRequest"
    }
}

/// Filters configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterConfig {
    /// Optional. Responsible AI settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rai_settings: std::option::Option<crate::model::RaiFilterSettings>,

    /// Optional. Sensitive Data Protection settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sdp_settings: std::option::Option<crate::model::SdpFilterSettings>,

    /// Optional. Prompt injection and Jailbreak filter settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pi_and_jailbreak_filter_settings:
        std::option::Option<crate::model::PiAndJailbreakFilterSettings>,

    /// Optional. Malicious URI filter settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub malicious_uri_filter_settings:
        std::option::Option<crate::model::MaliciousUriFilterSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rai_settings][crate::model::FilterConfig::rai_settings].
    pub fn set_rai_settings<
        T: std::convert::Into<std::option::Option<crate::model::RaiFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rai_settings = v.into();
        self
    }

    /// Sets the value of [sdp_settings][crate::model::FilterConfig::sdp_settings].
    pub fn set_sdp_settings<
        T: std::convert::Into<std::option::Option<crate::model::SdpFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_settings = v.into();
        self
    }

    /// Sets the value of [pi_and_jailbreak_filter_settings][crate::model::FilterConfig::pi_and_jailbreak_filter_settings].
    pub fn set_pi_and_jailbreak_filter_settings<
        T: std::convert::Into<std::option::Option<crate::model::PiAndJailbreakFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pi_and_jailbreak_filter_settings = v.into();
        self
    }

    /// Sets the value of [malicious_uri_filter_settings][crate::model::FilterConfig::malicious_uri_filter_settings].
    pub fn set_malicious_uri_filter_settings<
        T: std::convert::Into<std::option::Option<crate::model::MaliciousUriFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.malicious_uri_filter_settings = v.into();
        self
    }
}

impl wkt::message::Message for FilterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FilterConfig"
    }
}

/// Prompt injection and Jailbreak Filter settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PiAndJailbreakFilterSettings {
    /// Optional. Tells whether Prompt injection and Jailbreak filter is enabled or
    /// disabled.
    pub filter_enforcement:
        crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement,

    /// Optional. Confidence level for this filter.
    /// Confidence level is used to determine the threshold for the filter. If
    /// detection confidence is equal to or greater than the specified level, a
    /// positive match is reported. Confidence level will only be used if the
    /// filter is enabled.
    pub confidence_level: crate::model::DetectionConfidenceLevel,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PiAndJailbreakFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::PiAndJailbreakFilterSettings::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<
                crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }

    /// Sets the value of [confidence_level][crate::model::PiAndJailbreakFilterSettings::confidence_level].
    pub fn set_confidence_level<T: std::convert::Into<crate::model::DetectionConfidenceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidence_level = v.into();
        self
    }
}

impl wkt::message::Message for PiAndJailbreakFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.PiAndJailbreakFilterSettings"
    }
}

/// Defines additional types related to [PiAndJailbreakFilterSettings].
pub mod pi_and_jailbreak_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Prompt Injection and Jailbreak filter
    /// (ENABLED/DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PiAndJailbreakFilterEnforcement {
        /// Same as Disabled
        Unspecified,
        /// Enabled
        Enabled,
        /// Enabled
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PiAndJailbreakFilterEnforcement::value] or
        /// [PiAndJailbreakFilterEnforcement::name].
        UnknownValue(pi_and_jailbreak_filter_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod pi_and_jailbreak_filter_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PiAndJailbreakFilterEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PiAndJailbreakFilterEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PiAndJailbreakFilterEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PiAndJailbreakFilterEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(pi_and_jailbreak_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PiAndJailbreakFilterEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(pi_and_jailbreak_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PiAndJailbreakFilterEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PiAndJailbreakFilterEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PiAndJailbreakFilterEnforcement>::new(
                ".google.cloud.modelarmor.v1.PiAndJailbreakFilterSettings.PiAndJailbreakFilterEnforcement"))
        }
    }
}

/// Malicious URI filter settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaliciousUriFilterSettings {
    /// Optional. Tells whether the Malicious URI filter is enabled or disabled.
    pub filter_enforcement:
        crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaliciousUriFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::MaliciousUriFilterSettings::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<
                crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for MaliciousUriFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterSettings"
    }
}

/// Defines additional types related to [MaliciousUriFilterSettings].
pub mod malicious_uri_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Malicious URI filter (ENABLED/DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaliciousUriFilterEnforcement {
        /// Same as Disabled
        Unspecified,
        /// Enabled
        Enabled,
        /// Disabled
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaliciousUriFilterEnforcement::value] or
        /// [MaliciousUriFilterEnforcement::name].
        UnknownValue(malicious_uri_filter_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod malicious_uri_filter_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaliciousUriFilterEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaliciousUriFilterEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaliciousUriFilterEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaliciousUriFilterEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(malicious_uri_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaliciousUriFilterEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(malicious_uri_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaliciousUriFilterEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaliciousUriFilterEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaliciousUriFilterEnforcement>::new(
                ".google.cloud.modelarmor.v1.MaliciousUriFilterSettings.MaliciousUriFilterEnforcement"))
        }
    }
}

/// Responsible AI Filter settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RaiFilterSettings {
    /// Required. List of Responsible AI filters enabled for template.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rai_filters: std::vec::Vec<crate::model::rai_filter_settings::RaiFilter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RaiFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rai_filters][crate::model::RaiFilterSettings::rai_filters].
    pub fn set_rai_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rai_filter_settings::RaiFilter>,
    {
        use std::iter::Iterator;
        self.rai_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RaiFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterSettings"
    }
}

/// Defines additional types related to [RaiFilterSettings].
pub mod rai_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Responsible AI filter.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RaiFilter {
        /// Required. Type of responsible AI filter.
        pub filter_type: crate::model::RaiFilterType,

        /// Optional. Confidence level for this RAI filter.
        /// During data sanitization, if data is classified under this filter with a
        /// confidence level equal to or greater than the specified level, a positive
        /// match is reported. If the confidence level is unspecified (i.e., 0), the
        /// system will use a reasonable default level based on the `filter_type`.
        pub confidence_level: crate::model::DetectionConfidenceLevel,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RaiFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter_type][crate::model::rai_filter_settings::RaiFilter::filter_type].
        pub fn set_filter_type<T: std::convert::Into<crate::model::RaiFilterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.filter_type = v.into();
            self
        }

        /// Sets the value of [confidence_level][crate::model::rai_filter_settings::RaiFilter::confidence_level].
        pub fn set_confidence_level<
            T: std::convert::Into<crate::model::DetectionConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.confidence_level = v.into();
            self
        }
    }

    impl wkt::message::Message for RaiFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterSettings.RaiFilter"
        }
    }
}

/// Sensitive Data Protection settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpFilterSettings {
    /// Either of Sensitive Data Protection basic or advanced configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sdp_configuration: std::option::Option<crate::model::sdp_filter_settings::SdpConfiguration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration].
    ///
    /// Note that all the setters affecting `sdp_configuration` are mutually
    /// exclusive.
    pub fn set_sdp_configuration<
        T: std::convert::Into<
                std::option::Option<crate::model::sdp_filter_settings::SdpConfiguration>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = v.into();
        self
    }

    /// The value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// if it holds a `BasicConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpBasicConfig>> {
        #[allow(unreachable_patterns)]
        self.sdp_configuration.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// to hold a `BasicConfig`.
    ///
    /// Note that all the setters affecting `sdp_configuration` are
    /// mutually exclusive.
    pub fn set_basic_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpBasicConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = std::option::Option::Some(
            crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(v.into()),
        );
        self
    }

    /// The value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// if it holds a `AdvancedConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advanced_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpAdvancedConfig>> {
        #[allow(unreachable_patterns)]
        self.sdp_configuration.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// to hold a `AdvancedConfig`.
    ///
    /// Note that all the setters affecting `sdp_configuration` are
    /// mutually exclusive.
    pub fn set_advanced_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpAdvancedConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = std::option::Option::Some(
            crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SdpFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFilterSettings"
    }
}

/// Defines additional types related to [SdpFilterSettings].
pub mod sdp_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Either of Sensitive Data Protection basic or advanced configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SdpConfiguration {
        /// Optional. Basic Sensitive Data Protection configuration inspects the
        /// content for sensitive data using a fixed set of six info-types. Sensitive
        /// Data Protection templates cannot be used with basic configuration. Only
        /// Sensitive Data Protection inspection operation is supported with basic
        /// configuration.
        BasicConfig(std::boxed::Box<crate::model::SdpBasicConfig>),
        /// Optional. Advanced Sensitive Data Protection configuration which enables
        /// use of Sensitive Data Protection templates. Supports both Sensitive Data
        /// Protection inspection and de-identification operations.
        AdvancedConfig(std::boxed::Box<crate::model::SdpAdvancedConfig>),
    }
}

/// Sensitive Data Protection basic configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpBasicConfig {
    /// Optional. Tells whether the Sensitive Data Protection basic config is
    /// enabled or disabled.
    pub filter_enforcement: crate::model::sdp_basic_config::SdpBasicConfigEnforcement,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpBasicConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::SdpBasicConfig::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<crate::model::sdp_basic_config::SdpBasicConfigEnforcement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for SdpBasicConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpBasicConfig"
    }
}

/// Defines additional types related to [SdpBasicConfig].
pub mod sdp_basic_config {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Sensitive Data Protection basic config
    /// (ENABLED/DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SdpBasicConfigEnforcement {
        /// Same as Disabled
        Unspecified,
        /// Enabled
        Enabled,
        /// Disabled
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SdpBasicConfigEnforcement::value] or
        /// [SdpBasicConfigEnforcement::name].
        UnknownValue(sdp_basic_config_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sdp_basic_config_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SdpBasicConfigEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SdpBasicConfigEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SdpBasicConfigEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SdpBasicConfigEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(sdp_basic_config_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SdpBasicConfigEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(sdp_basic_config_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SdpBasicConfigEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SdpBasicConfigEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<SdpBasicConfigEnforcement>::new(
                    ".google.cloud.modelarmor.v1.SdpBasicConfig.SdpBasicConfigEnforcement",
                ),
            )
        }
    }
}

/// Sensitive Data Protection Advanced configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpAdvancedConfig {
    /// Optional. Sensitive Data Protection inspect template resource name
    ///
    /// If only inspect template is provided (de-identify template not provided),
    /// then Sensitive Data Protection InspectContent action is performed during
    /// Sanitization. All Sensitive Data Protection findings identified during
    /// inspection will be returned as SdpFinding in SdpInsepctionResult.
    ///
    /// e.g.
    /// `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template: std::string::String,

    /// Optional. Optional Sensitive Data Protection Deidentify template resource
    /// name.
    ///
    /// If provided then DeidentifyContent action is performed during Sanitization
    /// using this template and inspect template. The De-identified data will
    /// be returned in SdpDeidentifyResult.
    /// Note that all info-types present in the deidentify template must be present
    /// in inspect template.
    ///
    /// e.g.
    /// `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deidentify_template: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpAdvancedConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_template][crate::model::SdpAdvancedConfig::inspect_template].
    pub fn set_inspect_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::SdpAdvancedConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }
}

impl wkt::message::Message for SdpAdvancedConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpAdvancedConfig"
    }
}

/// Sanitize User Prompt request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeUserPromptRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User prompt data to sanitize.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_prompt_data: std::option::Option<crate::model::DataItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeUserPromptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SanitizeUserPromptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user_prompt_data][crate::model::SanitizeUserPromptRequest::user_prompt_data].
    pub fn set_user_prompt_data<
        T: std::convert::Into<std::option::Option<crate::model::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_prompt_data = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeUserPromptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeUserPromptRequest"
    }
}

/// Sanitize Model Response request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeModelResponseRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Model response data to sanitize.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_response_data: std::option::Option<crate::model::DataItem>,

    /// Optional. User Prompt associated with Model response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_prompt: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeModelResponseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SanitizeModelResponseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [model_response_data][crate::model::SanitizeModelResponseRequest::model_response_data].
    pub fn set_model_response_data<
        T: std::convert::Into<std::option::Option<crate::model::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_response_data = v.into();
        self
    }

    /// Sets the value of [user_prompt][crate::model::SanitizeModelResponseRequest::user_prompt].
    pub fn set_user_prompt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_prompt = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeModelResponseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeModelResponseRequest"
    }
}

/// Sanitized User Prompt Response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeUserPromptResponse {
    /// Output only. Sanitization Result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sanitization_result: std::option::Option<crate::model::SanitizationResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeUserPromptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sanitization_result][crate::model::SanitizeUserPromptResponse::sanitization_result].
    pub fn set_sanitization_result<
        T: std::convert::Into<std::option::Option<crate::model::SanitizationResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sanitization_result = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeUserPromptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeUserPromptResponse"
    }
}

/// Sanitized Model Response Response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeModelResponseResponse {
    /// Output only. Sanitization Result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sanitization_result: std::option::Option<crate::model::SanitizationResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeModelResponseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sanitization_result][crate::model::SanitizeModelResponseResponse::sanitization_result].
    pub fn set_sanitization_result<
        T: std::convert::Into<std::option::Option<crate::model::SanitizationResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sanitization_result = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeModelResponseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeModelResponseResponse"
    }
}

/// Sanitization result after applying all the filters on input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizationResult {
    /// Output only. Overall filter match state for Sanitization.
    /// The state can have below two values.
    ///
    /// ) NO_MATCH_FOUND: No filters in configuration satisfy matching criteria.
    ///   In other words, input passed all filters.
    ///
    /// ) MATCH_FOUND: At least one filter in configuration satisfies matching.
    ///   In other words, input did not pass one or more filters.
    ///
    pub filter_match_state: crate::model::FilterMatchState,

    /// Output only. Results for all filters where the key is the filter name -
    /// either of "csam", "malicious_uris", "rai", "pi_and_jailbreak" ,"sdp".
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub filter_results: std::collections::HashMap<std::string::String, crate::model::FilterResult>,

    /// Output only. A field indicating the outcome of the invocation, irrespective
    /// of match status. It can have the following three values: SUCCESS: All
    /// filters were executed successfully. PARTIAL: Some filters were skipped or
    /// failed execution. FAILURE: All filters were skipped or failed execution.
    pub invocation_result: crate::model::InvocationResult,

    /// Output only. Metadata related to Sanitization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sanitization_metadata:
        std::option::Option<crate::model::sanitization_result::SanitizationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_match_state][crate::model::SanitizationResult::filter_match_state].
    pub fn set_filter_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_match_state = v.into();
        self
    }

    /// Sets the value of [filter_results][crate::model::SanitizationResult::filter_results].
    pub fn set_filter_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FilterResult>,
    {
        use std::iter::Iterator;
        self.filter_results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [invocation_result][crate::model::SanitizationResult::invocation_result].
    pub fn set_invocation_result<T: std::convert::Into<crate::model::InvocationResult>>(
        mut self,
        v: T,
    ) -> Self {
        self.invocation_result = v.into();
        self
    }

    /// Sets the value of [sanitization_metadata][crate::model::SanitizationResult::sanitization_metadata].
    pub fn set_sanitization_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::sanitization_result::SanitizationMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sanitization_metadata = v.into();
        self
    }
}

impl wkt::message::Message for SanitizationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizationResult"
    }
}

/// Defines additional types related to [SanitizationResult].
pub mod sanitization_result {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing Sanitization metadata.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SanitizationMetadata {
        /// Error code if any.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub error_code: i64,

        /// Error message if any.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SanitizationMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_code][crate::model::sanitization_result::SanitizationMetadata::error_code].
        pub fn set_error_code<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.error_code = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::sanitization_result::SanitizationMetadata::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for SanitizationMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.SanitizationResult.SanitizationMetadata"
        }
    }
}

/// Filter Result obtained after Sanitization operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterResult {
    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter_result: std::option::Option<crate::model::filter_result::FilterResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result].
    ///
    /// Note that all the setters affecting `filter_result` are mutually
    /// exclusive.
    pub fn set_filter_result<
        T: std::convert::Into<std::option::Option<crate::model::filter_result::FilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = v.into();
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `RaiFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rai_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RaiFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::RaiFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `RaiFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_rai_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::RaiFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::RaiFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `SdpFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sdp_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::SdpFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `SdpFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_sdp_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::SdpFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `PiAndJailbreakFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pi_and_jailbreak_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PiAndJailbreakFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `PiAndJailbreakFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_pi_and_jailbreak_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PiAndJailbreakFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `MaliciousUriFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn malicious_uri_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaliciousUriFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::MaliciousUriFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `MaliciousUriFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_malicious_uri_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::MaliciousUriFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::MaliciousUriFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `CsamFilterFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csam_filter_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CsamFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::CsamFilterFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `CsamFilterFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_csam_filter_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CsamFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::CsamFilterFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `VirusScanFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn virus_scan_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VirusScanFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::VirusScanFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `VirusScanFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_virus_scan_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::VirusScanFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::VirusScanFilterResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FilterResult"
    }
}

/// Defines additional types related to [FilterResult].
pub mod filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FilterResult {
        /// Responsible AI filter results.
        RaiFilterResult(std::boxed::Box<crate::model::RaiFilterResult>),
        /// Sensitive Data Protection results.
        SdpFilterResult(std::boxed::Box<crate::model::SdpFilterResult>),
        /// Prompt injection and Jailbreak filter results.
        PiAndJailbreakFilterResult(std::boxed::Box<crate::model::PiAndJailbreakFilterResult>),
        /// Malicious URI filter results.
        MaliciousUriFilterResult(std::boxed::Box<crate::model::MaliciousUriFilterResult>),
        /// CSAM filter results.
        CsamFilterFilterResult(std::boxed::Box<crate::model::CsamFilterResult>),
        /// Virus scan results.
        VirusScanFilterResult(std::boxed::Box<crate::model::VirusScanFilterResult>),
    }
}

/// Responsible AI Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RaiFilterResult {
    /// Output only. Reports whether the RAI filter was successfully executed or
    /// not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Overall filter match state for RAI.
    /// Value is MATCH_FOUND if at least one RAI filter confidence level is
    /// equal to or higher than the confidence level defined in configuration.
    pub match_state: crate::model::FilterMatchState,

    /// The map of RAI filter results where key is RAI filter type - either of
    /// "sexually_explicit", "hate_speech", "harassment", "dangerous".
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub rai_filter_type_results: std::collections::HashMap<
        std::string::String,
        crate::model::rai_filter_result::RaiFilterTypeResult,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RaiFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::RaiFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::RaiFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::RaiFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [rai_filter_type_results][crate::model::RaiFilterResult::rai_filter_type_results].
    pub fn set_rai_filter_type_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::rai_filter_result::RaiFilterTypeResult>,
    {
        use std::iter::Iterator;
        self.rai_filter_type_results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RaiFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterResult"
    }
}

/// Defines additional types related to [RaiFilterResult].
pub mod rai_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed Filter result for each of the responsible AI Filter Types.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RaiFilterTypeResult {
        /// Type of responsible AI filter.
        pub filter_type: crate::model::RaiFilterType,

        /// Confidence level identified for this RAI filter.
        pub confidence_level: crate::model::DetectionConfidenceLevel,

        /// Output only. Match state for this RAI filter.
        pub match_state: crate::model::FilterMatchState,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RaiFilterTypeResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter_type][crate::model::rai_filter_result::RaiFilterTypeResult::filter_type].
        pub fn set_filter_type<T: std::convert::Into<crate::model::RaiFilterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.filter_type = v.into();
            self
        }

        /// Sets the value of [confidence_level][crate::model::rai_filter_result::RaiFilterTypeResult::confidence_level].
        pub fn set_confidence_level<
            T: std::convert::Into<crate::model::DetectionConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.confidence_level = v.into();
            self
        }

        /// Sets the value of [match_state][crate::model::rai_filter_result::RaiFilterTypeResult::match_state].
        pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
            mut self,
            v: T,
        ) -> Self {
            self.match_state = v.into();
            self
        }
    }

    impl wkt::message::Message for RaiFilterTypeResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterResult.RaiFilterTypeResult"
        }
    }
}

/// Sensitive Data Protection filter result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpFilterResult {
    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::sdp_filter_result::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::sdp_filter_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::SdpFilterResult::result]
    /// if it holds a `InspectResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpInspectResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_result::Result::InspectResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result]
    /// to hold a `InspectResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_inspect_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpInspectResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::sdp_filter_result::Result::InspectResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::SdpFilterResult::result]
    /// if it holds a `DeidentifyResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deidentify_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpDeidentifyResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_result::Result::DeidentifyResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result]
    /// to hold a `DeidentifyResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_deidentify_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpDeidentifyResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::sdp_filter_result::Result::DeidentifyResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SdpFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFilterResult"
    }
}

/// Defines additional types related to [SdpFilterResult].
pub mod sdp_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Sensitive Data Protection Inspection result if inspection is performed.
        InspectResult(std::boxed::Box<crate::model::SdpInspectResult>),
        /// Sensitive Data Protection Deidentification result if deidentification is
        /// performed.
        DeidentifyResult(std::boxed::Box<crate::model::SdpDeidentifyResult>),
    }
}

/// Sensitive Data Protection Inspection Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpInspectResult {
    /// Output only. Reports whether Sensitive Data Protection inspection was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for SDP Inspection.
    /// Value is MATCH_FOUND if at least one Sensitive Data Protection finding is
    /// identified.
    pub match_state: crate::model::FilterMatchState,

    /// List of Sensitive Data Protection findings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub findings: std::vec::Vec<crate::model::SdpFinding>,

    /// If true, then there is possibility that more findings were identified and
    /// the findings returned are a subset of all findings. The findings
    /// list might be truncated because the input items were too large, or because
    /// the server reached the maximum amount of resources allowed for a single API
    /// call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub findings_truncated: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpInspectResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::SdpInspectResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::SdpInspectResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::SdpInspectResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [findings][crate::model::SdpInspectResult::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SdpFinding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [findings_truncated][crate::model::SdpInspectResult::findings_truncated].
    pub fn set_findings_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.findings_truncated = v.into();
        self
    }
}

impl wkt::message::Message for SdpInspectResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpInspectResult"
    }
}

/// Represents Data item
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataItem {
    /// Either of text or bytes data.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_item: std::option::Option<crate::model::data_item::DataItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item].
    ///
    /// Note that all the setters affecting `data_item` are mutually
    /// exclusive.
    pub fn set_data_item<
        T: std::convert::Into<std::option::Option<crate::model::data_item::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// The value of [data_item][crate::model::DataItem::data_item]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::data_item::DataItem::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::data_item::DataItem::Text(v.into()));
        self
    }

    /// The value of [data_item][crate::model::DataItem::data_item]
    /// if it holds a `ByteItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn byte_item(&self) -> std::option::Option<&std::boxed::Box<crate::model::ByteDataItem>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::data_item::DataItem::ByteItem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item]
    /// to hold a `ByteItem`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_byte_item<T: std::convert::Into<std::boxed::Box<crate::model::ByteDataItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::data_item::DataItem::ByteItem(v.into()));
        self
    }
}

impl wkt::message::Message for DataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.DataItem"
    }
}

/// Defines additional types related to [DataItem].
pub mod data_item {
    #[allow(unused_imports)]
    use super::*;

    /// Either of text or bytes data.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataItem {
        /// Plaintext string data for sanitization.
        Text(std::string::String),
        /// Data provided in the form of bytes.
        ByteItem(std::boxed::Box<crate::model::ByteDataItem>),
    }
}

/// Represents Byte Data item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ByteDataItem {
    /// Required. The type of byte data
    pub byte_data_type: crate::model::byte_data_item::ByteItemType,

    /// Required. Bytes Data
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub byte_data: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ByteDataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [byte_data_type][crate::model::ByteDataItem::byte_data_type].
    pub fn set_byte_data_type<T: std::convert::Into<crate::model::byte_data_item::ByteItemType>>(
        mut self,
        v: T,
    ) -> Self {
        self.byte_data_type = v.into();
        self
    }

    /// Sets the value of [byte_data][crate::model::ByteDataItem::byte_data].
    pub fn set_byte_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.byte_data = v.into();
        self
    }
}

impl wkt::message::Message for ByteDataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ByteDataItem"
    }
}

/// Defines additional types related to [ByteDataItem].
pub mod byte_data_item {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the type of byte data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ByteItemType {
        /// Unused
        Unspecified,
        /// plain text
        PlaintextUtf8,
        /// PDF
        Pdf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ByteItemType::value] or
        /// [ByteItemType::name].
        UnknownValue(byte_item_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod byte_item_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ByteItemType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PlaintextUtf8 => std::option::Option::Some(1),
                Self::Pdf => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BYTE_ITEM_TYPE_UNSPECIFIED"),
                Self::PlaintextUtf8 => std::option::Option::Some("PLAINTEXT_UTF8"),
                Self::Pdf => std::option::Option::Some("PDF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ByteItemType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ByteItemType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ByteItemType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PlaintextUtf8,
                2 => Self::Pdf,
                _ => Self::UnknownValue(byte_item_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ByteItemType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BYTE_ITEM_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PLAINTEXT_UTF8" => Self::PlaintextUtf8,
                "PDF" => Self::Pdf,
                _ => Self::UnknownValue(byte_item_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ByteItemType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PlaintextUtf8 => serializer.serialize_i32(1),
                Self::Pdf => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ByteItemType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ByteItemType>::new(
                ".google.cloud.modelarmor.v1.ByteDataItem.ByteItemType",
            ))
        }
    }
}

/// Sensitive Data Protection Deidentification Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpDeidentifyResult {
    /// Output only. Reports whether Sensitive Data Protection deidentification was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for Sensitive Data Protection Deidentification.
    /// Value is MATCH_FOUND if content is de-identified.
    pub match_state: crate::model::FilterMatchState,

    /// De-identified data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::DataItem>,

    /// Total size in bytes that were transformed during deidentification.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// List of Sensitive Data Protection info-types that were de-identified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpDeidentifyResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::SdpDeidentifyResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::SdpDeidentifyResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::SdpDeidentifyResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [data][crate::model::SdpDeidentifyResult::data].
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::DataItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::SdpDeidentifyResult::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [info_types][crate::model::SdpDeidentifyResult::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SdpDeidentifyResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpDeidentifyResult"
    }
}

/// Finding corresponding to Sensitive Data Protection filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpFinding {
    /// Name of Sensitive Data Protection info type for this finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub info_type: std::string::String,

    /// Identified confidence likelihood for `info_type`.
    pub likelihood: crate::model::SdpFindingLikelihood,

    /// Location for this finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::sdp_finding::SdpFindingLocation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::SdpFinding::info_type].
    pub fn set_info_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [likelihood][crate::model::SdpFinding::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::SdpFindingLikelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [location][crate::model::SdpFinding::location].
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::sdp_finding::SdpFindingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for SdpFinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFinding"
    }
}

/// Defines additional types related to [SdpFinding].
pub mod sdp_finding {
    #[allow(unused_imports)]
    use super::*;

    /// Location of this Sensitive Data Protection Finding within input content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SdpFindingLocation {
        /// Zero-based byte offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Note that when the content is not textual, this references
        /// the UTF-8 encoded textual representation of the content.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub byte_range: std::option::Option<crate::model::RangeInfo>,

        /// Unicode character offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Provided when the content is text.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub codepoint_range: std::option::Option<crate::model::RangeInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SdpFindingLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [byte_range][crate::model::sdp_finding::SdpFindingLocation::byte_range].
        pub fn set_byte_range<
            T: std::convert::Into<std::option::Option<crate::model::RangeInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.byte_range = v.into();
            self
        }

        /// Sets the value of [codepoint_range][crate::model::sdp_finding::SdpFindingLocation::codepoint_range].
        pub fn set_codepoint_range<
            T: std::convert::Into<std::option::Option<crate::model::RangeInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.codepoint_range = v.into();
            self
        }
    }

    impl wkt::message::Message for SdpFindingLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.SdpFinding.SdpFindingLocation"
        }
    }
}

/// Prompt injection and Jailbreak Filter Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PiAndJailbreakFilterResult {
    /// Output only. Reports whether Prompt injection and Jailbreak filter was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for Prompt injection and Jailbreak.
    pub match_state: crate::model::FilterMatchState,

    /// Confidence level identified for Prompt injection and Jailbreak.
    pub confidence_level: crate::model::DetectionConfidenceLevel,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PiAndJailbreakFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::PiAndJailbreakFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::PiAndJailbreakFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::PiAndJailbreakFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [confidence_level][crate::model::PiAndJailbreakFilterResult::confidence_level].
    pub fn set_confidence_level<T: std::convert::Into<crate::model::DetectionConfidenceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidence_level = v.into();
        self
    }
}

impl wkt::message::Message for PiAndJailbreakFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.PiAndJailbreakFilterResult"
    }
}

/// Malicious URI Filter Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaliciousUriFilterResult {
    /// Output only. Reports whether Malicious URI filter was successfully executed
    /// or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for this Malicious URI.
    /// Value is MATCH_FOUND if at least one Malicious URI is found.
    pub match_state: crate::model::FilterMatchState,

    /// List of Malicious URIs found in data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub malicious_uri_matched_items:
        std::vec::Vec<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaliciousUriFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::MaliciousUriFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::MaliciousUriFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::MaliciousUriFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [malicious_uri_matched_items][crate::model::MaliciousUriFilterResult::malicious_uri_matched_items].
    pub fn set_malicious_uri_matched_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>,
    {
        use std::iter::Iterator;
        self.malicious_uri_matched_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaliciousUriFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterResult"
    }
}

/// Defines additional types related to [MaliciousUriFilterResult].
pub mod malicious_uri_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Information regarding malicious URI and its location within the input
    /// content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MaliciousUriMatchedItem {
        /// Malicious URI.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// List of locations where Malicious URI is identified.
        /// The `locations` field is supported only for plaintext content i.e.
        /// ByteItemType.PLAINTEXT_UTF8
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub locations: std::vec::Vec<crate::model::RangeInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MaliciousUriMatchedItem {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [locations][crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem::locations].
        pub fn set_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RangeInfo>,
        {
            use std::iter::Iterator;
            self.locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MaliciousUriMatchedItem {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterResult.MaliciousUriMatchedItem"
        }
    }
}

/// Virus scan results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirusScanFilterResult {
    /// Output only. Reports whether Virus Scan was successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution status is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match status for Virus.
    /// Value is MATCH_FOUND if the data is infected with a virus.
    pub match_state: crate::model::FilterMatchState,

    /// Type of content scanned.
    pub scanned_content_type: crate::model::virus_scan_filter_result::ScannedContentType,

    /// Size of scanned content in bytes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub scanned_size: std::option::Option<i64>,

    /// List of Viruses identified.
    /// This field will be empty if no virus was detected.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub virus_details: std::vec::Vec<crate::model::VirusDetail>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirusScanFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::VirusScanFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::VirusScanFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::VirusScanFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [scanned_content_type][crate::model::VirusScanFilterResult::scanned_content_type].
    pub fn set_scanned_content_type<
        T: std::convert::Into<crate::model::virus_scan_filter_result::ScannedContentType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scanned_content_type = v.into();
        self
    }

    /// Sets the value of [scanned_size][crate::model::VirusScanFilterResult::scanned_size].
    pub fn set_scanned_size<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scanned_size = v.into();
        self
    }

    /// Sets the value of [virus_details][crate::model::VirusScanFilterResult::virus_details].
    pub fn set_virus_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VirusDetail>,
    {
        use std::iter::Iterator;
        self.virus_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VirusScanFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.VirusScanFilterResult"
    }
}

/// Defines additional types related to [VirusScanFilterResult].
pub mod virus_scan_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Type of content scanned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScannedContentType {
        /// Unused
        Unspecified,
        /// Unknown content
        Unknown,
        /// Plaintext
        Plaintext,
        /// PDF
        /// Scanning for only PDF is supported.
        Pdf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ScannedContentType::value] or
        /// [ScannedContentType::name].
        UnknownValue(scanned_content_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scanned_content_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ScannedContentType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Plaintext => std::option::Option::Some(2),
                Self::Pdf => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCANNED_CONTENT_TYPE_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Plaintext => std::option::Option::Some("PLAINTEXT"),
                Self::Pdf => std::option::Option::Some("PDF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ScannedContentType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ScannedContentType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ScannedContentType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Plaintext,
                3 => Self::Pdf,
                _ => Self::UnknownValue(scanned_content_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ScannedContentType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCANNED_CONTENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "PLAINTEXT" => Self::Plaintext,
                "PDF" => Self::Pdf,
                _ => Self::UnknownValue(scanned_content_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ScannedContentType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Plaintext => serializer.serialize_i32(2),
                Self::Pdf => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ScannedContentType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScannedContentType>::new(
                ".google.cloud.modelarmor.v1.VirusScanFilterResult.ScannedContentType",
            ))
        }
    }
}

/// Details of an identified virus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirusDetail {
    /// Name of vendor that produced this virus identification.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vendor: std::string::String,

    /// Names of this Virus.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    /// Threat type of the identified virus
    pub threat_type: crate::model::virus_detail::ThreatType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirusDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vendor][crate::model::VirusDetail::vendor].
    pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vendor = v.into();
        self
    }

    /// Sets the value of [names][crate::model::VirusDetail::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [threat_type][crate::model::VirusDetail::threat_type].
    pub fn set_threat_type<T: std::convert::Into<crate::model::virus_detail::ThreatType>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_type = v.into();
        self
    }
}

impl wkt::message::Message for VirusDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.VirusDetail"
    }
}

/// Defines additional types related to [VirusDetail].
pub mod virus_detail {
    #[allow(unused_imports)]
    use super::*;

    /// Defines all the threat types of a virus
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ThreatType {
        /// Unused
        Unspecified,
        /// Unable to categorize threat
        Unknown,
        /// Virus or Worm threat.
        VirusOrWorm,
        /// Malicious program. E.g. Spyware, Trojan.
        MaliciousProgram,
        /// Potentially harmful content. E.g. Injected code, Macro
        PotentiallyHarmfulContent,
        /// Potentially unwanted content. E.g. Adware.
        PotentiallyUnwantedContent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ThreatType::value] or
        /// [ThreatType::name].
        UnknownValue(threat_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod threat_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ThreatType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::VirusOrWorm => std::option::Option::Some(2),
                Self::MaliciousProgram => std::option::Option::Some(3),
                Self::PotentiallyHarmfulContent => std::option::Option::Some(4),
                Self::PotentiallyUnwantedContent => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("THREAT_TYPE_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::VirusOrWorm => std::option::Option::Some("VIRUS_OR_WORM"),
                Self::MaliciousProgram => std::option::Option::Some("MALICIOUS_PROGRAM"),
                Self::PotentiallyHarmfulContent => {
                    std::option::Option::Some("POTENTIALLY_HARMFUL_CONTENT")
                }
                Self::PotentiallyUnwantedContent => {
                    std::option::Option::Some("POTENTIALLY_UNWANTED_CONTENT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ThreatType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ThreatType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ThreatType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::VirusOrWorm,
                3 => Self::MaliciousProgram,
                4 => Self::PotentiallyHarmfulContent,
                5 => Self::PotentiallyUnwantedContent,
                _ => Self::UnknownValue(threat_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ThreatType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "THREAT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "VIRUS_OR_WORM" => Self::VirusOrWorm,
                "MALICIOUS_PROGRAM" => Self::MaliciousProgram,
                "POTENTIALLY_HARMFUL_CONTENT" => Self::PotentiallyHarmfulContent,
                "POTENTIALLY_UNWANTED_CONTENT" => Self::PotentiallyUnwantedContent,
                _ => Self::UnknownValue(threat_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ThreatType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::VirusOrWorm => serializer.serialize_i32(2),
                Self::MaliciousProgram => serializer.serialize_i32(3),
                Self::PotentiallyHarmfulContent => serializer.serialize_i32(4),
                Self::PotentiallyUnwantedContent => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ThreatType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ThreatType>::new(
                ".google.cloud.modelarmor.v1.VirusDetail.ThreatType",
            ))
        }
    }
}

/// CSAM (Child Safety Abuse Material) Filter Result
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CsamFilterResult {
    /// Output only. Reports whether the CSAM filter was successfully executed or
    /// not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for CSAM.
    pub match_state: crate::model::FilterMatchState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CsamFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::CsamFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::CsamFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::CsamFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }
}

impl wkt::message::Message for CsamFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.CsamFilterResult"
    }
}

/// Message item to report information, warning or error messages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MessageItem {
    /// Type of message.
    pub message_type: crate::model::message_item::MessageType,

    /// The message content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_type][crate::model::MessageItem::message_type].
    pub fn set_message_type<T: std::convert::Into<crate::model::message_item::MessageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = v.into();
        self
    }

    /// Sets the value of [message][crate::model::MessageItem::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for MessageItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MessageItem"
    }
}

/// Defines additional types related to [MessageItem].
pub mod message_item {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the type of message.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MessageType {
        /// Unused
        Unspecified,
        /// Information related message.
        Info,
        /// Warning related message.
        Warning,
        /// Error message.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MessageType::value] or
        /// [MessageType::name].
        UnknownValue(message_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod message_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MessageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MESSAGE_TYPE_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MessageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MessageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MessageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MessageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MessageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MessageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MessageType>::new(
                ".google.cloud.modelarmor.v1.MessageItem.MessageType",
            ))
        }
    }
}

/// Half-open range interval [start, end)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RangeInfo {
    /// For proto3, value cannot be set to 0 unless the field is optional.
    /// Ref: <https://protobuf.dev/programming-guides/proto3/#default>
    /// Index of first character (inclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub start: std::option::Option<i64>,

    /// Index of last character (exclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub end: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RangeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::RangeInfo::start].
    pub fn set_start<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.start = v.into();
        self
    }

    /// Sets the value of [end][crate::model::RangeInfo::end].
    pub fn set_end<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.end = v.into();
        self
    }
}

impl wkt::message::Message for RangeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RangeInfo"
    }
}

/// Option to specify filter match state.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FilterMatchState {
    /// Unused
    Unspecified,
    /// Matching criteria is not achieved for filters.
    NoMatchFound,
    /// Matching criteria is achieved for the filter.
    MatchFound,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FilterMatchState::value] or
    /// [FilterMatchState::name].
    UnknownValue(filter_match_state::UnknownValue),
}

#[doc(hidden)]
pub mod filter_match_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FilterMatchState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NoMatchFound => std::option::Option::Some(1),
            Self::MatchFound => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FILTER_MATCH_STATE_UNSPECIFIED"),
            Self::NoMatchFound => std::option::Option::Some("NO_MATCH_FOUND"),
            Self::MatchFound => std::option::Option::Some("MATCH_FOUND"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FilterMatchState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FilterMatchState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FilterMatchState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NoMatchFound,
            2 => Self::MatchFound,
            _ => Self::UnknownValue(filter_match_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FilterMatchState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FILTER_MATCH_STATE_UNSPECIFIED" => Self::Unspecified,
            "NO_MATCH_FOUND" => Self::NoMatchFound,
            "MATCH_FOUND" => Self::MatchFound,
            _ => Self::UnknownValue(filter_match_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FilterMatchState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NoMatchFound => serializer.serialize_i32(1),
            Self::MatchFound => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FilterMatchState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilterMatchState>::new(
            ".google.cloud.modelarmor.v1.FilterMatchState",
        ))
    }
}

/// Enum which reports whether a specific filter executed successfully or not.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FilterExecutionState {
    /// Unused
    Unspecified,
    /// Filter executed successfully
    ExecutionSuccess,
    /// Filter execution was skipped. This can happen due to server-side error
    /// or permission issue.
    ExecutionSkipped,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FilterExecutionState::value] or
    /// [FilterExecutionState::name].
    UnknownValue(filter_execution_state::UnknownValue),
}

#[doc(hidden)]
pub mod filter_execution_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FilterExecutionState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ExecutionSuccess => std::option::Option::Some(1),
            Self::ExecutionSkipped => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FILTER_EXECUTION_STATE_UNSPECIFIED"),
            Self::ExecutionSuccess => std::option::Option::Some("EXECUTION_SUCCESS"),
            Self::ExecutionSkipped => std::option::Option::Some("EXECUTION_SKIPPED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FilterExecutionState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FilterExecutionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FilterExecutionState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ExecutionSuccess,
            2 => Self::ExecutionSkipped,
            _ => Self::UnknownValue(filter_execution_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FilterExecutionState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FILTER_EXECUTION_STATE_UNSPECIFIED" => Self::Unspecified,
            "EXECUTION_SUCCESS" => Self::ExecutionSuccess,
            "EXECUTION_SKIPPED" => Self::ExecutionSkipped,
            _ => Self::UnknownValue(filter_execution_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FilterExecutionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ExecutionSuccess => serializer.serialize_i32(1),
            Self::ExecutionSkipped => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FilterExecutionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilterExecutionState>::new(
            ".google.cloud.modelarmor.v1.FilterExecutionState",
        ))
    }
}

/// Options for responsible AI Filter Types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RaiFilterType {
    /// Unspecified filter type.
    Unspecified,
    /// Sexually Explicit.
    SexuallyExplicit,
    /// Hate Speech.
    HateSpeech,
    /// Harassment.
    Harassment,
    /// Danger
    Dangerous,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RaiFilterType::value] or
    /// [RaiFilterType::name].
    UnknownValue(rai_filter_type::UnknownValue),
}

#[doc(hidden)]
pub mod rai_filter_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RaiFilterType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SexuallyExplicit => std::option::Option::Some(2),
            Self::HateSpeech => std::option::Option::Some(3),
            Self::Harassment => std::option::Option::Some(6),
            Self::Dangerous => std::option::Option::Some(17),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RAI_FILTER_TYPE_UNSPECIFIED"),
            Self::SexuallyExplicit => std::option::Option::Some("SEXUALLY_EXPLICIT"),
            Self::HateSpeech => std::option::Option::Some("HATE_SPEECH"),
            Self::Harassment => std::option::Option::Some("HARASSMENT"),
            Self::Dangerous => std::option::Option::Some("DANGEROUS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RaiFilterType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RaiFilterType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RaiFilterType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::SexuallyExplicit,
            3 => Self::HateSpeech,
            6 => Self::Harassment,
            17 => Self::Dangerous,
            _ => Self::UnknownValue(rai_filter_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RaiFilterType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RAI_FILTER_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SEXUALLY_EXPLICIT" => Self::SexuallyExplicit,
            "HATE_SPEECH" => Self::HateSpeech,
            "HARASSMENT" => Self::Harassment,
            "DANGEROUS" => Self::Dangerous,
            _ => Self::UnknownValue(rai_filter_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RaiFilterType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SexuallyExplicit => serializer.serialize_i32(2),
            Self::HateSpeech => serializer.serialize_i32(3),
            Self::Harassment => serializer.serialize_i32(6),
            Self::Dangerous => serializer.serialize_i32(17),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RaiFilterType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RaiFilterType>::new(
            ".google.cloud.modelarmor.v1.RaiFilterType",
        ))
    }
}

/// Confidence levels for detectors.
/// Higher value maps to a greater confidence level. To enforce stricter level a
/// lower value should be used.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DetectionConfidenceLevel {
    /// Same as MEDIUM_AND_ABOVE.
    Unspecified,
    /// Highest chance of a false positive.
    LowAndAbove,
    /// Some chance of false positives.
    MediumAndAbove,
    /// Low chance of false positives.
    High,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DetectionConfidenceLevel::value] or
    /// [DetectionConfidenceLevel::name].
    UnknownValue(detection_confidence_level::UnknownValue),
}

#[doc(hidden)]
pub mod detection_confidence_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DetectionConfidenceLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::LowAndAbove => std::option::Option::Some(1),
            Self::MediumAndAbove => std::option::Option::Some(2),
            Self::High => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED")
            }
            Self::LowAndAbove => std::option::Option::Some("LOW_AND_ABOVE"),
            Self::MediumAndAbove => std::option::Option::Some("MEDIUM_AND_ABOVE"),
            Self::High => std::option::Option::Some("HIGH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DetectionConfidenceLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DetectionConfidenceLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DetectionConfidenceLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::LowAndAbove,
            2 => Self::MediumAndAbove,
            3 => Self::High,
            _ => Self::UnknownValue(detection_confidence_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DetectionConfidenceLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "LOW_AND_ABOVE" => Self::LowAndAbove,
            "MEDIUM_AND_ABOVE" => Self::MediumAndAbove,
            "HIGH" => Self::High,
            _ => Self::UnknownValue(detection_confidence_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DetectionConfidenceLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::LowAndAbove => serializer.serialize_i32(1),
            Self::MediumAndAbove => serializer.serialize_i32(2),
            Self::High => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DetectionConfidenceLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetectionConfidenceLevel>::new(
            ".google.cloud.modelarmor.v1.DetectionConfidenceLevel",
        ))
    }
}

/// For more information about each Sensitive Data Protection likelihood level,
/// see <https://cloud.google.com/sensitive-data-protection/docs/likelihood>.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SdpFindingLikelihood {
    /// Default value; same as POSSIBLE.
    Unspecified,
    /// Highest chance of a false positive.
    VeryUnlikely,
    /// High chance of a false positive.
    Unlikely,
    /// Some matching signals. The default value.
    Possible,
    /// Low chance of a false positive.
    Likely,
    /// Confidence level is high. Lowest chance of a false positive.
    VeryLikely,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SdpFindingLikelihood::value] or
    /// [SdpFindingLikelihood::name].
    UnknownValue(sdp_finding_likelihood::UnknownValue),
}

#[doc(hidden)]
pub mod sdp_finding_likelihood {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SdpFindingLikelihood {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::VeryUnlikely => std::option::Option::Some(1),
            Self::Unlikely => std::option::Option::Some(2),
            Self::Possible => std::option::Option::Some(3),
            Self::Likely => std::option::Option::Some(4),
            Self::VeryLikely => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SDP_FINDING_LIKELIHOOD_UNSPECIFIED"),
            Self::VeryUnlikely => std::option::Option::Some("VERY_UNLIKELY"),
            Self::Unlikely => std::option::Option::Some("UNLIKELY"),
            Self::Possible => std::option::Option::Some("POSSIBLE"),
            Self::Likely => std::option::Option::Some("LIKELY"),
            Self::VeryLikely => std::option::Option::Some("VERY_LIKELY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SdpFindingLikelihood {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SdpFindingLikelihood {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SdpFindingLikelihood {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::VeryUnlikely,
            2 => Self::Unlikely,
            3 => Self::Possible,
            4 => Self::Likely,
            5 => Self::VeryLikely,
            _ => Self::UnknownValue(sdp_finding_likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SdpFindingLikelihood {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SDP_FINDING_LIKELIHOOD_UNSPECIFIED" => Self::Unspecified,
            "VERY_UNLIKELY" => Self::VeryUnlikely,
            "UNLIKELY" => Self::Unlikely,
            "POSSIBLE" => Self::Possible,
            "LIKELY" => Self::Likely,
            "VERY_LIKELY" => Self::VeryLikely,
            _ => Self::UnknownValue(sdp_finding_likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SdpFindingLikelihood {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::VeryUnlikely => serializer.serialize_i32(1),
            Self::Unlikely => serializer.serialize_i32(2),
            Self::Possible => serializer.serialize_i32(3),
            Self::Likely => serializer.serialize_i32(4),
            Self::VeryLikely => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SdpFindingLikelihood {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SdpFindingLikelihood>::new(
            ".google.cloud.modelarmor.v1.SdpFindingLikelihood",
        ))
    }
}

/// A field indicating the outcome of the invocation, irrespective of match
/// status.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InvocationResult {
    /// Unused. Default value.
    Unspecified,
    /// All filters were invoked successfully.
    Success,
    /// Some filters were skipped or failed.
    Partial,
    /// All filters were skipped or failed.
    Failure,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InvocationResult::value] or
    /// [InvocationResult::name].
    UnknownValue(invocation_result::UnknownValue),
}

#[doc(hidden)]
pub mod invocation_result {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InvocationResult {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Success => std::option::Option::Some(1),
            Self::Partial => std::option::Option::Some(2),
            Self::Failure => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INVOCATION_RESULT_UNSPECIFIED"),
            Self::Success => std::option::Option::Some("SUCCESS"),
            Self::Partial => std::option::Option::Some("PARTIAL"),
            Self::Failure => std::option::Option::Some("FAILURE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InvocationResult {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InvocationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InvocationResult {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Success,
            2 => Self::Partial,
            3 => Self::Failure,
            _ => Self::UnknownValue(invocation_result::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InvocationResult {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INVOCATION_RESULT_UNSPECIFIED" => Self::Unspecified,
            "SUCCESS" => Self::Success,
            "PARTIAL" => Self::Partial,
            "FAILURE" => Self::Failure,
            _ => Self::UnknownValue(invocation_result::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InvocationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Success => serializer.serialize_i32(1),
            Self::Partial => serializer.serialize_i32(2),
            Self::Failure => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InvocationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InvocationResult>::new(
            ".google.cloud.modelarmor.v1.InvocationResult",
        ))
    }
}
