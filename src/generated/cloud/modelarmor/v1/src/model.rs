// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message describing Template resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Template {
    /// Identifier. name of resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. [Output only] Create time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. filter configuration for this template
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter_config: std::option::Option<crate::model::FilterConfig>,

    /// Optional. metadata for this template
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template_metadata: std::option::Option<crate::model::template::TemplateMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Template {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Template::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Template::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Template::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [filter_config][crate::model::Template::filter_config].
    pub fn set_filter_config<
        T: std::convert::Into<std::option::Option<crate::model::FilterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_config = v.into();
        self
    }

    /// Sets the value of [template_metadata][crate::model::Template::template_metadata].
    pub fn set_template_metadata<
        T: std::convert::Into<std::option::Option<crate::model::template::TemplateMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template_metadata = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Template::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Template {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.Template"
    }
}

/// Defines additional types related to [Template].
pub mod template {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing TemplateMetadata
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TemplateMetadata {
        /// Optional. If true, partial detector failures should be ignored.
        pub ignore_partial_invocation_failures: bool,

        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user by the service extension if the prompt trips Model Armor
        /// filters.
        pub custom_prompt_safety_error_code: i32,

        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the prompt trips Model Armor filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub custom_prompt_safety_error_message: std::string::String,

        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user if the LLM response trips Model Armor filters.
        pub custom_llm_response_safety_error_code: i32,

        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the LLM response trips Model Armor filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub custom_llm_response_safety_error_message: std::string::String,

        /// Optional. If true, log template crud operations.
        pub log_template_operations: bool,

        /// Optional. If true, log sanitize operations.
        pub log_sanitize_operations: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TemplateMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ignore_partial_invocation_failures][crate::model::template::TemplateMetadata::ignore_partial_invocation_failures].
        pub fn set_ignore_partial_invocation_failures<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.ignore_partial_invocation_failures = v.into();
            self
        }

        /// Sets the value of [custom_prompt_safety_error_code][crate::model::template::TemplateMetadata::custom_prompt_safety_error_code].
        pub fn set_custom_prompt_safety_error_code<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_prompt_safety_error_code = v.into();
            self
        }

        /// Sets the value of [custom_prompt_safety_error_message][crate::model::template::TemplateMetadata::custom_prompt_safety_error_message].
        pub fn set_custom_prompt_safety_error_message<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.custom_prompt_safety_error_message = v.into();
            self
        }

        /// Sets the value of [custom_llm_response_safety_error_code][crate::model::template::TemplateMetadata::custom_llm_response_safety_error_code].
        pub fn set_custom_llm_response_safety_error_code<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_llm_response_safety_error_code = v.into();
            self
        }

        /// Sets the value of [custom_llm_response_safety_error_message][crate::model::template::TemplateMetadata::custom_llm_response_safety_error_message].
        pub fn set_custom_llm_response_safety_error_message<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.custom_llm_response_safety_error_message = v.into();
            self
        }

        /// Sets the value of [log_template_operations][crate::model::template::TemplateMetadata::log_template_operations].
        pub fn set_log_template_operations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.log_template_operations = v.into();
            self
        }

        /// Sets the value of [log_sanitize_operations][crate::model::template::TemplateMetadata::log_sanitize_operations].
        pub fn set_log_sanitize_operations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.log_sanitize_operations = v.into();
            self
        }
    }

    impl wkt::message::Message for TemplateMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.Template.TemplateMetadata"
        }
    }
}

/// Message describing FloorSetting resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FloorSetting {
    /// Identifier. The resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. [Output only] Create timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. ModelArmor filter configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter_config: std::option::Option<crate::model::FilterConfig>,

    /// Optional. Floor Settings enforcement status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_floor_setting_enforcement: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FloorSetting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FloorSetting::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FloorSetting::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FloorSetting::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [filter_config][crate::model::FloorSetting::filter_config].
    pub fn set_filter_config<
        T: std::convert::Into<std::option::Option<crate::model::FilterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_config = v.into();
        self
    }

    /// Sets the value of [enable_floor_setting_enforcement][crate::model::FloorSetting::enable_floor_setting_enforcement].
    pub fn set_enable_floor_setting_enforcement<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enable_floor_setting_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for FloorSetting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FloorSetting"
    }
}

/// Message for requesting list of Templates
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTemplatesRequest {
    /// Required. Parent value for ListTemplatesRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ListTemplatesRequest"
    }
}

/// Message for response to listing Templates
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTemplatesResponse {
    /// The list of Template
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub templates: std::vec::Vec<crate::model::Template>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [templates][crate::model::ListTemplatesResponse::templates].
    pub fn set_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Template>,
    {
        use std::iter::Iterator;
        self.templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTemplatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ListTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTemplatesResponse {
    type PageItem = crate::model::Template;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTemplateRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.GetTemplateRequest"
    }
}

/// Message for creating a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTemplateRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// template_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::Template>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [template_id][crate::model::CreateTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [template][crate::model::CreateTemplateRequest::template].
    pub fn set_template<T: std::convert::Into<std::option::Option<crate::model::Template>>>(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.CreateTemplateRequest"
    }
}

/// Message for updating a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTemplateRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Template resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::Template>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [template][crate::model::UpdateTemplateRequest::template].
    pub fn set_template<T: std::convert::Into<std::option::Option<crate::model::Template>>>(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.UpdateTemplateRequest"
    }
}

/// Message for deleting a Template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTemplateRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.DeleteTemplateRequest"
    }
}

/// Message for getting a Floor Setting
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFloorSettingRequest {
    /// Required. The name of the floor setting to get, example
    /// projects/123/floorsetting.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFloorSettingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFloorSettingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFloorSettingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.GetFloorSettingRequest"
    }
}

/// Message for Updating a Floor Setting
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFloorSettingRequest {
    /// Required. The floor setting being updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub floor_setting: std::option::Option<crate::model::FloorSetting>,

    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// FloorSetting resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFloorSettingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [floor_setting][crate::model::UpdateFloorSettingRequest::floor_setting].
    pub fn set_floor_setting<
        T: std::convert::Into<std::option::Option<crate::model::FloorSetting>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.floor_setting = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFloorSettingRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFloorSettingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.UpdateFloorSettingRequest"
    }
}

/// Filters configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterConfig {
    /// Optional. Responsible AI settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rai_settings: std::option::Option<crate::model::RaiFilterSettings>,

    /// Optional. Sensitive Data Protection settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sdp_settings: std::option::Option<crate::model::SdpFilterSettings>,

    /// Optional. Prompt injection and Jailbreak filter settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pi_and_jailbreak_filter_settings:
        std::option::Option<crate::model::PiAndJailbreakFilterSettings>,

    /// Optional. Malicious URI filter settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub malicious_uri_filter_settings:
        std::option::Option<crate::model::MaliciousUriFilterSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rai_settings][crate::model::FilterConfig::rai_settings].
    pub fn set_rai_settings<
        T: std::convert::Into<std::option::Option<crate::model::RaiFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rai_settings = v.into();
        self
    }

    /// Sets the value of [sdp_settings][crate::model::FilterConfig::sdp_settings].
    pub fn set_sdp_settings<
        T: std::convert::Into<std::option::Option<crate::model::SdpFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_settings = v.into();
        self
    }

    /// Sets the value of [pi_and_jailbreak_filter_settings][crate::model::FilterConfig::pi_and_jailbreak_filter_settings].
    pub fn set_pi_and_jailbreak_filter_settings<
        T: std::convert::Into<std::option::Option<crate::model::PiAndJailbreakFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pi_and_jailbreak_filter_settings = v.into();
        self
    }

    /// Sets the value of [malicious_uri_filter_settings][crate::model::FilterConfig::malicious_uri_filter_settings].
    pub fn set_malicious_uri_filter_settings<
        T: std::convert::Into<std::option::Option<crate::model::MaliciousUriFilterSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.malicious_uri_filter_settings = v.into();
        self
    }
}

impl wkt::message::Message for FilterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FilterConfig"
    }
}

/// Prompt injection and Jailbreak Filter settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PiAndJailbreakFilterSettings {
    /// Optional. Tells whether Prompt injection and Jailbreak filter is enabled or
    /// disabled.
    pub filter_enforcement:
        crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement,

    /// Optional. Confidence level for this filter.
    /// Confidence level is used to determine the threshold for the filter. If
    /// detection confidence is equal to or greater than the specified level, a
    /// positive match is reported. Confidence level will only be used if the
    /// filter is enabled.
    pub confidence_level: crate::model::DetectionConfidenceLevel,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PiAndJailbreakFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::PiAndJailbreakFilterSettings::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<
                crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }

    /// Sets the value of [confidence_level][crate::model::PiAndJailbreakFilterSettings::confidence_level].
    pub fn set_confidence_level<T: std::convert::Into<crate::model::DetectionConfidenceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidence_level = v.into();
        self
    }
}

impl wkt::message::Message for PiAndJailbreakFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.PiAndJailbreakFilterSettings"
    }
}

/// Defines additional types related to [PiAndJailbreakFilterSettings].
pub mod pi_and_jailbreak_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Prompt Injection and Jailbreak filter
    /// (ENABLED/DISABLED).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PiAndJailbreakFilterEnforcement(i32);

    impl PiAndJailbreakFilterEnforcement {
        /// Same as Disabled
        pub const PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED: PiAndJailbreakFilterEnforcement =
            PiAndJailbreakFilterEnforcement::new(0);

        /// Enabled
        pub const ENABLED: PiAndJailbreakFilterEnforcement =
            PiAndJailbreakFilterEnforcement::new(1);

        /// Enabled
        pub const DISABLED: PiAndJailbreakFilterEnforcement =
            PiAndJailbreakFilterEnforcement::new(2);

        /// Creates a new PiAndJailbreakFilterEnforcement instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENABLED"),
                2 => std::borrow::Cow::Borrowed("DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED)
                }
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for PiAndJailbreakFilterEnforcement {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for PiAndJailbreakFilterEnforcement {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Malicious URI filter settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaliciousUriFilterSettings {
    /// Optional. Tells whether the Malicious URI filter is enabled or disabled.
    pub filter_enforcement:
        crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaliciousUriFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::MaliciousUriFilterSettings::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<
                crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for MaliciousUriFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterSettings"
    }
}

/// Defines additional types related to [MaliciousUriFilterSettings].
pub mod malicious_uri_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Malicious URI filter (ENABLED/DISABLED).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MaliciousUriFilterEnforcement(i32);

    impl MaliciousUriFilterEnforcement {
        /// Same as Disabled
        pub const MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED: MaliciousUriFilterEnforcement =
            MaliciousUriFilterEnforcement::new(0);

        /// Enabled
        pub const ENABLED: MaliciousUriFilterEnforcement = MaliciousUriFilterEnforcement::new(1);

        /// Disabled
        pub const DISABLED: MaliciousUriFilterEnforcement = MaliciousUriFilterEnforcement::new(2);

        /// Creates a new MaliciousUriFilterEnforcement instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENABLED"),
                2 => std::borrow::Cow::Borrowed("DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED)
                }
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MaliciousUriFilterEnforcement {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MaliciousUriFilterEnforcement {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Responsible AI Filter settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RaiFilterSettings {
    /// Required. List of Responsible AI filters enabled for template.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rai_filters: std::vec::Vec<crate::model::rai_filter_settings::RaiFilter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RaiFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rai_filters][crate::model::RaiFilterSettings::rai_filters].
    pub fn set_rai_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rai_filter_settings::RaiFilter>,
    {
        use std::iter::Iterator;
        self.rai_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RaiFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterSettings"
    }
}

/// Defines additional types related to [RaiFilterSettings].
pub mod rai_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Responsible AI filter.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RaiFilter {
        /// Required. Type of responsible AI filter.
        pub filter_type: crate::model::RaiFilterType,

        /// Optional. Confidence level for this RAI filter.
        /// During data sanitization, if data is classified under this filter with a
        /// confidence level equal to or greater than the specified level, a positive
        /// match is reported. If the confidence level is unspecified (i.e., 0), the
        /// system will use a reasonable default level based on the `filter_type`.
        pub confidence_level: crate::model::DetectionConfidenceLevel,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RaiFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter_type][crate::model::rai_filter_settings::RaiFilter::filter_type].
        pub fn set_filter_type<T: std::convert::Into<crate::model::RaiFilterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.filter_type = v.into();
            self
        }

        /// Sets the value of [confidence_level][crate::model::rai_filter_settings::RaiFilter::confidence_level].
        pub fn set_confidence_level<
            T: std::convert::Into<crate::model::DetectionConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.confidence_level = v.into();
            self
        }
    }

    impl wkt::message::Message for RaiFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterSettings.RaiFilter"
        }
    }
}

/// Sensitive Data Protection settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpFilterSettings {
    /// Either of Sensitive Data Protection basic or advanced configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sdp_configuration: std::option::Option<crate::model::sdp_filter_settings::SdpConfiguration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration].
    ///
    /// Note that all the setters affecting `sdp_configuration` are mutually
    /// exclusive.
    pub fn set_sdp_configuration<
        T: std::convert::Into<
                std::option::Option<crate::model::sdp_filter_settings::SdpConfiguration>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = v.into();
        self
    }

    /// The value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// if it holds a `BasicConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpBasicConfig>> {
        #[allow(unreachable_patterns)]
        self.sdp_configuration.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// if it holds a `AdvancedConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advanced_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpAdvancedConfig>> {
        #[allow(unreachable_patterns)]
        self.sdp_configuration.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// to hold a `BasicConfig`.
    ///
    /// Note that all the setters affecting `sdp_configuration` are
    /// mutually exclusive.
    pub fn set_basic_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpBasicConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = std::option::Option::Some(
            crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(v.into()),
        );
        self
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// to hold a `AdvancedConfig`.
    ///
    /// Note that all the setters affecting `sdp_configuration` are
    /// mutually exclusive.
    pub fn set_advanced_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpAdvancedConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = std::option::Option::Some(
            crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SdpFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFilterSettings"
    }
}

/// Defines additional types related to [SdpFilterSettings].
pub mod sdp_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Either of Sensitive Data Protection basic or advanced configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SdpConfiguration {
        /// Optional. Basic Sensitive Data Protection configuration inspects the
        /// content for sensitive data using a fixed set of six info-types. Sensitive
        /// Data Protection templates cannot be used with basic configuration. Only
        /// Sensitive Data Protection inspection operation is supported with basic
        /// configuration.
        BasicConfig(std::boxed::Box<crate::model::SdpBasicConfig>),
        /// Optional. Advanced Sensitive Data Protection configuration which enables
        /// use of Sensitive Data Protection templates. Supports both Sensitive Data
        /// Protection inspection and de-identification operations.
        AdvancedConfig(std::boxed::Box<crate::model::SdpAdvancedConfig>),
    }
}

/// Sensitive Data Protection basic configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpBasicConfig {
    /// Optional. Tells whether the Sensitive Data Protection basic config is
    /// enabled or disabled.
    pub filter_enforcement: crate::model::sdp_basic_config::SdpBasicConfigEnforcement,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpBasicConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::SdpBasicConfig::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<crate::model::sdp_basic_config::SdpBasicConfigEnforcement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for SdpBasicConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpBasicConfig"
    }
}

/// Defines additional types related to [SdpBasicConfig].
pub mod sdp_basic_config {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Sensitive Data Protection basic config
    /// (ENABLED/DISABLED).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SdpBasicConfigEnforcement(i32);

    impl SdpBasicConfigEnforcement {
        /// Same as Disabled
        pub const SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED: SdpBasicConfigEnforcement =
            SdpBasicConfigEnforcement::new(0);

        /// Enabled
        pub const ENABLED: SdpBasicConfigEnforcement = SdpBasicConfigEnforcement::new(1);

        /// Disabled
        pub const DISABLED: SdpBasicConfigEnforcement = SdpBasicConfigEnforcement::new(2);

        /// Creates a new SdpBasicConfigEnforcement instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENABLED"),
                2 => std::borrow::Cow::Borrowed("DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED)
                }
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SdpBasicConfigEnforcement {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SdpBasicConfigEnforcement {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Sensitive Data Protection Advanced configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpAdvancedConfig {
    /// Optional. Sensitive Data Protection inspect template resource name
    ///
    /// If only inspect template is provided (de-identify template not provided),
    /// then Sensitive Data Protection InspectContent action is performed during
    /// Sanitization. All Sensitive Data Protection findings identified during
    /// inspection will be returned as SdpFinding in SdpInsepctionResult.
    ///
    /// e.g.
    /// `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template: std::string::String,

    /// Optional. Optional Sensitive Data Protection Deidentify template resource
    /// name.
    ///
    /// If provided then DeidentifyContent action is performed during Sanitization
    /// using this template and inspect template. The De-identified data will
    /// be returned in SdpDeidentifyResult.
    /// Note that all info-types present in the deidentify template must be present
    /// in inspect template.
    ///
    /// e.g.
    /// `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deidentify_template: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpAdvancedConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_template][crate::model::SdpAdvancedConfig::inspect_template].
    pub fn set_inspect_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::SdpAdvancedConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }
}

impl wkt::message::Message for SdpAdvancedConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpAdvancedConfig"
    }
}

/// Sanitize User Prompt request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeUserPromptRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User prompt data to sanitize.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_prompt_data: std::option::Option<crate::model::DataItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeUserPromptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SanitizeUserPromptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user_prompt_data][crate::model::SanitizeUserPromptRequest::user_prompt_data].
    pub fn set_user_prompt_data<
        T: std::convert::Into<std::option::Option<crate::model::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_prompt_data = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeUserPromptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeUserPromptRequest"
    }
}

/// Sanitize Model Response request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeModelResponseRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Model response data to sanitize.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_response_data: std::option::Option<crate::model::DataItem>,

    /// Optional. User Prompt associated with Model response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_prompt: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeModelResponseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SanitizeModelResponseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [model_response_data][crate::model::SanitizeModelResponseRequest::model_response_data].
    pub fn set_model_response_data<
        T: std::convert::Into<std::option::Option<crate::model::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_response_data = v.into();
        self
    }

    /// Sets the value of [user_prompt][crate::model::SanitizeModelResponseRequest::user_prompt].
    pub fn set_user_prompt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_prompt = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeModelResponseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeModelResponseRequest"
    }
}

/// Sanitized User Prompt Response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeUserPromptResponse {
    /// Output only. Sanitization Result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sanitization_result: std::option::Option<crate::model::SanitizationResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeUserPromptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sanitization_result][crate::model::SanitizeUserPromptResponse::sanitization_result].
    pub fn set_sanitization_result<
        T: std::convert::Into<std::option::Option<crate::model::SanitizationResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sanitization_result = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeUserPromptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeUserPromptResponse"
    }
}

/// Sanitized Model Response Response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizeModelResponseResponse {
    /// Output only. Sanitization Result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sanitization_result: std::option::Option<crate::model::SanitizationResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeModelResponseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sanitization_result][crate::model::SanitizeModelResponseResponse::sanitization_result].
    pub fn set_sanitization_result<
        T: std::convert::Into<std::option::Option<crate::model::SanitizationResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sanitization_result = v.into();
        self
    }
}

impl wkt::message::Message for SanitizeModelResponseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeModelResponseResponse"
    }
}

/// Sanitization result after applying all the filters on input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SanitizationResult {
    /// Output only. Overall filter match state for Sanitization.
    /// The state can have below two values.
    ///
    /// ) NO_MATCH_FOUND: No filters in configuration satisfy matching criteria.
    ///   In other words, input passed all filters.
    ///
    /// ) MATCH_FOUND: At least one filter in configuration satisfies matching.
    ///   In other words, input did not pass one or more filters.
    ///
    pub filter_match_state: crate::model::FilterMatchState,

    /// Output only. Results for all filters where the key is the filter name -
    /// either of "csam", "malicious_uris", "rai", "pi_and_jailbreak" ,"sdp".
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub filter_results: std::collections::HashMap<std::string::String, crate::model::FilterResult>,

    /// Output only. A field indicating the outcome of the invocation, irrespective
    /// of match status. It can have the following three values: SUCCESS: All
    /// filters were executed successfully. PARTIAL: Some filters were skipped or
    /// failed execution. FAILURE: All filters were skipped or failed execution.
    pub invocation_result: crate::model::InvocationResult,

    /// Output only. Metadata related to Sanitization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sanitization_metadata:
        std::option::Option<crate::model::sanitization_result::SanitizationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_match_state][crate::model::SanitizationResult::filter_match_state].
    pub fn set_filter_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_match_state = v.into();
        self
    }

    /// Sets the value of [invocation_result][crate::model::SanitizationResult::invocation_result].
    pub fn set_invocation_result<T: std::convert::Into<crate::model::InvocationResult>>(
        mut self,
        v: T,
    ) -> Self {
        self.invocation_result = v.into();
        self
    }

    /// Sets the value of [sanitization_metadata][crate::model::SanitizationResult::sanitization_metadata].
    pub fn set_sanitization_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::sanitization_result::SanitizationMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sanitization_metadata = v.into();
        self
    }

    /// Sets the value of [filter_results][crate::model::SanitizationResult::filter_results].
    pub fn set_filter_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FilterResult>,
    {
        use std::iter::Iterator;
        self.filter_results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SanitizationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizationResult"
    }
}

/// Defines additional types related to [SanitizationResult].
pub mod sanitization_result {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing Sanitization metadata.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SanitizationMetadata {
        /// Error code if any.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub error_code: i64,

        /// Error message if any.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SanitizationMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_code][crate::model::sanitization_result::SanitizationMetadata::error_code].
        pub fn set_error_code<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.error_code = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::sanitization_result::SanitizationMetadata::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for SanitizationMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.SanitizationResult.SanitizationMetadata"
        }
    }
}

/// Filter Result obtained after Sanitization operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterResult {
    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter_result: std::option::Option<crate::model::filter_result::FilterResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result].
    ///
    /// Note that all the setters affecting `filter_result` are mutually
    /// exclusive.
    pub fn set_filter_result<
        T: std::convert::Into<std::option::Option<crate::model::filter_result::FilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = v.into();
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `RaiFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rai_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RaiFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::RaiFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `SdpFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sdp_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::SdpFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `PiAndJailbreakFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pi_and_jailbreak_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PiAndJailbreakFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `MaliciousUriFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn malicious_uri_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaliciousUriFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::MaliciousUriFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `CsamFilterFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csam_filter_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CsamFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::CsamFilterFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `VirusScanFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn virus_scan_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VirusScanFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::VirusScanFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `RaiFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_rai_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::RaiFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::RaiFilterResult(v.into()),
        );
        self
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `SdpFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_sdp_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::SdpFilterResult(v.into()),
        );
        self
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `PiAndJailbreakFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_pi_and_jailbreak_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PiAndJailbreakFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(v.into()),
        );
        self
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `MaliciousUriFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_malicious_uri_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::MaliciousUriFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::MaliciousUriFilterResult(v.into()),
        );
        self
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `CsamFilterFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_csam_filter_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CsamFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::CsamFilterFilterResult(v.into()),
        );
        self
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `VirusScanFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_virus_scan_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::VirusScanFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::VirusScanFilterResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FilterResult"
    }
}

/// Defines additional types related to [FilterResult].
pub mod filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FilterResult {
        /// Responsible AI filter results.
        RaiFilterResult(std::boxed::Box<crate::model::RaiFilterResult>),
        /// Sensitive Data Protection results.
        SdpFilterResult(std::boxed::Box<crate::model::SdpFilterResult>),
        /// Prompt injection and Jailbreak filter results.
        PiAndJailbreakFilterResult(std::boxed::Box<crate::model::PiAndJailbreakFilterResult>),
        /// Malicious URI filter results.
        MaliciousUriFilterResult(std::boxed::Box<crate::model::MaliciousUriFilterResult>),
        /// CSAM filter results.
        CsamFilterFilterResult(std::boxed::Box<crate::model::CsamFilterResult>),
        /// Virus scan results.
        VirusScanFilterResult(std::boxed::Box<crate::model::VirusScanFilterResult>),
    }
}

/// Responsible AI Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RaiFilterResult {
    /// Output only. Reports whether the RAI filter was successfully executed or
    /// not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Overall filter match state for RAI.
    /// Value is MATCH_FOUND if at least one RAI filter confidence level is
    /// equal to or higher than the confidence level defined in configuration.
    pub match_state: crate::model::FilterMatchState,

    /// The map of RAI filter results where key is RAI filter type - either of
    /// "sexually_explicit", "hate_speech", "harassment", "dangerous".
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub rai_filter_type_results: std::collections::HashMap<
        std::string::String,
        crate::model::rai_filter_result::RaiFilterTypeResult,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RaiFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::RaiFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [match_state][crate::model::RaiFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::RaiFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rai_filter_type_results][crate::model::RaiFilterResult::rai_filter_type_results].
    pub fn set_rai_filter_type_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::rai_filter_result::RaiFilterTypeResult>,
    {
        use std::iter::Iterator;
        self.rai_filter_type_results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RaiFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterResult"
    }
}

/// Defines additional types related to [RaiFilterResult].
pub mod rai_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed Filter result for each of the responsible AI Filter Types.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RaiFilterTypeResult {
        /// Type of responsible AI filter.
        pub filter_type: crate::model::RaiFilterType,

        /// Confidence level identified for this RAI filter.
        pub confidence_level: crate::model::DetectionConfidenceLevel,

        /// Output only. Match state for this RAI filter.
        pub match_state: crate::model::FilterMatchState,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RaiFilterTypeResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter_type][crate::model::rai_filter_result::RaiFilterTypeResult::filter_type].
        pub fn set_filter_type<T: std::convert::Into<crate::model::RaiFilterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.filter_type = v.into();
            self
        }

        /// Sets the value of [confidence_level][crate::model::rai_filter_result::RaiFilterTypeResult::confidence_level].
        pub fn set_confidence_level<
            T: std::convert::Into<crate::model::DetectionConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.confidence_level = v.into();
            self
        }

        /// Sets the value of [match_state][crate::model::rai_filter_result::RaiFilterTypeResult::match_state].
        pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
            mut self,
            v: T,
        ) -> Self {
            self.match_state = v.into();
            self
        }
    }

    impl wkt::message::Message for RaiFilterTypeResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterResult.RaiFilterTypeResult"
        }
    }
}

/// Sensitive Data Protection filter result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpFilterResult {
    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::sdp_filter_result::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::sdp_filter_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::SdpFilterResult::result]
    /// if it holds a `InspectResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpInspectResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_result::Result::InspectResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::SdpFilterResult::result]
    /// if it holds a `DeidentifyResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deidentify_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpDeidentifyResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_result::Result::DeidentifyResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result]
    /// to hold a `InspectResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_inspect_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpInspectResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::sdp_filter_result::Result::InspectResult(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result]
    /// to hold a `DeidentifyResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_deidentify_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpDeidentifyResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::sdp_filter_result::Result::DeidentifyResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SdpFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFilterResult"
    }
}

/// Defines additional types related to [SdpFilterResult].
pub mod sdp_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Sensitive Data Protection Inspection result if inspection is performed.
        InspectResult(std::boxed::Box<crate::model::SdpInspectResult>),
        /// Sensitive Data Protection Deidentification result if deidentification is
        /// performed.
        DeidentifyResult(std::boxed::Box<crate::model::SdpDeidentifyResult>),
    }
}

/// Sensitive Data Protection Inspection Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpInspectResult {
    /// Output only. Reports whether Sensitive Data Protection inspection was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for SDP Inspection.
    /// Value is MATCH_FOUND if at least one Sensitive Data Protection finding is
    /// identified.
    pub match_state: crate::model::FilterMatchState,

    /// List of Sensitive Data Protection findings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub findings: std::vec::Vec<crate::model::SdpFinding>,

    /// If true, then there is possibility that more findings were identified and
    /// the findings returned are a subset of all findings. The findings
    /// list might be truncated because the input items were too large, or because
    /// the server reached the maximum amount of resources allowed for a single API
    /// call.
    pub findings_truncated: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpInspectResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::SdpInspectResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [match_state][crate::model::SdpInspectResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [findings_truncated][crate::model::SdpInspectResult::findings_truncated].
    pub fn set_findings_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.findings_truncated = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::SdpInspectResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [findings][crate::model::SdpInspectResult::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SdpFinding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SdpInspectResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpInspectResult"
    }
}

/// Represents Data item
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataItem {
    /// Either of text or bytes data.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_item: std::option::Option<crate::model::data_item::DataItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item].
    ///
    /// Note that all the setters affecting `data_item` are mutually
    /// exclusive.
    pub fn set_data_item<
        T: std::convert::Into<std::option::Option<crate::model::data_item::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// The value of [data_item][crate::model::DataItem::data_item]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::data_item::DataItem::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data_item][crate::model::DataItem::data_item]
    /// if it holds a `ByteItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn byte_item(&self) -> std::option::Option<&std::boxed::Box<crate::model::ByteDataItem>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::data_item::DataItem::ByteItem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::data_item::DataItem::Text(v.into()));
        self
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item]
    /// to hold a `ByteItem`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_byte_item<T: std::convert::Into<std::boxed::Box<crate::model::ByteDataItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::data_item::DataItem::ByteItem(v.into()));
        self
    }
}

impl wkt::message::Message for DataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.DataItem"
    }
}

/// Defines additional types related to [DataItem].
pub mod data_item {
    #[allow(unused_imports)]
    use super::*;

    /// Either of text or bytes data.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataItem {
        /// Plaintext string data for sanitization.
        Text(std::string::String),
        /// Data provided in the form of bytes.
        ByteItem(std::boxed::Box<crate::model::ByteDataItem>),
    }
}

/// Represents Byte Data item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ByteDataItem {
    /// Required. The type of byte data
    pub byte_data_type: crate::model::byte_data_item::ByteItemType,

    /// Required. Bytes Data
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub byte_data: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ByteDataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [byte_data_type][crate::model::ByteDataItem::byte_data_type].
    pub fn set_byte_data_type<T: std::convert::Into<crate::model::byte_data_item::ByteItemType>>(
        mut self,
        v: T,
    ) -> Self {
        self.byte_data_type = v.into();
        self
    }

    /// Sets the value of [byte_data][crate::model::ByteDataItem::byte_data].
    pub fn set_byte_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.byte_data = v.into();
        self
    }
}

impl wkt::message::Message for ByteDataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ByteDataItem"
    }
}

/// Defines additional types related to [ByteDataItem].
pub mod byte_data_item {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the type of byte data.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ByteItemType(i32);

    impl ByteItemType {
        /// Unused
        pub const BYTE_ITEM_TYPE_UNSPECIFIED: ByteItemType = ByteItemType::new(0);

        /// plain text
        pub const PLAINTEXT_UTF8: ByteItemType = ByteItemType::new(1);

        /// PDF
        pub const PDF: ByteItemType = ByteItemType::new(2);

        /// Creates a new ByteItemType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("BYTE_ITEM_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PLAINTEXT_UTF8"),
                2 => std::borrow::Cow::Borrowed("PDF"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "BYTE_ITEM_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::BYTE_ITEM_TYPE_UNSPECIFIED)
                }
                "PLAINTEXT_UTF8" => std::option::Option::Some(Self::PLAINTEXT_UTF8),
                "PDF" => std::option::Option::Some(Self::PDF),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ByteItemType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ByteItemType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Sensitive Data Protection Deidentification Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpDeidentifyResult {
    /// Output only. Reports whether Sensitive Data Protection deidentification was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for Sensitive Data Protection Deidentification.
    /// Value is MATCH_FOUND if content is de-identified.
    pub match_state: crate::model::FilterMatchState,

    /// De-identified data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::DataItem>,

    /// Total size in bytes that were transformed during deidentification.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// List of Sensitive Data Protection info-types that were de-identified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpDeidentifyResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::SdpDeidentifyResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [match_state][crate::model::SdpDeidentifyResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [data][crate::model::SdpDeidentifyResult::data].
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::DataItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::SdpDeidentifyResult::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::SdpDeidentifyResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [info_types][crate::model::SdpDeidentifyResult::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SdpDeidentifyResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpDeidentifyResult"
    }
}

/// Finding corresponding to Sensitive Data Protection filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SdpFinding {
    /// Name of Sensitive Data Protection info type for this finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub info_type: std::string::String,

    /// Identified confidence likelihood for `info_type`.
    pub likelihood: crate::model::SdpFindingLikelihood,

    /// Location for this finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::sdp_finding::SdpFindingLocation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::SdpFinding::info_type].
    pub fn set_info_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [likelihood][crate::model::SdpFinding::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::SdpFindingLikelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [location][crate::model::SdpFinding::location].
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::sdp_finding::SdpFindingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for SdpFinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFinding"
    }
}

/// Defines additional types related to [SdpFinding].
pub mod sdp_finding {
    #[allow(unused_imports)]
    use super::*;

    /// Location of this Sensitive Data Protection Finding within input content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SdpFindingLocation {
        /// Zero-based byte offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Note that when the content is not textual, this references
        /// the UTF-8 encoded textual representation of the content.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub byte_range: std::option::Option<crate::model::RangeInfo>,

        /// Unicode character offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Provided when the content is text.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub codepoint_range: std::option::Option<crate::model::RangeInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SdpFindingLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [byte_range][crate::model::sdp_finding::SdpFindingLocation::byte_range].
        pub fn set_byte_range<
            T: std::convert::Into<std::option::Option<crate::model::RangeInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.byte_range = v.into();
            self
        }

        /// Sets the value of [codepoint_range][crate::model::sdp_finding::SdpFindingLocation::codepoint_range].
        pub fn set_codepoint_range<
            T: std::convert::Into<std::option::Option<crate::model::RangeInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.codepoint_range = v.into();
            self
        }
    }

    impl wkt::message::Message for SdpFindingLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.SdpFinding.SdpFindingLocation"
        }
    }
}

/// Prompt injection and Jailbreak Filter Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PiAndJailbreakFilterResult {
    /// Output only. Reports whether Prompt injection and Jailbreak filter was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for Prompt injection and Jailbreak.
    pub match_state: crate::model::FilterMatchState,

    /// Confidence level identified for Prompt injection and Jailbreak.
    pub confidence_level: crate::model::DetectionConfidenceLevel,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PiAndJailbreakFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::PiAndJailbreakFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [match_state][crate::model::PiAndJailbreakFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [confidence_level][crate::model::PiAndJailbreakFilterResult::confidence_level].
    pub fn set_confidence_level<T: std::convert::Into<crate::model::DetectionConfidenceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidence_level = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::PiAndJailbreakFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PiAndJailbreakFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.PiAndJailbreakFilterResult"
    }
}

/// Malicious URI Filter Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaliciousUriFilterResult {
    /// Output only. Reports whether Malicious URI filter was successfully executed
    /// or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for this Malicious URI.
    /// Value is MATCH_FOUND if at least one Malicious URI is found.
    pub match_state: crate::model::FilterMatchState,

    /// List of Malicious URIs found in data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub malicious_uri_matched_items:
        std::vec::Vec<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaliciousUriFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::MaliciousUriFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [match_state][crate::model::MaliciousUriFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::MaliciousUriFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [malicious_uri_matched_items][crate::model::MaliciousUriFilterResult::malicious_uri_matched_items].
    pub fn set_malicious_uri_matched_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>,
    {
        use std::iter::Iterator;
        self.malicious_uri_matched_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaliciousUriFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterResult"
    }
}

/// Defines additional types related to [MaliciousUriFilterResult].
pub mod malicious_uri_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Information regarding malicious URI and its location within the input
    /// content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MaliciousUriMatchedItem {
        /// Malicious URI.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// List of locations where Malicious URI is identified.
        /// The `locations` field is supported only for plaintext content i.e.
        /// ByteItemType.PLAINTEXT_UTF8
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub locations: std::vec::Vec<crate::model::RangeInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MaliciousUriMatchedItem {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [locations][crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem::locations].
        pub fn set_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RangeInfo>,
        {
            use std::iter::Iterator;
            self.locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MaliciousUriMatchedItem {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterResult.MaliciousUriMatchedItem"
        }
    }
}

/// Virus scan results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirusScanFilterResult {
    /// Output only. Reports whether Virus Scan was successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution status is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match status for Virus.
    /// Value is MATCH_FOUND if the data is infected with a virus.
    pub match_state: crate::model::FilterMatchState,

    /// Type of content scanned.
    pub scanned_content_type: crate::model::virus_scan_filter_result::ScannedContentType,

    /// Size of scanned content in bytes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub scanned_size: std::option::Option<i64>,

    /// List of Viruses identified.
    /// This field will be empty if no virus was detected.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub virus_details: std::vec::Vec<crate::model::VirusDetail>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirusScanFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::VirusScanFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [match_state][crate::model::VirusScanFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [scanned_content_type][crate::model::VirusScanFilterResult::scanned_content_type].
    pub fn set_scanned_content_type<
        T: std::convert::Into<crate::model::virus_scan_filter_result::ScannedContentType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scanned_content_type = v.into();
        self
    }

    /// Sets the value of [scanned_size][crate::model::VirusScanFilterResult::scanned_size].
    pub fn set_scanned_size<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scanned_size = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::VirusScanFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [virus_details][crate::model::VirusScanFilterResult::virus_details].
    pub fn set_virus_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VirusDetail>,
    {
        use std::iter::Iterator;
        self.virus_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VirusScanFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.VirusScanFilterResult"
    }
}

/// Defines additional types related to [VirusScanFilterResult].
pub mod virus_scan_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Type of content scanned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ScannedContentType(i32);

    impl ScannedContentType {
        /// Unused
        pub const SCANNED_CONTENT_TYPE_UNSPECIFIED: ScannedContentType = ScannedContentType::new(0);

        /// Unknown content
        pub const UNKNOWN: ScannedContentType = ScannedContentType::new(1);

        /// Plaintext
        pub const PLAINTEXT: ScannedContentType = ScannedContentType::new(2);

        /// PDF
        /// Scanning for only PDF is supported.
        pub const PDF: ScannedContentType = ScannedContentType::new(3);

        /// Creates a new ScannedContentType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SCANNED_CONTENT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("UNKNOWN"),
                2 => std::borrow::Cow::Borrowed("PLAINTEXT"),
                3 => std::borrow::Cow::Borrowed("PDF"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SCANNED_CONTENT_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SCANNED_CONTENT_TYPE_UNSPECIFIED)
                }
                "UNKNOWN" => std::option::Option::Some(Self::UNKNOWN),
                "PLAINTEXT" => std::option::Option::Some(Self::PLAINTEXT),
                "PDF" => std::option::Option::Some(Self::PDF),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ScannedContentType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ScannedContentType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details of an identified virus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirusDetail {
    /// Name of vendor that produced this virus identification.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vendor: std::string::String,

    /// Names of this Virus.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    /// Threat type of the identified virus
    pub threat_type: crate::model::virus_detail::ThreatType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirusDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vendor][crate::model::VirusDetail::vendor].
    pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vendor = v.into();
        self
    }

    /// Sets the value of [threat_type][crate::model::VirusDetail::threat_type].
    pub fn set_threat_type<T: std::convert::Into<crate::model::virus_detail::ThreatType>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_type = v.into();
        self
    }

    /// Sets the value of [names][crate::model::VirusDetail::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VirusDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.VirusDetail"
    }
}

/// Defines additional types related to [VirusDetail].
pub mod virus_detail {
    #[allow(unused_imports)]
    use super::*;

    /// Defines all the threat types of a virus
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ThreatType(i32);

    impl ThreatType {
        /// Unused
        pub const THREAT_TYPE_UNSPECIFIED: ThreatType = ThreatType::new(0);

        /// Unable to categorize threat
        pub const UNKNOWN: ThreatType = ThreatType::new(1);

        /// Virus or Worm threat.
        pub const VIRUS_OR_WORM: ThreatType = ThreatType::new(2);

        /// Malicious program. E.g. Spyware, Trojan.
        pub const MALICIOUS_PROGRAM: ThreatType = ThreatType::new(3);

        /// Potentially harmful content. E.g. Injected code, Macro
        pub const POTENTIALLY_HARMFUL_CONTENT: ThreatType = ThreatType::new(4);

        /// Potentially unwanted content. E.g. Adware.
        pub const POTENTIALLY_UNWANTED_CONTENT: ThreatType = ThreatType::new(5);

        /// Creates a new ThreatType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("THREAT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("UNKNOWN"),
                2 => std::borrow::Cow::Borrowed("VIRUS_OR_WORM"),
                3 => std::borrow::Cow::Borrowed("MALICIOUS_PROGRAM"),
                4 => std::borrow::Cow::Borrowed("POTENTIALLY_HARMFUL_CONTENT"),
                5 => std::borrow::Cow::Borrowed("POTENTIALLY_UNWANTED_CONTENT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "THREAT_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::THREAT_TYPE_UNSPECIFIED)
                }
                "UNKNOWN" => std::option::Option::Some(Self::UNKNOWN),
                "VIRUS_OR_WORM" => std::option::Option::Some(Self::VIRUS_OR_WORM),
                "MALICIOUS_PROGRAM" => std::option::Option::Some(Self::MALICIOUS_PROGRAM),
                "POTENTIALLY_HARMFUL_CONTENT" => {
                    std::option::Option::Some(Self::POTENTIALLY_HARMFUL_CONTENT)
                }
                "POTENTIALLY_UNWANTED_CONTENT" => {
                    std::option::Option::Some(Self::POTENTIALLY_UNWANTED_CONTENT)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ThreatType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ThreatType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// CSAM (Child Safety Abuse Material) Filter Result
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CsamFilterResult {
    /// Output only. Reports whether the CSAM filter was successfully executed or
    /// not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for CSAM.
    pub match_state: crate::model::FilterMatchState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CsamFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::CsamFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [match_state][crate::model::CsamFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::CsamFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CsamFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.CsamFilterResult"
    }
}

/// Message item to report information, warning or error messages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MessageItem {
    /// Type of message.
    pub message_type: crate::model::message_item::MessageType,

    /// The message content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_type][crate::model::MessageItem::message_type].
    pub fn set_message_type<T: std::convert::Into<crate::model::message_item::MessageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = v.into();
        self
    }

    /// Sets the value of [message][crate::model::MessageItem::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for MessageItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MessageItem"
    }
}

/// Defines additional types related to [MessageItem].
pub mod message_item {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the type of message.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MessageType(i32);

    impl MessageType {
        /// Unused
        pub const MESSAGE_TYPE_UNSPECIFIED: MessageType = MessageType::new(0);

        /// Information related message.
        pub const INFO: MessageType = MessageType::new(1);

        /// Warning related message.
        pub const WARNING: MessageType = MessageType::new(2);

        /// Error message.
        pub const ERROR: MessageType = MessageType::new(3);

        /// Creates a new MessageType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MESSAGE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INFO"),
                2 => std::borrow::Cow::Borrowed("WARNING"),
                3 => std::borrow::Cow::Borrowed("ERROR"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MESSAGE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::MESSAGE_TYPE_UNSPECIFIED)
                }
                "INFO" => std::option::Option::Some(Self::INFO),
                "WARNING" => std::option::Option::Some(Self::WARNING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MessageType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MessageType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Half-open range interval [start, end)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RangeInfo {
    /// For proto3, value cannot be set to 0 unless the field is optional.
    /// Ref: <https://protobuf.dev/programming-guides/proto3/#default>
    /// Index of first character (inclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub start: std::option::Option<i64>,

    /// Index of last character (exclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub end: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RangeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::RangeInfo::start].
    pub fn set_start<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.start = v.into();
        self
    }

    /// Sets the value of [end][crate::model::RangeInfo::end].
    pub fn set_end<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.end = v.into();
        self
    }
}

impl wkt::message::Message for RangeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RangeInfo"
    }
}

/// Option to specify filter match state.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct FilterMatchState(i32);

impl FilterMatchState {
    /// Unused
    pub const FILTER_MATCH_STATE_UNSPECIFIED: FilterMatchState = FilterMatchState::new(0);

    /// Matching criteria is not achieved for filters.
    pub const NO_MATCH_FOUND: FilterMatchState = FilterMatchState::new(1);

    /// Matching criteria is achieved for the filter.
    pub const MATCH_FOUND: FilterMatchState = FilterMatchState::new(2);

    /// Creates a new FilterMatchState instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("FILTER_MATCH_STATE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("NO_MATCH_FOUND"),
            2 => std::borrow::Cow::Borrowed("MATCH_FOUND"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "FILTER_MATCH_STATE_UNSPECIFIED" => {
                std::option::Option::Some(Self::FILTER_MATCH_STATE_UNSPECIFIED)
            }
            "NO_MATCH_FOUND" => std::option::Option::Some(Self::NO_MATCH_FOUND),
            "MATCH_FOUND" => std::option::Option::Some(Self::MATCH_FOUND),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for FilterMatchState {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for FilterMatchState {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Enum which reports whether a specific filter executed successfully or not.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct FilterExecutionState(i32);

impl FilterExecutionState {
    /// Unused
    pub const FILTER_EXECUTION_STATE_UNSPECIFIED: FilterExecutionState =
        FilterExecutionState::new(0);

    /// Filter executed successfully
    pub const EXECUTION_SUCCESS: FilterExecutionState = FilterExecutionState::new(1);

    /// Filter execution was skipped. This can happen due to server-side error
    /// or permission issue.
    pub const EXECUTION_SKIPPED: FilterExecutionState = FilterExecutionState::new(2);

    /// Creates a new FilterExecutionState instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("FILTER_EXECUTION_STATE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("EXECUTION_SUCCESS"),
            2 => std::borrow::Cow::Borrowed("EXECUTION_SKIPPED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "FILTER_EXECUTION_STATE_UNSPECIFIED" => {
                std::option::Option::Some(Self::FILTER_EXECUTION_STATE_UNSPECIFIED)
            }
            "EXECUTION_SUCCESS" => std::option::Option::Some(Self::EXECUTION_SUCCESS),
            "EXECUTION_SKIPPED" => std::option::Option::Some(Self::EXECUTION_SKIPPED),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for FilterExecutionState {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for FilterExecutionState {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Options for responsible AI Filter Types.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct RaiFilterType(i32);

impl RaiFilterType {
    /// Unspecified filter type.
    pub const RAI_FILTER_TYPE_UNSPECIFIED: RaiFilterType = RaiFilterType::new(0);

    /// Sexually Explicit.
    pub const SEXUALLY_EXPLICIT: RaiFilterType = RaiFilterType::new(2);

    /// Hate Speech.
    pub const HATE_SPEECH: RaiFilterType = RaiFilterType::new(3);

    /// Harassment.
    pub const HARASSMENT: RaiFilterType = RaiFilterType::new(6);

    /// Danger
    pub const DANGEROUS: RaiFilterType = RaiFilterType::new(17);

    /// Creates a new RaiFilterType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("RAI_FILTER_TYPE_UNSPECIFIED"),
            2 => std::borrow::Cow::Borrowed("SEXUALLY_EXPLICIT"),
            3 => std::borrow::Cow::Borrowed("HATE_SPEECH"),
            6 => std::borrow::Cow::Borrowed("HARASSMENT"),
            17 => std::borrow::Cow::Borrowed("DANGEROUS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "RAI_FILTER_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::RAI_FILTER_TYPE_UNSPECIFIED)
            }
            "SEXUALLY_EXPLICIT" => std::option::Option::Some(Self::SEXUALLY_EXPLICIT),
            "HATE_SPEECH" => std::option::Option::Some(Self::HATE_SPEECH),
            "HARASSMENT" => std::option::Option::Some(Self::HARASSMENT),
            "DANGEROUS" => std::option::Option::Some(Self::DANGEROUS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for RaiFilterType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for RaiFilterType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Confidence levels for detectors.
/// Higher value maps to a greater confidence level. To enforce stricter level a
/// lower value should be used.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DetectionConfidenceLevel(i32);

impl DetectionConfidenceLevel {
    /// Same as MEDIUM_AND_ABOVE.
    pub const DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED: DetectionConfidenceLevel =
        DetectionConfidenceLevel::new(0);

    /// Highest chance of a false positive.
    pub const LOW_AND_ABOVE: DetectionConfidenceLevel = DetectionConfidenceLevel::new(1);

    /// Some chance of false positives.
    pub const MEDIUM_AND_ABOVE: DetectionConfidenceLevel = DetectionConfidenceLevel::new(2);

    /// Low chance of false positives.
    pub const HIGH: DetectionConfidenceLevel = DetectionConfidenceLevel::new(3);

    /// Creates a new DetectionConfidenceLevel instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("LOW_AND_ABOVE"),
            2 => std::borrow::Cow::Borrowed("MEDIUM_AND_ABOVE"),
            3 => std::borrow::Cow::Borrowed("HIGH"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED" => {
                std::option::Option::Some(Self::DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED)
            }
            "LOW_AND_ABOVE" => std::option::Option::Some(Self::LOW_AND_ABOVE),
            "MEDIUM_AND_ABOVE" => std::option::Option::Some(Self::MEDIUM_AND_ABOVE),
            "HIGH" => std::option::Option::Some(Self::HIGH),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DetectionConfidenceLevel {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DetectionConfidenceLevel {
    fn default() -> Self {
        Self::new(0)
    }
}

/// For more information about each Sensitive Data Protection likelihood level,
/// see <https://cloud.google.com/sensitive-data-protection/docs/likelihood>.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct SdpFindingLikelihood(i32);

impl SdpFindingLikelihood {
    /// Default value; same as POSSIBLE.
    pub const SDP_FINDING_LIKELIHOOD_UNSPECIFIED: SdpFindingLikelihood =
        SdpFindingLikelihood::new(0);

    /// Highest chance of a false positive.
    pub const VERY_UNLIKELY: SdpFindingLikelihood = SdpFindingLikelihood::new(1);

    /// High chance of a false positive.
    pub const UNLIKELY: SdpFindingLikelihood = SdpFindingLikelihood::new(2);

    /// Some matching signals. The default value.
    pub const POSSIBLE: SdpFindingLikelihood = SdpFindingLikelihood::new(3);

    /// Low chance of a false positive.
    pub const LIKELY: SdpFindingLikelihood = SdpFindingLikelihood::new(4);

    /// Confidence level is high. Lowest chance of a false positive.
    pub const VERY_LIKELY: SdpFindingLikelihood = SdpFindingLikelihood::new(5);

    /// Creates a new SdpFindingLikelihood instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SDP_FINDING_LIKELIHOOD_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("VERY_UNLIKELY"),
            2 => std::borrow::Cow::Borrowed("UNLIKELY"),
            3 => std::borrow::Cow::Borrowed("POSSIBLE"),
            4 => std::borrow::Cow::Borrowed("LIKELY"),
            5 => std::borrow::Cow::Borrowed("VERY_LIKELY"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SDP_FINDING_LIKELIHOOD_UNSPECIFIED" => {
                std::option::Option::Some(Self::SDP_FINDING_LIKELIHOOD_UNSPECIFIED)
            }
            "VERY_UNLIKELY" => std::option::Option::Some(Self::VERY_UNLIKELY),
            "UNLIKELY" => std::option::Option::Some(Self::UNLIKELY),
            "POSSIBLE" => std::option::Option::Some(Self::POSSIBLE),
            "LIKELY" => std::option::Option::Some(Self::LIKELY),
            "VERY_LIKELY" => std::option::Option::Some(Self::VERY_LIKELY),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for SdpFindingLikelihood {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for SdpFindingLikelihood {
    fn default() -> Self {
        Self::new(0)
    }
}

/// A field indicating the outcome of the invocation, irrespective of match
/// status.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct InvocationResult(i32);

impl InvocationResult {
    /// Unused. Default value.
    pub const INVOCATION_RESULT_UNSPECIFIED: InvocationResult = InvocationResult::new(0);

    /// All filters were invoked successfully.
    pub const SUCCESS: InvocationResult = InvocationResult::new(1);

    /// Some filters were skipped or failed.
    pub const PARTIAL: InvocationResult = InvocationResult::new(2);

    /// All filters were skipped or failed.
    pub const FAILURE: InvocationResult = InvocationResult::new(3);

    /// Creates a new InvocationResult instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("INVOCATION_RESULT_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("SUCCESS"),
            2 => std::borrow::Cow::Borrowed("PARTIAL"),
            3 => std::borrow::Cow::Borrowed("FAILURE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "INVOCATION_RESULT_UNSPECIFIED" => {
                std::option::Option::Some(Self::INVOCATION_RESULT_UNSPECIFIED)
            }
            "SUCCESS" => std::option::Option::Some(Self::SUCCESS),
            "PARTIAL" => std::option::Option::Some(Self::PARTIAL),
            "FAILURE" => std::option::Option::Some(Self::FAILURE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for InvocationResult {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for InvocationResult {
    fn default() -> Self {
        Self::new(0)
    }
}
