// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message describing Template resource
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Template {
    /// Identifier. name of resource
    pub name: std::string::String,

    /// Output only. [Output only] Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. filter configuration for this template
    pub filter_config: std::option::Option<crate::model::FilterConfig>,

    /// Optional. metadata for this template
    pub template_metadata: std::option::Option<crate::model::template::TemplateMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Template {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Template::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Template::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Template::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Template::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Template::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Template::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [filter_config][crate::model::Template::filter_config].
    pub fn set_filter_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FilterConfig>,
    {
        self.filter_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter_config][crate::model::Template::filter_config].
    pub fn set_or_clear_filter_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FilterConfig>,
    {
        self.filter_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [template_metadata][crate::model::Template::template_metadata].
    pub fn set_template_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::template::TemplateMetadata>,
    {
        self.template_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template_metadata][crate::model::Template::template_metadata].
    pub fn set_or_clear_template_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::template::TemplateMetadata>,
    {
        self.template_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Template {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.Template"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Template {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __filter_config,
            __template_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Template")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "filterConfig" => Ok(__FieldTag::__filter_config),
                            "filter_config" => Ok(__FieldTag::__filter_config),
                            "templateMetadata" => Ok(__FieldTag::__template_metadata),
                            "template_metadata" => Ok(__FieldTag::__template_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Template;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Template")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter_config => {
                            if !fields.insert(__FieldTag::__filter_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_config",
                                ));
                            }
                            result.filter_config = map
                                .next_value::<std::option::Option<crate::model::FilterConfig>>()?;
                        }
                        __FieldTag::__template_metadata => {
                            if !fields.insert(__FieldTag::__template_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_metadata",
                                ));
                            }
                            result.template_metadata = map.next_value::<std::option::Option<crate::model::template::TemplateMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Template {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.filter_config.is_some() {
            state.serialize_entry("filterConfig", &self.filter_config)?;
        }
        if self.template_metadata.is_some() {
            state.serialize_entry("templateMetadata", &self.template_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Template {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Template");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("filter_config", &self.filter_config);
        debug_struct.field("template_metadata", &self.template_metadata);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Template].
pub mod template {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing TemplateMetadata
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TemplateMetadata {
        /// Optional. If true, partial detector failures should be ignored.
        pub ignore_partial_invocation_failures: bool,

        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user by the service extension if the prompt trips Model Armor
        /// filters.
        pub custom_prompt_safety_error_code: i32,

        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the prompt trips Model Armor filters.
        pub custom_prompt_safety_error_message: std::string::String,

        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user if the LLM response trips Model Armor filters.
        pub custom_llm_response_safety_error_code: i32,

        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the LLM response trips Model Armor filters.
        pub custom_llm_response_safety_error_message: std::string::String,

        /// Optional. If true, log template crud operations.
        pub log_template_operations: bool,

        /// Optional. If true, log sanitize operations.
        pub log_sanitize_operations: bool,

        /// Optional. Metadata for multi language detection.
        pub multi_language_detection:
            std::option::Option<crate::model::template::template_metadata::MultiLanguageDetection>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TemplateMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ignore_partial_invocation_failures][crate::model::template::TemplateMetadata::ignore_partial_invocation_failures].
        pub fn set_ignore_partial_invocation_failures<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.ignore_partial_invocation_failures = v.into();
            self
        }

        /// Sets the value of [custom_prompt_safety_error_code][crate::model::template::TemplateMetadata::custom_prompt_safety_error_code].
        pub fn set_custom_prompt_safety_error_code<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_prompt_safety_error_code = v.into();
            self
        }

        /// Sets the value of [custom_prompt_safety_error_message][crate::model::template::TemplateMetadata::custom_prompt_safety_error_message].
        pub fn set_custom_prompt_safety_error_message<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.custom_prompt_safety_error_message = v.into();
            self
        }

        /// Sets the value of [custom_llm_response_safety_error_code][crate::model::template::TemplateMetadata::custom_llm_response_safety_error_code].
        pub fn set_custom_llm_response_safety_error_code<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_llm_response_safety_error_code = v.into();
            self
        }

        /// Sets the value of [custom_llm_response_safety_error_message][crate::model::template::TemplateMetadata::custom_llm_response_safety_error_message].
        pub fn set_custom_llm_response_safety_error_message<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.custom_llm_response_safety_error_message = v.into();
            self
        }

        /// Sets the value of [log_template_operations][crate::model::template::TemplateMetadata::log_template_operations].
        pub fn set_log_template_operations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.log_template_operations = v.into();
            self
        }

        /// Sets the value of [log_sanitize_operations][crate::model::template::TemplateMetadata::log_sanitize_operations].
        pub fn set_log_sanitize_operations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.log_sanitize_operations = v.into();
            self
        }

        /// Sets the value of [multi_language_detection][crate::model::template::TemplateMetadata::multi_language_detection].
        pub fn set_multi_language_detection<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::template::template_metadata::MultiLanguageDetection,
                >,
        {
            self.multi_language_detection = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [multi_language_detection][crate::model::template::TemplateMetadata::multi_language_detection].
        pub fn set_or_clear_multi_language_detection<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::template::template_metadata::MultiLanguageDetection,
                >,
        {
            self.multi_language_detection = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TemplateMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.Template.TemplateMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TemplateMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ignore_partial_invocation_failures,
                __custom_prompt_safety_error_code,
                __custom_prompt_safety_error_message,
                __custom_llm_response_safety_error_code,
                __custom_llm_response_safety_error_message,
                __log_template_operations,
                __log_sanitize_operations,
                __multi_language_detection,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TemplateMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ignorePartialInvocationFailures" => {
                                    Ok(__FieldTag::__ignore_partial_invocation_failures)
                                }
                                "ignore_partial_invocation_failures" => {
                                    Ok(__FieldTag::__ignore_partial_invocation_failures)
                                }
                                "customPromptSafetyErrorCode" => {
                                    Ok(__FieldTag::__custom_prompt_safety_error_code)
                                }
                                "custom_prompt_safety_error_code" => {
                                    Ok(__FieldTag::__custom_prompt_safety_error_code)
                                }
                                "customPromptSafetyErrorMessage" => {
                                    Ok(__FieldTag::__custom_prompt_safety_error_message)
                                }
                                "custom_prompt_safety_error_message" => {
                                    Ok(__FieldTag::__custom_prompt_safety_error_message)
                                }
                                "customLlmResponseSafetyErrorCode" => {
                                    Ok(__FieldTag::__custom_llm_response_safety_error_code)
                                }
                                "custom_llm_response_safety_error_code" => {
                                    Ok(__FieldTag::__custom_llm_response_safety_error_code)
                                }
                                "customLlmResponseSafetyErrorMessage" => {
                                    Ok(__FieldTag::__custom_llm_response_safety_error_message)
                                }
                                "custom_llm_response_safety_error_message" => {
                                    Ok(__FieldTag::__custom_llm_response_safety_error_message)
                                }
                                "logTemplateOperations" => {
                                    Ok(__FieldTag::__log_template_operations)
                                }
                                "log_template_operations" => {
                                    Ok(__FieldTag::__log_template_operations)
                                }
                                "logSanitizeOperations" => {
                                    Ok(__FieldTag::__log_sanitize_operations)
                                }
                                "log_sanitize_operations" => {
                                    Ok(__FieldTag::__log_sanitize_operations)
                                }
                                "multiLanguageDetection" => {
                                    Ok(__FieldTag::__multi_language_detection)
                                }
                                "multi_language_detection" => {
                                    Ok(__FieldTag::__multi_language_detection)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TemplateMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TemplateMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ignore_partial_invocation_failures => {
                                if !fields.insert(__FieldTag::__ignore_partial_invocation_failures)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ignore_partial_invocation_failures",
                                    ));
                                }
                                result.ignore_partial_invocation_failures = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__custom_prompt_safety_error_code => {
                                if !fields.insert(__FieldTag::__custom_prompt_safety_error_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_prompt_safety_error_code",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.custom_prompt_safety_error_code =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__custom_prompt_safety_error_message => {
                                if !fields.insert(__FieldTag::__custom_prompt_safety_error_message)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_prompt_safety_error_message",
                                    ));
                                }
                                result.custom_prompt_safety_error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__custom_llm_response_safety_error_code => {
                                if !fields
                                    .insert(__FieldTag::__custom_llm_response_safety_error_code)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_llm_response_safety_error_code",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.custom_llm_response_safety_error_code =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__custom_llm_response_safety_error_message => {
                                if !fields
                                    .insert(__FieldTag::__custom_llm_response_safety_error_message)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_llm_response_safety_error_message",
                                    ));
                                }
                                result.custom_llm_response_safety_error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__log_template_operations => {
                                if !fields.insert(__FieldTag::__log_template_operations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_template_operations",
                                    ));
                                }
                                result.log_template_operations = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__log_sanitize_operations => {
                                if !fields.insert(__FieldTag::__log_sanitize_operations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_sanitize_operations",
                                    ));
                                }
                                result.log_sanitize_operations = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__multi_language_detection => {
                                if !fields.insert(__FieldTag::__multi_language_detection) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for multi_language_detection",
                                    ));
                                }
                                result.multi_language_detection = map.next_value::<std::option::Option<crate::model::template::template_metadata::MultiLanguageDetection>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TemplateMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.ignore_partial_invocation_failures) {
                state.serialize_entry(
                    "ignorePartialInvocationFailures",
                    &self.ignore_partial_invocation_failures,
                )?;
            }
            if !wkt::internal::is_default(&self.custom_prompt_safety_error_code) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "customPromptSafetyErrorCode",
                    &__With(&self.custom_prompt_safety_error_code),
                )?;
            }
            if !self.custom_prompt_safety_error_message.is_empty() {
                state.serialize_entry(
                    "customPromptSafetyErrorMessage",
                    &self.custom_prompt_safety_error_message,
                )?;
            }
            if !wkt::internal::is_default(&self.custom_llm_response_safety_error_code) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "customLlmResponseSafetyErrorCode",
                    &__With(&self.custom_llm_response_safety_error_code),
                )?;
            }
            if !self.custom_llm_response_safety_error_message.is_empty() {
                state.serialize_entry(
                    "customLlmResponseSafetyErrorMessage",
                    &self.custom_llm_response_safety_error_message,
                )?;
            }
            if !wkt::internal::is_default(&self.log_template_operations) {
                state.serialize_entry("logTemplateOperations", &self.log_template_operations)?;
            }
            if !wkt::internal::is_default(&self.log_sanitize_operations) {
                state.serialize_entry("logSanitizeOperations", &self.log_sanitize_operations)?;
            }
            if self.multi_language_detection.is_some() {
                state.serialize_entry("multiLanguageDetection", &self.multi_language_detection)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TemplateMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TemplateMetadata");
            debug_struct.field(
                "ignore_partial_invocation_failures",
                &self.ignore_partial_invocation_failures,
            );
            debug_struct.field(
                "custom_prompt_safety_error_code",
                &self.custom_prompt_safety_error_code,
            );
            debug_struct.field(
                "custom_prompt_safety_error_message",
                &self.custom_prompt_safety_error_message,
            );
            debug_struct.field(
                "custom_llm_response_safety_error_code",
                &self.custom_llm_response_safety_error_code,
            );
            debug_struct.field(
                "custom_llm_response_safety_error_message",
                &self.custom_llm_response_safety_error_message,
            );
            debug_struct.field("log_template_operations", &self.log_template_operations);
            debug_struct.field("log_sanitize_operations", &self.log_sanitize_operations);
            debug_struct.field("multi_language_detection", &self.multi_language_detection);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [TemplateMetadata].
    pub mod template_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Metadata to enable multi language detection via template.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MultiLanguageDetection {
            /// Required. If true, multi language detection will be enabled.
            pub enable_multi_language_detection: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MultiLanguageDetection {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [enable_multi_language_detection][crate::model::template::template_metadata::MultiLanguageDetection::enable_multi_language_detection].
            pub fn set_enable_multi_language_detection<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.enable_multi_language_detection = v.into();
                self
            }
        }

        impl wkt::message::Message for MultiLanguageDetection {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.modelarmor.v1.Template.TemplateMetadata.MultiLanguageDetection"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MultiLanguageDetection {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __enable_multi_language_detection,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MultiLanguageDetection")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "enableMultiLanguageDetection" => {
                                        Ok(__FieldTag::__enable_multi_language_detection)
                                    }
                                    "enable_multi_language_detection" => {
                                        Ok(__FieldTag::__enable_multi_language_detection)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MultiLanguageDetection;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MultiLanguageDetection")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__enable_multi_language_detection => {
                                    if !fields.insert(__FieldTag::__enable_multi_language_detection)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for enable_multi_language_detection",
                                            ),
                                        );
                                    }
                                    result.enable_multi_language_detection = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MultiLanguageDetection {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.enable_multi_language_detection) {
                    state.serialize_entry(
                        "enableMultiLanguageDetection",
                        &self.enable_multi_language_detection,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for MultiLanguageDetection {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("MultiLanguageDetection");
                debug_struct.field(
                    "enable_multi_language_detection",
                    &self.enable_multi_language_detection,
                );

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// Message describing FloorSetting resource
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FloorSetting {
    /// Identifier. The resource name.
    pub name: std::string::String,

    /// Output only. [Output only] Create timestamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. ModelArmor filter configuration.
    pub filter_config: std::option::Option<crate::model::FilterConfig>,

    /// Optional. Floor Settings enforcement status.
    pub enable_floor_setting_enforcement: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FloorSetting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FloorSetting::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FloorSetting::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::FloorSetting::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::FloorSetting::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FloorSetting::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter_config][crate::model::FloorSetting::filter_config].
    pub fn set_filter_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FilterConfig>,
    {
        self.filter_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter_config][crate::model::FloorSetting::filter_config].
    pub fn set_or_clear_filter_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FilterConfig>,
    {
        self.filter_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_floor_setting_enforcement][crate::model::FloorSetting::enable_floor_setting_enforcement].
    pub fn set_enable_floor_setting_enforcement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_floor_setting_enforcement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_floor_setting_enforcement][crate::model::FloorSetting::enable_floor_setting_enforcement].
    pub fn set_or_clear_enable_floor_setting_enforcement<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_floor_setting_enforcement = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FloorSetting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FloorSetting"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FloorSetting {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __filter_config,
            __enable_floor_setting_enforcement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FloorSetting")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "filterConfig" => Ok(__FieldTag::__filter_config),
                            "filter_config" => Ok(__FieldTag::__filter_config),
                            "enableFloorSettingEnforcement" => {
                                Ok(__FieldTag::__enable_floor_setting_enforcement)
                            }
                            "enable_floor_setting_enforcement" => {
                                Ok(__FieldTag::__enable_floor_setting_enforcement)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FloorSetting;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FloorSetting")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__filter_config => {
                            if !fields.insert(__FieldTag::__filter_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_config",
                                ));
                            }
                            result.filter_config = map
                                .next_value::<std::option::Option<crate::model::FilterConfig>>()?;
                        }
                        __FieldTag::__enable_floor_setting_enforcement => {
                            if !fields.insert(__FieldTag::__enable_floor_setting_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_floor_setting_enforcement",
                                ));
                            }
                            result.enable_floor_setting_enforcement =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FloorSetting {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.filter_config.is_some() {
            state.serialize_entry("filterConfig", &self.filter_config)?;
        }
        if self.enable_floor_setting_enforcement.is_some() {
            state.serialize_entry(
                "enableFloorSettingEnforcement",
                &self.enable_floor_setting_enforcement,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FloorSetting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FloorSetting");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("filter_config", &self.filter_config);
        debug_struct.field(
            "enable_floor_setting_enforcement",
            &self.enable_floor_setting_enforcement,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for requesting list of Templates
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTemplatesRequest {
    /// Required. Parent value for ListTemplatesRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ListTemplatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTemplatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTemplatesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTemplatesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing Templates
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTemplatesResponse {
    /// The list of Template
    pub templates: std::vec::Vec<crate::model::Template>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [templates][crate::model::ListTemplatesResponse::templates].
    pub fn set_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Template>,
    {
        use std::iter::Iterator;
        self.templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTemplatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ListTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTemplatesResponse {
    type PageItem = crate::model::Template;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __templates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "templates" => Ok(__FieldTag::__templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__templates => {
                            if !fields.insert(__FieldTag::__templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for templates",
                                ));
                            }
                            result.templates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Template>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTemplatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.templates.is_empty() {
            state.serialize_entry("templates", &self.templates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTemplatesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTemplatesResponse");
        debug_struct.field("templates", &self.templates);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a Template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTemplateRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.GetTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTemplateRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for creating a Template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTemplateRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// template_id from the method_signature of Create RPC
    pub template_id: std::string::String,

    /// Required. The resource being created
    pub template: std::option::Option<crate::model::Template>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [template_id][crate::model::CreateTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [template][crate::model::CreateTemplateRequest::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Template>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::CreateTemplateRequest::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Template>,
    {
        self.template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.CreateTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __template_id,
            __template,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "templateId" => Ok(__FieldTag::__template_id),
                            "template_id" => Ok(__FieldTag::__template_id),
                            "template" => Ok(__FieldTag::__template),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template_id => {
                            if !fields.insert(__FieldTag::__template_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_id",
                                ));
                            }
                            result.template_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template =
                                map.next_value::<std::option::Option<crate::model::Template>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.template_id.is_empty() {
            state.serialize_entry("templateId", &self.template_id)?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTemplateRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("template_id", &self.template_id);
        debug_struct.field("template", &self.template);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for updating a Template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTemplateRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Template resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub template: std::option::Option<crate::model::Template>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTemplateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTemplateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [template][crate::model::UpdateTemplateRequest::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Template>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::UpdateTemplateRequest::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Template>,
    {
        self.template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.UpdateTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __template,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "template" => Ok(__FieldTag::__template),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template =
                                map.next_value::<std::option::Option<crate::model::Template>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTemplateRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("template", &self.template);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for deleting a Template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTemplateRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.DeleteTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTemplateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a Floor Setting
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFloorSettingRequest {
    /// Required. The name of the floor setting to get, example
    /// projects/123/floorsetting.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFloorSettingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFloorSettingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFloorSettingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.GetFloorSettingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFloorSettingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFloorSettingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFloorSettingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFloorSettingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFloorSettingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetFloorSettingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFloorSettingRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for Updating a Floor Setting
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFloorSettingRequest {
    /// Required. The floor setting being updated.
    pub floor_setting: std::option::Option<crate::model::FloorSetting>,

    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// FloorSetting resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFloorSettingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [floor_setting][crate::model::UpdateFloorSettingRequest::floor_setting].
    pub fn set_floor_setting<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FloorSetting>,
    {
        self.floor_setting = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [floor_setting][crate::model::UpdateFloorSettingRequest::floor_setting].
    pub fn set_or_clear_floor_setting<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FloorSetting>,
    {
        self.floor_setting = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFloorSettingRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFloorSettingRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFloorSettingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.UpdateFloorSettingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFloorSettingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __floor_setting,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFloorSettingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "floorSetting" => Ok(__FieldTag::__floor_setting),
                            "floor_setting" => Ok(__FieldTag::__floor_setting),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFloorSettingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFloorSettingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__floor_setting => {
                            if !fields.insert(__FieldTag::__floor_setting) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for floor_setting",
                                ));
                            }
                            result.floor_setting = map
                                .next_value::<std::option::Option<crate::model::FloorSetting>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateFloorSettingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.floor_setting.is_some() {
            state.serialize_entry("floorSetting", &self.floor_setting)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateFloorSettingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateFloorSettingRequest");
        debug_struct.field("floor_setting", &self.floor_setting);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Filters configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FilterConfig {
    /// Optional. Responsible AI settings.
    pub rai_settings: std::option::Option<crate::model::RaiFilterSettings>,

    /// Optional. Sensitive Data Protection settings.
    pub sdp_settings: std::option::Option<crate::model::SdpFilterSettings>,

    /// Optional. Prompt injection and Jailbreak filter settings.
    pub pi_and_jailbreak_filter_settings:
        std::option::Option<crate::model::PiAndJailbreakFilterSettings>,

    /// Optional. Malicious URI filter settings.
    pub malicious_uri_filter_settings:
        std::option::Option<crate::model::MaliciousUriFilterSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rai_settings][crate::model::FilterConfig::rai_settings].
    pub fn set_rai_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RaiFilterSettings>,
    {
        self.rai_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rai_settings][crate::model::FilterConfig::rai_settings].
    pub fn set_or_clear_rai_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RaiFilterSettings>,
    {
        self.rai_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sdp_settings][crate::model::FilterConfig::sdp_settings].
    pub fn set_sdp_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SdpFilterSettings>,
    {
        self.sdp_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sdp_settings][crate::model::FilterConfig::sdp_settings].
    pub fn set_or_clear_sdp_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SdpFilterSettings>,
    {
        self.sdp_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pi_and_jailbreak_filter_settings][crate::model::FilterConfig::pi_and_jailbreak_filter_settings].
    pub fn set_pi_and_jailbreak_filter_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PiAndJailbreakFilterSettings>,
    {
        self.pi_and_jailbreak_filter_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pi_and_jailbreak_filter_settings][crate::model::FilterConfig::pi_and_jailbreak_filter_settings].
    pub fn set_or_clear_pi_and_jailbreak_filter_settings<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::PiAndJailbreakFilterSettings>,
    {
        self.pi_and_jailbreak_filter_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [malicious_uri_filter_settings][crate::model::FilterConfig::malicious_uri_filter_settings].
    pub fn set_malicious_uri_filter_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaliciousUriFilterSettings>,
    {
        self.malicious_uri_filter_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [malicious_uri_filter_settings][crate::model::FilterConfig::malicious_uri_filter_settings].
    pub fn set_or_clear_malicious_uri_filter_settings<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::MaliciousUriFilterSettings>,
    {
        self.malicious_uri_filter_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FilterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FilterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FilterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rai_settings,
            __sdp_settings,
            __pi_and_jailbreak_filter_settings,
            __malicious_uri_filter_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "raiSettings" => Ok(__FieldTag::__rai_settings),
                            "rai_settings" => Ok(__FieldTag::__rai_settings),
                            "sdpSettings" => Ok(__FieldTag::__sdp_settings),
                            "sdp_settings" => Ok(__FieldTag::__sdp_settings),
                            "piAndJailbreakFilterSettings" => {
                                Ok(__FieldTag::__pi_and_jailbreak_filter_settings)
                            }
                            "pi_and_jailbreak_filter_settings" => {
                                Ok(__FieldTag::__pi_and_jailbreak_filter_settings)
                            }
                            "maliciousUriFilterSettings" => {
                                Ok(__FieldTag::__malicious_uri_filter_settings)
                            }
                            "malicious_uri_filter_settings" => {
                                Ok(__FieldTag::__malicious_uri_filter_settings)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FilterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rai_settings => {
                            if !fields.insert(__FieldTag::__rai_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rai_settings",
                                ));
                            }
                            result.rai_settings = map
                                .next_value::<std::option::Option<crate::model::RaiFilterSettings>>(
                                )?;
                        }
                        __FieldTag::__sdp_settings => {
                            if !fields.insert(__FieldTag::__sdp_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sdp_settings",
                                ));
                            }
                            result.sdp_settings = map
                                .next_value::<std::option::Option<crate::model::SdpFilterSettings>>(
                                )?;
                        }
                        __FieldTag::__pi_and_jailbreak_filter_settings => {
                            if !fields.insert(__FieldTag::__pi_and_jailbreak_filter_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pi_and_jailbreak_filter_settings",
                                ));
                            }
                            result.pi_and_jailbreak_filter_settings = map.next_value::<std::option::Option<crate::model::PiAndJailbreakFilterSettings>>()?
                                ;
                        }
                        __FieldTag::__malicious_uri_filter_settings => {
                            if !fields.insert(__FieldTag::__malicious_uri_filter_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for malicious_uri_filter_settings",
                                ));
                            }
                            result.malicious_uri_filter_settings = map.next_value::<std::option::Option<crate::model::MaliciousUriFilterSettings>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FilterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rai_settings.is_some() {
            state.serialize_entry("raiSettings", &self.rai_settings)?;
        }
        if self.sdp_settings.is_some() {
            state.serialize_entry("sdpSettings", &self.sdp_settings)?;
        }
        if self.pi_and_jailbreak_filter_settings.is_some() {
            state.serialize_entry(
                "piAndJailbreakFilterSettings",
                &self.pi_and_jailbreak_filter_settings,
            )?;
        }
        if self.malicious_uri_filter_settings.is_some() {
            state.serialize_entry(
                "maliciousUriFilterSettings",
                &self.malicious_uri_filter_settings,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FilterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FilterConfig");
        debug_struct.field("rai_settings", &self.rai_settings);
        debug_struct.field("sdp_settings", &self.sdp_settings);
        debug_struct.field(
            "pi_and_jailbreak_filter_settings",
            &self.pi_and_jailbreak_filter_settings,
        );
        debug_struct.field(
            "malicious_uri_filter_settings",
            &self.malicious_uri_filter_settings,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Prompt injection and Jailbreak Filter settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PiAndJailbreakFilterSettings {
    /// Optional. Tells whether Prompt injection and Jailbreak filter is enabled or
    /// disabled.
    pub filter_enforcement:
        crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement,

    /// Optional. Confidence level for this filter.
    /// Confidence level is used to determine the threshold for the filter. If
    /// detection confidence is equal to or greater than the specified level, a
    /// positive match is reported. Confidence level will only be used if the
    /// filter is enabled.
    pub confidence_level: crate::model::DetectionConfidenceLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PiAndJailbreakFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::PiAndJailbreakFilterSettings::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<
                crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }

    /// Sets the value of [confidence_level][crate::model::PiAndJailbreakFilterSettings::confidence_level].
    pub fn set_confidence_level<T: std::convert::Into<crate::model::DetectionConfidenceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidence_level = v.into();
        self
    }
}

impl wkt::message::Message for PiAndJailbreakFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.PiAndJailbreakFilterSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PiAndJailbreakFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_enforcement,
            __confidence_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PiAndJailbreakFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterEnforcement" => Ok(__FieldTag::__filter_enforcement),
                            "filter_enforcement" => Ok(__FieldTag::__filter_enforcement),
                            "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                            "confidence_level" => Ok(__FieldTag::__confidence_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PiAndJailbreakFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PiAndJailbreakFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_enforcement => {
                            if !fields.insert(__FieldTag::__filter_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_enforcement",
                                ));
                            }
                            result.filter_enforcement = map.next_value::<std::option::Option<crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement>>()?.unwrap_or_default();
                        }
                        __FieldTag::__confidence_level => {
                            if !fields.insert(__FieldTag::__confidence_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_level",
                                ));
                            }
                            result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PiAndJailbreakFilterSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.filter_enforcement) {
            state.serialize_entry("filterEnforcement", &self.filter_enforcement)?;
        }
        if !wkt::internal::is_default(&self.confidence_level) {
            state.serialize_entry("confidenceLevel", &self.confidence_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PiAndJailbreakFilterSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PiAndJailbreakFilterSettings");
        debug_struct.field("filter_enforcement", &self.filter_enforcement);
        debug_struct.field("confidence_level", &self.confidence_level);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PiAndJailbreakFilterSettings].
pub mod pi_and_jailbreak_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Prompt Injection and Jailbreak filter
    /// (ENABLED/DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PiAndJailbreakFilterEnforcement {
        /// Same as Disabled
        Unspecified,
        /// Enabled
        Enabled,
        /// Enabled
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PiAndJailbreakFilterEnforcement::value] or
        /// [PiAndJailbreakFilterEnforcement::name].
        UnknownValue(pi_and_jailbreak_filter_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod pi_and_jailbreak_filter_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PiAndJailbreakFilterEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PiAndJailbreakFilterEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PiAndJailbreakFilterEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PiAndJailbreakFilterEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(pi_and_jailbreak_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PiAndJailbreakFilterEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(pi_and_jailbreak_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PiAndJailbreakFilterEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PiAndJailbreakFilterEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PiAndJailbreakFilterEnforcement>::new(
                ".google.cloud.modelarmor.v1.PiAndJailbreakFilterSettings.PiAndJailbreakFilterEnforcement"))
        }
    }
}

/// Malicious URI filter settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaliciousUriFilterSettings {
    /// Optional. Tells whether the Malicious URI filter is enabled or disabled.
    pub filter_enforcement:
        crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaliciousUriFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::MaliciousUriFilterSettings::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<
                crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for MaliciousUriFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaliciousUriFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_enforcement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaliciousUriFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterEnforcement" => Ok(__FieldTag::__filter_enforcement),
                            "filter_enforcement" => Ok(__FieldTag::__filter_enforcement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaliciousUriFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaliciousUriFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_enforcement => {
                            if !fields.insert(__FieldTag::__filter_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_enforcement",
                                ));
                            }
                            result.filter_enforcement = map.next_value::<std::option::Option<crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaliciousUriFilterSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.filter_enforcement) {
            state.serialize_entry("filterEnforcement", &self.filter_enforcement)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaliciousUriFilterSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaliciousUriFilterSettings");
        debug_struct.field("filter_enforcement", &self.filter_enforcement);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MaliciousUriFilterSettings].
pub mod malicious_uri_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Malicious URI filter (ENABLED/DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaliciousUriFilterEnforcement {
        /// Same as Disabled
        Unspecified,
        /// Enabled
        Enabled,
        /// Disabled
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaliciousUriFilterEnforcement::value] or
        /// [MaliciousUriFilterEnforcement::name].
        UnknownValue(malicious_uri_filter_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod malicious_uri_filter_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MaliciousUriFilterEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MaliciousUriFilterEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MaliciousUriFilterEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MaliciousUriFilterEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(malicious_uri_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MaliciousUriFilterEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(malicious_uri_filter_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MaliciousUriFilterEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MaliciousUriFilterEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaliciousUriFilterEnforcement>::new(
                ".google.cloud.modelarmor.v1.MaliciousUriFilterSettings.MaliciousUriFilterEnforcement"))
        }
    }
}

/// Responsible AI Filter settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RaiFilterSettings {
    /// Required. List of Responsible AI filters enabled for template.
    pub rai_filters: std::vec::Vec<crate::model::rai_filter_settings::RaiFilter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RaiFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rai_filters][crate::model::RaiFilterSettings::rai_filters].
    pub fn set_rai_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rai_filter_settings::RaiFilter>,
    {
        use std::iter::Iterator;
        self.rai_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RaiFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RaiFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rai_filters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "raiFilters" => Ok(__FieldTag::__rai_filters),
                            "rai_filters" => Ok(__FieldTag::__rai_filters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RaiFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rai_filters => {
                            if !fields.insert(__FieldTag::__rai_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rai_filters",
                                ));
                            }
                            result.rai_filters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::rai_filter_settings::RaiFilter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RaiFilterSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rai_filters.is_empty() {
            state.serialize_entry("raiFilters", &self.rai_filters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RaiFilterSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RaiFilterSettings");
        debug_struct.field("rai_filters", &self.rai_filters);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RaiFilterSettings].
pub mod rai_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Responsible AI filter.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RaiFilter {
        /// Required. Type of responsible AI filter.
        pub filter_type: crate::model::RaiFilterType,

        /// Optional. Confidence level for this RAI filter.
        /// During data sanitization, if data is classified under this filter with a
        /// confidence level equal to or greater than the specified level, a positive
        /// match is reported. If the confidence level is unspecified (i.e., 0), the
        /// system will use a reasonable default level based on the `filter_type`.
        pub confidence_level: crate::model::DetectionConfidenceLevel,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RaiFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter_type][crate::model::rai_filter_settings::RaiFilter::filter_type].
        pub fn set_filter_type<T: std::convert::Into<crate::model::RaiFilterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.filter_type = v.into();
            self
        }

        /// Sets the value of [confidence_level][crate::model::rai_filter_settings::RaiFilter::confidence_level].
        pub fn set_confidence_level<
            T: std::convert::Into<crate::model::DetectionConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.confidence_level = v.into();
            self
        }
    }

    impl wkt::message::Message for RaiFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterSettings.RaiFilter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RaiFilter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __filter_type,
                __confidence_level,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RaiFilter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "filterType" => Ok(__FieldTag::__filter_type),
                                "filter_type" => Ok(__FieldTag::__filter_type),
                                "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                                "confidence_level" => Ok(__FieldTag::__confidence_level),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RaiFilter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RaiFilter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__filter_type => {
                                if !fields.insert(__FieldTag::__filter_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter_type",
                                    ));
                                }
                                result.filter_type = map
                                    .next_value::<std::option::Option<crate::model::RaiFilterType>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__confidence_level => {
                                if !fields.insert(__FieldTag::__confidence_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence_level",
                                    ));
                                }
                                result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RaiFilter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.filter_type) {
                state.serialize_entry("filterType", &self.filter_type)?;
            }
            if !wkt::internal::is_default(&self.confidence_level) {
                state.serialize_entry("confidenceLevel", &self.confidence_level)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RaiFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RaiFilter");
            debug_struct.field("filter_type", &self.filter_type);
            debug_struct.field("confidence_level", &self.confidence_level);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Sensitive Data Protection settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SdpFilterSettings {
    /// Either of Sensitive Data Protection basic or advanced configuration.
    pub sdp_configuration: std::option::Option<crate::model::sdp_filter_settings::SdpConfiguration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFilterSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration].
    ///
    /// Note that all the setters affecting `sdp_configuration` are mutually
    /// exclusive.
    pub fn set_sdp_configuration<
        T: std::convert::Into<
                std::option::Option<crate::model::sdp_filter_settings::SdpConfiguration>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = v.into();
        self
    }

    /// The value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// if it holds a `BasicConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpBasicConfig>> {
        #[allow(unreachable_patterns)]
        self.sdp_configuration.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// to hold a `BasicConfig`.
    ///
    /// Note that all the setters affecting `sdp_configuration` are
    /// mutually exclusive.
    pub fn set_basic_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpBasicConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = std::option::Option::Some(
            crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(v.into()),
        );
        self
    }

    /// The value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// if it holds a `AdvancedConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advanced_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpAdvancedConfig>> {
        #[allow(unreachable_patterns)]
        self.sdp_configuration.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sdp_configuration][crate::model::SdpFilterSettings::sdp_configuration]
    /// to hold a `AdvancedConfig`.
    ///
    /// Note that all the setters affecting `sdp_configuration` are
    /// mutually exclusive.
    pub fn set_advanced_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpAdvancedConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sdp_configuration = std::option::Option::Some(
            crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SdpFilterSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFilterSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SdpFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __basic_config,
            __advanced_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "basicConfig" => Ok(__FieldTag::__basic_config),
                            "basic_config" => Ok(__FieldTag::__basic_config),
                            "advancedConfig" => Ok(__FieldTag::__advanced_config),
                            "advanced_config" => Ok(__FieldTag::__advanced_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SdpFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__basic_config => {
                            if !fields.insert(__FieldTag::__basic_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for basic_config",
                                ));
                            }
                            if result.sdp_configuration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sdp_configuration`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterSettings.basic_config, latest field was basicConfig",
                                ));
                            }
                            result.sdp_configuration = std::option::Option::Some(
                                crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SdpBasicConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__advanced_config => {
                            if !fields.insert(__FieldTag::__advanced_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_config",
                                ));
                            }
                            if result.sdp_configuration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sdp_configuration`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterSettings.advanced_config, latest field was advancedConfig",
                                ));
                            }
                            result.sdp_configuration = std::option::Option::Some(
                                crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SdpAdvancedConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SdpFilterSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.basic_config() {
            state.serialize_entry("basicConfig", value)?;
        }
        if let Some(value) = self.advanced_config() {
            state.serialize_entry("advancedConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SdpFilterSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SdpFilterSettings");
        debug_struct.field("sdp_configuration", &self.sdp_configuration);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SdpFilterSettings].
pub mod sdp_filter_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Either of Sensitive Data Protection basic or advanced configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SdpConfiguration {
        /// Optional. Basic Sensitive Data Protection configuration inspects the
        /// content for sensitive data using a fixed set of six info-types. Sensitive
        /// Data Protection templates cannot be used with basic configuration. Only
        /// Sensitive Data Protection inspection operation is supported with basic
        /// configuration.
        BasicConfig(std::boxed::Box<crate::model::SdpBasicConfig>),
        /// Optional. Advanced Sensitive Data Protection configuration which enables
        /// use of Sensitive Data Protection templates. Supports both Sensitive Data
        /// Protection inspection and de-identification operations.
        AdvancedConfig(std::boxed::Box<crate::model::SdpAdvancedConfig>),
    }
}

/// Sensitive Data Protection basic configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SdpBasicConfig {
    /// Optional. Tells whether the Sensitive Data Protection basic config is
    /// enabled or disabled.
    pub filter_enforcement: crate::model::sdp_basic_config::SdpBasicConfigEnforcement,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpBasicConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_enforcement][crate::model::SdpBasicConfig::filter_enforcement].
    pub fn set_filter_enforcement<
        T: std::convert::Into<crate::model::sdp_basic_config::SdpBasicConfigEnforcement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_enforcement = v.into();
        self
    }
}

impl wkt::message::Message for SdpBasicConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpBasicConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SdpBasicConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_enforcement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpBasicConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterEnforcement" => Ok(__FieldTag::__filter_enforcement),
                            "filter_enforcement" => Ok(__FieldTag::__filter_enforcement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SdpBasicConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpBasicConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_enforcement => {
                            if !fields.insert(__FieldTag::__filter_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_enforcement",
                                ));
                            }
                            result.filter_enforcement = map
                                .next_value::<std::option::Option<
                                    crate::model::sdp_basic_config::SdpBasicConfigEnforcement,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SdpBasicConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.filter_enforcement) {
            state.serialize_entry("filterEnforcement", &self.filter_enforcement)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SdpBasicConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SdpBasicConfig");
        debug_struct.field("filter_enforcement", &self.filter_enforcement);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SdpBasicConfig].
pub mod sdp_basic_config {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the state of Sensitive Data Protection basic config
    /// (ENABLED/DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SdpBasicConfigEnforcement {
        /// Same as Disabled
        Unspecified,
        /// Enabled
        Enabled,
        /// Disabled
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SdpBasicConfigEnforcement::value] or
        /// [SdpBasicConfigEnforcement::name].
        UnknownValue(sdp_basic_config_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sdp_basic_config_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SdpBasicConfigEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SdpBasicConfigEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SdpBasicConfigEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SdpBasicConfigEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(sdp_basic_config_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SdpBasicConfigEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(sdp_basic_config_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SdpBasicConfigEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SdpBasicConfigEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<SdpBasicConfigEnforcement>::new(
                    ".google.cloud.modelarmor.v1.SdpBasicConfig.SdpBasicConfigEnforcement",
                ),
            )
        }
    }
}

/// Sensitive Data Protection Advanced configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SdpAdvancedConfig {
    /// Optional. Sensitive Data Protection inspect template resource name
    ///
    /// If only inspect template is provided (de-identify template not provided),
    /// then Sensitive Data Protection InspectContent action is performed during
    /// Sanitization. All Sensitive Data Protection findings identified during
    /// inspection will be returned as SdpFinding in SdpInsepctionResult.
    ///
    /// e.g.
    /// `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
    pub inspect_template: std::string::String,

    /// Optional. Optional Sensitive Data Protection Deidentify template resource
    /// name.
    ///
    /// If provided then DeidentifyContent action is performed during Sanitization
    /// using this template and inspect template. The De-identified data will
    /// be returned in SdpDeidentifyResult.
    /// Note that all info-types present in the deidentify template must be present
    /// in inspect template.
    ///
    /// e.g.
    /// `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
    pub deidentify_template: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpAdvancedConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_template][crate::model::SdpAdvancedConfig::inspect_template].
    pub fn set_inspect_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::SdpAdvancedConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }
}

impl wkt::message::Message for SdpAdvancedConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpAdvancedConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SdpAdvancedConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_template,
            __deidentify_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpAdvancedConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectTemplate" => Ok(__FieldTag::__inspect_template),
                            "inspect_template" => Ok(__FieldTag::__inspect_template),
                            "deidentifyTemplate" => Ok(__FieldTag::__deidentify_template),
                            "deidentify_template" => Ok(__FieldTag::__deidentify_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SdpAdvancedConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpAdvancedConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_template => {
                            if !fields.insert(__FieldTag::__inspect_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template",
                                ));
                            }
                            result.inspect_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deidentify_template => {
                            if !fields.insert(__FieldTag::__deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_template",
                                ));
                            }
                            result.deidentify_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SdpAdvancedConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.inspect_template.is_empty() {
            state.serialize_entry("inspectTemplate", &self.inspect_template)?;
        }
        if !self.deidentify_template.is_empty() {
            state.serialize_entry("deidentifyTemplate", &self.deidentify_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SdpAdvancedConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SdpAdvancedConfig");
        debug_struct.field("inspect_template", &self.inspect_template);
        debug_struct.field("deidentify_template", &self.deidentify_template);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Sanitize User Prompt request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SanitizeUserPromptRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    pub name: std::string::String,

    /// Required. User prompt data to sanitize.
    pub user_prompt_data: std::option::Option<crate::model::DataItem>,

    /// Optional. Metadata related to Multi Language Detection.
    pub multi_language_detection_metadata:
        std::option::Option<crate::model::MultiLanguageDetectionMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeUserPromptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SanitizeUserPromptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user_prompt_data][crate::model::SanitizeUserPromptRequest::user_prompt_data].
    pub fn set_user_prompt_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataItem>,
    {
        self.user_prompt_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_prompt_data][crate::model::SanitizeUserPromptRequest::user_prompt_data].
    pub fn set_or_clear_user_prompt_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataItem>,
    {
        self.user_prompt_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [multi_language_detection_metadata][crate::model::SanitizeUserPromptRequest::multi_language_detection_metadata].
    pub fn set_multi_language_detection_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MultiLanguageDetectionMetadata>,
    {
        self.multi_language_detection_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [multi_language_detection_metadata][crate::model::SanitizeUserPromptRequest::multi_language_detection_metadata].
    pub fn set_or_clear_multi_language_detection_metadata<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::MultiLanguageDetectionMetadata>,
    {
        self.multi_language_detection_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SanitizeUserPromptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeUserPromptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SanitizeUserPromptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __user_prompt_data,
            __multi_language_detection_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeUserPromptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "userPromptData" => Ok(__FieldTag::__user_prompt_data),
                            "user_prompt_data" => Ok(__FieldTag::__user_prompt_data),
                            "multiLanguageDetectionMetadata" => {
                                Ok(__FieldTag::__multi_language_detection_metadata)
                            }
                            "multi_language_detection_metadata" => {
                                Ok(__FieldTag::__multi_language_detection_metadata)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SanitizeUserPromptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeUserPromptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_prompt_data => {
                            if !fields.insert(__FieldTag::__user_prompt_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_prompt_data",
                                ));
                            }
                            result.user_prompt_data =
                                map.next_value::<std::option::Option<crate::model::DataItem>>()?;
                        }
                        __FieldTag::__multi_language_detection_metadata => {
                            if !fields.insert(__FieldTag::__multi_language_detection_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_language_detection_metadata",
                                ));
                            }
                            result.multi_language_detection_metadata =
                                map.next_value::<std::option::Option<
                                    crate::model::MultiLanguageDetectionMetadata,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SanitizeUserPromptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.user_prompt_data.is_some() {
            state.serialize_entry("userPromptData", &self.user_prompt_data)?;
        }
        if self.multi_language_detection_metadata.is_some() {
            state.serialize_entry(
                "multiLanguageDetectionMetadata",
                &self.multi_language_detection_metadata,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SanitizeUserPromptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SanitizeUserPromptRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("user_prompt_data", &self.user_prompt_data);
        debug_struct.field(
            "multi_language_detection_metadata",
            &self.multi_language_detection_metadata,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Sanitize Model Response request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SanitizeModelResponseRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    pub name: std::string::String,

    /// Required. Model response data to sanitize.
    pub model_response_data: std::option::Option<crate::model::DataItem>,

    /// Optional. User Prompt associated with Model response.
    pub user_prompt: std::string::String,

    /// Optional. Metadata related for multi language detection.
    pub multi_language_detection_metadata:
        std::option::Option<crate::model::MultiLanguageDetectionMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeModelResponseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SanitizeModelResponseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [model_response_data][crate::model::SanitizeModelResponseRequest::model_response_data].
    pub fn set_model_response_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataItem>,
    {
        self.model_response_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model_response_data][crate::model::SanitizeModelResponseRequest::model_response_data].
    pub fn set_or_clear_model_response_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataItem>,
    {
        self.model_response_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_prompt][crate::model::SanitizeModelResponseRequest::user_prompt].
    pub fn set_user_prompt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_prompt = v.into();
        self
    }

    /// Sets the value of [multi_language_detection_metadata][crate::model::SanitizeModelResponseRequest::multi_language_detection_metadata].
    pub fn set_multi_language_detection_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MultiLanguageDetectionMetadata>,
    {
        self.multi_language_detection_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [multi_language_detection_metadata][crate::model::SanitizeModelResponseRequest::multi_language_detection_metadata].
    pub fn set_or_clear_multi_language_detection_metadata<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::MultiLanguageDetectionMetadata>,
    {
        self.multi_language_detection_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SanitizeModelResponseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeModelResponseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SanitizeModelResponseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __model_response_data,
            __user_prompt,
            __multi_language_detection_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeModelResponseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "modelResponseData" => Ok(__FieldTag::__model_response_data),
                            "model_response_data" => Ok(__FieldTag::__model_response_data),
                            "userPrompt" => Ok(__FieldTag::__user_prompt),
                            "user_prompt" => Ok(__FieldTag::__user_prompt),
                            "multiLanguageDetectionMetadata" => {
                                Ok(__FieldTag::__multi_language_detection_metadata)
                            }
                            "multi_language_detection_metadata" => {
                                Ok(__FieldTag::__multi_language_detection_metadata)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SanitizeModelResponseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeModelResponseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_response_data => {
                            if !fields.insert(__FieldTag::__model_response_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_response_data",
                                ));
                            }
                            result.model_response_data =
                                map.next_value::<std::option::Option<crate::model::DataItem>>()?;
                        }
                        __FieldTag::__user_prompt => {
                            if !fields.insert(__FieldTag::__user_prompt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_prompt",
                                ));
                            }
                            result.user_prompt = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multi_language_detection_metadata => {
                            if !fields.insert(__FieldTag::__multi_language_detection_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_language_detection_metadata",
                                ));
                            }
                            result.multi_language_detection_metadata =
                                map.next_value::<std::option::Option<
                                    crate::model::MultiLanguageDetectionMetadata,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SanitizeModelResponseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.model_response_data.is_some() {
            state.serialize_entry("modelResponseData", &self.model_response_data)?;
        }
        if !self.user_prompt.is_empty() {
            state.serialize_entry("userPrompt", &self.user_prompt)?;
        }
        if self.multi_language_detection_metadata.is_some() {
            state.serialize_entry(
                "multiLanguageDetectionMetadata",
                &self.multi_language_detection_metadata,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SanitizeModelResponseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SanitizeModelResponseRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("model_response_data", &self.model_response_data);
        debug_struct.field("user_prompt", &self.user_prompt);
        debug_struct.field(
            "multi_language_detection_metadata",
            &self.multi_language_detection_metadata,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Sanitized User Prompt Response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SanitizeUserPromptResponse {
    /// Output only. Sanitization Result.
    pub sanitization_result: std::option::Option<crate::model::SanitizationResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeUserPromptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sanitization_result][crate::model::SanitizeUserPromptResponse::sanitization_result].
    pub fn set_sanitization_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SanitizationResult>,
    {
        self.sanitization_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sanitization_result][crate::model::SanitizeUserPromptResponse::sanitization_result].
    pub fn set_or_clear_sanitization_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SanitizationResult>,
    {
        self.sanitization_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SanitizeUserPromptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeUserPromptResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SanitizeUserPromptResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sanitization_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeUserPromptResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sanitizationResult" => Ok(__FieldTag::__sanitization_result),
                            "sanitization_result" => Ok(__FieldTag::__sanitization_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SanitizeUserPromptResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeUserPromptResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sanitization_result => {
                            if !fields.insert(__FieldTag::__sanitization_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sanitization_result",
                                ));
                            }
                            result.sanitization_result = map.next_value::<std::option::Option<crate::model::SanitizationResult>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SanitizeUserPromptResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.sanitization_result.is_some() {
            state.serialize_entry("sanitizationResult", &self.sanitization_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SanitizeUserPromptResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SanitizeUserPromptResponse");
        debug_struct.field("sanitization_result", &self.sanitization_result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Sanitized Model Response Response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SanitizeModelResponseResponse {
    /// Output only. Sanitization Result.
    pub sanitization_result: std::option::Option<crate::model::SanitizationResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizeModelResponseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sanitization_result][crate::model::SanitizeModelResponseResponse::sanitization_result].
    pub fn set_sanitization_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SanitizationResult>,
    {
        self.sanitization_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sanitization_result][crate::model::SanitizeModelResponseResponse::sanitization_result].
    pub fn set_or_clear_sanitization_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SanitizationResult>,
    {
        self.sanitization_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SanitizeModelResponseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizeModelResponseResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SanitizeModelResponseResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sanitization_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeModelResponseResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sanitizationResult" => Ok(__FieldTag::__sanitization_result),
                            "sanitization_result" => Ok(__FieldTag::__sanitization_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SanitizeModelResponseResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeModelResponseResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sanitization_result => {
                            if !fields.insert(__FieldTag::__sanitization_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sanitization_result",
                                ));
                            }
                            result.sanitization_result = map.next_value::<std::option::Option<crate::model::SanitizationResult>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SanitizeModelResponseResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.sanitization_result.is_some() {
            state.serialize_entry("sanitizationResult", &self.sanitization_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SanitizeModelResponseResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SanitizeModelResponseResponse");
        debug_struct.field("sanitization_result", &self.sanitization_result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Sanitization result after applying all the filters on input content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SanitizationResult {
    /// Output only. Overall filter match state for Sanitization.
    /// The state can have below two values.
    ///
    /// 1. NO_MATCH_FOUND: No filters in configuration satisfy matching criteria.
    ///    In other words, input passed all filters.
    ///
    /// 1. MATCH_FOUND: At least one filter in configuration satisfies matching.
    ///    In other words, input did not pass one or more filters.
    ///
    pub filter_match_state: crate::model::FilterMatchState,

    /// Output only. Results for all filters where the key is the filter name -
    /// either of "csam", "malicious_uris", "rai", "pi_and_jailbreak" ,"sdp".
    pub filter_results: std::collections::HashMap<std::string::String, crate::model::FilterResult>,

    /// Output only. A field indicating the outcome of the invocation, irrespective
    /// of match status. It can have the following three values: SUCCESS: All
    /// filters were executed successfully. PARTIAL: Some filters were skipped or
    /// failed execution. FAILURE: All filters were skipped or failed execution.
    pub invocation_result: crate::model::InvocationResult,

    /// Output only. Metadata related to Sanitization.
    pub sanitization_metadata:
        std::option::Option<crate::model::sanitization_result::SanitizationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SanitizationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_match_state][crate::model::SanitizationResult::filter_match_state].
    pub fn set_filter_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_match_state = v.into();
        self
    }

    /// Sets the value of [filter_results][crate::model::SanitizationResult::filter_results].
    pub fn set_filter_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FilterResult>,
    {
        use std::iter::Iterator;
        self.filter_results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [invocation_result][crate::model::SanitizationResult::invocation_result].
    pub fn set_invocation_result<T: std::convert::Into<crate::model::InvocationResult>>(
        mut self,
        v: T,
    ) -> Self {
        self.invocation_result = v.into();
        self
    }

    /// Sets the value of [sanitization_metadata][crate::model::SanitizationResult::sanitization_metadata].
    pub fn set_sanitization_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::sanitization_result::SanitizationMetadata>,
    {
        self.sanitization_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sanitization_metadata][crate::model::SanitizationResult::sanitization_metadata].
    pub fn set_or_clear_sanitization_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::sanitization_result::SanitizationMetadata>,
    {
        self.sanitization_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SanitizationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SanitizationResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SanitizationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_match_state,
            __filter_results,
            __invocation_result,
            __sanitization_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterMatchState" => Ok(__FieldTag::__filter_match_state),
                            "filter_match_state" => Ok(__FieldTag::__filter_match_state),
                            "filterResults" => Ok(__FieldTag::__filter_results),
                            "filter_results" => Ok(__FieldTag::__filter_results),
                            "invocationResult" => Ok(__FieldTag::__invocation_result),
                            "invocation_result" => Ok(__FieldTag::__invocation_result),
                            "sanitizationMetadata" => Ok(__FieldTag::__sanitization_metadata),
                            "sanitization_metadata" => Ok(__FieldTag::__sanitization_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SanitizationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_match_state => {
                            if !fields.insert(__FieldTag::__filter_match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_match_state",
                                ));
                            }
                            result.filter_match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter_results => {
                            if !fields.insert(__FieldTag::__filter_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_results",
                                ));
                            }
                            result.filter_results = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::FilterResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invocation_result => {
                            if !fields.insert(__FieldTag::__invocation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation_result",
                                ));
                            }
                            result.invocation_result = map
                                .next_value::<std::option::Option<crate::model::InvocationResult>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sanitization_metadata => {
                            if !fields.insert(__FieldTag::__sanitization_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sanitization_metadata",
                                ));
                            }
                            result.sanitization_metadata = map.next_value::<std::option::Option<
                                crate::model::sanitization_result::SanitizationMetadata,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SanitizationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.filter_match_state) {
            state.serialize_entry("filterMatchState", &self.filter_match_state)?;
        }
        if !self.filter_results.is_empty() {
            state.serialize_entry("filterResults", &self.filter_results)?;
        }
        if !wkt::internal::is_default(&self.invocation_result) {
            state.serialize_entry("invocationResult", &self.invocation_result)?;
        }
        if self.sanitization_metadata.is_some() {
            state.serialize_entry("sanitizationMetadata", &self.sanitization_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SanitizationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SanitizationResult");
        debug_struct.field("filter_match_state", &self.filter_match_state);
        debug_struct.field("filter_results", &self.filter_results);
        debug_struct.field("invocation_result", &self.invocation_result);
        debug_struct.field("sanitization_metadata", &self.sanitization_metadata);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SanitizationResult].
pub mod sanitization_result {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing Sanitization metadata.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SanitizationMetadata {
        /// Error code if any.
        pub error_code: i64,

        /// Error message if any.
        pub error_message: std::string::String,

        /// Passthrough field defined in TemplateMetadata to indicate whether to
        /// ignore partial invocation failures.
        pub ignore_partial_invocation_failures: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SanitizationMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_code][crate::model::sanitization_result::SanitizationMetadata::error_code].
        pub fn set_error_code<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.error_code = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::sanitization_result::SanitizationMetadata::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [ignore_partial_invocation_failures][crate::model::sanitization_result::SanitizationMetadata::ignore_partial_invocation_failures].
        pub fn set_ignore_partial_invocation_failures<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.ignore_partial_invocation_failures = v.into();
            self
        }
    }

    impl wkt::message::Message for SanitizationMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.SanitizationResult.SanitizationMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SanitizationMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __error_code,
                __error_message,
                __ignore_partial_invocation_failures,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SanitizationMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "errorCode" => Ok(__FieldTag::__error_code),
                                "error_code" => Ok(__FieldTag::__error_code),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                "ignorePartialInvocationFailures" => {
                                    Ok(__FieldTag::__ignore_partial_invocation_failures)
                                }
                                "ignore_partial_invocation_failures" => {
                                    Ok(__FieldTag::__ignore_partial_invocation_failures)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SanitizationMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SanitizationMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__error_code => {
                                if !fields.insert(__FieldTag::__error_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_code",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.error_code =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ignore_partial_invocation_failures => {
                                if !fields.insert(__FieldTag::__ignore_partial_invocation_failures)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ignore_partial_invocation_failures",
                                    ));
                                }
                                result.ignore_partial_invocation_failures = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SanitizationMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.error_code) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("errorCode", &__With(&self.error_code))?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if !wkt::internal::is_default(&self.ignore_partial_invocation_failures) {
                state.serialize_entry(
                    "ignorePartialInvocationFailures",
                    &self.ignore_partial_invocation_failures,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SanitizationMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SanitizationMetadata");
            debug_struct.field("error_code", &self.error_code);
            debug_struct.field("error_message", &self.error_message);
            debug_struct.field(
                "ignore_partial_invocation_failures",
                &self.ignore_partial_invocation_failures,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Message for Enabling Multi Language Detection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MultiLanguageDetectionMetadata {
    /// Optional. Optional Source language of the user prompt.
    ///
    /// If multi-language detection is enabled but language is not set in that case
    /// we would automatically detect the source language.
    pub source_language: std::string::String,

    /// Optional. Enable detection of multi-language prompts and responses.
    pub enable_multi_language_detection: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiLanguageDetectionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_language][crate::model::MultiLanguageDetectionMetadata::source_language].
    pub fn set_source_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_language = v.into();
        self
    }

    /// Sets the value of [enable_multi_language_detection][crate::model::MultiLanguageDetectionMetadata::enable_multi_language_detection].
    pub fn set_enable_multi_language_detection<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_multi_language_detection = v.into();
        self
    }
}

impl wkt::message::Message for MultiLanguageDetectionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MultiLanguageDetectionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MultiLanguageDetectionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_language,
            __enable_multi_language_detection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiLanguageDetectionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceLanguage" => Ok(__FieldTag::__source_language),
                            "source_language" => Ok(__FieldTag::__source_language),
                            "enableMultiLanguageDetection" => {
                                Ok(__FieldTag::__enable_multi_language_detection)
                            }
                            "enable_multi_language_detection" => {
                                Ok(__FieldTag::__enable_multi_language_detection)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MultiLanguageDetectionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiLanguageDetectionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_language => {
                            if !fields.insert(__FieldTag::__source_language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language",
                                ));
                            }
                            result.source_language = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_multi_language_detection => {
                            if !fields.insert(__FieldTag::__enable_multi_language_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_multi_language_detection",
                                ));
                            }
                            result.enable_multi_language_detection = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MultiLanguageDetectionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_language.is_empty() {
            state.serialize_entry("sourceLanguage", &self.source_language)?;
        }
        if !wkt::internal::is_default(&self.enable_multi_language_detection) {
            state.serialize_entry(
                "enableMultiLanguageDetection",
                &self.enable_multi_language_detection,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MultiLanguageDetectionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiLanguageDetectionMetadata");
        debug_struct.field("source_language", &self.source_language);
        debug_struct.field(
            "enable_multi_language_detection",
            &self.enable_multi_language_detection,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Filter Result obtained after Sanitization operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FilterResult {
    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    pub filter_result: std::option::Option<crate::model::filter_result::FilterResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result].
    ///
    /// Note that all the setters affecting `filter_result` are mutually
    /// exclusive.
    pub fn set_filter_result<
        T: std::convert::Into<std::option::Option<crate::model::filter_result::FilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = v.into();
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `RaiFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rai_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RaiFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::RaiFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `RaiFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_rai_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::RaiFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::RaiFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `SdpFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sdp_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::SdpFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `SdpFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_sdp_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::SdpFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `PiAndJailbreakFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pi_and_jailbreak_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PiAndJailbreakFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `PiAndJailbreakFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_pi_and_jailbreak_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PiAndJailbreakFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `MaliciousUriFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn malicious_uri_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaliciousUriFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::MaliciousUriFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `MaliciousUriFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_malicious_uri_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::MaliciousUriFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::MaliciousUriFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `CsamFilterFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csam_filter_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CsamFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::CsamFilterFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `CsamFilterFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_csam_filter_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CsamFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::CsamFilterFilterResult(v.into()),
        );
        self
    }

    /// The value of [filter_result][crate::model::FilterResult::filter_result]
    /// if it holds a `VirusScanFilterResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn virus_scan_filter_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VirusScanFilterResult>> {
        #[allow(unreachable_patterns)]
        self.filter_result.as_ref().and_then(|v| match v {
            crate::model::filter_result::FilterResult::VirusScanFilterResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter_result][crate::model::FilterResult::filter_result]
    /// to hold a `VirusScanFilterResult`.
    ///
    /// Note that all the setters affecting `filter_result` are
    /// mutually exclusive.
    pub fn set_virus_scan_filter_result<
        T: std::convert::Into<std::boxed::Box<crate::model::VirusScanFilterResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter_result = std::option::Option::Some(
            crate::model::filter_result::FilterResult::VirusScanFilterResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.FilterResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rai_filter_result,
            __sdp_filter_result,
            __pi_and_jailbreak_filter_result,
            __malicious_uri_filter_result,
            __csam_filter_filter_result,
            __virus_scan_filter_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "raiFilterResult" => Ok(__FieldTag::__rai_filter_result),
                            "rai_filter_result" => Ok(__FieldTag::__rai_filter_result),
                            "sdpFilterResult" => Ok(__FieldTag::__sdp_filter_result),
                            "sdp_filter_result" => Ok(__FieldTag::__sdp_filter_result),
                            "piAndJailbreakFilterResult" => {
                                Ok(__FieldTag::__pi_and_jailbreak_filter_result)
                            }
                            "pi_and_jailbreak_filter_result" => {
                                Ok(__FieldTag::__pi_and_jailbreak_filter_result)
                            }
                            "maliciousUriFilterResult" => {
                                Ok(__FieldTag::__malicious_uri_filter_result)
                            }
                            "malicious_uri_filter_result" => {
                                Ok(__FieldTag::__malicious_uri_filter_result)
                            }
                            "csamFilterFilterResult" => Ok(__FieldTag::__csam_filter_filter_result),
                            "csam_filter_filter_result" => {
                                Ok(__FieldTag::__csam_filter_filter_result)
                            }
                            "virusScanFilterResult" => Ok(__FieldTag::__virus_scan_filter_result),
                            "virus_scan_filter_result" => {
                                Ok(__FieldTag::__virus_scan_filter_result)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rai_filter_result => {
                            if !fields.insert(__FieldTag::__rai_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rai_filter_result",
                                ));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.rai_filter_result, latest field was raiFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::RaiFilterResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RaiFilterResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sdp_filter_result => {
                            if !fields.insert(__FieldTag::__sdp_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sdp_filter_result",
                                ));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.sdp_filter_result, latest field was sdpFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::SdpFilterResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SdpFilterResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pi_and_jailbreak_filter_result => {
                            if !fields.insert(__FieldTag::__pi_and_jailbreak_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pi_and_jailbreak_filter_result",
                                ));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.pi_and_jailbreak_filter_result, latest field was piAndJailbreakFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PiAndJailbreakFilterResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__malicious_uri_filter_result => {
                            if !fields.insert(__FieldTag::__malicious_uri_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for malicious_uri_filter_result",
                                ));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.malicious_uri_filter_result, latest field was maliciousUriFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::MaliciousUriFilterResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MaliciousUriFilterResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__csam_filter_filter_result => {
                            if !fields.insert(__FieldTag::__csam_filter_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csam_filter_filter_result",
                                ));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.csam_filter_filter_result, latest field was csamFilterFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::CsamFilterFilterResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CsamFilterResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__virus_scan_filter_result => {
                            if !fields.insert(__FieldTag::__virus_scan_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virus_scan_filter_result",
                                ));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.virus_scan_filter_result, latest field was virusScanFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::VirusScanFilterResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VirusScanFilterResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FilterResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.rai_filter_result() {
            state.serialize_entry("raiFilterResult", value)?;
        }
        if let Some(value) = self.sdp_filter_result() {
            state.serialize_entry("sdpFilterResult", value)?;
        }
        if let Some(value) = self.pi_and_jailbreak_filter_result() {
            state.serialize_entry("piAndJailbreakFilterResult", value)?;
        }
        if let Some(value) = self.malicious_uri_filter_result() {
            state.serialize_entry("maliciousUriFilterResult", value)?;
        }
        if let Some(value) = self.csam_filter_filter_result() {
            state.serialize_entry("csamFilterFilterResult", value)?;
        }
        if let Some(value) = self.virus_scan_filter_result() {
            state.serialize_entry("virusScanFilterResult", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FilterResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FilterResult");
        debug_struct.field("filter_result", &self.filter_result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FilterResult].
pub mod filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FilterResult {
        /// Responsible AI filter results.
        RaiFilterResult(std::boxed::Box<crate::model::RaiFilterResult>),
        /// Sensitive Data Protection results.
        SdpFilterResult(std::boxed::Box<crate::model::SdpFilterResult>),
        /// Prompt injection and Jailbreak filter results.
        PiAndJailbreakFilterResult(std::boxed::Box<crate::model::PiAndJailbreakFilterResult>),
        /// Malicious URI filter results.
        MaliciousUriFilterResult(std::boxed::Box<crate::model::MaliciousUriFilterResult>),
        /// CSAM filter results.
        CsamFilterFilterResult(std::boxed::Box<crate::model::CsamFilterResult>),
        /// Virus scan results.
        VirusScanFilterResult(std::boxed::Box<crate::model::VirusScanFilterResult>),
    }
}

/// Responsible AI Result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RaiFilterResult {
    /// Output only. Reports whether the RAI filter was successfully executed or
    /// not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Overall filter match state for RAI.
    /// Value is MATCH_FOUND if at least one RAI filter confidence level is
    /// equal to or higher than the confidence level defined in configuration.
    pub match_state: crate::model::FilterMatchState,

    /// The map of RAI filter results where key is RAI filter type - either of
    /// "sexually_explicit", "hate_speech", "harassment", "dangerous".
    pub rai_filter_type_results: std::collections::HashMap<
        std::string::String,
        crate::model::rai_filter_result::RaiFilterTypeResult,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RaiFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::RaiFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::RaiFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::RaiFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [rai_filter_type_results][crate::model::RaiFilterResult::rai_filter_type_results].
    pub fn set_rai_filter_type_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::rai_filter_result::RaiFilterTypeResult>,
    {
        use std::iter::Iterator;
        self.rai_filter_type_results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RaiFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RaiFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __rai_filter_type_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "raiFilterTypeResults" => Ok(__FieldTag::__rai_filter_type_results),
                            "rai_filter_type_results" => Ok(__FieldTag::__rai_filter_type_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RaiFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_items",
                                ));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_state",
                                ));
                            }
                            result.match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rai_filter_type_results => {
                            if !fields.insert(__FieldTag::__rai_filter_type_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rai_filter_type_results",
                                ));
                            }
                            result.rai_filter_type_results = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::rai_filter_result::RaiFilterTypeResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RaiFilterResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !self.message_items.is_empty() {
            state.serialize_entry("messageItems", &self.message_items)?;
        }
        if !wkt::internal::is_default(&self.match_state) {
            state.serialize_entry("matchState", &self.match_state)?;
        }
        if !self.rai_filter_type_results.is_empty() {
            state.serialize_entry("raiFilterTypeResults", &self.rai_filter_type_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RaiFilterResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RaiFilterResult");
        debug_struct.field("execution_state", &self.execution_state);
        debug_struct.field("message_items", &self.message_items);
        debug_struct.field("match_state", &self.match_state);
        debug_struct.field("rai_filter_type_results", &self.rai_filter_type_results);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RaiFilterResult].
pub mod rai_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed Filter result for each of the responsible AI Filter Types.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RaiFilterTypeResult {
        /// Type of responsible AI filter.
        pub filter_type: crate::model::RaiFilterType,

        /// Confidence level identified for this RAI filter.
        pub confidence_level: crate::model::DetectionConfidenceLevel,

        /// Output only. Match state for this RAI filter.
        pub match_state: crate::model::FilterMatchState,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RaiFilterTypeResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter_type][crate::model::rai_filter_result::RaiFilterTypeResult::filter_type].
        pub fn set_filter_type<T: std::convert::Into<crate::model::RaiFilterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.filter_type = v.into();
            self
        }

        /// Sets the value of [confidence_level][crate::model::rai_filter_result::RaiFilterTypeResult::confidence_level].
        pub fn set_confidence_level<
            T: std::convert::Into<crate::model::DetectionConfidenceLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.confidence_level = v.into();
            self
        }

        /// Sets the value of [match_state][crate::model::rai_filter_result::RaiFilterTypeResult::match_state].
        pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
            mut self,
            v: T,
        ) -> Self {
            self.match_state = v.into();
            self
        }
    }

    impl wkt::message::Message for RaiFilterTypeResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.RaiFilterResult.RaiFilterTypeResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RaiFilterTypeResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __filter_type,
                __confidence_level,
                __match_state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RaiFilterTypeResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "filterType" => Ok(__FieldTag::__filter_type),
                                "filter_type" => Ok(__FieldTag::__filter_type),
                                "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                                "confidence_level" => Ok(__FieldTag::__confidence_level),
                                "matchState" => Ok(__FieldTag::__match_state),
                                "match_state" => Ok(__FieldTag::__match_state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RaiFilterTypeResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RaiFilterTypeResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__filter_type => {
                                if !fields.insert(__FieldTag::__filter_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter_type",
                                    ));
                                }
                                result.filter_type = map
                                    .next_value::<std::option::Option<crate::model::RaiFilterType>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__confidence_level => {
                                if !fields.insert(__FieldTag::__confidence_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence_level",
                                    ));
                                }
                                result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                            }
                            __FieldTag::__match_state => {
                                if !fields.insert(__FieldTag::__match_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for match_state",
                                    ));
                                }
                                result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RaiFilterTypeResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.filter_type) {
                state.serialize_entry("filterType", &self.filter_type)?;
            }
            if !wkt::internal::is_default(&self.confidence_level) {
                state.serialize_entry("confidenceLevel", &self.confidence_level)?;
            }
            if !wkt::internal::is_default(&self.match_state) {
                state.serialize_entry("matchState", &self.match_state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RaiFilterTypeResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RaiFilterTypeResult");
            debug_struct.field("filter_type", &self.filter_type);
            debug_struct.field("confidence_level", &self.confidence_level);
            debug_struct.field("match_state", &self.match_state);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Sensitive Data Protection filter result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SdpFilterResult {
    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    pub result: std::option::Option<crate::model::sdp_filter_result::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::sdp_filter_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::SdpFilterResult::result]
    /// if it holds a `InspectResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpInspectResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_result::Result::InspectResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result]
    /// to hold a `InspectResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_inspect_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpInspectResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::sdp_filter_result::Result::InspectResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::SdpFilterResult::result]
    /// if it holds a `DeidentifyResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deidentify_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SdpDeidentifyResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::sdp_filter_result::Result::DeidentifyResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::SdpFilterResult::result]
    /// to hold a `DeidentifyResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_deidentify_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SdpDeidentifyResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::sdp_filter_result::Result::DeidentifyResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SdpFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFilterResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SdpFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_result,
            __deidentify_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectResult" => Ok(__FieldTag::__inspect_result),
                            "inspect_result" => Ok(__FieldTag::__inspect_result),
                            "deidentifyResult" => Ok(__FieldTag::__deidentify_result),
                            "deidentify_result" => Ok(__FieldTag::__deidentify_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SdpFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_result => {
                            if !fields.insert(__FieldTag::__inspect_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterResult.inspect_result, latest field was inspectResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::sdp_filter_result::Result::InspectResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SdpInspectResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__deidentify_result => {
                            if !fields.insert(__FieldTag::__deidentify_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterResult.deidentify_result, latest field was deidentifyResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::sdp_filter_result::Result::DeidentifyResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SdpDeidentifyResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SdpFilterResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inspect_result() {
            state.serialize_entry("inspectResult", value)?;
        }
        if let Some(value) = self.deidentify_result() {
            state.serialize_entry("deidentifyResult", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SdpFilterResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SdpFilterResult");
        debug_struct.field("result", &self.result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SdpFilterResult].
pub mod sdp_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Sensitive Data Protection Inspection result if inspection is performed.
        InspectResult(std::boxed::Box<crate::model::SdpInspectResult>),
        /// Sensitive Data Protection Deidentification result if deidentification is
        /// performed.
        DeidentifyResult(std::boxed::Box<crate::model::SdpDeidentifyResult>),
    }
}

/// Sensitive Data Protection Inspection Result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SdpInspectResult {
    /// Output only. Reports whether Sensitive Data Protection inspection was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for SDP Inspection.
    /// Value is MATCH_FOUND if at least one Sensitive Data Protection finding is
    /// identified.
    pub match_state: crate::model::FilterMatchState,

    /// List of Sensitive Data Protection findings.
    pub findings: std::vec::Vec<crate::model::SdpFinding>,

    /// If true, then there is possibility that more findings were identified and
    /// the findings returned are a subset of all findings. The findings
    /// list might be truncated because the input items were too large, or because
    /// the server reached the maximum amount of resources allowed for a single API
    /// call.
    pub findings_truncated: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpInspectResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::SdpInspectResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::SdpInspectResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::SdpInspectResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [findings][crate::model::SdpInspectResult::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SdpFinding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [findings_truncated][crate::model::SdpInspectResult::findings_truncated].
    pub fn set_findings_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.findings_truncated = v.into();
        self
    }
}

impl wkt::message::Message for SdpInspectResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpInspectResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SdpInspectResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __findings,
            __findings_truncated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpInspectResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "findings" => Ok(__FieldTag::__findings),
                            "findingsTruncated" => Ok(__FieldTag::__findings_truncated),
                            "findings_truncated" => Ok(__FieldTag::__findings_truncated),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SdpInspectResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpInspectResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_items",
                                ));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_state",
                                ));
                            }
                            result.match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__findings => {
                            if !fields.insert(__FieldTag::__findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for findings",
                                ));
                            }
                            result.findings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SdpFinding>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__findings_truncated => {
                            if !fields.insert(__FieldTag::__findings_truncated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for findings_truncated",
                                ));
                            }
                            result.findings_truncated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SdpInspectResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !self.message_items.is_empty() {
            state.serialize_entry("messageItems", &self.message_items)?;
        }
        if !wkt::internal::is_default(&self.match_state) {
            state.serialize_entry("matchState", &self.match_state)?;
        }
        if !self.findings.is_empty() {
            state.serialize_entry("findings", &self.findings)?;
        }
        if !wkt::internal::is_default(&self.findings_truncated) {
            state.serialize_entry("findingsTruncated", &self.findings_truncated)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SdpInspectResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SdpInspectResult");
        debug_struct.field("execution_state", &self.execution_state);
        debug_struct.field("message_items", &self.message_items);
        debug_struct.field("match_state", &self.match_state);
        debug_struct.field("findings", &self.findings);
        debug_struct.field("findings_truncated", &self.findings_truncated);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents Data item
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataItem {
    /// Either of text or bytes data.
    pub data_item: std::option::Option<crate::model::data_item::DataItem>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item].
    ///
    /// Note that all the setters affecting `data_item` are mutually
    /// exclusive.
    pub fn set_data_item<
        T: std::convert::Into<std::option::Option<crate::model::data_item::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// The value of [data_item][crate::model::DataItem::data_item]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::data_item::DataItem::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::data_item::DataItem::Text(v.into()));
        self
    }

    /// The value of [data_item][crate::model::DataItem::data_item]
    /// if it holds a `ByteItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn byte_item(&self) -> std::option::Option<&std::boxed::Box<crate::model::ByteDataItem>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::data_item::DataItem::ByteItem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::DataItem::data_item]
    /// to hold a `ByteItem`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_byte_item<T: std::convert::Into<std::boxed::Box<crate::model::ByteDataItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::data_item::DataItem::ByteItem(v.into()));
        self
    }
}

impl wkt::message::Message for DataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.DataItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __byte_item,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "byteItem" => Ok(__FieldTag::__byte_item),
                            "byte_item" => Ok(__FieldTag::__byte_item),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.data_item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_item`, a oneof with full ID .google.cloud.modelarmor.v1.DataItem.text, latest field was text",
                                ));
                            }
                            result.data_item =
                                std::option::Option::Some(crate::model::data_item::DataItem::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__byte_item => {
                            if !fields.insert(__FieldTag::__byte_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byte_item",
                                ));
                            }
                            if result.data_item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_item`, a oneof with full ID .google.cloud.modelarmor.v1.DataItem.byte_item, latest field was byteItem",
                                ));
                            }
                            result.data_item = std::option::Option::Some(
                                crate::model::data_item::DataItem::ByteItem(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ByteDataItem>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.byte_item() {
            state.serialize_entry("byteItem", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataItem");
        debug_struct.field("data_item", &self.data_item);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DataItem].
pub mod data_item {
    #[allow(unused_imports)]
    use super::*;

    /// Either of text or bytes data.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataItem {
        /// Plaintext string data for sanitization.
        Text(std::string::String),
        /// Data provided in the form of bytes.
        ByteItem(std::boxed::Box<crate::model::ByteDataItem>),
    }
}

/// Represents Byte Data item.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ByteDataItem {
    /// Required. The type of byte data
    pub byte_data_type: crate::model::byte_data_item::ByteItemType,

    /// Required. Bytes Data
    pub byte_data: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ByteDataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [byte_data_type][crate::model::ByteDataItem::byte_data_type].
    pub fn set_byte_data_type<T: std::convert::Into<crate::model::byte_data_item::ByteItemType>>(
        mut self,
        v: T,
    ) -> Self {
        self.byte_data_type = v.into();
        self
    }

    /// Sets the value of [byte_data][crate::model::ByteDataItem::byte_data].
    pub fn set_byte_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.byte_data = v.into();
        self
    }
}

impl wkt::message::Message for ByteDataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.ByteDataItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ByteDataItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __byte_data_type,
            __byte_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ByteDataItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "byteDataType" => Ok(__FieldTag::__byte_data_type),
                            "byte_data_type" => Ok(__FieldTag::__byte_data_type),
                            "byteData" => Ok(__FieldTag::__byte_data),
                            "byte_data" => Ok(__FieldTag::__byte_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ByteDataItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ByteDataItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__byte_data_type => {
                            if !fields.insert(__FieldTag::__byte_data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byte_data_type",
                                ));
                            }
                            result.byte_data_type = map.next_value::<std::option::Option<crate::model::byte_data_item::ByteItemType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__byte_data => {
                            if !fields.insert(__FieldTag::__byte_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byte_data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.byte_data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ByteDataItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.byte_data_type) {
            state.serialize_entry("byteDataType", &self.byte_data_type)?;
        }
        if !self.byte_data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("byteData", &__With(&self.byte_data))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ByteDataItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ByteDataItem");
        debug_struct.field("byte_data_type", &self.byte_data_type);
        debug_struct.field("byte_data", &self.byte_data);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ByteDataItem].
pub mod byte_data_item {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the type of byte data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ByteItemType {
        /// Unused
        Unspecified,
        /// plain text
        PlaintextUtf8,
        /// PDF
        Pdf,
        /// DOCX, DOCM, DOTX, DOTM
        WordDocument,
        /// XLSX, XLSM, XLTX, XLYM
        ExcelDocument,
        /// PPTX, PPTM, POTX, POTM, POT
        PowerpointDocument,
        /// TXT
        Txt,
        /// CSV
        Csv,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ByteItemType::value] or
        /// [ByteItemType::name].
        UnknownValue(byte_item_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod byte_item_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ByteItemType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PlaintextUtf8 => std::option::Option::Some(1),
                Self::Pdf => std::option::Option::Some(2),
                Self::WordDocument => std::option::Option::Some(3),
                Self::ExcelDocument => std::option::Option::Some(4),
                Self::PowerpointDocument => std::option::Option::Some(5),
                Self::Txt => std::option::Option::Some(6),
                Self::Csv => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BYTE_ITEM_TYPE_UNSPECIFIED"),
                Self::PlaintextUtf8 => std::option::Option::Some("PLAINTEXT_UTF8"),
                Self::Pdf => std::option::Option::Some("PDF"),
                Self::WordDocument => std::option::Option::Some("WORD_DOCUMENT"),
                Self::ExcelDocument => std::option::Option::Some("EXCEL_DOCUMENT"),
                Self::PowerpointDocument => std::option::Option::Some("POWERPOINT_DOCUMENT"),
                Self::Txt => std::option::Option::Some("TXT"),
                Self::Csv => std::option::Option::Some("CSV"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ByteItemType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ByteItemType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ByteItemType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PlaintextUtf8,
                2 => Self::Pdf,
                3 => Self::WordDocument,
                4 => Self::ExcelDocument,
                5 => Self::PowerpointDocument,
                6 => Self::Txt,
                7 => Self::Csv,
                _ => Self::UnknownValue(byte_item_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ByteItemType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BYTE_ITEM_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PLAINTEXT_UTF8" => Self::PlaintextUtf8,
                "PDF" => Self::Pdf,
                "WORD_DOCUMENT" => Self::WordDocument,
                "EXCEL_DOCUMENT" => Self::ExcelDocument,
                "POWERPOINT_DOCUMENT" => Self::PowerpointDocument,
                "TXT" => Self::Txt,
                "CSV" => Self::Csv,
                _ => Self::UnknownValue(byte_item_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ByteItemType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PlaintextUtf8 => serializer.serialize_i32(1),
                Self::Pdf => serializer.serialize_i32(2),
                Self::WordDocument => serializer.serialize_i32(3),
                Self::ExcelDocument => serializer.serialize_i32(4),
                Self::PowerpointDocument => serializer.serialize_i32(5),
                Self::Txt => serializer.serialize_i32(6),
                Self::Csv => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ByteItemType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ByteItemType>::new(
                ".google.cloud.modelarmor.v1.ByteDataItem.ByteItemType",
            ))
        }
    }
}

/// Sensitive Data Protection Deidentification Result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SdpDeidentifyResult {
    /// Output only. Reports whether Sensitive Data Protection deidentification was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for Sensitive Data Protection Deidentification.
    /// Value is MATCH_FOUND if content is de-identified.
    pub match_state: crate::model::FilterMatchState,

    /// De-identified data.
    pub data: std::option::Option<crate::model::DataItem>,

    /// Total size in bytes that were transformed during deidentification.
    pub transformed_bytes: i64,

    /// List of Sensitive Data Protection info-types that were de-identified.
    pub info_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpDeidentifyResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::SdpDeidentifyResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::SdpDeidentifyResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::SdpDeidentifyResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [data][crate::model::SdpDeidentifyResult::data].
    pub fn set_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataItem>,
    {
        self.data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data][crate::model::SdpDeidentifyResult::data].
    pub fn set_or_clear_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataItem>,
    {
        self.data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::SdpDeidentifyResult::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [info_types][crate::model::SdpDeidentifyResult::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SdpDeidentifyResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpDeidentifyResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SdpDeidentifyResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __data,
            __transformed_bytes,
            __info_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpDeidentifyResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "data" => Ok(__FieldTag::__data),
                            "transformedBytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformed_bytes" => Ok(__FieldTag::__transformed_bytes),
                            "infoTypes" => Ok(__FieldTag::__info_types),
                            "info_types" => Ok(__FieldTag::__info_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SdpDeidentifyResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpDeidentifyResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_items",
                                ));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_state",
                                ));
                            }
                            result.match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            result.data =
                                map.next_value::<std::option::Option<crate::model::DataItem>>()?;
                        }
                        __FieldTag::__transformed_bytes => {
                            if !fields.insert(__FieldTag::__transformed_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformed_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformed_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__info_types => {
                            if !fields.insert(__FieldTag::__info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_types",
                                ));
                            }
                            result.info_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SdpDeidentifyResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !self.message_items.is_empty() {
            state.serialize_entry("messageItems", &self.message_items)?;
        }
        if !wkt::internal::is_default(&self.match_state) {
            state.serialize_entry("matchState", &self.match_state)?;
        }
        if self.data.is_some() {
            state.serialize_entry("data", &self.data)?;
        }
        if !wkt::internal::is_default(&self.transformed_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transformedBytes", &__With(&self.transformed_bytes))?;
        }
        if !self.info_types.is_empty() {
            state.serialize_entry("infoTypes", &self.info_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SdpDeidentifyResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SdpDeidentifyResult");
        debug_struct.field("execution_state", &self.execution_state);
        debug_struct.field("message_items", &self.message_items);
        debug_struct.field("match_state", &self.match_state);
        debug_struct.field("data", &self.data);
        debug_struct.field("transformed_bytes", &self.transformed_bytes);
        debug_struct.field("info_types", &self.info_types);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Finding corresponding to Sensitive Data Protection filter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SdpFinding {
    /// Name of Sensitive Data Protection info type for this finding.
    pub info_type: std::string::String,

    /// Identified confidence likelihood for `info_type`.
    pub likelihood: crate::model::SdpFindingLikelihood,

    /// Location for this finding.
    pub location: std::option::Option<crate::model::sdp_finding::SdpFindingLocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SdpFinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::SdpFinding::info_type].
    pub fn set_info_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [likelihood][crate::model::SdpFinding::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::SdpFindingLikelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [location][crate::model::SdpFinding::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::sdp_finding::SdpFindingLocation>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::SdpFinding::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::sdp_finding::SdpFindingLocation>,
    {
        self.location = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SdpFinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.SdpFinding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SdpFinding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            __likelihood,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpFinding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "likelihood" => Ok(__FieldTag::__likelihood),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SdpFinding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpFinding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__likelihood => {
                            if !fields.insert(__FieldTag::__likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for likelihood",
                                ));
                            }
                            result.likelihood = map.next_value::<std::option::Option<crate::model::SdpFindingLikelihood>>()?.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map.next_value::<std::option::Option<
                                crate::model::sdp_finding::SdpFindingLocation,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SdpFinding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.info_type.is_empty() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !wkt::internal::is_default(&self.likelihood) {
            state.serialize_entry("likelihood", &self.likelihood)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SdpFinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SdpFinding");
        debug_struct.field("info_type", &self.info_type);
        debug_struct.field("likelihood", &self.likelihood);
        debug_struct.field("location", &self.location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SdpFinding].
pub mod sdp_finding {
    #[allow(unused_imports)]
    use super::*;

    /// Location of this Sensitive Data Protection Finding within input content.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SdpFindingLocation {
        /// Zero-based byte offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Note that when the content is not textual, this references
        /// the UTF-8 encoded textual representation of the content.
        pub byte_range: std::option::Option<crate::model::RangeInfo>,

        /// Unicode character offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Provided when the content is text.
        pub codepoint_range: std::option::Option<crate::model::RangeInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SdpFindingLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [byte_range][crate::model::sdp_finding::SdpFindingLocation::byte_range].
        pub fn set_byte_range<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RangeInfo>,
        {
            self.byte_range = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [byte_range][crate::model::sdp_finding::SdpFindingLocation::byte_range].
        pub fn set_or_clear_byte_range<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RangeInfo>,
        {
            self.byte_range = v.map(|x| x.into());
            self
        }

        /// Sets the value of [codepoint_range][crate::model::sdp_finding::SdpFindingLocation::codepoint_range].
        pub fn set_codepoint_range<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RangeInfo>,
        {
            self.codepoint_range = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [codepoint_range][crate::model::sdp_finding::SdpFindingLocation::codepoint_range].
        pub fn set_or_clear_codepoint_range<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RangeInfo>,
        {
            self.codepoint_range = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SdpFindingLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.SdpFinding.SdpFindingLocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SdpFindingLocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __byte_range,
                __codepoint_range,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SdpFindingLocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "byteRange" => Ok(__FieldTag::__byte_range),
                                "byte_range" => Ok(__FieldTag::__byte_range),
                                "codepointRange" => Ok(__FieldTag::__codepoint_range),
                                "codepoint_range" => Ok(__FieldTag::__codepoint_range),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SdpFindingLocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SdpFindingLocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__byte_range => {
                                if !fields.insert(__FieldTag::__byte_range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for byte_range",
                                    ));
                                }
                                result.byte_range = map
                                    .next_value::<std::option::Option<crate::model::RangeInfo>>()?;
                            }
                            __FieldTag::__codepoint_range => {
                                if !fields.insert(__FieldTag::__codepoint_range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for codepoint_range",
                                    ));
                                }
                                result.codepoint_range = map
                                    .next_value::<std::option::Option<crate::model::RangeInfo>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SdpFindingLocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.byte_range.is_some() {
                state.serialize_entry("byteRange", &self.byte_range)?;
            }
            if self.codepoint_range.is_some() {
                state.serialize_entry("codepointRange", &self.codepoint_range)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SdpFindingLocation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SdpFindingLocation");
            debug_struct.field("byte_range", &self.byte_range);
            debug_struct.field("codepoint_range", &self.codepoint_range);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Prompt injection and Jailbreak Filter Result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PiAndJailbreakFilterResult {
    /// Output only. Reports whether Prompt injection and Jailbreak filter was
    /// successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for Prompt injection and Jailbreak.
    pub match_state: crate::model::FilterMatchState,

    /// Confidence level identified for Prompt injection and Jailbreak.
    pub confidence_level: crate::model::DetectionConfidenceLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PiAndJailbreakFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::PiAndJailbreakFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::PiAndJailbreakFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::PiAndJailbreakFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [confidence_level][crate::model::PiAndJailbreakFilterResult::confidence_level].
    pub fn set_confidence_level<T: std::convert::Into<crate::model::DetectionConfidenceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidence_level = v.into();
        self
    }
}

impl wkt::message::Message for PiAndJailbreakFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.PiAndJailbreakFilterResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PiAndJailbreakFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __confidence_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PiAndJailbreakFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                            "confidence_level" => Ok(__FieldTag::__confidence_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PiAndJailbreakFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PiAndJailbreakFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_items",
                                ));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_state",
                                ));
                            }
                            result.match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence_level => {
                            if !fields.insert(__FieldTag::__confidence_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_level",
                                ));
                            }
                            result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PiAndJailbreakFilterResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !self.message_items.is_empty() {
            state.serialize_entry("messageItems", &self.message_items)?;
        }
        if !wkt::internal::is_default(&self.match_state) {
            state.serialize_entry("matchState", &self.match_state)?;
        }
        if !wkt::internal::is_default(&self.confidence_level) {
            state.serialize_entry("confidenceLevel", &self.confidence_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PiAndJailbreakFilterResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PiAndJailbreakFilterResult");
        debug_struct.field("execution_state", &self.execution_state);
        debug_struct.field("message_items", &self.message_items);
        debug_struct.field("match_state", &self.match_state);
        debug_struct.field("confidence_level", &self.confidence_level);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Malicious URI Filter Result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaliciousUriFilterResult {
    /// Output only. Reports whether Malicious URI filter was successfully executed
    /// or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for this Malicious URI.
    /// Value is MATCH_FOUND if at least one Malicious URI is found.
    pub match_state: crate::model::FilterMatchState,

    /// List of Malicious URIs found in data.
    pub malicious_uri_matched_items:
        std::vec::Vec<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaliciousUriFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::MaliciousUriFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::MaliciousUriFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::MaliciousUriFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [malicious_uri_matched_items][crate::model::MaliciousUriFilterResult::malicious_uri_matched_items].
    pub fn set_malicious_uri_matched_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>,
    {
        use std::iter::Iterator;
        self.malicious_uri_matched_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaliciousUriFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaliciousUriFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __malicious_uri_matched_items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaliciousUriFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "maliciousUriMatchedItems" => {
                                Ok(__FieldTag::__malicious_uri_matched_items)
                            }
                            "malicious_uri_matched_items" => {
                                Ok(__FieldTag::__malicious_uri_matched_items)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaliciousUriFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaliciousUriFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_items",
                                ));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_state",
                                ));
                            }
                            result.match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__malicious_uri_matched_items => {
                            if !fields.insert(__FieldTag::__malicious_uri_matched_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for malicious_uri_matched_items",
                                ));
                            }
                            result.malicious_uri_matched_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaliciousUriFilterResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !self.message_items.is_empty() {
            state.serialize_entry("messageItems", &self.message_items)?;
        }
        if !wkt::internal::is_default(&self.match_state) {
            state.serialize_entry("matchState", &self.match_state)?;
        }
        if !self.malicious_uri_matched_items.is_empty() {
            state.serialize_entry(
                "maliciousUriMatchedItems",
                &self.malicious_uri_matched_items,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaliciousUriFilterResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaliciousUriFilterResult");
        debug_struct.field("execution_state", &self.execution_state);
        debug_struct.field("message_items", &self.message_items);
        debug_struct.field("match_state", &self.match_state);
        debug_struct.field(
            "malicious_uri_matched_items",
            &self.malicious_uri_matched_items,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MaliciousUriFilterResult].
pub mod malicious_uri_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Information regarding malicious URI and its location within the input
    /// content.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MaliciousUriMatchedItem {
        /// Malicious URI.
        pub uri: std::string::String,

        /// List of locations where Malicious URI is identified.
        /// The `locations` field is supported only for plaintext content i.e.
        /// ByteItemType.PLAINTEXT_UTF8
        pub locations: std::vec::Vec<crate::model::RangeInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MaliciousUriMatchedItem {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [locations][crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem::locations].
        pub fn set_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RangeInfo>,
        {
            use std::iter::Iterator;
            self.locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MaliciousUriMatchedItem {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.modelarmor.v1.MaliciousUriFilterResult.MaliciousUriMatchedItem"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MaliciousUriMatchedItem {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                __locations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MaliciousUriMatchedItem")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                "locations" => Ok(__FieldTag::__locations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MaliciousUriMatchedItem;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MaliciousUriMatchedItem")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__locations => {
                                if !fields.insert(__FieldTag::__locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for locations",
                                    ));
                                }
                                result.locations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RangeInfo>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MaliciousUriMatchedItem {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.locations.is_empty() {
                state.serialize_entry("locations", &self.locations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MaliciousUriMatchedItem {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MaliciousUriMatchedItem");
            debug_struct.field("uri", &self.uri);
            debug_struct.field("locations", &self.locations);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Virus scan results.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VirusScanFilterResult {
    /// Output only. Reports whether Virus Scan was successfully executed or not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution status is skipped then this field provides
    /// related reason/explanation.
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match status for Virus.
    /// Value is MATCH_FOUND if the data is infected with a virus.
    pub match_state: crate::model::FilterMatchState,

    /// Type of content scanned.
    pub scanned_content_type: crate::model::virus_scan_filter_result::ScannedContentType,

    /// Size of scanned content in bytes.
    pub scanned_size: std::option::Option<i64>,

    /// List of Viruses identified.
    /// This field will be empty if no virus was detected.
    pub virus_details: std::vec::Vec<crate::model::VirusDetail>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirusScanFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::VirusScanFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::VirusScanFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::VirusScanFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }

    /// Sets the value of [scanned_content_type][crate::model::VirusScanFilterResult::scanned_content_type].
    pub fn set_scanned_content_type<
        T: std::convert::Into<crate::model::virus_scan_filter_result::ScannedContentType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scanned_content_type = v.into();
        self
    }

    /// Sets the value of [scanned_size][crate::model::VirusScanFilterResult::scanned_size].
    pub fn set_scanned_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.scanned_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scanned_size][crate::model::VirusScanFilterResult::scanned_size].
    pub fn set_or_clear_scanned_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.scanned_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [virus_details][crate::model::VirusScanFilterResult::virus_details].
    pub fn set_virus_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VirusDetail>,
    {
        use std::iter::Iterator;
        self.virus_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VirusScanFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.VirusScanFilterResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VirusScanFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __scanned_content_type,
            __scanned_size,
            __virus_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirusScanFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "scannedContentType" => Ok(__FieldTag::__scanned_content_type),
                            "scanned_content_type" => Ok(__FieldTag::__scanned_content_type),
                            "scannedSize" => Ok(__FieldTag::__scanned_size),
                            "scanned_size" => Ok(__FieldTag::__scanned_size),
                            "virusDetails" => Ok(__FieldTag::__virus_details),
                            "virus_details" => Ok(__FieldTag::__virus_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VirusScanFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirusScanFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_items",
                                ));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_state",
                                ));
                            }
                            result.match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scanned_content_type => {
                            if !fields.insert(__FieldTag::__scanned_content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scanned_content_type",
                                ));
                            }
                            result.scanned_content_type = map
                                .next_value::<std::option::Option<
                                    crate::model::virus_scan_filter_result::ScannedContentType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scanned_size => {
                            if !fields.insert(__FieldTag::__scanned_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scanned_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scanned_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__virus_details => {
                            if !fields.insert(__FieldTag::__virus_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virus_details",
                                ));
                            }
                            result.virus_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VirusDetail>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VirusScanFilterResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !self.message_items.is_empty() {
            state.serialize_entry("messageItems", &self.message_items)?;
        }
        if !wkt::internal::is_default(&self.match_state) {
            state.serialize_entry("matchState", &self.match_state)?;
        }
        if !wkt::internal::is_default(&self.scanned_content_type) {
            state.serialize_entry("scannedContentType", &self.scanned_content_type)?;
        }
        if self.scanned_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("scannedSize", &__With(&self.scanned_size))?;
        }
        if !self.virus_details.is_empty() {
            state.serialize_entry("virusDetails", &self.virus_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VirusScanFilterResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VirusScanFilterResult");
        debug_struct.field("execution_state", &self.execution_state);
        debug_struct.field("message_items", &self.message_items);
        debug_struct.field("match_state", &self.match_state);
        debug_struct.field("scanned_content_type", &self.scanned_content_type);
        debug_struct.field("scanned_size", &self.scanned_size);
        debug_struct.field("virus_details", &self.virus_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VirusScanFilterResult].
pub mod virus_scan_filter_result {
    #[allow(unused_imports)]
    use super::*;

    /// Type of content scanned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScannedContentType {
        /// Unused
        Unspecified,
        /// Unknown content
        Unknown,
        /// Plaintext
        Plaintext,
        /// PDF
        /// Scanning for only PDF is supported.
        Pdf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ScannedContentType::value] or
        /// [ScannedContentType::name].
        UnknownValue(scanned_content_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scanned_content_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ScannedContentType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Plaintext => std::option::Option::Some(2),
                Self::Pdf => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCANNED_CONTENT_TYPE_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Plaintext => std::option::Option::Some("PLAINTEXT"),
                Self::Pdf => std::option::Option::Some("PDF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ScannedContentType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ScannedContentType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ScannedContentType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Plaintext,
                3 => Self::Pdf,
                _ => Self::UnknownValue(scanned_content_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ScannedContentType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCANNED_CONTENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "PLAINTEXT" => Self::Plaintext,
                "PDF" => Self::Pdf,
                _ => Self::UnknownValue(scanned_content_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ScannedContentType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Plaintext => serializer.serialize_i32(2),
                Self::Pdf => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ScannedContentType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScannedContentType>::new(
                ".google.cloud.modelarmor.v1.VirusScanFilterResult.ScannedContentType",
            ))
        }
    }
}

/// Details of an identified virus
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VirusDetail {
    /// Name of vendor that produced this virus identification.
    pub vendor: std::string::String,

    /// Names of this Virus.
    pub names: std::vec::Vec<std::string::String>,

    /// Threat type of the identified virus
    pub threat_type: crate::model::virus_detail::ThreatType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirusDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vendor][crate::model::VirusDetail::vendor].
    pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vendor = v.into();
        self
    }

    /// Sets the value of [names][crate::model::VirusDetail::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [threat_type][crate::model::VirusDetail::threat_type].
    pub fn set_threat_type<T: std::convert::Into<crate::model::virus_detail::ThreatType>>(
        mut self,
        v: T,
    ) -> Self {
        self.threat_type = v.into();
        self
    }
}

impl wkt::message::Message for VirusDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.VirusDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VirusDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vendor,
            __names,
            __threat_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirusDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vendor" => Ok(__FieldTag::__vendor),
                            "names" => Ok(__FieldTag::__names),
                            "threatType" => Ok(__FieldTag::__threat_type),
                            "threat_type" => Ok(__FieldTag::__threat_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VirusDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirusDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vendor => {
                            if !fields.insert(__FieldTag::__vendor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vendor",
                                ));
                            }
                            result.vendor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__threat_type => {
                            if !fields.insert(__FieldTag::__threat_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_type",
                                ));
                            }
                            result.threat_type = map.next_value::<std::option::Option<crate::model::virus_detail::ThreatType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VirusDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vendor.is_empty() {
            state.serialize_entry("vendor", &self.vendor)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !wkt::internal::is_default(&self.threat_type) {
            state.serialize_entry("threatType", &self.threat_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VirusDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VirusDetail");
        debug_struct.field("vendor", &self.vendor);
        debug_struct.field("names", &self.names);
        debug_struct.field("threat_type", &self.threat_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VirusDetail].
pub mod virus_detail {
    #[allow(unused_imports)]
    use super::*;

    /// Defines all the threat types of a virus
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ThreatType {
        /// Unused
        Unspecified,
        /// Unable to categorize threat
        Unknown,
        /// Virus or Worm threat.
        VirusOrWorm,
        /// Malicious program. E.g. Spyware, Trojan.
        MaliciousProgram,
        /// Potentially harmful content. E.g. Injected code, Macro
        PotentiallyHarmfulContent,
        /// Potentially unwanted content. E.g. Adware.
        PotentiallyUnwantedContent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ThreatType::value] or
        /// [ThreatType::name].
        UnknownValue(threat_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod threat_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ThreatType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::VirusOrWorm => std::option::Option::Some(2),
                Self::MaliciousProgram => std::option::Option::Some(3),
                Self::PotentiallyHarmfulContent => std::option::Option::Some(4),
                Self::PotentiallyUnwantedContent => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("THREAT_TYPE_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::VirusOrWorm => std::option::Option::Some("VIRUS_OR_WORM"),
                Self::MaliciousProgram => std::option::Option::Some("MALICIOUS_PROGRAM"),
                Self::PotentiallyHarmfulContent => {
                    std::option::Option::Some("POTENTIALLY_HARMFUL_CONTENT")
                }
                Self::PotentiallyUnwantedContent => {
                    std::option::Option::Some("POTENTIALLY_UNWANTED_CONTENT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ThreatType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ThreatType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ThreatType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::VirusOrWorm,
                3 => Self::MaliciousProgram,
                4 => Self::PotentiallyHarmfulContent,
                5 => Self::PotentiallyUnwantedContent,
                _ => Self::UnknownValue(threat_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ThreatType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "THREAT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "VIRUS_OR_WORM" => Self::VirusOrWorm,
                "MALICIOUS_PROGRAM" => Self::MaliciousProgram,
                "POTENTIALLY_HARMFUL_CONTENT" => Self::PotentiallyHarmfulContent,
                "POTENTIALLY_UNWANTED_CONTENT" => Self::PotentiallyUnwantedContent,
                _ => Self::UnknownValue(threat_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ThreatType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::VirusOrWorm => serializer.serialize_i32(2),
                Self::MaliciousProgram => serializer.serialize_i32(3),
                Self::PotentiallyHarmfulContent => serializer.serialize_i32(4),
                Self::PotentiallyUnwantedContent => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ThreatType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ThreatType>::new(
                ".google.cloud.modelarmor.v1.VirusDetail.ThreatType",
            ))
        }
    }
}

/// CSAM (Child Safety Abuse Material) Filter Result
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CsamFilterResult {
    /// Output only. Reports whether the CSAM filter was successfully executed or
    /// not.
    pub execution_state: crate::model::FilterExecutionState,

    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    pub message_items: std::vec::Vec<crate::model::MessageItem>,

    /// Output only. Match state for CSAM.
    pub match_state: crate::model::FilterMatchState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CsamFilterResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_state][crate::model::CsamFilterResult::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::FilterExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [message_items][crate::model::CsamFilterResult::message_items].
    pub fn set_message_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageItem>,
    {
        use std::iter::Iterator;
        self.message_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [match_state][crate::model::CsamFilterResult::match_state].
    pub fn set_match_state<T: std::convert::Into<crate::model::FilterMatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_state = v.into();
        self
    }
}

impl wkt::message::Message for CsamFilterResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.CsamFilterResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CsamFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CsamFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CsamFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CsamFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_items",
                                ));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_state",
                                ));
                            }
                            result.match_state = map
                                .next_value::<std::option::Option<crate::model::FilterMatchState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CsamFilterResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !self.message_items.is_empty() {
            state.serialize_entry("messageItems", &self.message_items)?;
        }
        if !wkt::internal::is_default(&self.match_state) {
            state.serialize_entry("matchState", &self.match_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CsamFilterResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CsamFilterResult");
        debug_struct.field("execution_state", &self.execution_state);
        debug_struct.field("message_items", &self.message_items);
        debug_struct.field("match_state", &self.match_state);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message item to report information, warning or error messages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageItem {
    /// Type of message.
    pub message_type: crate::model::message_item::MessageType,

    /// The message content.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_type][crate::model::MessageItem::message_type].
    pub fn set_message_type<T: std::convert::Into<crate::model::message_item::MessageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = v.into();
        self
    }

    /// Sets the value of [message][crate::model::MessageItem::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for MessageItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.MessageItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MessageItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_type,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageType" => Ok(__FieldTag::__message_type),
                            "message_type" => Ok(__FieldTag::__message_type),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MessageItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_type => {
                            if !fields.insert(__FieldTag::__message_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_type",
                                ));
                            }
                            result.message_type = map.next_value::<std::option::Option<crate::model::message_item::MessageType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MessageItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.message_type) {
            state.serialize_entry("messageType", &self.message_type)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MessageItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MessageItem");
        debug_struct.field("message_type", &self.message_type);
        debug_struct.field("message", &self.message);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MessageItem].
pub mod message_item {
    #[allow(unused_imports)]
    use super::*;

    /// Option to specify the type of message.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MessageType {
        /// Unused
        Unspecified,
        /// Information related message.
        Info,
        /// Warning related message.
        Warning,
        /// Error message.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MessageType::value] or
        /// [MessageType::name].
        UnknownValue(message_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod message_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MessageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MESSAGE_TYPE_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MessageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MessageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MessageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MessageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MessageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MessageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MessageType>::new(
                ".google.cloud.modelarmor.v1.MessageItem.MessageType",
            ))
        }
    }
}

/// Half-open range interval [start, end)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RangeInfo {
    /// For proto3, value cannot be set to 0 unless the field is optional.
    /// Ref: <https://protobuf.dev/programming-guides/proto3/#default>
    /// Index of first character (inclusive).
    pub start: std::option::Option<i64>,

    /// Index of last character (exclusive).
    pub end: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RangeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::RangeInfo::start].
    pub fn set_start<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.start = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start][crate::model::RangeInfo::start].
    pub fn set_or_clear_start<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.start = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end][crate::model::RangeInfo::end].
    pub fn set_end<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.end = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end][crate::model::RangeInfo::end].
    pub fn set_or_clear_end<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.end = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RangeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.modelarmor.v1.RangeInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RangeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RangeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RangeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("start", &__With(&self.start))?;
        }
        if self.end.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("end", &__With(&self.end))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RangeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RangeInfo");
        debug_struct.field("start", &self.start);
        debug_struct.field("end", &self.end);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Option to specify filter match state.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FilterMatchState {
    /// Unused
    Unspecified,
    /// Matching criteria is not achieved for filters.
    NoMatchFound,
    /// Matching criteria is achieved for the filter.
    MatchFound,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FilterMatchState::value] or
    /// [FilterMatchState::name].
    UnknownValue(filter_match_state::UnknownValue),
}

#[doc(hidden)]
pub mod filter_match_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FilterMatchState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NoMatchFound => std::option::Option::Some(1),
            Self::MatchFound => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FILTER_MATCH_STATE_UNSPECIFIED"),
            Self::NoMatchFound => std::option::Option::Some("NO_MATCH_FOUND"),
            Self::MatchFound => std::option::Option::Some("MATCH_FOUND"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FilterMatchState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FilterMatchState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FilterMatchState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NoMatchFound,
            2 => Self::MatchFound,
            _ => Self::UnknownValue(filter_match_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FilterMatchState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FILTER_MATCH_STATE_UNSPECIFIED" => Self::Unspecified,
            "NO_MATCH_FOUND" => Self::NoMatchFound,
            "MATCH_FOUND" => Self::MatchFound,
            _ => Self::UnknownValue(filter_match_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FilterMatchState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NoMatchFound => serializer.serialize_i32(1),
            Self::MatchFound => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FilterMatchState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilterMatchState>::new(
            ".google.cloud.modelarmor.v1.FilterMatchState",
        ))
    }
}

/// Enum which reports whether a specific filter executed successfully or not.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FilterExecutionState {
    /// Unused
    Unspecified,
    /// Filter executed successfully
    ExecutionSuccess,
    /// Filter execution was skipped. This can happen due to server-side error
    /// or permission issue.
    ExecutionSkipped,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FilterExecutionState::value] or
    /// [FilterExecutionState::name].
    UnknownValue(filter_execution_state::UnknownValue),
}

#[doc(hidden)]
pub mod filter_execution_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FilterExecutionState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ExecutionSuccess => std::option::Option::Some(1),
            Self::ExecutionSkipped => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FILTER_EXECUTION_STATE_UNSPECIFIED"),
            Self::ExecutionSuccess => std::option::Option::Some("EXECUTION_SUCCESS"),
            Self::ExecutionSkipped => std::option::Option::Some("EXECUTION_SKIPPED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FilterExecutionState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FilterExecutionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FilterExecutionState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ExecutionSuccess,
            2 => Self::ExecutionSkipped,
            _ => Self::UnknownValue(filter_execution_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FilterExecutionState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FILTER_EXECUTION_STATE_UNSPECIFIED" => Self::Unspecified,
            "EXECUTION_SUCCESS" => Self::ExecutionSuccess,
            "EXECUTION_SKIPPED" => Self::ExecutionSkipped,
            _ => Self::UnknownValue(filter_execution_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FilterExecutionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ExecutionSuccess => serializer.serialize_i32(1),
            Self::ExecutionSkipped => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FilterExecutionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilterExecutionState>::new(
            ".google.cloud.modelarmor.v1.FilterExecutionState",
        ))
    }
}

/// Options for responsible AI Filter Types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RaiFilterType {
    /// Unspecified filter type.
    Unspecified,
    /// Sexually Explicit.
    SexuallyExplicit,
    /// Hate Speech.
    HateSpeech,
    /// Harassment.
    Harassment,
    /// Danger
    Dangerous,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RaiFilterType::value] or
    /// [RaiFilterType::name].
    UnknownValue(rai_filter_type::UnknownValue),
}

#[doc(hidden)]
pub mod rai_filter_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RaiFilterType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SexuallyExplicit => std::option::Option::Some(2),
            Self::HateSpeech => std::option::Option::Some(3),
            Self::Harassment => std::option::Option::Some(6),
            Self::Dangerous => std::option::Option::Some(17),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RAI_FILTER_TYPE_UNSPECIFIED"),
            Self::SexuallyExplicit => std::option::Option::Some("SEXUALLY_EXPLICIT"),
            Self::HateSpeech => std::option::Option::Some("HATE_SPEECH"),
            Self::Harassment => std::option::Option::Some("HARASSMENT"),
            Self::Dangerous => std::option::Option::Some("DANGEROUS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RaiFilterType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RaiFilterType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RaiFilterType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::SexuallyExplicit,
            3 => Self::HateSpeech,
            6 => Self::Harassment,
            17 => Self::Dangerous,
            _ => Self::UnknownValue(rai_filter_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RaiFilterType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RAI_FILTER_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SEXUALLY_EXPLICIT" => Self::SexuallyExplicit,
            "HATE_SPEECH" => Self::HateSpeech,
            "HARASSMENT" => Self::Harassment,
            "DANGEROUS" => Self::Dangerous,
            _ => Self::UnknownValue(rai_filter_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RaiFilterType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SexuallyExplicit => serializer.serialize_i32(2),
            Self::HateSpeech => serializer.serialize_i32(3),
            Self::Harassment => serializer.serialize_i32(6),
            Self::Dangerous => serializer.serialize_i32(17),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RaiFilterType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RaiFilterType>::new(
            ".google.cloud.modelarmor.v1.RaiFilterType",
        ))
    }
}

/// Confidence levels for detectors.
/// Higher value maps to a greater confidence level. To enforce stricter level a
/// lower value should be used.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DetectionConfidenceLevel {
    /// Same as LOW_AND_ABOVE.
    Unspecified,
    /// Highest chance of a false positive.
    LowAndAbove,
    /// Some chance of false positives.
    MediumAndAbove,
    /// Low chance of false positives.
    High,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DetectionConfidenceLevel::value] or
    /// [DetectionConfidenceLevel::name].
    UnknownValue(detection_confidence_level::UnknownValue),
}

#[doc(hidden)]
pub mod detection_confidence_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DetectionConfidenceLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::LowAndAbove => std::option::Option::Some(1),
            Self::MediumAndAbove => std::option::Option::Some(2),
            Self::High => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED")
            }
            Self::LowAndAbove => std::option::Option::Some("LOW_AND_ABOVE"),
            Self::MediumAndAbove => std::option::Option::Some("MEDIUM_AND_ABOVE"),
            Self::High => std::option::Option::Some("HIGH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DetectionConfidenceLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DetectionConfidenceLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DetectionConfidenceLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::LowAndAbove,
            2 => Self::MediumAndAbove,
            3 => Self::High,
            _ => Self::UnknownValue(detection_confidence_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DetectionConfidenceLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "LOW_AND_ABOVE" => Self::LowAndAbove,
            "MEDIUM_AND_ABOVE" => Self::MediumAndAbove,
            "HIGH" => Self::High,
            _ => Self::UnknownValue(detection_confidence_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DetectionConfidenceLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::LowAndAbove => serializer.serialize_i32(1),
            Self::MediumAndAbove => serializer.serialize_i32(2),
            Self::High => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DetectionConfidenceLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetectionConfidenceLevel>::new(
            ".google.cloud.modelarmor.v1.DetectionConfidenceLevel",
        ))
    }
}

/// For more information about each Sensitive Data Protection likelihood level,
/// see <https://cloud.google.com/sensitive-data-protection/docs/likelihood>.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SdpFindingLikelihood {
    /// Default value; same as POSSIBLE.
    Unspecified,
    /// Highest chance of a false positive.
    VeryUnlikely,
    /// High chance of a false positive.
    Unlikely,
    /// Some matching signals. The default value.
    Possible,
    /// Low chance of a false positive.
    Likely,
    /// Confidence level is high. Lowest chance of a false positive.
    VeryLikely,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SdpFindingLikelihood::value] or
    /// [SdpFindingLikelihood::name].
    UnknownValue(sdp_finding_likelihood::UnknownValue),
}

#[doc(hidden)]
pub mod sdp_finding_likelihood {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SdpFindingLikelihood {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::VeryUnlikely => std::option::Option::Some(1),
            Self::Unlikely => std::option::Option::Some(2),
            Self::Possible => std::option::Option::Some(3),
            Self::Likely => std::option::Option::Some(4),
            Self::VeryLikely => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SDP_FINDING_LIKELIHOOD_UNSPECIFIED"),
            Self::VeryUnlikely => std::option::Option::Some("VERY_UNLIKELY"),
            Self::Unlikely => std::option::Option::Some("UNLIKELY"),
            Self::Possible => std::option::Option::Some("POSSIBLE"),
            Self::Likely => std::option::Option::Some("LIKELY"),
            Self::VeryLikely => std::option::Option::Some("VERY_LIKELY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SdpFindingLikelihood {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SdpFindingLikelihood {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SdpFindingLikelihood {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::VeryUnlikely,
            2 => Self::Unlikely,
            3 => Self::Possible,
            4 => Self::Likely,
            5 => Self::VeryLikely,
            _ => Self::UnknownValue(sdp_finding_likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SdpFindingLikelihood {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SDP_FINDING_LIKELIHOOD_UNSPECIFIED" => Self::Unspecified,
            "VERY_UNLIKELY" => Self::VeryUnlikely,
            "UNLIKELY" => Self::Unlikely,
            "POSSIBLE" => Self::Possible,
            "LIKELY" => Self::Likely,
            "VERY_LIKELY" => Self::VeryLikely,
            _ => Self::UnknownValue(sdp_finding_likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SdpFindingLikelihood {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::VeryUnlikely => serializer.serialize_i32(1),
            Self::Unlikely => serializer.serialize_i32(2),
            Self::Possible => serializer.serialize_i32(3),
            Self::Likely => serializer.serialize_i32(4),
            Self::VeryLikely => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SdpFindingLikelihood {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SdpFindingLikelihood>::new(
            ".google.cloud.modelarmor.v1.SdpFindingLikelihood",
        ))
    }
}

/// A field indicating the outcome of the invocation, irrespective of match
/// status.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InvocationResult {
    /// Unused. Default value.
    Unspecified,
    /// All filters were invoked successfully.
    Success,
    /// Some filters were skipped or failed.
    Partial,
    /// All filters were skipped or failed.
    Failure,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InvocationResult::value] or
    /// [InvocationResult::name].
    UnknownValue(invocation_result::UnknownValue),
}

#[doc(hidden)]
pub mod invocation_result {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InvocationResult {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Success => std::option::Option::Some(1),
            Self::Partial => std::option::Option::Some(2),
            Self::Failure => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INVOCATION_RESULT_UNSPECIFIED"),
            Self::Success => std::option::Option::Some("SUCCESS"),
            Self::Partial => std::option::Option::Some("PARTIAL"),
            Self::Failure => std::option::Option::Some("FAILURE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InvocationResult {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InvocationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InvocationResult {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Success,
            2 => Self::Partial,
            3 => Self::Failure,
            _ => Self::UnknownValue(invocation_result::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InvocationResult {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INVOCATION_RESULT_UNSPECIFIED" => Self::Unspecified,
            "SUCCESS" => Self::Success,
            "PARTIAL" => Self::Partial,
            "FAILURE" => Self::Failure,
            _ => Self::UnknownValue(invocation_result::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InvocationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Success => serializer.serialize_i32(1),
            Self::Partial => serializer.serialize_i32(2),
            Self::Failure => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InvocationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InvocationResult>::new(
            ".google.cloud.modelarmor.v1.InvocationResult",
        ))
    }
}
