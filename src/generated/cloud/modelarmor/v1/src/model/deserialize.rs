// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Template {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __filter_config,
            __template_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Template")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "filterConfig" => Ok(__FieldTag::__filter_config),
                            "filter_config" => Ok(__FieldTag::__filter_config),
                            "templateMetadata" => Ok(__FieldTag::__template_metadata),
                            "template_metadata" => Ok(__FieldTag::__template_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Template;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Template")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for labels"));
                            }
                            result.labels = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter_config => {
                            if !fields.insert(__FieldTag::__filter_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_config"));
                            }
                            result.filter_config = map.next_value::<std::option::Option<crate::model::FilterConfig>>()?
                                ;
                        },
                        __FieldTag::__template_metadata => {
                            if !fields.insert(__FieldTag::__template_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for template_metadata"));
                            }
                            result.template_metadata = map.next_value::<std::option::Option<crate::model::template::TemplateMetadata>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::template::TemplateMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ignore_partial_invocation_failures,
            __custom_prompt_safety_error_code,
            __custom_prompt_safety_error_message,
            __custom_llm_response_safety_error_code,
            __custom_llm_response_safety_error_message,
            __log_template_operations,
            __log_sanitize_operations,
            __enforcement_type,
            __multi_language_detection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TemplateMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ignorePartialInvocationFailures" => Ok(__FieldTag::__ignore_partial_invocation_failures),
                            "ignore_partial_invocation_failures" => Ok(__FieldTag::__ignore_partial_invocation_failures),
                            "customPromptSafetyErrorCode" => Ok(__FieldTag::__custom_prompt_safety_error_code),
                            "custom_prompt_safety_error_code" => Ok(__FieldTag::__custom_prompt_safety_error_code),
                            "customPromptSafetyErrorMessage" => Ok(__FieldTag::__custom_prompt_safety_error_message),
                            "custom_prompt_safety_error_message" => Ok(__FieldTag::__custom_prompt_safety_error_message),
                            "customLlmResponseSafetyErrorCode" => Ok(__FieldTag::__custom_llm_response_safety_error_code),
                            "custom_llm_response_safety_error_code" => Ok(__FieldTag::__custom_llm_response_safety_error_code),
                            "customLlmResponseSafetyErrorMessage" => Ok(__FieldTag::__custom_llm_response_safety_error_message),
                            "custom_llm_response_safety_error_message" => Ok(__FieldTag::__custom_llm_response_safety_error_message),
                            "logTemplateOperations" => Ok(__FieldTag::__log_template_operations),
                            "log_template_operations" => Ok(__FieldTag::__log_template_operations),
                            "logSanitizeOperations" => Ok(__FieldTag::__log_sanitize_operations),
                            "log_sanitize_operations" => Ok(__FieldTag::__log_sanitize_operations),
                            "enforcementType" => Ok(__FieldTag::__enforcement_type),
                            "enforcement_type" => Ok(__FieldTag::__enforcement_type),
                            "multiLanguageDetection" => Ok(__FieldTag::__multi_language_detection),
                            "multi_language_detection" => Ok(__FieldTag::__multi_language_detection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::template::TemplateMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TemplateMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ignore_partial_invocation_failures => {
                            if !fields.insert(__FieldTag::__ignore_partial_invocation_failures) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ignore_partial_invocation_failures"));
                            }
                            result.ignore_partial_invocation_failures = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__custom_prompt_safety_error_code => {
                            if !fields.insert(__FieldTag::__custom_prompt_safety_error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom_prompt_safety_error_code"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.custom_prompt_safety_error_code = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__custom_prompt_safety_error_message => {
                            if !fields.insert(__FieldTag::__custom_prompt_safety_error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom_prompt_safety_error_message"));
                            }
                            result.custom_prompt_safety_error_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__custom_llm_response_safety_error_code => {
                            if !fields.insert(__FieldTag::__custom_llm_response_safety_error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom_llm_response_safety_error_code"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.custom_llm_response_safety_error_code = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__custom_llm_response_safety_error_message => {
                            if !fields.insert(__FieldTag::__custom_llm_response_safety_error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom_llm_response_safety_error_message"));
                            }
                            result.custom_llm_response_safety_error_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__log_template_operations => {
                            if !fields.insert(__FieldTag::__log_template_operations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for log_template_operations"));
                            }
                            result.log_template_operations = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__log_sanitize_operations => {
                            if !fields.insert(__FieldTag::__log_sanitize_operations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for log_sanitize_operations"));
                            }
                            result.log_sanitize_operations = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enforcement_type => {
                            if !fields.insert(__FieldTag::__enforcement_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enforcement_type"));
                            }
                            result.enforcement_type = map.next_value::<std::option::Option<crate::model::template::template_metadata::EnforcementType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__multi_language_detection => {
                            if !fields.insert(__FieldTag::__multi_language_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for multi_language_detection"));
                            }
                            result.multi_language_detection = map.next_value::<std::option::Option<crate::model::template::template_metadata::MultiLanguageDetection>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::template::template_metadata::MultiLanguageDetection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_multi_language_detection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiLanguageDetection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableMultiLanguageDetection" => Ok(__FieldTag::__enable_multi_language_detection),
                            "enable_multi_language_detection" => Ok(__FieldTag::__enable_multi_language_detection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::template::template_metadata::MultiLanguageDetection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiLanguageDetection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_multi_language_detection => {
                            if !fields.insert(__FieldTag::__enable_multi_language_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_multi_language_detection"));
                            }
                            result.enable_multi_language_detection = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FloorSetting {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __filter_config,
            __enable_floor_setting_enforcement,
            __integrated_services,
            __ai_platform_floor_setting,
            __floor_setting_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FloorSetting")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "filterConfig" => Ok(__FieldTag::__filter_config),
                            "filter_config" => Ok(__FieldTag::__filter_config),
                            "enableFloorSettingEnforcement" => Ok(__FieldTag::__enable_floor_setting_enforcement),
                            "enable_floor_setting_enforcement" => Ok(__FieldTag::__enable_floor_setting_enforcement),
                            "integratedServices" => Ok(__FieldTag::__integrated_services),
                            "integrated_services" => Ok(__FieldTag::__integrated_services),
                            "aiPlatformFloorSetting" => Ok(__FieldTag::__ai_platform_floor_setting),
                            "ai_platform_floor_setting" => Ok(__FieldTag::__ai_platform_floor_setting),
                            "floorSettingMetadata" => Ok(__FieldTag::__floor_setting_metadata),
                            "floor_setting_metadata" => Ok(__FieldTag::__floor_setting_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FloorSetting;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FloorSetting")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__filter_config => {
                            if !fields.insert(__FieldTag::__filter_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_config"));
                            }
                            result.filter_config = map.next_value::<std::option::Option<crate::model::FilterConfig>>()?
                                ;
                        },
                        __FieldTag::__enable_floor_setting_enforcement => {
                            if !fields.insert(__FieldTag::__enable_floor_setting_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_floor_setting_enforcement"));
                            }
                            result.enable_floor_setting_enforcement = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__integrated_services => {
                            if !fields.insert(__FieldTag::__integrated_services) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for integrated_services"));
                            }
                            result.integrated_services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::floor_setting::IntegratedService>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ai_platform_floor_setting => {
                            if !fields.insert(__FieldTag::__ai_platform_floor_setting) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ai_platform_floor_setting"));
                            }
                            result.ai_platform_floor_setting = map.next_value::<std::option::Option<crate::model::AiPlatformFloorSetting>>()?
                                ;
                        },
                        __FieldTag::__floor_setting_metadata => {
                            if !fields.insert(__FieldTag::__floor_setting_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for floor_setting_metadata"));
                            }
                            result.floor_setting_metadata = map.next_value::<std::option::Option<crate::model::floor_setting::FloorSettingMetadata>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::floor_setting::FloorSettingMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __multi_language_detection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FloorSettingMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "multiLanguageDetection" => Ok(__FieldTag::__multi_language_detection),
                            "multi_language_detection" => Ok(__FieldTag::__multi_language_detection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::floor_setting::FloorSettingMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FloorSettingMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__multi_language_detection => {
                            if !fields.insert(__FieldTag::__multi_language_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for multi_language_detection"));
                            }
                            result.multi_language_detection = map.next_value::<std::option::Option<crate::model::floor_setting::floor_setting_metadata::MultiLanguageDetection>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::floor_setting::floor_setting_metadata::MultiLanguageDetection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_multi_language_detection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiLanguageDetection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableMultiLanguageDetection" => Ok(__FieldTag::__enable_multi_language_detection),
                            "enable_multi_language_detection" => Ok(__FieldTag::__enable_multi_language_detection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::floor_setting::floor_setting_metadata::MultiLanguageDetection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiLanguageDetection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_multi_language_detection => {
                            if !fields.insert(__FieldTag::__enable_multi_language_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_multi_language_detection"));
                            }
                            result.enable_multi_language_detection = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AiPlatformFloorSetting {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_only,
            __inspect_and_block,
            __enable_cloud_logging,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AiPlatformFloorSetting")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectOnly" => Ok(__FieldTag::__inspect_only),
                            "inspect_only" => Ok(__FieldTag::__inspect_only),
                            "inspectAndBlock" => Ok(__FieldTag::__inspect_and_block),
                            "inspect_and_block" => Ok(__FieldTag::__inspect_and_block),
                            "enableCloudLogging" => Ok(__FieldTag::__enable_cloud_logging),
                            "enable_cloud_logging" => Ok(__FieldTag::__enable_cloud_logging),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AiPlatformFloorSetting;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AiPlatformFloorSetting")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_only => {
                            if !fields.insert(__FieldTag::__inspect_only) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for inspect_only"));
                            }
                            if result.enforcement_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `enforcement_type`, a oneof with full ID .google.cloud.modelarmor.v1.AiPlatformFloorSetting.inspect_only, latest field was inspectOnly",
                                ));
                            }
                            result.enforcement_type = std::option::Option::Some(
                                crate::model::ai_platform_floor_setting::EnforcementType::InspectOnly(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__inspect_and_block => {
                            if !fields.insert(__FieldTag::__inspect_and_block) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for inspect_and_block"));
                            }
                            if result.enforcement_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `enforcement_type`, a oneof with full ID .google.cloud.modelarmor.v1.AiPlatformFloorSetting.inspect_and_block, latest field was inspectAndBlock",
                                ));
                            }
                            result.enforcement_type = std::option::Option::Some(
                                crate::model::ai_platform_floor_setting::EnforcementType::InspectAndBlock(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__enable_cloud_logging => {
                            if !fields.insert(__FieldTag::__enable_cloud_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_cloud_logging"));
                            }
                            result.enable_cloud_logging = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for order_by"));
                            }
                            result.order_by = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __templates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "templates" => Ok(__FieldTag::__templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__templates => {
                            if !fields.insert(__FieldTag::__templates) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for templates"));
                            }
                            result.templates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Template>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for unreachable"));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __template_id,
            __template,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "templateId" => Ok(__FieldTag::__template_id),
                            "template_id" => Ok(__FieldTag::__template_id),
                            "template" => Ok(__FieldTag::__template),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__template_id => {
                            if !fields.insert(__FieldTag::__template_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for template_id"));
                            }
                            result.template_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for template"));
                            }
                            result.template = map.next_value::<std::option::Option<crate::model::Template>>()?
                                ;
                        },
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_id"));
                            }
                            result.request_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __template,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "template" => Ok(__FieldTag::__template),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for template"));
                            }
                            result.template = map.next_value::<std::option::Option<crate::model::Template>>()?
                                ;
                        },
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_id"));
                            }
                            result.request_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_id"));
                            }
                            result.request_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetFloorSettingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFloorSettingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetFloorSettingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFloorSettingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateFloorSettingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __floor_setting,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFloorSettingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "floorSetting" => Ok(__FieldTag::__floor_setting),
                            "floor_setting" => Ok(__FieldTag::__floor_setting),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateFloorSettingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFloorSettingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__floor_setting => {
                            if !fields.insert(__FieldTag::__floor_setting) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for floor_setting"));
                            }
                            result.floor_setting = map.next_value::<std::option::Option<crate::model::FloorSetting>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FilterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rai_settings,
            __sdp_settings,
            __pi_and_jailbreak_filter_settings,
            __malicious_uri_filter_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "raiSettings" => Ok(__FieldTag::__rai_settings),
                            "rai_settings" => Ok(__FieldTag::__rai_settings),
                            "sdpSettings" => Ok(__FieldTag::__sdp_settings),
                            "sdp_settings" => Ok(__FieldTag::__sdp_settings),
                            "piAndJailbreakFilterSettings" => Ok(__FieldTag::__pi_and_jailbreak_filter_settings),
                            "pi_and_jailbreak_filter_settings" => Ok(__FieldTag::__pi_and_jailbreak_filter_settings),
                            "maliciousUriFilterSettings" => Ok(__FieldTag::__malicious_uri_filter_settings),
                            "malicious_uri_filter_settings" => Ok(__FieldTag::__malicious_uri_filter_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FilterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rai_settings => {
                            if !fields.insert(__FieldTag::__rai_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rai_settings"));
                            }
                            result.rai_settings = map.next_value::<std::option::Option<crate::model::RaiFilterSettings>>()?
                                ;
                        },
                        __FieldTag::__sdp_settings => {
                            if !fields.insert(__FieldTag::__sdp_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sdp_settings"));
                            }
                            result.sdp_settings = map.next_value::<std::option::Option<crate::model::SdpFilterSettings>>()?
                                ;
                        },
                        __FieldTag::__pi_and_jailbreak_filter_settings => {
                            if !fields.insert(__FieldTag::__pi_and_jailbreak_filter_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for pi_and_jailbreak_filter_settings"));
                            }
                            result.pi_and_jailbreak_filter_settings = map.next_value::<std::option::Option<crate::model::PiAndJailbreakFilterSettings>>()?
                                ;
                        },
                        __FieldTag::__malicious_uri_filter_settings => {
                            if !fields.insert(__FieldTag::__malicious_uri_filter_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for malicious_uri_filter_settings"));
                            }
                            result.malicious_uri_filter_settings = map.next_value::<std::option::Option<crate::model::MaliciousUriFilterSettings>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PiAndJailbreakFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_enforcement,
            __confidence_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PiAndJailbreakFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterEnforcement" => Ok(__FieldTag::__filter_enforcement),
                            "filter_enforcement" => Ok(__FieldTag::__filter_enforcement),
                            "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                            "confidence_level" => Ok(__FieldTag::__confidence_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PiAndJailbreakFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PiAndJailbreakFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_enforcement => {
                            if !fields.insert(__FieldTag::__filter_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_enforcement"));
                            }
                            result.filter_enforcement = map.next_value::<std::option::Option<crate::model::pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence_level => {
                            if !fields.insert(__FieldTag::__confidence_level) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence_level"));
                            }
                            result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaliciousUriFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_enforcement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaliciousUriFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterEnforcement" => Ok(__FieldTag::__filter_enforcement),
                            "filter_enforcement" => Ok(__FieldTag::__filter_enforcement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaliciousUriFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaliciousUriFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_enforcement => {
                            if !fields.insert(__FieldTag::__filter_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_enforcement"));
                            }
                            result.filter_enforcement = map.next_value::<std::option::Option<crate::model::malicious_uri_filter_settings::MaliciousUriFilterEnforcement>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RaiFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rai_filters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "raiFilters" => Ok(__FieldTag::__rai_filters),
                            "rai_filters" => Ok(__FieldTag::__rai_filters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RaiFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rai_filters => {
                            if !fields.insert(__FieldTag::__rai_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rai_filters"));
                            }
                            result.rai_filters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::rai_filter_settings::RaiFilter>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::rai_filter_settings::RaiFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_type,
            __confidence_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterType" => Ok(__FieldTag::__filter_type),
                            "filter_type" => Ok(__FieldTag::__filter_type),
                            "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                            "confidence_level" => Ok(__FieldTag::__confidence_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::rai_filter_settings::RaiFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_type => {
                            if !fields.insert(__FieldTag::__filter_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_type"));
                            }
                            result.filter_type = map.next_value::<std::option::Option<crate::model::RaiFilterType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence_level => {
                            if !fields.insert(__FieldTag::__confidence_level) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence_level"));
                            }
                            result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SdpFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __basic_config,
            __advanced_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "basicConfig" => Ok(__FieldTag::__basic_config),
                            "basic_config" => Ok(__FieldTag::__basic_config),
                            "advancedConfig" => Ok(__FieldTag::__advanced_config),
                            "advanced_config" => Ok(__FieldTag::__advanced_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SdpFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__basic_config => {
                            if !fields.insert(__FieldTag::__basic_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for basic_config"));
                            }
                            if result.sdp_configuration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sdp_configuration`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterSettings.basic_config, latest field was basicConfig",
                                ));
                            }
                            result.sdp_configuration = std::option::Option::Some(
                                crate::model::sdp_filter_settings::SdpConfiguration::BasicConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SdpBasicConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__advanced_config => {
                            if !fields.insert(__FieldTag::__advanced_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for advanced_config"));
                            }
                            if result.sdp_configuration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sdp_configuration`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterSettings.advanced_config, latest field was advancedConfig",
                                ));
                            }
                            result.sdp_configuration = std::option::Option::Some(
                                crate::model::sdp_filter_settings::SdpConfiguration::AdvancedConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SdpAdvancedConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SdpBasicConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_enforcement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpBasicConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterEnforcement" => Ok(__FieldTag::__filter_enforcement),
                            "filter_enforcement" => Ok(__FieldTag::__filter_enforcement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SdpBasicConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpBasicConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_enforcement => {
                            if !fields.insert(__FieldTag::__filter_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_enforcement"));
                            }
                            result.filter_enforcement = map.next_value::<std::option::Option<crate::model::sdp_basic_config::SdpBasicConfigEnforcement>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SdpAdvancedConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_template,
            __deidentify_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpAdvancedConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectTemplate" => Ok(__FieldTag::__inspect_template),
                            "inspect_template" => Ok(__FieldTag::__inspect_template),
                            "deidentifyTemplate" => Ok(__FieldTag::__deidentify_template),
                            "deidentify_template" => Ok(__FieldTag::__deidentify_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SdpAdvancedConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpAdvancedConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_template => {
                            if !fields.insert(__FieldTag::__inspect_template) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for inspect_template"));
                            }
                            result.inspect_template = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__deidentify_template => {
                            if !fields.insert(__FieldTag::__deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for deidentify_template"));
                            }
                            result.deidentify_template = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SanitizeUserPromptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __user_prompt_data,
            __multi_language_detection_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeUserPromptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "userPromptData" => Ok(__FieldTag::__user_prompt_data),
                            "user_prompt_data" => Ok(__FieldTag::__user_prompt_data),
                            "multiLanguageDetectionMetadata" => Ok(__FieldTag::__multi_language_detection_metadata),
                            "multi_language_detection_metadata" => Ok(__FieldTag::__multi_language_detection_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SanitizeUserPromptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeUserPromptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__user_prompt_data => {
                            if !fields.insert(__FieldTag::__user_prompt_data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for user_prompt_data"));
                            }
                            result.user_prompt_data = map.next_value::<std::option::Option<crate::model::DataItem>>()?
                                ;
                        },
                        __FieldTag::__multi_language_detection_metadata => {
                            if !fields.insert(__FieldTag::__multi_language_detection_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for multi_language_detection_metadata"));
                            }
                            result.multi_language_detection_metadata = map.next_value::<std::option::Option<crate::model::MultiLanguageDetectionMetadata>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SanitizeModelResponseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __model_response_data,
            __user_prompt,
            __multi_language_detection_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeModelResponseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "modelResponseData" => Ok(__FieldTag::__model_response_data),
                            "model_response_data" => Ok(__FieldTag::__model_response_data),
                            "userPrompt" => Ok(__FieldTag::__user_prompt),
                            "user_prompt" => Ok(__FieldTag::__user_prompt),
                            "multiLanguageDetectionMetadata" => Ok(__FieldTag::__multi_language_detection_metadata),
                            "multi_language_detection_metadata" => Ok(__FieldTag::__multi_language_detection_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SanitizeModelResponseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeModelResponseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__model_response_data => {
                            if !fields.insert(__FieldTag::__model_response_data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for model_response_data"));
                            }
                            result.model_response_data = map.next_value::<std::option::Option<crate::model::DataItem>>()?
                                ;
                        },
                        __FieldTag::__user_prompt => {
                            if !fields.insert(__FieldTag::__user_prompt) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for user_prompt"));
                            }
                            result.user_prompt = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__multi_language_detection_metadata => {
                            if !fields.insert(__FieldTag::__multi_language_detection_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for multi_language_detection_metadata"));
                            }
                            result.multi_language_detection_metadata = map.next_value::<std::option::Option<crate::model::MultiLanguageDetectionMetadata>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SanitizeUserPromptResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sanitization_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeUserPromptResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sanitizationResult" => Ok(__FieldTag::__sanitization_result),
                            "sanitization_result" => Ok(__FieldTag::__sanitization_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SanitizeUserPromptResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeUserPromptResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sanitization_result => {
                            if !fields.insert(__FieldTag::__sanitization_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sanitization_result"));
                            }
                            result.sanitization_result = map.next_value::<std::option::Option<crate::model::SanitizationResult>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SanitizeModelResponseResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sanitization_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizeModelResponseResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sanitizationResult" => Ok(__FieldTag::__sanitization_result),
                            "sanitization_result" => Ok(__FieldTag::__sanitization_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SanitizeModelResponseResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizeModelResponseResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sanitization_result => {
                            if !fields.insert(__FieldTag::__sanitization_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sanitization_result"));
                            }
                            result.sanitization_result = map.next_value::<std::option::Option<crate::model::SanitizationResult>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SanitizationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_match_state,
            __filter_results,
            __invocation_result,
            __sanitization_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterMatchState" => Ok(__FieldTag::__filter_match_state),
                            "filter_match_state" => Ok(__FieldTag::__filter_match_state),
                            "filterResults" => Ok(__FieldTag::__filter_results),
                            "filter_results" => Ok(__FieldTag::__filter_results),
                            "invocationResult" => Ok(__FieldTag::__invocation_result),
                            "invocation_result" => Ok(__FieldTag::__invocation_result),
                            "sanitizationMetadata" => Ok(__FieldTag::__sanitization_metadata),
                            "sanitization_metadata" => Ok(__FieldTag::__sanitization_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SanitizationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_match_state => {
                            if !fields.insert(__FieldTag::__filter_match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_match_state"));
                            }
                            result.filter_match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter_results => {
                            if !fields.insert(__FieldTag::__filter_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_results"));
                            }
                            result.filter_results = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::FilterResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__invocation_result => {
                            if !fields.insert(__FieldTag::__invocation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for invocation_result"));
                            }
                            result.invocation_result = map.next_value::<std::option::Option<crate::model::InvocationResult>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sanitization_metadata => {
                            if !fields.insert(__FieldTag::__sanitization_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sanitization_metadata"));
                            }
                            result.sanitization_metadata = map.next_value::<std::option::Option<crate::model::sanitization_result::SanitizationMetadata>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::sanitization_result::SanitizationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_code,
            __error_message,
            __ignore_partial_invocation_failures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SanitizationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorCode" => Ok(__FieldTag::__error_code),
                            "error_code" => Ok(__FieldTag::__error_code),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "ignorePartialInvocationFailures" => Ok(__FieldTag::__ignore_partial_invocation_failures),
                            "ignore_partial_invocation_failures" => Ok(__FieldTag::__ignore_partial_invocation_failures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::sanitization_result::SanitizationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SanitizationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_code => {
                            if !fields.insert(__FieldTag::__error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error_code"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.error_code = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error_message"));
                            }
                            result.error_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ignore_partial_invocation_failures => {
                            if !fields.insert(__FieldTag::__ignore_partial_invocation_failures) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ignore_partial_invocation_failures"));
                            }
                            result.ignore_partial_invocation_failures = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MultiLanguageDetectionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_language,
            __enable_multi_language_detection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiLanguageDetectionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceLanguage" => Ok(__FieldTag::__source_language),
                            "source_language" => Ok(__FieldTag::__source_language),
                            "enableMultiLanguageDetection" => Ok(__FieldTag::__enable_multi_language_detection),
                            "enable_multi_language_detection" => Ok(__FieldTag::__enable_multi_language_detection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MultiLanguageDetectionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiLanguageDetectionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_language => {
                            if !fields.insert(__FieldTag::__source_language) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_language"));
                            }
                            result.source_language = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_multi_language_detection => {
                            if !fields.insert(__FieldTag::__enable_multi_language_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_multi_language_detection"));
                            }
                            result.enable_multi_language_detection = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rai_filter_result,
            __sdp_filter_result,
            __pi_and_jailbreak_filter_result,
            __malicious_uri_filter_result,
            __csam_filter_filter_result,
            __virus_scan_filter_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "raiFilterResult" => Ok(__FieldTag::__rai_filter_result),
                            "rai_filter_result" => Ok(__FieldTag::__rai_filter_result),
                            "sdpFilterResult" => Ok(__FieldTag::__sdp_filter_result),
                            "sdp_filter_result" => Ok(__FieldTag::__sdp_filter_result),
                            "piAndJailbreakFilterResult" => Ok(__FieldTag::__pi_and_jailbreak_filter_result),
                            "pi_and_jailbreak_filter_result" => Ok(__FieldTag::__pi_and_jailbreak_filter_result),
                            "maliciousUriFilterResult" => Ok(__FieldTag::__malicious_uri_filter_result),
                            "malicious_uri_filter_result" => Ok(__FieldTag::__malicious_uri_filter_result),
                            "csamFilterFilterResult" => Ok(__FieldTag::__csam_filter_filter_result),
                            "csam_filter_filter_result" => Ok(__FieldTag::__csam_filter_filter_result),
                            "virusScanFilterResult" => Ok(__FieldTag::__virus_scan_filter_result),
                            "virus_scan_filter_result" => Ok(__FieldTag::__virus_scan_filter_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rai_filter_result => {
                            if !fields.insert(__FieldTag::__rai_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rai_filter_result"));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.rai_filter_result, latest field was raiFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::RaiFilterResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::RaiFilterResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__sdp_filter_result => {
                            if !fields.insert(__FieldTag::__sdp_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sdp_filter_result"));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.sdp_filter_result, latest field was sdpFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::SdpFilterResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SdpFilterResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__pi_and_jailbreak_filter_result => {
                            if !fields.insert(__FieldTag::__pi_and_jailbreak_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for pi_and_jailbreak_filter_result"));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.pi_and_jailbreak_filter_result, latest field was piAndJailbreakFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::PiAndJailbreakFilterResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PiAndJailbreakFilterResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__malicious_uri_filter_result => {
                            if !fields.insert(__FieldTag::__malicious_uri_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for malicious_uri_filter_result"));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.malicious_uri_filter_result, latest field was maliciousUriFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::MaliciousUriFilterResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MaliciousUriFilterResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__csam_filter_filter_result => {
                            if !fields.insert(__FieldTag::__csam_filter_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for csam_filter_filter_result"));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.csam_filter_filter_result, latest field was csamFilterFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::CsamFilterFilterResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CsamFilterResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__virus_scan_filter_result => {
                            if !fields.insert(__FieldTag::__virus_scan_filter_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for virus_scan_filter_result"));
                            }
                            if result.filter_result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_result`, a oneof with full ID .google.cloud.modelarmor.v1.FilterResult.virus_scan_filter_result, latest field was virusScanFilterResult",
                                ));
                            }
                            result.filter_result = std::option::Option::Some(
                                crate::model::filter_result::FilterResult::VirusScanFilterResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VirusScanFilterResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RaiFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __rai_filter_type_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "raiFilterTypeResults" => Ok(__FieldTag::__rai_filter_type_results),
                            "rai_filter_type_results" => Ok(__FieldTag::__rai_filter_type_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RaiFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for execution_state"));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_items"));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__rai_filter_type_results => {
                            if !fields.insert(__FieldTag::__rai_filter_type_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rai_filter_type_results"));
                            }
                            result.rai_filter_type_results = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::rai_filter_result::RaiFilterTypeResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::rai_filter_result::RaiFilterTypeResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter_type,
            __confidence_level,
            __match_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiFilterTypeResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filterType" => Ok(__FieldTag::__filter_type),
                            "filter_type" => Ok(__FieldTag::__filter_type),
                            "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                            "confidence_level" => Ok(__FieldTag::__confidence_level),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::rai_filter_result::RaiFilterTypeResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiFilterTypeResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter_type => {
                            if !fields.insert(__FieldTag::__filter_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_type"));
                            }
                            result.filter_type = map.next_value::<std::option::Option<crate::model::RaiFilterType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence_level => {
                            if !fields.insert(__FieldTag::__confidence_level) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence_level"));
                            }
                            result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SdpFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_result,
            __deidentify_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectResult" => Ok(__FieldTag::__inspect_result),
                            "inspect_result" => Ok(__FieldTag::__inspect_result),
                            "deidentifyResult" => Ok(__FieldTag::__deidentify_result),
                            "deidentify_result" => Ok(__FieldTag::__deidentify_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SdpFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_result => {
                            if !fields.insert(__FieldTag::__inspect_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for inspect_result"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterResult.inspect_result, latest field was inspectResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::sdp_filter_result::Result::InspectResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SdpInspectResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__deidentify_result => {
                            if !fields.insert(__FieldTag::__deidentify_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for deidentify_result"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.modelarmor.v1.SdpFilterResult.deidentify_result, latest field was deidentifyResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::sdp_filter_result::Result::DeidentifyResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SdpDeidentifyResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SdpInspectResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __findings,
            __findings_truncated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpInspectResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "findings" => Ok(__FieldTag::__findings),
                            "findingsTruncated" => Ok(__FieldTag::__findings_truncated),
                            "findings_truncated" => Ok(__FieldTag::__findings_truncated),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SdpInspectResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpInspectResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for execution_state"));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_items"));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__findings => {
                            if !fields.insert(__FieldTag::__findings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for findings"));
                            }
                            result.findings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SdpFinding>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__findings_truncated => {
                            if !fields.insert(__FieldTag::__findings_truncated) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for findings_truncated"));
                            }
                            result.findings_truncated = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DataItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __byte_item,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "byteItem" => Ok(__FieldTag::__byte_item),
                            "byte_item" => Ok(__FieldTag::__byte_item),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DataItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            if result.data_item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_item`, a oneof with full ID .google.cloud.modelarmor.v1.DataItem.text, latest field was text",
                                ));
                            }
                            result.data_item = std::option::Option::Some(
                                crate::model::data_item::DataItem::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__byte_item => {
                            if !fields.insert(__FieldTag::__byte_item) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for byte_item"));
                            }
                            if result.data_item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_item`, a oneof with full ID .google.cloud.modelarmor.v1.DataItem.byte_item, latest field was byteItem",
                                ));
                            }
                            result.data_item = std::option::Option::Some(
                                crate::model::data_item::DataItem::ByteItem(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ByteDataItem>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ByteDataItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __byte_data_type,
            __byte_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ByteDataItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "byteDataType" => Ok(__FieldTag::__byte_data_type),
                            "byte_data_type" => Ok(__FieldTag::__byte_data_type),
                            "byteData" => Ok(__FieldTag::__byte_data),
                            "byte_data" => Ok(__FieldTag::__byte_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ByteDataItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ByteDataItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__byte_data_type => {
                            if !fields.insert(__FieldTag::__byte_data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for byte_data_type"));
                            }
                            result.byte_data_type = map.next_value::<std::option::Option<crate::model::byte_data_item::ByteItemType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__byte_data => {
                            if !fields.insert(__FieldTag::__byte_data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for byte_data"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.byte_data = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SdpDeidentifyResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __data,
            __transformed_bytes,
            __info_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpDeidentifyResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "data" => Ok(__FieldTag::__data),
                            "transformedBytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformed_bytes" => Ok(__FieldTag::__transformed_bytes),
                            "infoTypes" => Ok(__FieldTag::__info_types),
                            "info_types" => Ok(__FieldTag::__info_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SdpDeidentifyResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpDeidentifyResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for execution_state"));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_items"));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for data"));
                            }
                            result.data = map.next_value::<std::option::Option<crate::model::DataItem>>()?
                                ;
                        },
                        __FieldTag::__transformed_bytes => {
                            if !fields.insert(__FieldTag::__transformed_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for transformed_bytes"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformed_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__info_types => {
                            if !fields.insert(__FieldTag::__info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for info_types"));
                            }
                            result.info_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SdpFinding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            __likelihood,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpFinding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "likelihood" => Ok(__FieldTag::__likelihood),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SdpFinding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpFinding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for info_type"));
                            }
                            result.info_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__likelihood => {
                            if !fields.insert(__FieldTag::__likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for likelihood"));
                            }
                            result.likelihood = map.next_value::<std::option::Option<crate::model::SdpFindingLikelihood>>()?.unwrap_or_default();
                        },
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for location"));
                            }
                            result.location = map.next_value::<std::option::Option<crate::model::sdp_finding::SdpFindingLocation>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::sdp_finding::SdpFindingLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __byte_range,
            __codepoint_range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SdpFindingLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "byteRange" => Ok(__FieldTag::__byte_range),
                            "byte_range" => Ok(__FieldTag::__byte_range),
                            "codepointRange" => Ok(__FieldTag::__codepoint_range),
                            "codepoint_range" => Ok(__FieldTag::__codepoint_range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::sdp_finding::SdpFindingLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SdpFindingLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__byte_range => {
                            if !fields.insert(__FieldTag::__byte_range) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for byte_range"));
                            }
                            result.byte_range = map.next_value::<std::option::Option<crate::model::RangeInfo>>()?
                                ;
                        },
                        __FieldTag::__codepoint_range => {
                            if !fields.insert(__FieldTag::__codepoint_range) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for codepoint_range"));
                            }
                            result.codepoint_range = map.next_value::<std::option::Option<crate::model::RangeInfo>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PiAndJailbreakFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __confidence_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PiAndJailbreakFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                            "confidence_level" => Ok(__FieldTag::__confidence_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PiAndJailbreakFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PiAndJailbreakFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for execution_state"));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_items"));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence_level => {
                            if !fields.insert(__FieldTag::__confidence_level) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence_level"));
                            }
                            result.confidence_level = map.next_value::<std::option::Option<crate::model::DetectionConfidenceLevel>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaliciousUriFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __malicious_uri_matched_items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaliciousUriFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "maliciousUriMatchedItems" => Ok(__FieldTag::__malicious_uri_matched_items),
                            "malicious_uri_matched_items" => Ok(__FieldTag::__malicious_uri_matched_items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaliciousUriFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaliciousUriFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for execution_state"));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_items"));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__malicious_uri_matched_items => {
                            if !fields.insert(__FieldTag::__malicious_uri_matched_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for malicious_uri_matched_items"));
                            }
                            result.malicious_uri_matched_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::malicious_uri_filter_result::MaliciousUriMatchedItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::malicious_uri_filter_result::MaliciousUriMatchedItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaliciousUriMatchedItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "locations" => Ok(__FieldTag::__locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::malicious_uri_filter_result::MaliciousUriMatchedItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaliciousUriMatchedItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for locations"));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RangeInfo>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VirusScanFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            __scanned_content_type,
            __scanned_size,
            __virus_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirusScanFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            "scannedContentType" => Ok(__FieldTag::__scanned_content_type),
                            "scanned_content_type" => Ok(__FieldTag::__scanned_content_type),
                            "scannedSize" => Ok(__FieldTag::__scanned_size),
                            "scanned_size" => Ok(__FieldTag::__scanned_size),
                            "virusDetails" => Ok(__FieldTag::__virus_details),
                            "virus_details" => Ok(__FieldTag::__virus_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VirusScanFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirusScanFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for execution_state"));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_items"));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__scanned_content_type => {
                            if !fields.insert(__FieldTag::__scanned_content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for scanned_content_type"));
                            }
                            result.scanned_content_type = map.next_value::<std::option::Option<crate::model::virus_scan_filter_result::ScannedContentType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__scanned_size => {
                            if !fields.insert(__FieldTag::__scanned_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for scanned_size"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scanned_size = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__virus_details => {
                            if !fields.insert(__FieldTag::__virus_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for virus_details"));
                            }
                            result.virus_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VirusDetail>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VirusDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vendor,
            __names,
            __threat_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirusDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vendor" => Ok(__FieldTag::__vendor),
                            "names" => Ok(__FieldTag::__names),
                            "threatType" => Ok(__FieldTag::__threat_type),
                            "threat_type" => Ok(__FieldTag::__threat_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VirusDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirusDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vendor => {
                            if !fields.insert(__FieldTag::__vendor) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vendor"));
                            }
                            result.vendor = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for names"));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__threat_type => {
                            if !fields.insert(__FieldTag::__threat_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for threat_type"));
                            }
                            result.threat_type = map.next_value::<std::option::Option<crate::model::virus_detail::ThreatType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CsamFilterResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_state,
            __message_items,
            __match_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CsamFilterResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "messageItems" => Ok(__FieldTag::__message_items),
                            "message_items" => Ok(__FieldTag::__message_items),
                            "matchState" => Ok(__FieldTag::__match_state),
                            "match_state" => Ok(__FieldTag::__match_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CsamFilterResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CsamFilterResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for execution_state"));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::FilterExecutionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_items => {
                            if !fields.insert(__FieldTag::__message_items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_items"));
                            }
                            result.message_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_state => {
                            if !fields.insert(__FieldTag::__match_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_state"));
                            }
                            result.match_state = map.next_value::<std::option::Option<crate::model::FilterMatchState>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_type,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageType" => Ok(__FieldTag::__message_type),
                            "message_type" => Ok(__FieldTag::__message_type),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_type => {
                            if !fields.insert(__FieldTag::__message_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_type"));
                            }
                            result.message_type = map.next_value::<std::option::Option<crate::model::message_item::MessageType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message"));
                            }
                            result.message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RangeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RangeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for start"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
