// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate cloud_common;
extern crate gax;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Network configuration for the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// The name of the Google Compute Engine
    /// [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the
    /// instance is connected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Internet protocol versions for which the instance has IP addresses
    /// assigned. For this version, only MODE_IPV4 is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub modes: std::vec::Vec<crate::model::network_config::AddressMode>,

    /// Optional, reserved_ip_range can have one of the following two types of
    /// values.
    ///
    /// * CIDR range value when using DIRECT_PEERING connect mode.
    /// * [Allocated IP address
    ///   range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address)
    ///   when using PRIVATE_SERVICE_ACCESS connect mode.
    ///
    /// When the name of an allocated IP address range is specified, it must be one
    /// of the ranges associated with the private service access connection.
    /// When specified as a direct CIDR value, it must be a /29 CIDR block for
    /// Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for
    /// Enterprise tier in one of the [internal IP address
    /// ranges](https://www.arin.net/reference/research/statistics/address_filters/)
    /// that identifies the range of IP addresses reserved for this instance. For
    /// example, 10.0.0.0/29, 192.168.0.0/24 or 192.168.0.0/26, respectively. The
    /// range you specify can't overlap with either existing subnets or assigned IP
    /// address ranges for other Filestore instances in the selected VPC
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reserved_ip_range: std::string::String,

    /// Output only. IPv4 addresses in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format
    /// `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_addresses: std::vec::Vec<std::string::String>,

    /// The network connect mode of the Filestore instance.
    /// If not provided, the connect mode defaults to DIRECT_PEERING.
    pub connect_mode: crate::model::network_config::ConnectMode,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [reserved_ip_range][crate::model::NetworkConfig::reserved_ip_range].
    pub fn set_reserved_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reserved_ip_range = v.into();
        self
    }

    /// Sets the value of [connect_mode][crate::model::NetworkConfig::connect_mode].
    pub fn set_connect_mode<T: std::convert::Into<crate::model::network_config::ConnectMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.connect_mode = v.into();
        self
    }

    /// Sets the value of [modes][crate::model::NetworkConfig::modes].
    pub fn set_modes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::network_config::AddressMode>,
    {
        use std::iter::Iterator;
        self.modes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::NetworkConfig::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.NetworkConfig"
    }
}

/// Defines additional types related to NetworkConfig
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// Internet protocol versions supported by Filestore.
    #[derive(Clone, Debug, PartialEq)]
    pub struct AddressMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [AddressMode](AddressMode)
    pub mod address_mode {
        use super::AddressMode;

        /// Internet protocol not set.
        pub const ADDRESS_MODE_UNSPECIFIED: AddressMode =
            AddressMode::known("ADDRESS_MODE_UNSPECIFIED", 0);

        /// Use the IPv4 internet protocol.
        pub const MODE_IPV4: AddressMode = AddressMode::known("MODE_IPV4", 1);
    }

    impl AddressMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for AddressMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AddressMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(AddressMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(AddressMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(AddressMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for AddressMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "ADDRESS_MODE_UNSPECIFIED" => address_mode::ADDRESS_MODE_UNSPECIFIED,
                "MODE_IPV4" => address_mode::MODE_IPV4,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for AddressMode {
        fn from(value: i32) -> Self {
            match value {
                0 => address_mode::ADDRESS_MODE_UNSPECIFIED,
                1 => address_mode::MODE_IPV4,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for AddressMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// Available connection modes.
    #[derive(Clone, Debug, PartialEq)]
    pub struct ConnectMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [ConnectMode](ConnectMode)
    pub mod connect_mode {
        use super::ConnectMode;

        /// Not set.
        pub const CONNECT_MODE_UNSPECIFIED: ConnectMode =
            ConnectMode::known("CONNECT_MODE_UNSPECIFIED", 0);

        /// Connect via direct peering to the Filestore service.
        pub const DIRECT_PEERING: ConnectMode = ConnectMode::known("DIRECT_PEERING", 1);

        /// Connect to your Filestore instance using Private Service
        /// Access. Private services access provides an IP address range for multiple
        /// Google Cloud services, including Filestore.
        pub const PRIVATE_SERVICE_ACCESS: ConnectMode =
            ConnectMode::known("PRIVATE_SERVICE_ACCESS", 2);
    }

    impl ConnectMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for ConnectMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(ConnectMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(ConnectMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(ConnectMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for ConnectMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "CONNECT_MODE_UNSPECIFIED" => connect_mode::CONNECT_MODE_UNSPECIFIED,
                "DIRECT_PEERING" => connect_mode::DIRECT_PEERING,
                "PRIVATE_SERVICE_ACCESS" => connect_mode::PRIVATE_SERVICE_ACCESS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for ConnectMode {
        fn from(value: i32) -> Self {
            match value {
                0 => connect_mode::CONNECT_MODE_UNSPECIFIED,
                1 => connect_mode::DIRECT_PEERING,
                2 => connect_mode::PRIVATE_SERVICE_ACCESS,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for ConnectMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// File share configuration for the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileShareConfig {
    /// Required. The name of the file share. Must use 1-16 characters for the
    /// basic service tier and 1-63 characters for all other service tiers.
    /// Must use lowercase letters, numbers, or underscores `[a-z0-9_]`. Must
    /// start with a letter. Immutable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// File share capacity in gigabytes (GB).
    /// Filestore defines 1 GB as 1024^3 bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gb: i64,

    /// Nfs Export Options.
    /// There is a limit of 10 export options per file share.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nfs_export_options: std::vec::Vec<crate::model::NfsExportOptions>,

    /// The source that this file share has been restored from. Empty if the file
    /// share is created from scratch.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::file_share_config::Source>,
}

impl FileShareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FileShareConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [capacity_gb][crate::model::FileShareConfig::capacity_gb].
    pub fn set_capacity_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gb = v.into();
        self
    }

    /// Sets the value of [nfs_export_options][crate::model::FileShareConfig::nfs_export_options].
    pub fn set_nfs_export_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsExportOptions>,
    {
        use std::iter::Iterator;
        self.nfs_export_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::file_share_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::FileShareConfig::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::file_share_config::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::FileShareConfig::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::file_share_config::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileShareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.FileShareConfig"
    }
}

/// Defines additional types related to FileShareConfig
pub mod file_share_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source that this file share has been restored from. Empty if the file
    /// share is created from scratch.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The resource name of the backup, in the format
        /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`,
        /// that this file share has been restored from.
        SourceBackup(std::string::String),
    }
}

/// NFS export options specifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsExportOptions {
    /// List of either an IPv4 addresses in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}` or CIDR ranges in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}/{mask size}` which may mount the
    /// file share.
    /// Overlapping IP ranges are not allowed, both within and across
    /// NfsExportOptions. An error will be returned.
    /// The limit is 64 IP ranges/addresses for each FileShareConfig among all
    /// NfsExportOptions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_ranges: std::vec::Vec<std::string::String>,

    /// Either READ_ONLY, for allowing only read requests on the exported
    /// directory, or READ_WRITE, for allowing both read and write requests.
    /// The default is READ_WRITE.
    pub access_mode: crate::model::nfs_export_options::AccessMode,

    /// Either NO_ROOT_SQUASH, for allowing root access on the exported directory,
    /// or ROOT_SQUASH, for not allowing root access. The default is
    /// NO_ROOT_SQUASH.
    pub squash_mode: crate::model::nfs_export_options::SquashMode,

    /// An integer representing the anonymous user id with a default value of
    /// 65534.
    /// Anon_uid may only be set with squash_mode of ROOT_SQUASH.  An error will be
    /// returned if this field is specified for other squash_mode settings.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub anon_uid: i64,

    /// An integer representing the anonymous group id with a default value of
    /// 65534.
    /// Anon_gid may only be set with squash_mode of ROOT_SQUASH.  An error will be
    /// returned if this field is specified for other squash_mode settings.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub anon_gid: i64,
}

impl NfsExportOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_mode][crate::model::NfsExportOptions::access_mode].
    pub fn set_access_mode<T: std::convert::Into<crate::model::nfs_export_options::AccessMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.access_mode = v.into();
        self
    }

    /// Sets the value of [squash_mode][crate::model::NfsExportOptions::squash_mode].
    pub fn set_squash_mode<T: std::convert::Into<crate::model::nfs_export_options::SquashMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.squash_mode = v.into();
        self
    }

    /// Sets the value of [anon_uid][crate::model::NfsExportOptions::anon_uid].
    pub fn set_anon_uid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.anon_uid = v.into();
        self
    }

    /// Sets the value of [anon_gid][crate::model::NfsExportOptions::anon_gid].
    pub fn set_anon_gid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.anon_gid = v.into();
        self
    }

    /// Sets the value of [ip_ranges][crate::model::NfsExportOptions::ip_ranges].
    pub fn set_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NfsExportOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.NfsExportOptions"
    }
}

/// Defines additional types related to NfsExportOptions
pub mod nfs_export_options {
    #[allow(unused_imports)]
    use super::*;

    /// The access mode.
    #[derive(Clone, Debug, PartialEq)]
    pub struct AccessMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [AccessMode](AccessMode)
    pub mod access_mode {
        use super::AccessMode;

        /// AccessMode not set.
        pub const ACCESS_MODE_UNSPECIFIED: AccessMode =
            AccessMode::known("ACCESS_MODE_UNSPECIFIED", 0);

        /// The client can only read the file share.
        pub const READ_ONLY: AccessMode = AccessMode::known("READ_ONLY", 1);

        /// The client can read and write the file share (default).
        pub const READ_WRITE: AccessMode = AccessMode::known("READ_WRITE", 2);
    }

    impl AccessMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for AccessMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccessMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(AccessMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(AccessMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(AccessMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for AccessMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "ACCESS_MODE_UNSPECIFIED" => access_mode::ACCESS_MODE_UNSPECIFIED,
                "READ_ONLY" => access_mode::READ_ONLY,
                "READ_WRITE" => access_mode::READ_WRITE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for AccessMode {
        fn from(value: i32) -> Self {
            match value {
                0 => access_mode::ACCESS_MODE_UNSPECIFIED,
                1 => access_mode::READ_ONLY,
                2 => access_mode::READ_WRITE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for AccessMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The squash mode.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SquashMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SquashMode](SquashMode)
    pub mod squash_mode {
        use super::SquashMode;

        /// SquashMode not set.
        pub const SQUASH_MODE_UNSPECIFIED: SquashMode =
            SquashMode::known("SQUASH_MODE_UNSPECIFIED", 0);

        /// The Root user has root access to the file share (default).
        pub const NO_ROOT_SQUASH: SquashMode = SquashMode::known("NO_ROOT_SQUASH", 1);

        /// The Root user has squashed access to the anonymous uid/gid.
        pub const ROOT_SQUASH: SquashMode = SquashMode::known("ROOT_SQUASH", 2);
    }

    impl SquashMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SquashMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SquashMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SquashMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SquashMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(SquashMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SquashMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQUASH_MODE_UNSPECIFIED" => squash_mode::SQUASH_MODE_UNSPECIFIED,
                "NO_ROOT_SQUASH" => squash_mode::NO_ROOT_SQUASH,
                "ROOT_SQUASH" => squash_mode::ROOT_SQUASH,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SquashMode {
        fn from(value: i32) -> Self {
            match value {
                0 => squash_mode::SQUASH_MODE_UNSPECIFIED,
                1 => squash_mode::NO_ROOT_SQUASH,
                2 => squash_mode::ROOT_SQUASH,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SquashMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// A Filestore instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The resource name of the instance, in the format
    /// `projects/{project}/locations/{location}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The description of the instance (2048 characters or less).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The instance state.
    pub state: crate::model::instance::State,

    /// Output only. Additional information about the instance state, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The service tier of the instance.
    pub tier: crate::model::instance::Tier,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// File system shares on the instance.
    /// For this version, only a single file share is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_shares: std::vec::Vec<crate::model::FileShareConfig>,

    /// VPC networks to which the instance is connected.
    /// For this version, only a single network is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Server-specified ETag for the instance resource to prevent simultaneous
    /// updates from overwriting each other.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// KMS key name used for data encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. Field indicates all the reasons the instance is in "SUSPENDED"
    /// state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub suspension_reasons: std::vec::Vec<crate::model::instance::SuspensionReason>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Instance::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Instance::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::Instance::tier].
    pub fn set_tier<T: std::convert::Into<crate::model::instance::Tier>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Instance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Instance::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [file_shares][crate::model::Instance::file_shares].
    pub fn set_file_shares<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileShareConfig>,
    {
        use std::iter::Iterator;
        self.file_shares = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::Instance::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suspension_reasons][crate::model::Instance::suspension_reasons].
    pub fn set_suspension_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::SuspensionReason>,
    {
        use std::iter::Iterator;
        self.suspension_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The instance state.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// The instance is being created.
        pub const CREATING: State = State::known("CREATING", 1);

        /// The instance is available for use.
        pub const READY: State = State::known("READY", 2);

        /// Work is being done on the instance. You can get further details from the
        /// `statusMessage` field of the `Instance` resource.
        pub const REPAIRING: State = State::known("REPAIRING", 3);

        /// The instance is shutting down.
        pub const DELETING: State = State::known("DELETING", 4);

        /// The instance is experiencing an issue and might be unusable. You can get
        /// further details from the `statusMessage` field of the `Instance`
        /// resource.
        pub const ERROR: State = State::known("ERROR", 6);

        /// The instance is restoring a backup to an existing file share and may be
        /// unusable during this time.
        pub const RESTORING: State = State::known("RESTORING", 7);

        /// The instance is suspended. You can get further details from
        /// the `suspension_reasons` field of the `Instance` resource.
        pub const SUSPENDED: State = State::known("SUSPENDED", 8);

        /// The instance is in the process of becoming suspended.
        pub const SUSPENDING: State = State::known("SUSPENDING", 9);

        /// The instance is in the process of becoming active.
        pub const RESUMING: State = State::known("RESUMING", 10);

        /// The instance is reverting to a snapshot.
        pub const REVERTING: State = State::known("REVERTING", 12);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "CREATING" => state::CREATING,
                "READY" => state::READY,
                "REPAIRING" => state::REPAIRING,
                "DELETING" => state::DELETING,
                "ERROR" => state::ERROR,
                "RESTORING" => state::RESTORING,
                "SUSPENDED" => state::SUSPENDED,
                "SUSPENDING" => state::SUSPENDING,
                "RESUMING" => state::RESUMING,
                "REVERTING" => state::REVERTING,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::CREATING,
                2 => state::READY,
                3 => state::REPAIRING,
                4 => state::DELETING,
                6 => state::ERROR,
                7 => state::RESTORING,
                8 => state::SUSPENDED,
                9 => state::SUSPENDING,
                10 => state::RESUMING,
                12 => state::REVERTING,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// Available service tiers.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Tier(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Tier](Tier)
    pub mod tier {
        use super::Tier;

        /// Not set.
        pub const TIER_UNSPECIFIED: Tier = Tier::known("TIER_UNSPECIFIED", 0);

        /// STANDARD tier. BASIC_HDD is the preferred term for this tier.
        pub const STANDARD: Tier = Tier::known("STANDARD", 1);

        /// PREMIUM tier. BASIC_SSD is the preferred term for this tier.
        pub const PREMIUM: Tier = Tier::known("PREMIUM", 2);

        /// BASIC instances offer a maximum capacity of 63.9 TB.
        /// BASIC_HDD is an alias for STANDARD Tier, offering economical
        /// performance backed by HDD.
        pub const BASIC_HDD: Tier = Tier::known("BASIC_HDD", 3);

        /// BASIC instances offer a maximum capacity of 63.9 TB.
        /// BASIC_SSD is an alias for PREMIUM Tier, and offers improved
        /// performance backed by SSD.
        pub const BASIC_SSD: Tier = Tier::known("BASIC_SSD", 4);

        /// HIGH_SCALE instances offer expanded capacity and performance scaling
        /// capabilities.
        pub const HIGH_SCALE_SSD: Tier = Tier::known("HIGH_SCALE_SSD", 5);

        /// ENTERPRISE instances offer the features and availability needed for
        /// mission-critical workloads.
        pub const ENTERPRISE: Tier = Tier::known("ENTERPRISE", 6);

        /// ZONAL instances offer expanded capacity and performance scaling
        /// capabilities.
        pub const ZONAL: Tier = Tier::known("ZONAL", 7);

        /// REGIONAL instances offer the features and availability needed for
        /// mission-critical workloads.
        pub const REGIONAL: Tier = Tier::known("REGIONAL", 8);
    }

    impl Tier {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Tier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Tier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Tier::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Tier::from(val)),
                Enumeration::UnknownNum { str } => Ok(Tier::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Tier {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "TIER_UNSPECIFIED" => tier::TIER_UNSPECIFIED,
                "STANDARD" => tier::STANDARD,
                "PREMIUM" => tier::PREMIUM,
                "BASIC_HDD" => tier::BASIC_HDD,
                "BASIC_SSD" => tier::BASIC_SSD,
                "HIGH_SCALE_SSD" => tier::HIGH_SCALE_SSD,
                "ENTERPRISE" => tier::ENTERPRISE,
                "ZONAL" => tier::ZONAL,
                "REGIONAL" => tier::REGIONAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            match value {
                0 => tier::TIER_UNSPECIFIED,
                1 => tier::STANDARD,
                2 => tier::PREMIUM,
                3 => tier::BASIC_HDD,
                4 => tier::BASIC_SSD,
                5 => tier::HIGH_SCALE_SSD,
                6 => tier::ENTERPRISE,
                7 => tier::ZONAL,
                8 => tier::REGIONAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Tier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// SuspensionReason contains the possible reasons for a suspension.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SuspensionReason(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SuspensionReason](SuspensionReason)
    pub mod suspension_reason {
        use super::SuspensionReason;

        /// Not set.
        pub const SUSPENSION_REASON_UNSPECIFIED: SuspensionReason =
            SuspensionReason::known("SUSPENSION_REASON_UNSPECIFIED", 0);

        /// The KMS key used by the instance is either revoked or denied access to.
        pub const KMS_KEY_ISSUE: SuspensionReason = SuspensionReason::known("KMS_KEY_ISSUE", 1);
    }

    impl SuspensionReason {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SuspensionReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SuspensionReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SuspensionReason::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SuspensionReason::from(val)),
                Enumeration::UnknownNum { str } => Ok(SuspensionReason::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SuspensionReason {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SUSPENSION_REASON_UNSPECIFIED" => suspension_reason::SUSPENSION_REASON_UNSPECIFIED,
                "KMS_KEY_ISSUE" => suspension_reason::KMS_KEY_ISSUE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SuspensionReason {
        fn from(value: i32) -> Self {
            match value {
                0 => suspension_reason::SUSPENSION_REASON_UNSPECIFIED,
                1 => suspension_reason::KMS_KEY_ISSUE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SuspensionReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// CreateInstanceRequest creates an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The instance's project and location, in the format
    /// `projects/{project_id}/locations/{location}`. In Filestore,
    /// locations map to Google Cloud zones, for example **us-west1-b**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name of the instance to create.
    /// The name must be unique for the specified project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. An [instance resource][google.cloud.filestore.v1.Instance]
    ///
    /// [google.cloud.filestore.v1.Instance]: crate::model::Instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateInstanceRequest"
    }
}

/// GetInstanceRequest gets the state of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The instance resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetInstanceRequest"
    }
}

/// UpdateInstanceRequest updates the settings of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Mask of fields to update.  At least one path must be supplied in this
    /// field.  The elements of the repeated paths field may only include these
    /// fields:
    ///
    /// * "description"
    /// * "file_shares"
    /// * "labels"
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Only fields specified in update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateInstanceRequest"
    }
}

/// RestoreInstanceRequest restores an existing instance's file share from a
/// backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreInstanceRequest {
    /// Required. The resource name of the instance, in the format
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Name of the file share in the Filestore instance that the backup
    /// is being restored to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_share: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::restore_instance_request::Source>,
}

impl RestoreInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [file_share][crate::model::RestoreInstanceRequest::file_share].
    pub fn set_file_share<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_share = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_instance_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreInstanceRequest::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_instance_request::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreInstanceRequest::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_instance_request::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.RestoreInstanceRequest"
    }
}

/// Defines additional types related to RestoreInstanceRequest
pub mod restore_instance_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The resource name of the backup, in the format
        /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
        SourceBackup(std::string::String),
    }
}

/// RevertInstanceRequest reverts the given instance's file share to the
/// specified snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevertInstanceRequest {
    /// Required.
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}`.
    /// The resource name of the instance, in the format
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The snapshot resource ID, in the format 'my-snapshot', where the
    /// specified ID is the {snapshot_id} of the fully qualified name like
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_snapshot_id: std::string::String,
}

impl RevertInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevertInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_snapshot_id][crate::model::RevertInstanceRequest::target_snapshot_id].
    pub fn set_target_snapshot_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_snapshot_id = v.into();
        self
    }
}

impl wkt::message::Message for RevertInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.RevertInstanceRequest"
    }
}

/// DeleteInstanceRequest deletes an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The instance resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, all snapshots of the instance will also be deleted.
    /// (Otherwise, the request will only work if the instance has no snapshots.)
    pub force: bool,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteInstanceRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteInstanceRequest"
    }
}

/// ListInstancesRequest lists instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The project and location for which to retrieve instance
    /// information, in the format `projects/{project_id}/locations/{location}`. In
    /// Cloud Filestore, locations map to Google Cloud zones, for example
    /// **us-west1-b**. To retrieve instance information for all locations, use "-"
    /// for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListInstancesRequest"
    }
}

/// ListInstancesResponse is the result of ListInstancesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// A list of instances in the project for the specified location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of instances from all locations. If any location is unreachable, the
    /// response will only return instances in reachable locations and the
    /// "unreachable" field will be populated with a list of unreachable locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListInstancesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A Filestore snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Snapshot {
    /// Output only. The resource name of the snapshot, in the format
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A description of the snapshot with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The snapshot state.
    pub state: crate::model::snapshot::State,

    /// Output only. The time when the snapshot was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The amount of bytes needed to allocate a full copy of the
    /// snapshot content
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub filesystem_used_bytes: i64,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Snapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Snapshot::state].
    pub fn set_state<T: std::convert::Into<crate::model::snapshot::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [filesystem_used_bytes][crate::model::Snapshot::filesystem_used_bytes].
    pub fn set_filesystem_used_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.filesystem_used_bytes = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Snapshot::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Snapshot"
    }
}

/// Defines additional types related to Snapshot
pub mod snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// The snapshot state.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// Snapshot is being created.
        pub const CREATING: State = State::known("CREATING", 1);

        /// Snapshot is available for use.
        pub const READY: State = State::known("READY", 2);

        /// Snapshot is being deleted.
        pub const DELETING: State = State::known("DELETING", 3);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "CREATING" => state::CREATING,
                "READY" => state::READY,
                "DELETING" => state::DELETING,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::CREATING,
                2 => state::READY,
                3 => state::DELETING,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// CreateSnapshotRequest creates a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSnapshotRequest {
    /// Required. The Filestore Instance to create the snapshots of, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the snapshot.
    /// The ID must be unique within the specified instance.
    ///
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_id: std::string::String,

    /// Required. A snapshot resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,
}

impl CreateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::CreateSnapshotRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::CreateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for CreateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateSnapshotRequest"
    }
}

/// GetSnapshotRequest gets the state of a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetSnapshotRequest"
    }
}

/// DeleteSnapshotRequest deletes a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteSnapshotRequest"
    }
}

/// UpdateSnapshotRequest updates description and/or labels for a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSnapshotRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A snapshot resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,
}

impl UpdateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateSnapshotRequest"
    }
}

/// ListSnapshotsRequest lists snapshots.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The instance for which to retrieve snapshot information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSnapshotsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSnapshotsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListSnapshotsRequest"
    }
}

/// ListSnapshotsResponse is the result of ListSnapshotsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// A list of snapshots in the project for the specified instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListSnapshotsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A Filestore backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The resource name of the backup, in the format
    /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A description of the backup with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The backup state.
    pub state: crate::model::backup::State,

    /// Output only. The time when the backup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Capacity of the source file share when the backup was created.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gb: i64,

    /// Output only. The size of the storage used by the backup. As backups share
    /// storage, this number is expected to change with backup creation/deletion.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub storage_bytes: i64,

    /// The resource name of the source Filestore instance, in the format
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`,
    /// used to create this backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_instance: std::string::String,

    /// Name of the file share in the source Filestore instance that the
    /// backup is created from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_file_share: std::string::String,

    /// Output only. The service tier of the source Filestore instance that this
    /// backup is created from.
    pub source_instance_tier: crate::model::instance::Tier,

    /// Output only. Amount of bytes that will be downloaded if the backup is
    /// restored. This may be different than storage bytes, since sequential
    /// backups of the same disk will share storage.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub download_bytes: i64,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// Immutable. KMS key name used for data encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [capacity_gb][crate::model::Backup::capacity_gb].
    pub fn set_capacity_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gb = v.into();
        self
    }

    /// Sets the value of [storage_bytes][crate::model::Backup::storage_bytes].
    pub fn set_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.storage_bytes = v.into();
        self
    }

    /// Sets the value of [source_instance][crate::model::Backup::source_instance].
    pub fn set_source_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_instance = v.into();
        self
    }

    /// Sets the value of [source_file_share][crate::model::Backup::source_file_share].
    pub fn set_source_file_share<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_file_share = v.into();
        self
    }

    /// Sets the value of [source_instance_tier][crate::model::Backup::source_instance_tier].
    pub fn set_source_instance_tier<T: std::convert::Into<crate::model::instance::Tier>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_instance_tier = v.into();
        self
    }

    /// Sets the value of [download_bytes][crate::model::Backup::download_bytes].
    pub fn set_download_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.download_bytes = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Backup::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::Backup::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Backup"
    }
}

/// Defines additional types related to Backup
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// The backup state.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// Backup is being created.
        pub const CREATING: State = State::known("CREATING", 1);

        /// Backup has been taken and the operation is being finalized. At this
        /// point, changes to the file share will not be reflected in the backup.
        pub const FINALIZING: State = State::known("FINALIZING", 2);

        /// Backup is available for use.
        pub const READY: State = State::known("READY", 3);

        /// Backup is being deleted.
        pub const DELETING: State = State::known("DELETING", 4);

        /// Backup is not valid and cannot be used for creating new instances or
        /// restoring existing instances.
        pub const INVALID: State = State::known("INVALID", 5);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "CREATING" => state::CREATING,
                "FINALIZING" => state::FINALIZING,
                "READY" => state::READY,
                "DELETING" => state::DELETING,
                "INVALID" => state::INVALID,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::CREATING,
                2 => state::FINALIZING,
                3 => state::READY,
                4 => state::DELETING,
                5 => state::INVALID,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// CreateBackupRequest creates a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. The backup's project and location, in the format
    /// `projects/{project_number}/locations/{location}`. In Filestore,
    /// backup locations map to Google Cloud regions, for example **us-west1**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A [backup resource][google.cloud.filestore.v1.Backup]
    ///
    /// [google.cloud.filestore.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. The ID to use for the backup.
    /// The ID must be unique within the specified project and location.
    ///
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    /// Values that do not match this pattern will trigger an INVALID_ARGUMENT
    /// error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_id: std::string::String,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateBackupRequest"
    }
}

/// DeleteBackupRequest deletes a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_number}/locations/{location}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteBackupRequest"
    }
}

/// UpdateBackupRequest updates description and/or labels for a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. A [backup resource][google.cloud.filestore.v1.Backup]
    ///
    /// [google.cloud.filestore.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. Mask of fields to update.  At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateBackupRequest"
    }
}

/// GetBackupRequest gets the state of a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_number}/locations/{location}/backups/{backup_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetBackupRequest"
    }
}

/// ListBackupsRequest lists backups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The project and location for which to retrieve backup
    /// information, in the format
    /// `projects/{project_number}/locations/{location}`. In Filestore, backup
    /// locations map to Google Cloud regions, for example **us-west1**. To
    /// retrieve backup information for all locations, use "-" for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListBackupsRequest"
    }
}

/// ListBackupsResponse is the result of ListBackupsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project for the specified location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of backups from all locations. If any location is unreachable, the
    /// response will only return backups in reachable locations and the
    /// "unreachable" field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListBackupsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}
