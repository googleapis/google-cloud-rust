// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate cloud_common;
extern crate gax;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Network configuration for the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// The name of the Google Compute Engine
    /// [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the
    /// instance is connected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Internet protocol versions for which the instance has IP addresses
    /// assigned. For this version, only MODE_IPV4 is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub modes: std::vec::Vec<crate::model::network_config::AddressMode>,

    /// Optional, reserved_ip_range can have one of the following two types of
    /// values.
    ///
    /// * CIDR range value when using DIRECT_PEERING connect mode.
    /// * [Allocated IP address
    ///   range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address)
    ///   when using PRIVATE_SERVICE_ACCESS connect mode.
    ///
    /// When the name of an allocated IP address range is specified, it must be one
    /// of the ranges associated with the private service access connection.
    /// When specified as a direct CIDR value, it must be a /29 CIDR block for
    /// Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for
    /// Enterprise tier in one of the [internal IP address
    /// ranges](https://www.arin.net/reference/research/statistics/address_filters/)
    /// that identifies the range of IP addresses reserved for this instance. For
    /// example, 10.0.0.0/29, 192.168.0.0/24 or 192.168.0.0/26, respectively. The
    /// range you specify can't overlap with either existing subnets or assigned IP
    /// address ranges for other Filestore instances in the selected VPC
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reserved_ip_range: std::string::String,

    /// Output only. IPv4 addresses in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format
    /// `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_addresses: std::vec::Vec<std::string::String>,

    /// The network connect mode of the Filestore instance.
    /// If not provided, the connect mode defaults to DIRECT_PEERING.
    pub connect_mode: crate::model::network_config::ConnectMode,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [reserved_ip_range][crate::model::NetworkConfig::reserved_ip_range].
    pub fn set_reserved_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reserved_ip_range = v.into();
        self
    }

    /// Sets the value of [connect_mode][crate::model::NetworkConfig::connect_mode].
    pub fn set_connect_mode<T: std::convert::Into<crate::model::network_config::ConnectMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.connect_mode = v.into();
        self
    }

    /// Sets the value of [modes][crate::model::NetworkConfig::modes].
    pub fn set_modes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::network_config::AddressMode>,
    {
        use std::iter::Iterator;
        self.modes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::NetworkConfig::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.NetworkConfig"
    }
}

/// Defines additional types related to NetworkConfig
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// Internet protocol versions supported by Filestore.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AddressMode(i32);

    impl AddressMode {
        /// Internet protocol not set.
        pub const ADDRESS_MODE_UNSPECIFIED: AddressMode = AddressMode::new(0);

        /// Use the IPv4 internet protocol.
        pub const MODE_IPV4: AddressMode = AddressMode::new(1);

        /// Creates a new AddressMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ADDRESS_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("MODE_IPV4"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ADDRESS_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ADDRESS_MODE_UNSPECIFIED)
                }
                "MODE_IPV4" => std::option::Option::Some(Self::MODE_IPV4),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AddressMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AddressMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Available connection modes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConnectMode(i32);

    impl ConnectMode {
        /// Not set.
        pub const CONNECT_MODE_UNSPECIFIED: ConnectMode = ConnectMode::new(0);

        /// Connect via direct peering to the Filestore service.
        pub const DIRECT_PEERING: ConnectMode = ConnectMode::new(1);

        /// Connect to your Filestore instance using Private Service
        /// Access. Private services access provides an IP address range for multiple
        /// Google Cloud services, including Filestore.
        pub const PRIVATE_SERVICE_ACCESS: ConnectMode = ConnectMode::new(2);

        /// Creates a new ConnectMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONNECT_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DIRECT_PEERING"),
                2 => std::borrow::Cow::Borrowed("PRIVATE_SERVICE_ACCESS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONNECT_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONNECT_MODE_UNSPECIFIED)
                }
                "DIRECT_PEERING" => std::option::Option::Some(Self::DIRECT_PEERING),
                "PRIVATE_SERVICE_ACCESS" => std::option::Option::Some(Self::PRIVATE_SERVICE_ACCESS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConnectMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConnectMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// File share configuration for the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileShareConfig {
    /// Required. The name of the file share. Must use 1-16 characters for the
    /// basic service tier and 1-63 characters for all other service tiers.
    /// Must use lowercase letters, numbers, or underscores `[a-z0-9_]`. Must
    /// start with a letter. Immutable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// File share capacity in gigabytes (GB).
    /// Filestore defines 1 GB as 1024^3 bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gb: i64,

    /// Nfs Export Options.
    /// There is a limit of 10 export options per file share.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nfs_export_options: std::vec::Vec<crate::model::NfsExportOptions>,

    /// The source that this file share has been restored from. Empty if the file
    /// share is created from scratch.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::file_share_config::Source>,
}

impl FileShareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FileShareConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [capacity_gb][crate::model::FileShareConfig::capacity_gb].
    pub fn set_capacity_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gb = v.into();
        self
    }

    /// Sets the value of [nfs_export_options][crate::model::FileShareConfig::nfs_export_options].
    pub fn set_nfs_export_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsExportOptions>,
    {
        use std::iter::Iterator;
        self.nfs_export_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::file_share_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::FileShareConfig::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::file_share_config::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::FileShareConfig::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::file_share_config::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileShareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.FileShareConfig"
    }
}

/// Defines additional types related to FileShareConfig
pub mod file_share_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source that this file share has been restored from. Empty if the file
    /// share is created from scratch.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The resource name of the backup, in the format
        /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`,
        /// that this file share has been restored from.
        SourceBackup(std::string::String),
    }
}

/// NFS export options specifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsExportOptions {
    /// List of either an IPv4 addresses in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}` or CIDR ranges in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}/{mask size}` which may mount the
    /// file share.
    /// Overlapping IP ranges are not allowed, both within and across
    /// NfsExportOptions. An error will be returned.
    /// The limit is 64 IP ranges/addresses for each FileShareConfig among all
    /// NfsExportOptions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_ranges: std::vec::Vec<std::string::String>,

    /// Either READ_ONLY, for allowing only read requests on the exported
    /// directory, or READ_WRITE, for allowing both read and write requests.
    /// The default is READ_WRITE.
    pub access_mode: crate::model::nfs_export_options::AccessMode,

    /// Either NO_ROOT_SQUASH, for allowing root access on the exported directory,
    /// or ROOT_SQUASH, for not allowing root access. The default is
    /// NO_ROOT_SQUASH.
    pub squash_mode: crate::model::nfs_export_options::SquashMode,

    /// An integer representing the anonymous user id with a default value of
    /// 65534.
    /// Anon_uid may only be set with squash_mode of ROOT_SQUASH.  An error will be
    /// returned if this field is specified for other squash_mode settings.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub anon_uid: i64,

    /// An integer representing the anonymous group id with a default value of
    /// 65534.
    /// Anon_gid may only be set with squash_mode of ROOT_SQUASH.  An error will be
    /// returned if this field is specified for other squash_mode settings.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub anon_gid: i64,
}

impl NfsExportOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_mode][crate::model::NfsExportOptions::access_mode].
    pub fn set_access_mode<T: std::convert::Into<crate::model::nfs_export_options::AccessMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.access_mode = v.into();
        self
    }

    /// Sets the value of [squash_mode][crate::model::NfsExportOptions::squash_mode].
    pub fn set_squash_mode<T: std::convert::Into<crate::model::nfs_export_options::SquashMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.squash_mode = v.into();
        self
    }

    /// Sets the value of [anon_uid][crate::model::NfsExportOptions::anon_uid].
    pub fn set_anon_uid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.anon_uid = v.into();
        self
    }

    /// Sets the value of [anon_gid][crate::model::NfsExportOptions::anon_gid].
    pub fn set_anon_gid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.anon_gid = v.into();
        self
    }

    /// Sets the value of [ip_ranges][crate::model::NfsExportOptions::ip_ranges].
    pub fn set_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NfsExportOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.NfsExportOptions"
    }
}

/// Defines additional types related to NfsExportOptions
pub mod nfs_export_options {
    #[allow(unused_imports)]
    use super::*;

    /// The access mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AccessMode(i32);

    impl AccessMode {
        /// AccessMode not set.
        pub const ACCESS_MODE_UNSPECIFIED: AccessMode = AccessMode::new(0);

        /// The client can only read the file share.
        pub const READ_ONLY: AccessMode = AccessMode::new(1);

        /// The client can read and write the file share (default).
        pub const READ_WRITE: AccessMode = AccessMode::new(2);

        /// Creates a new AccessMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ACCESS_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("READ_ONLY"),
                2 => std::borrow::Cow::Borrowed("READ_WRITE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ACCESS_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ACCESS_MODE_UNSPECIFIED)
                }
                "READ_ONLY" => std::option::Option::Some(Self::READ_ONLY),
                "READ_WRITE" => std::option::Option::Some(Self::READ_WRITE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AccessMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AccessMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The squash mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SquashMode(i32);

    impl SquashMode {
        /// SquashMode not set.
        pub const SQUASH_MODE_UNSPECIFIED: SquashMode = SquashMode::new(0);

        /// The Root user has root access to the file share (default).
        pub const NO_ROOT_SQUASH: SquashMode = SquashMode::new(1);

        /// The Root user has squashed access to the anonymous uid/gid.
        pub const ROOT_SQUASH: SquashMode = SquashMode::new(2);

        /// Creates a new SquashMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SQUASH_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NO_ROOT_SQUASH"),
                2 => std::borrow::Cow::Borrowed("ROOT_SQUASH"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SQUASH_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SQUASH_MODE_UNSPECIFIED)
                }
                "NO_ROOT_SQUASH" => std::option::Option::Some(Self::NO_ROOT_SQUASH),
                "ROOT_SQUASH" => std::option::Option::Some(Self::ROOT_SQUASH),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SquashMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SquashMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A Filestore instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The resource name of the instance, in the format
    /// `projects/{project}/locations/{location}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The description of the instance (2048 characters or less).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The instance state.
    pub state: crate::model::instance::State,

    /// Output only. Additional information about the instance state, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The service tier of the instance.
    pub tier: crate::model::instance::Tier,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// File system shares on the instance.
    /// For this version, only a single file share is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_shares: std::vec::Vec<crate::model::FileShareConfig>,

    /// VPC networks to which the instance is connected.
    /// For this version, only a single network is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Server-specified ETag for the instance resource to prevent simultaneous
    /// updates from overwriting each other.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// KMS key name used for data encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. Field indicates all the reasons the instance is in "SUSPENDED"
    /// state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub suspension_reasons: std::vec::Vec<crate::model::instance::SuspensionReason>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Instance::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Instance::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::Instance::tier].
    pub fn set_tier<T: std::convert::Into<crate::model::instance::Tier>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Instance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Instance::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [file_shares][crate::model::Instance::file_shares].
    pub fn set_file_shares<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileShareConfig>,
    {
        use std::iter::Iterator;
        self.file_shares = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::Instance::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suspension_reasons][crate::model::Instance::suspension_reasons].
    pub fn set_suspension_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::SuspensionReason>,
    {
        use std::iter::Iterator;
        self.suspension_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The instance state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The instance is being created.
        pub const CREATING: State = State::new(1);

        /// The instance is available for use.
        pub const READY: State = State::new(2);

        /// Work is being done on the instance. You can get further details from the
        /// `statusMessage` field of the `Instance` resource.
        pub const REPAIRING: State = State::new(3);

        /// The instance is shutting down.
        pub const DELETING: State = State::new(4);

        /// The instance is experiencing an issue and might be unusable. You can get
        /// further details from the `statusMessage` field of the `Instance`
        /// resource.
        pub const ERROR: State = State::new(6);

        /// The instance is restoring a backup to an existing file share and may be
        /// unusable during this time.
        pub const RESTORING: State = State::new(7);

        /// The instance is suspended. You can get further details from
        /// the `suspension_reasons` field of the `Instance` resource.
        pub const SUSPENDED: State = State::new(8);

        /// The instance is in the process of becoming suspended.
        pub const SUSPENDING: State = State::new(9);

        /// The instance is in the process of becoming active.
        pub const RESUMING: State = State::new(10);

        /// The instance is reverting to a snapshot.
        pub const REVERTING: State = State::new(12);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("REPAIRING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                6 => std::borrow::Cow::Borrowed("ERROR"),
                7 => std::borrow::Cow::Borrowed("RESTORING"),
                8 => std::borrow::Cow::Borrowed("SUSPENDED"),
                9 => std::borrow::Cow::Borrowed("SUSPENDING"),
                10 => std::borrow::Cow::Borrowed("RESUMING"),
                12 => std::borrow::Cow::Borrowed("REVERTING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "REPAIRING" => std::option::Option::Some(Self::REPAIRING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "RESTORING" => std::option::Option::Some(Self::RESTORING),
                "SUSPENDED" => std::option::Option::Some(Self::SUSPENDED),
                "SUSPENDING" => std::option::Option::Some(Self::SUSPENDING),
                "RESUMING" => std::option::Option::Some(Self::RESUMING),
                "REVERTING" => std::option::Option::Some(Self::REVERTING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Available service tiers.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Tier(i32);

    impl Tier {
        /// Not set.
        pub const TIER_UNSPECIFIED: Tier = Tier::new(0);

        /// STANDARD tier. BASIC_HDD is the preferred term for this tier.
        pub const STANDARD: Tier = Tier::new(1);

        /// PREMIUM tier. BASIC_SSD is the preferred term for this tier.
        pub const PREMIUM: Tier = Tier::new(2);

        /// BASIC instances offer a maximum capacity of 63.9 TB.
        /// BASIC_HDD is an alias for STANDARD Tier, offering economical
        /// performance backed by HDD.
        pub const BASIC_HDD: Tier = Tier::new(3);

        /// BASIC instances offer a maximum capacity of 63.9 TB.
        /// BASIC_SSD is an alias for PREMIUM Tier, and offers improved
        /// performance backed by SSD.
        pub const BASIC_SSD: Tier = Tier::new(4);

        /// HIGH_SCALE instances offer expanded capacity and performance scaling
        /// capabilities.
        pub const HIGH_SCALE_SSD: Tier = Tier::new(5);

        /// ENTERPRISE instances offer the features and availability needed for
        /// mission-critical workloads.
        pub const ENTERPRISE: Tier = Tier::new(6);

        /// ZONAL instances offer expanded capacity and performance scaling
        /// capabilities.
        pub const ZONAL: Tier = Tier::new(7);

        /// REGIONAL instances offer the features and availability needed for
        /// mission-critical workloads.
        pub const REGIONAL: Tier = Tier::new(8);

        /// Creates a new Tier instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TIER_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STANDARD"),
                2 => std::borrow::Cow::Borrowed("PREMIUM"),
                3 => std::borrow::Cow::Borrowed("BASIC_HDD"),
                4 => std::borrow::Cow::Borrowed("BASIC_SSD"),
                5 => std::borrow::Cow::Borrowed("HIGH_SCALE_SSD"),
                6 => std::borrow::Cow::Borrowed("ENTERPRISE"),
                7 => std::borrow::Cow::Borrowed("ZONAL"),
                8 => std::borrow::Cow::Borrowed("REGIONAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TIER_UNSPECIFIED" => std::option::Option::Some(Self::TIER_UNSPECIFIED),
                "STANDARD" => std::option::Option::Some(Self::STANDARD),
                "PREMIUM" => std::option::Option::Some(Self::PREMIUM),
                "BASIC_HDD" => std::option::Option::Some(Self::BASIC_HDD),
                "BASIC_SSD" => std::option::Option::Some(Self::BASIC_SSD),
                "HIGH_SCALE_SSD" => std::option::Option::Some(Self::HIGH_SCALE_SSD),
                "ENTERPRISE" => std::option::Option::Some(Self::ENTERPRISE),
                "ZONAL" => std::option::Option::Some(Self::ZONAL),
                "REGIONAL" => std::option::Option::Some(Self::REGIONAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Tier {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// SuspensionReason contains the possible reasons for a suspension.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SuspensionReason(i32);

    impl SuspensionReason {
        /// Not set.
        pub const SUSPENSION_REASON_UNSPECIFIED: SuspensionReason = SuspensionReason::new(0);

        /// The KMS key used by the instance is either revoked or denied access to.
        pub const KMS_KEY_ISSUE: SuspensionReason = SuspensionReason::new(1);

        /// Creates a new SuspensionReason instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SUSPENSION_REASON_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("KMS_KEY_ISSUE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SUSPENSION_REASON_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SUSPENSION_REASON_UNSPECIFIED)
                }
                "KMS_KEY_ISSUE" => std::option::Option::Some(Self::KMS_KEY_ISSUE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SuspensionReason {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SuspensionReason {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// CreateInstanceRequest creates an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The instance's project and location, in the format
    /// `projects/{project_id}/locations/{location}`. In Filestore,
    /// locations map to Google Cloud zones, for example **us-west1-b**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name of the instance to create.
    /// The name must be unique for the specified project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. An [instance resource][google.cloud.filestore.v1.Instance]
    ///
    /// [google.cloud.filestore.v1.Instance]: crate::model::Instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateInstanceRequest"
    }
}

/// GetInstanceRequest gets the state of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The instance resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetInstanceRequest"
    }
}

/// UpdateInstanceRequest updates the settings of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Mask of fields to update.  At least one path must be supplied in this
    /// field.  The elements of the repeated paths field may only include these
    /// fields:
    ///
    /// * "description"
    /// * "file_shares"
    /// * "labels"
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Only fields specified in update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateInstanceRequest"
    }
}

/// RestoreInstanceRequest restores an existing instance's file share from a
/// backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreInstanceRequest {
    /// Required. The resource name of the instance, in the format
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Name of the file share in the Filestore instance that the backup
    /// is being restored to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_share: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::restore_instance_request::Source>,
}

impl RestoreInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [file_share][crate::model::RestoreInstanceRequest::file_share].
    pub fn set_file_share<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_share = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_instance_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreInstanceRequest::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_instance_request::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreInstanceRequest::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_instance_request::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.RestoreInstanceRequest"
    }
}

/// Defines additional types related to RestoreInstanceRequest
pub mod restore_instance_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The resource name of the backup, in the format
        /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
        SourceBackup(std::string::String),
    }
}

/// RevertInstanceRequest reverts the given instance's file share to the
/// specified snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevertInstanceRequest {
    /// Required.
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}`.
    /// The resource name of the instance, in the format
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The snapshot resource ID, in the format 'my-snapshot', where the
    /// specified ID is the {snapshot_id} of the fully qualified name like
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_snapshot_id: std::string::String,
}

impl RevertInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevertInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_snapshot_id][crate::model::RevertInstanceRequest::target_snapshot_id].
    pub fn set_target_snapshot_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_snapshot_id = v.into();
        self
    }
}

impl wkt::message::Message for RevertInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.RevertInstanceRequest"
    }
}

/// DeleteInstanceRequest deletes an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The instance resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, all snapshots of the instance will also be deleted.
    /// (Otherwise, the request will only work if the instance has no snapshots.)
    pub force: bool,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteInstanceRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteInstanceRequest"
    }
}

/// ListInstancesRequest lists instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The project and location for which to retrieve instance
    /// information, in the format `projects/{project_id}/locations/{location}`. In
    /// Cloud Filestore, locations map to Google Cloud zones, for example
    /// **us-west1-b**. To retrieve instance information for all locations, use "-"
    /// for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListInstancesRequest"
    }
}

/// ListInstancesResponse is the result of ListInstancesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// A list of instances in the project for the specified location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of instances from all locations. If any location is unreachable, the
    /// response will only return instances in reachable locations and the
    /// "unreachable" field will be populated with a list of unreachable locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListInstancesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A Filestore snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Snapshot {
    /// Output only. The resource name of the snapshot, in the format
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A description of the snapshot with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The snapshot state.
    pub state: crate::model::snapshot::State,

    /// Output only. The time when the snapshot was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The amount of bytes needed to allocate a full copy of the
    /// snapshot content
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub filesystem_used_bytes: i64,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Snapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Snapshot::state].
    pub fn set_state<T: std::convert::Into<crate::model::snapshot::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [filesystem_used_bytes][crate::model::Snapshot::filesystem_used_bytes].
    pub fn set_filesystem_used_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.filesystem_used_bytes = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Snapshot::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Snapshot"
    }
}

/// Defines additional types related to Snapshot
pub mod snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// The snapshot state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Snapshot is being created.
        pub const CREATING: State = State::new(1);

        /// Snapshot is available for use.
        pub const READY: State = State::new(2);

        /// Snapshot is being deleted.
        pub const DELETING: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// CreateSnapshotRequest creates a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSnapshotRequest {
    /// Required. The Filestore Instance to create the snapshots of, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the snapshot.
    /// The ID must be unique within the specified instance.
    ///
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_id: std::string::String,

    /// Required. A snapshot resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,
}

impl CreateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::CreateSnapshotRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::CreateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for CreateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateSnapshotRequest"
    }
}

/// GetSnapshotRequest gets the state of a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetSnapshotRequest"
    }
}

/// DeleteSnapshotRequest deletes a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteSnapshotRequest"
    }
}

/// UpdateSnapshotRequest updates description and/or labels for a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSnapshotRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A snapshot resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,
}

impl UpdateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateSnapshotRequest"
    }
}

/// ListSnapshotsRequest lists snapshots.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The instance for which to retrieve snapshot information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSnapshotsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSnapshotsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListSnapshotsRequest"
    }
}

/// ListSnapshotsResponse is the result of ListSnapshotsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// A list of snapshots in the project for the specified instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListSnapshotsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A Filestore backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The resource name of the backup, in the format
    /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A description of the backup with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The backup state.
    pub state: crate::model::backup::State,

    /// Output only. The time when the backup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Capacity of the source file share when the backup was created.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gb: i64,

    /// Output only. The size of the storage used by the backup. As backups share
    /// storage, this number is expected to change with backup creation/deletion.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub storage_bytes: i64,

    /// The resource name of the source Filestore instance, in the format
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`,
    /// used to create this backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_instance: std::string::String,

    /// Name of the file share in the source Filestore instance that the
    /// backup is created from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_file_share: std::string::String,

    /// Output only. The service tier of the source Filestore instance that this
    /// backup is created from.
    pub source_instance_tier: crate::model::instance::Tier,

    /// Output only. Amount of bytes that will be downloaded if the backup is
    /// restored. This may be different than storage bytes, since sequential
    /// backups of the same disk will share storage.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub download_bytes: i64,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// Immutable. KMS key name used for data encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [capacity_gb][crate::model::Backup::capacity_gb].
    pub fn set_capacity_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gb = v.into();
        self
    }

    /// Sets the value of [storage_bytes][crate::model::Backup::storage_bytes].
    pub fn set_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.storage_bytes = v.into();
        self
    }

    /// Sets the value of [source_instance][crate::model::Backup::source_instance].
    pub fn set_source_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_instance = v.into();
        self
    }

    /// Sets the value of [source_file_share][crate::model::Backup::source_file_share].
    pub fn set_source_file_share<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_file_share = v.into();
        self
    }

    /// Sets the value of [source_instance_tier][crate::model::Backup::source_instance_tier].
    pub fn set_source_instance_tier<T: std::convert::Into<crate::model::instance::Tier>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_instance_tier = v.into();
        self
    }

    /// Sets the value of [download_bytes][crate::model::Backup::download_bytes].
    pub fn set_download_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.download_bytes = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Backup::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::Backup::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Backup"
    }
}

/// Defines additional types related to Backup
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// The backup state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Backup is being created.
        pub const CREATING: State = State::new(1);

        /// Backup has been taken and the operation is being finalized. At this
        /// point, changes to the file share will not be reflected in the backup.
        pub const FINALIZING: State = State::new(2);

        /// Backup is available for use.
        pub const READY: State = State::new(3);

        /// Backup is being deleted.
        pub const DELETING: State = State::new(4);

        /// Backup is not valid and cannot be used for creating new instances or
        /// restoring existing instances.
        pub const INVALID: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("FINALIZING"),
                3 => std::borrow::Cow::Borrowed("READY"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                5 => std::borrow::Cow::Borrowed("INVALID"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "FINALIZING" => std::option::Option::Some(Self::FINALIZING),
                "READY" => std::option::Option::Some(Self::READY),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "INVALID" => std::option::Option::Some(Self::INVALID),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// CreateBackupRequest creates a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. The backup's project and location, in the format
    /// `projects/{project_number}/locations/{location}`. In Filestore,
    /// backup locations map to Google Cloud regions, for example **us-west1**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A [backup resource][google.cloud.filestore.v1.Backup]
    ///
    /// [google.cloud.filestore.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. The ID to use for the backup.
    /// The ID must be unique within the specified project and location.
    ///
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    /// Values that do not match this pattern will trigger an INVALID_ARGUMENT
    /// error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_id: std::string::String,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateBackupRequest"
    }
}

/// DeleteBackupRequest deletes a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_number}/locations/{location}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteBackupRequest"
    }
}

/// UpdateBackupRequest updates description and/or labels for a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. A [backup resource][google.cloud.filestore.v1.Backup]
    ///
    /// [google.cloud.filestore.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. Mask of fields to update.  At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateBackupRequest"
    }
}

/// GetBackupRequest gets the state of a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_number}/locations/{location}/backups/{backup_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetBackupRequest"
    }
}

/// ListBackupsRequest lists backups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The project and location for which to retrieve backup
    /// information, in the format
    /// `projects/{project_number}/locations/{location}`. In Filestore, backup
    /// locations map to Google Cloud regions, for example **us-west1**. To
    /// retrieve backup information for all locations, use "-" for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListBackupsRequest"
    }
}

/// ListBackupsResponse is the result of ListBackupsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project for the specified location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of backups from all locations. If any location is unreachable, the
    /// response will only return backups in reachable locations and the
    /// "unreachable" field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListBackupsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}
