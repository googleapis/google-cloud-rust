// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate cloud_common;
extern crate gax;
extern crate gclient;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Network configuration for the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// The name of the Google Compute Engine
    /// [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the
    /// instance is connected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Internet protocol versions for which the instance has IP addresses
    /// assigned. For this version, only MODE_IPV4 is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub modes: std::vec::Vec<crate::model::network_config::AddressMode>,

    /// Optional, reserved_ip_range can have one of the following two types of
    /// values.
    ///
    /// * CIDR range value when using DIRECT_PEERING connect mode.
    /// * [Allocated IP address
    ///   range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address)
    ///   when using PRIVATE_SERVICE_ACCESS connect mode.
    ///
    /// When the name of an allocated IP address range is specified, it must be one
    /// of the ranges associated with the private service access connection.
    /// When specified as a direct CIDR value, it must be a /29 CIDR block for
    /// Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for
    /// Enterprise tier in one of the [internal IP address
    /// ranges](https://www.arin.net/reference/research/statistics/address_filters/)
    /// that identifies the range of IP addresses reserved for this instance. For
    /// example, 10.0.0.0/29, 192.168.0.0/24 or 192.168.0.0/26, respectively. The
    /// range you specify can't overlap with either existing subnets or assigned IP
    /// address ranges for other Filestore instances in the selected VPC
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reserved_ip_range: std::string::String,

    /// Output only. IPv4 addresses in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format
    /// `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_addresses: std::vec::Vec<std::string::String>,

    /// The network connect mode of the Filestore instance.
    /// If not provided, the connect mode defaults to DIRECT_PEERING.
    pub connect_mode: crate::model::network_config::ConnectMode,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [reserved_ip_range][crate::model::NetworkConfig::reserved_ip_range].
    pub fn set_reserved_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reserved_ip_range = v.into();
        self
    }

    /// Sets the value of [connect_mode][crate::model::NetworkConfig::connect_mode].
    pub fn set_connect_mode<T: std::convert::Into<crate::model::network_config::ConnectMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.connect_mode = v.into();
        self
    }

    /// Sets the value of [modes][crate::model::NetworkConfig::modes].
    pub fn set_modes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::network_config::AddressMode>,
    {
        use std::iter::Iterator;
        self.modes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::NetworkConfig::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.NetworkConfig"
    }
}

/// Defines additional types related to NetworkConfig
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// Internet protocol versions supported by Filestore.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AddressMode(i32);

    impl AddressMode {
        /// Internet protocol not set.
        pub const ADDRESS_MODE_UNSPECIFIED: AddressMode = AddressMode::new(0);

        /// Use the IPv4 internet protocol.
        pub const MODE_IPV4: AddressMode = AddressMode::new(1);

        /// Creates a new AddressMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ADDRESS_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("MODE_IPV4"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ADDRESS_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ADDRESS_MODE_UNSPECIFIED)
                }
                "MODE_IPV4" => std::option::Option::Some(Self::MODE_IPV4),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AddressMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AddressMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Available connection modes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConnectMode(i32);

    impl ConnectMode {
        /// Not set.
        pub const CONNECT_MODE_UNSPECIFIED: ConnectMode = ConnectMode::new(0);

        /// Connect via direct peering to the Filestore service.
        pub const DIRECT_PEERING: ConnectMode = ConnectMode::new(1);

        /// Connect to your Filestore instance using Private Service
        /// Access. Private services access provides an IP address range for multiple
        /// Google Cloud services, including Filestore.
        pub const PRIVATE_SERVICE_ACCESS: ConnectMode = ConnectMode::new(2);

        /// Creates a new ConnectMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONNECT_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DIRECT_PEERING"),
                2 => std::borrow::Cow::Borrowed("PRIVATE_SERVICE_ACCESS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONNECT_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONNECT_MODE_UNSPECIFIED)
                }
                "DIRECT_PEERING" => std::option::Option::Some(Self::DIRECT_PEERING),
                "PRIVATE_SERVICE_ACCESS" => std::option::Option::Some(Self::PRIVATE_SERVICE_ACCESS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConnectMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConnectMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// File share configuration for the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileShareConfig {
    /// Required. The name of the file share. Must use 1-16 characters for the
    /// basic service tier and 1-63 characters for all other service tiers.
    /// Must use lowercase letters, numbers, or underscores `[a-z0-9_]`. Must
    /// start with a letter. Immutable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// File share capacity in gigabytes (GB).
    /// Filestore defines 1 GB as 1024^3 bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gb: i64,

    /// Nfs Export Options.
    /// There is a limit of 10 export options per file share.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nfs_export_options: std::vec::Vec<crate::model::NfsExportOptions>,

    /// The source that this file share has been restored from. Empty if the file
    /// share is created from scratch.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::file_share_config::Source>,
}

impl FileShareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FileShareConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [capacity_gb][crate::model::FileShareConfig::capacity_gb].
    pub fn set_capacity_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gb = v.into();
        self
    }

    /// Sets the value of [nfs_export_options][crate::model::FileShareConfig::nfs_export_options].
    pub fn set_nfs_export_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsExportOptions>,
    {
        use std::iter::Iterator;
        self.nfs_export_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::file_share_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::FileShareConfig::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::file_share_config::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::FileShareConfig::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::file_share_config::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileShareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.FileShareConfig"
    }
}

/// Defines additional types related to FileShareConfig
pub mod file_share_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source that this file share has been restored from. Empty if the file
    /// share is created from scratch.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The resource name of the backup, in the format
        /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`,
        /// that this file share has been restored from.
        SourceBackup(std::string::String),
    }
}

/// NFS export options specifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsExportOptions {
    /// List of either an IPv4 addresses in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}` or CIDR ranges in the format
    /// `{octet1}.{octet2}.{octet3}.{octet4}/{mask size}` which may mount the
    /// file share.
    /// Overlapping IP ranges are not allowed, both within and across
    /// NfsExportOptions. An error will be returned.
    /// The limit is 64 IP ranges/addresses for each FileShareConfig among all
    /// NfsExportOptions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_ranges: std::vec::Vec<std::string::String>,

    /// Either READ_ONLY, for allowing only read requests on the exported
    /// directory, or READ_WRITE, for allowing both read and write requests.
    /// The default is READ_WRITE.
    pub access_mode: crate::model::nfs_export_options::AccessMode,

    /// Either NO_ROOT_SQUASH, for allowing root access on the exported directory,
    /// or ROOT_SQUASH, for not allowing root access. The default is
    /// NO_ROOT_SQUASH.
    pub squash_mode: crate::model::nfs_export_options::SquashMode,

    /// An integer representing the anonymous user id with a default value of
    /// 65534.
    /// Anon_uid may only be set with squash_mode of ROOT_SQUASH.  An error will be
    /// returned if this field is specified for other squash_mode settings.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub anon_uid: i64,

    /// An integer representing the anonymous group id with a default value of
    /// 65534.
    /// Anon_gid may only be set with squash_mode of ROOT_SQUASH.  An error will be
    /// returned if this field is specified for other squash_mode settings.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub anon_gid: i64,
}

impl NfsExportOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_mode][crate::model::NfsExportOptions::access_mode].
    pub fn set_access_mode<T: std::convert::Into<crate::model::nfs_export_options::AccessMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.access_mode = v.into();
        self
    }

    /// Sets the value of [squash_mode][crate::model::NfsExportOptions::squash_mode].
    pub fn set_squash_mode<T: std::convert::Into<crate::model::nfs_export_options::SquashMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.squash_mode = v.into();
        self
    }

    /// Sets the value of [anon_uid][crate::model::NfsExportOptions::anon_uid].
    pub fn set_anon_uid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.anon_uid = v.into();
        self
    }

    /// Sets the value of [anon_gid][crate::model::NfsExportOptions::anon_gid].
    pub fn set_anon_gid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.anon_gid = v.into();
        self
    }

    /// Sets the value of [ip_ranges][crate::model::NfsExportOptions::ip_ranges].
    pub fn set_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NfsExportOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.NfsExportOptions"
    }
}

/// Defines additional types related to NfsExportOptions
pub mod nfs_export_options {
    #[allow(unused_imports)]
    use super::*;

    /// The access mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AccessMode(i32);

    impl AccessMode {
        /// AccessMode not set.
        pub const ACCESS_MODE_UNSPECIFIED: AccessMode = AccessMode::new(0);

        /// The client can only read the file share.
        pub const READ_ONLY: AccessMode = AccessMode::new(1);

        /// The client can read and write the file share (default).
        pub const READ_WRITE: AccessMode = AccessMode::new(2);

        /// Creates a new AccessMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ACCESS_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("READ_ONLY"),
                2 => std::borrow::Cow::Borrowed("READ_WRITE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ACCESS_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ACCESS_MODE_UNSPECIFIED)
                }
                "READ_ONLY" => std::option::Option::Some(Self::READ_ONLY),
                "READ_WRITE" => std::option::Option::Some(Self::READ_WRITE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AccessMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AccessMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The squash mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SquashMode(i32);

    impl SquashMode {
        /// SquashMode not set.
        pub const SQUASH_MODE_UNSPECIFIED: SquashMode = SquashMode::new(0);

        /// The Root user has root access to the file share (default).
        pub const NO_ROOT_SQUASH: SquashMode = SquashMode::new(1);

        /// The Root user has squashed access to the anonymous uid/gid.
        pub const ROOT_SQUASH: SquashMode = SquashMode::new(2);

        /// Creates a new SquashMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SQUASH_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NO_ROOT_SQUASH"),
                2 => std::borrow::Cow::Borrowed("ROOT_SQUASH"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SQUASH_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SQUASH_MODE_UNSPECIFIED)
                }
                "NO_ROOT_SQUASH" => std::option::Option::Some(Self::NO_ROOT_SQUASH),
                "ROOT_SQUASH" => std::option::Option::Some(Self::ROOT_SQUASH),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SquashMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SquashMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Replica configuration for the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaConfig {
    /// Output only. The replica state.
    pub state: crate::model::replica_config::State,

    /// Output only. Additional information about the replication state, if
    /// available.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub state_reasons: std::vec::Vec<crate::model::replica_config::StateReason>,

    /// Optional. The peer instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_instance: std::string::String,

    /// Output only. The timestamp of the latest replication snapshot taken on the
    /// active instance and is already replicated safely.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_active_sync_time: std::option::Option<wkt::Timestamp>,
}

impl ReplicaConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ReplicaConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::replica_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [peer_instance][crate::model::ReplicaConfig::peer_instance].
    pub fn set_peer_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_instance = v.into();
        self
    }

    /// Sets the value of [last_active_sync_time][crate::model::ReplicaConfig::last_active_sync_time].
    pub fn set_last_active_sync_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_active_sync_time = v.into();
        self
    }

    /// Sets the value of [state_reasons][crate::model::ReplicaConfig::state_reasons].
    pub fn set_state_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::replica_config::StateReason>,
    {
        use std::iter::Iterator;
        self.state_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReplicaConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ReplicaConfig"
    }
}

/// Defines additional types related to ReplicaConfig
pub mod replica_config {
    #[allow(unused_imports)]
    use super::*;

    /// The replica state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The replica is being created.
        pub const CREATING: State = State::new(1);

        /// The replica is ready.
        pub const READY: State = State::new(3);

        /// The replica is being removed.
        pub const REMOVING: State = State::new(4);

        /// The replica is experiencing an issue and might be unusable. You can get
        /// further details from the `stateReasons` field of the `ReplicaConfig`
        /// object.
        pub const FAILED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                3 => std::borrow::Cow::Borrowed("READY"),
                4 => std::borrow::Cow::Borrowed("REMOVING"),
                5 => std::borrow::Cow::Borrowed("FAILED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "REMOVING" => std::option::Option::Some(Self::REMOVING),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Additional information about the replication state, if available.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StateReason(i32);

    impl StateReason {
        /// Reason not specified.
        pub const STATE_REASON_UNSPECIFIED: StateReason = StateReason::new(0);

        /// The peer instance is unreachable.
        pub const PEER_INSTANCE_UNREACHABLE: StateReason = StateReason::new(1);

        /// The remove replica peer instance operation failed.
        pub const REMOVE_FAILED: StateReason = StateReason::new(2);

        /// Creates a new StateReason instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_REASON_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PEER_INSTANCE_UNREACHABLE"),
                2 => std::borrow::Cow::Borrowed("REMOVE_FAILED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_REASON_UNSPECIFIED" => {
                    std::option::Option::Some(Self::STATE_REASON_UNSPECIFIED)
                }
                "PEER_INSTANCE_UNREACHABLE" => {
                    std::option::Option::Some(Self::PEER_INSTANCE_UNREACHABLE)
                }
                "REMOVE_FAILED" => std::option::Option::Some(Self::REMOVE_FAILED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StateReason {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StateReason {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Replication specifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Replication {
    /// Optional. The replication role.
    pub role: crate::model::replication::Role,

    /// Optional. Replication configuration for the replica instance associated
    /// with this instance. Only a single replica is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replicas: std::vec::Vec<crate::model::ReplicaConfig>,
}

impl Replication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::Replication::role].
    pub fn set_role<T: std::convert::Into<crate::model::replication::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [replicas][crate::model::Replication::replicas].
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaConfig>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Replication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Replication"
    }
}

/// Defines additional types related to Replication
pub mod replication {
    #[allow(unused_imports)]
    use super::*;

    /// Replication role.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Role(i32);

    impl Role {
        /// Role not set.
        pub const ROLE_UNSPECIFIED: Role = Role::new(0);

        /// The instance is the `ACTIVE` replication member, functions as
        /// the replication source instance.
        pub const ACTIVE: Role = Role::new(1);

        /// The instance is the `STANDBY` replication member, functions as
        /// the replication destination instance.
        pub const STANDBY: Role = Role::new(2);

        /// Creates a new Role instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ROLE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ACTIVE"),
                2 => std::borrow::Cow::Borrowed("STANDBY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ROLE_UNSPECIFIED" => std::option::Option::Some(Self::ROLE_UNSPECIFIED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "STANDBY" => std::option::Option::Some(Self::STANDBY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A Filestore instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The resource name of the instance, in the format
    /// `projects/{project}/locations/{location}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The description of the instance (2048 characters or less).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The instance state.
    pub state: crate::model::instance::State,

    /// Output only. Additional information about the instance state, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The service tier of the instance.
    pub tier: crate::model::instance::Tier,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// File system shares on the instance.
    /// For this version, only a single file share is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_shares: std::vec::Vec<crate::model::FileShareConfig>,

    /// VPC networks to which the instance is connected.
    /// For this version, only a single network is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Server-specified ETag for the instance resource to prevent simultaneous
    /// updates from overwriting each other.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// KMS key name used for data encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. Field indicates all the reasons the instance is in "SUSPENDED"
    /// state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub suspension_reasons: std::vec::Vec<crate::model::instance::SuspensionReason>,

    /// Optional. Replication configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication: std::option::Option<crate::model::Replication>,

    /// Optional. Input only. Immutable. Tag key-value pairs bound to this
    /// resource. Each key must be a namespaced name and each value a short name.
    /// Example:
    /// "123456789012/environment" : "production",
    /// "123456789013/costCenter" : "marketing"
    /// See the documentation for more information:
    ///
    /// - Namespaced name:
    ///   <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_key>
    /// - Short name:
    ///   <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_value>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. The protocol indicates the access protocol for all shares in the
    /// instance. This field is immutable and it cannot be changed after the
    /// instance has been created. Default value: `NFS_V3`.
    pub protocol: crate::model::instance::FileProtocol,

    /// Output only. Indicates whether this instance supports configuring its
    /// performance. If true, the user can configure the instance's performance by
    /// using the 'performance_config' field.
    pub custom_performance_supported: bool,

    /// Optional. Used to configure performance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_config: std::option::Option<crate::model::instance::PerformanceConfig>,

    /// Output only. Used for getting performance limits.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_limits: std::option::Option<crate::model::instance::PerformanceLimits>,

    /// Optional. Indicates whether the instance is protected against deletion.
    pub deletion_protection_enabled: bool,

    /// Optional. The reason for enabling deletion protection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deletion_protection_reason: std::string::String,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Instance::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Instance::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::Instance::tier].
    pub fn set_tier<T: std::convert::Into<crate::model::instance::Tier>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Instance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Instance::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [replication][crate::model::Instance::replication].
    pub fn set_replication<
        T: std::convert::Into<std::option::Option<crate::model::Replication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::Instance::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::instance::FileProtocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [custom_performance_supported][crate::model::Instance::custom_performance_supported].
    pub fn set_custom_performance_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.custom_performance_supported = v.into();
        self
    }

    /// Sets the value of [performance_config][crate::model::Instance::performance_config].
    pub fn set_performance_config<
        T: std::convert::Into<std::option::Option<crate::model::instance::PerformanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_config = v.into();
        self
    }

    /// Sets the value of [performance_limits][crate::model::Instance::performance_limits].
    pub fn set_performance_limits<
        T: std::convert::Into<std::option::Option<crate::model::instance::PerformanceLimits>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_limits = v.into();
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Instance::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deletion_protection_enabled = v.into();
        self
    }

    /// Sets the value of [deletion_protection_reason][crate::model::Instance::deletion_protection_reason].
    pub fn set_deletion_protection_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deletion_protection_reason = v.into();
        self
    }

    /// Sets the value of [file_shares][crate::model::Instance::file_shares].
    pub fn set_file_shares<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileShareConfig>,
    {
        use std::iter::Iterator;
        self.file_shares = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::Instance::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suspension_reasons][crate::model::Instance::suspension_reasons].
    pub fn set_suspension_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::SuspensionReason>,
    {
        use std::iter::Iterator;
        self.suspension_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Instance::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// IOPS per TB.
    /// Filestore defines TB as 1024^4 bytes (TiB).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IOPSPerTB {
        /// Required. Maximum IOPS per TiB.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_iops_per_tb: i64,
    }

    impl IOPSPerTB {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_iops_per_tb][crate::model::instance::IOPSPerTB::max_iops_per_tb].
        pub fn set_max_iops_per_tb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_iops_per_tb = v.into();
            self
        }
    }

    impl wkt::message::Message for IOPSPerTB {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.filestore.v1.Instance.IOPSPerTB"
        }
    }

    /// Fixed IOPS (input/output operations per second) parameters.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FixedIOPS {
        /// Required. Maximum IOPS.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_iops: i64,
    }

    impl FixedIOPS {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_iops][crate::model::instance::FixedIOPS::max_iops].
        pub fn set_max_iops<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_iops = v.into();
            self
        }
    }

    impl wkt::message::Message for FixedIOPS {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.filestore.v1.Instance.FixedIOPS"
        }
    }

    /// Used for setting the performance configuration.
    /// If the user doesn't specify PerformanceConfig, automatically provision
    /// the default performance settings as described in
    /// <https://cloud.google.com/filestore/docs/performance>. Larger instances will
    /// be linearly set to more IOPS. If the instance's capacity is increased or
    /// decreased, its performance will be automatically adjusted upwards or
    /// downwards accordingly (respectively).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerformanceConfig {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub mode: std::option::Option<crate::model::instance::performance_config::Mode>,
    }

    impl PerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `mode`.
        pub fn set_mode<
            T: std::convert::Into<
                std::option::Option<crate::model::instance::performance_config::Mode>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }

        /// The value of [mode][crate::model::instance::PerformanceConfig::mode]
        /// if it holds a `IopsPerTb`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_iops_per_tb(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::instance::IOPSPerTB>> {
            #[allow(unreachable_patterns)]
            self.mode.as_ref().and_then(|v| match v {
                crate::model::instance::performance_config::Mode::IopsPerTb(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [mode][crate::model::instance::PerformanceConfig::mode]
        /// if it holds a `FixedIops`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_fixed_iops(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::instance::FixedIOPS>> {
            #[allow(unreachable_patterns)]
            self.mode.as_ref().and_then(|v| match v {
                crate::model::instance::performance_config::Mode::FixedIops(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [mode][crate::model::instance::PerformanceConfig::mode]
        /// to hold a `IopsPerTb`.
        ///
        /// Note that all the setters affecting `mode` are
        /// mutually exclusive.
        pub fn set_iops_per_tb<
            T: std::convert::Into<std::boxed::Box<crate::model::instance::IOPSPerTB>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = std::option::Option::Some(
                crate::model::instance::performance_config::Mode::IopsPerTb(v.into()),
            );
            self
        }

        /// Sets the value of [mode][crate::model::instance::PerformanceConfig::mode]
        /// to hold a `FixedIops`.
        ///
        /// Note that all the setters affecting `mode` are
        /// mutually exclusive.
        pub fn set_fixed_iops<
            T: std::convert::Into<std::boxed::Box<crate::model::instance::FixedIOPS>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = std::option::Option::Some(
                crate::model::instance::performance_config::Mode::FixedIops(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for PerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.filestore.v1.Instance.PerformanceConfig"
        }
    }

    /// Defines additional types related to PerformanceConfig
    pub mod performance_config {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Mode {
            /// Provision IOPS dynamically based on the capacity of the instance.
            /// Provisioned IOPS will be calculated by multiplying the capacity of the
            /// instance in TiB by the `iops_per_tb` value. For example, for a 2 TiB
            /// instance with an `iops_per_tb` value of 17000 the provisioned IOPS will
            /// be 34000.
            ///
            /// If the calculated value is outside the supported range for the
            /// instance's capacity during instance creation, instance creation will
            /// fail with an `InvalidArgument` error. Similarly, if an instance
            /// capacity update would result in a value outside the supported range,
            /// the update will fail with an `InvalidArgument` error.
            IopsPerTb(std::boxed::Box<crate::model::instance::IOPSPerTB>),
            /// Choose a fixed provisioned IOPS value for the instance, which will
            /// remain constant regardless of instance capacity. Value must be a
            /// multiple of 1000.
            ///
            /// If the chosen value is outside the supported range for the instance's
            /// capacity during instance creation, instance creation will fail with an
            /// `InvalidArgument` error. Similarly, if an instance capacity update
            /// would result in a value outside the supported range, the update will
            /// fail with an `InvalidArgument` error.
            FixedIops(std::boxed::Box<crate::model::instance::FixedIOPS>),
        }
    }

    /// The enforced performance limits, calculated from the instance's performance
    /// configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerformanceLimits {
        /// Output only. The max IOPS.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_iops: i64,

        /// Output only. The max read IOPS.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_read_iops: i64,

        /// Output only. The max write IOPS.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_write_iops: i64,

        /// Output only. The max read throughput in bytes per second.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_read_throughput_bps: i64,

        /// Output only. The max write throughput in bytes per second.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_write_throughput_bps: i64,
    }

    impl PerformanceLimits {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_iops][crate::model::instance::PerformanceLimits::max_iops].
        pub fn set_max_iops<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_iops = v.into();
            self
        }

        /// Sets the value of [max_read_iops][crate::model::instance::PerformanceLimits::max_read_iops].
        pub fn set_max_read_iops<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_read_iops = v.into();
            self
        }

        /// Sets the value of [max_write_iops][crate::model::instance::PerformanceLimits::max_write_iops].
        pub fn set_max_write_iops<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_write_iops = v.into();
            self
        }

        /// Sets the value of [max_read_throughput_bps][crate::model::instance::PerformanceLimits::max_read_throughput_bps].
        pub fn set_max_read_throughput_bps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_read_throughput_bps = v.into();
            self
        }

        /// Sets the value of [max_write_throughput_bps][crate::model::instance::PerformanceLimits::max_write_throughput_bps].
        pub fn set_max_write_throughput_bps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_write_throughput_bps = v.into();
            self
        }
    }

    impl wkt::message::Message for PerformanceLimits {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.filestore.v1.Instance.PerformanceLimits"
        }
    }

    /// The instance state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The instance is being created.
        pub const CREATING: State = State::new(1);

        /// The instance is available for use.
        pub const READY: State = State::new(2);

        /// Work is being done on the instance. You can get further details from the
        /// `statusMessage` field of the `Instance` resource.
        pub const REPAIRING: State = State::new(3);

        /// The instance is shutting down.
        pub const DELETING: State = State::new(4);

        /// The instance is experiencing an issue and might be unusable. You can get
        /// further details from the `statusMessage` field of the `Instance`
        /// resource.
        pub const ERROR: State = State::new(6);

        /// The instance is restoring a backup to an existing file share and may be
        /// unusable during this time.
        pub const RESTORING: State = State::new(7);

        /// The instance is suspended. You can get further details from
        /// the `suspension_reasons` field of the `Instance` resource.
        pub const SUSPENDED: State = State::new(8);

        /// The instance is in the process of becoming suspended.
        pub const SUSPENDING: State = State::new(9);

        /// The instance is in the process of becoming active.
        pub const RESUMING: State = State::new(10);

        /// The instance is reverting to a snapshot.
        pub const REVERTING: State = State::new(12);

        /// The replica instance is being promoted.
        pub const PROMOTING: State = State::new(13);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("REPAIRING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                6 => std::borrow::Cow::Borrowed("ERROR"),
                7 => std::borrow::Cow::Borrowed("RESTORING"),
                8 => std::borrow::Cow::Borrowed("SUSPENDED"),
                9 => std::borrow::Cow::Borrowed("SUSPENDING"),
                10 => std::borrow::Cow::Borrowed("RESUMING"),
                12 => std::borrow::Cow::Borrowed("REVERTING"),
                13 => std::borrow::Cow::Borrowed("PROMOTING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "REPAIRING" => std::option::Option::Some(Self::REPAIRING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "RESTORING" => std::option::Option::Some(Self::RESTORING),
                "SUSPENDED" => std::option::Option::Some(Self::SUSPENDED),
                "SUSPENDING" => std::option::Option::Some(Self::SUSPENDING),
                "RESUMING" => std::option::Option::Some(Self::RESUMING),
                "REVERTING" => std::option::Option::Some(Self::REVERTING),
                "PROMOTING" => std::option::Option::Some(Self::PROMOTING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Available service tiers.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Tier(i32);

    impl Tier {
        /// Not set.
        pub const TIER_UNSPECIFIED: Tier = Tier::new(0);

        /// STANDARD tier. BASIC_HDD is the preferred term for this tier.
        pub const STANDARD: Tier = Tier::new(1);

        /// PREMIUM tier. BASIC_SSD is the preferred term for this tier.
        pub const PREMIUM: Tier = Tier::new(2);

        /// BASIC instances offer a maximum capacity of 63.9 TB.
        /// BASIC_HDD is an alias for STANDARD Tier, offering economical
        /// performance backed by HDD.
        pub const BASIC_HDD: Tier = Tier::new(3);

        /// BASIC instances offer a maximum capacity of 63.9 TB.
        /// BASIC_SSD is an alias for PREMIUM Tier, and offers improved
        /// performance backed by SSD.
        pub const BASIC_SSD: Tier = Tier::new(4);

        /// HIGH_SCALE instances offer expanded capacity and performance scaling
        /// capabilities.
        pub const HIGH_SCALE_SSD: Tier = Tier::new(5);

        /// ENTERPRISE instances offer the features and availability needed for
        /// mission-critical workloads.
        pub const ENTERPRISE: Tier = Tier::new(6);

        /// ZONAL instances offer expanded capacity and performance scaling
        /// capabilities.
        pub const ZONAL: Tier = Tier::new(7);

        /// REGIONAL instances offer the features and availability needed for
        /// mission-critical workloads.
        pub const REGIONAL: Tier = Tier::new(8);

        /// Creates a new Tier instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TIER_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STANDARD"),
                2 => std::borrow::Cow::Borrowed("PREMIUM"),
                3 => std::borrow::Cow::Borrowed("BASIC_HDD"),
                4 => std::borrow::Cow::Borrowed("BASIC_SSD"),
                5 => std::borrow::Cow::Borrowed("HIGH_SCALE_SSD"),
                6 => std::borrow::Cow::Borrowed("ENTERPRISE"),
                7 => std::borrow::Cow::Borrowed("ZONAL"),
                8 => std::borrow::Cow::Borrowed("REGIONAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TIER_UNSPECIFIED" => std::option::Option::Some(Self::TIER_UNSPECIFIED),
                "STANDARD" => std::option::Option::Some(Self::STANDARD),
                "PREMIUM" => std::option::Option::Some(Self::PREMIUM),
                "BASIC_HDD" => std::option::Option::Some(Self::BASIC_HDD),
                "BASIC_SSD" => std::option::Option::Some(Self::BASIC_SSD),
                "HIGH_SCALE_SSD" => std::option::Option::Some(Self::HIGH_SCALE_SSD),
                "ENTERPRISE" => std::option::Option::Some(Self::ENTERPRISE),
                "ZONAL" => std::option::Option::Some(Self::ZONAL),
                "REGIONAL" => std::option::Option::Some(Self::REGIONAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Tier {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// SuspensionReason contains the possible reasons for a suspension.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SuspensionReason(i32);

    impl SuspensionReason {
        /// Not set.
        pub const SUSPENSION_REASON_UNSPECIFIED: SuspensionReason = SuspensionReason::new(0);

        /// The KMS key used by the instance is either revoked or denied access to.
        pub const KMS_KEY_ISSUE: SuspensionReason = SuspensionReason::new(1);

        /// Creates a new SuspensionReason instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SUSPENSION_REASON_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("KMS_KEY_ISSUE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SUSPENSION_REASON_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SUSPENSION_REASON_UNSPECIFIED)
                }
                "KMS_KEY_ISSUE" => std::option::Option::Some(Self::KMS_KEY_ISSUE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SuspensionReason {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SuspensionReason {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// File access protocol.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FileProtocol(i32);

    impl FileProtocol {
        /// FILE_PROTOCOL_UNSPECIFIED serves a "not set" default value when
        /// a FileProtocol is a separate field in a message.
        pub const FILE_PROTOCOL_UNSPECIFIED: FileProtocol = FileProtocol::new(0);

        /// NFS 3.0.
        pub const NFS_V3: FileProtocol = FileProtocol::new(1);

        /// NFS 4.1.
        pub const NFS_V4_1: FileProtocol = FileProtocol::new(2);

        /// Creates a new FileProtocol instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FILE_PROTOCOL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NFS_V3"),
                2 => std::borrow::Cow::Borrowed("NFS_V4_1"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FILE_PROTOCOL_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FILE_PROTOCOL_UNSPECIFIED)
                }
                "NFS_V3" => std::option::Option::Some(Self::NFS_V3),
                "NFS_V4_1" => std::option::Option::Some(Self::NFS_V4_1),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FileProtocol {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FileProtocol {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// CreateInstanceRequest creates an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The instance's project and location, in the format
    /// `projects/{project_id}/locations/{location}`. In Filestore,
    /// locations map to Google Cloud zones, for example **us-west1-b**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name of the instance to create.
    /// The name must be unique for the specified project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. An [instance resource][google.cloud.filestore.v1.Instance]
    ///
    /// [google.cloud.filestore.v1.Instance]: crate::model::Instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateInstanceRequest"
    }
}

/// GetInstanceRequest gets the state of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The instance resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetInstanceRequest"
    }
}

/// UpdateInstanceRequest updates the settings of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Mask of fields to update.  At least one path must be supplied in this
    /// field.  The elements of the repeated paths field may only include these
    /// fields:
    ///
    /// * "description"
    /// * "file_shares"
    /// * "labels"
    /// * "performance_config"
    /// * "deletion_protection_enabled"
    /// * "deletion_protection_reason"
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Only fields specified in update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateInstanceRequest"
    }
}

/// RestoreInstanceRequest restores an existing instance's file share from a
/// backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreInstanceRequest {
    /// Required. The resource name of the instance, in the format
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Name of the file share in the Filestore instance that the backup
    /// is being restored to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_share: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::restore_instance_request::Source>,
}

impl RestoreInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [file_share][crate::model::RestoreInstanceRequest::file_share].
    pub fn set_file_share<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_share = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_instance_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreInstanceRequest::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_instance_request::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreInstanceRequest::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_instance_request::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.RestoreInstanceRequest"
    }
}

/// Defines additional types related to RestoreInstanceRequest
pub mod restore_instance_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The resource name of the backup, in the format
        /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
        SourceBackup(std::string::String),
    }
}

/// RevertInstanceRequest reverts the given instance's file share to the
/// specified snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevertInstanceRequest {
    /// Required. The resource name of the instance, in the format
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The snapshot resource ID, in the format 'my-snapshot', where the
    /// specified ID is the {snapshot_id} of the fully qualified name like
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_snapshot_id: std::string::String,
}

impl RevertInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevertInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_snapshot_id][crate::model::RevertInstanceRequest::target_snapshot_id].
    pub fn set_target_snapshot_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_snapshot_id = v.into();
        self
    }
}

impl wkt::message::Message for RevertInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.RevertInstanceRequest"
    }
}

/// DeleteInstanceRequest deletes an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The instance resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, all snapshots of the instance will also be deleted.
    /// (Otherwise, the request will only work if the instance has no snapshots.)
    pub force: bool,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteInstanceRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteInstanceRequest"
    }
}

/// ListInstancesRequest lists instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The project and location for which to retrieve instance
    /// information, in the format `projects/{project_id}/locations/{location}`. In
    /// Cloud Filestore, locations map to Google Cloud zones, for example
    /// **us-west1-b**. To retrieve instance information for all locations, use "-"
    /// for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListInstancesRequest"
    }
}

/// ListInstancesResponse is the result of ListInstancesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// A list of instances in the project for the specified location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of instances from all locations. If any location is unreachable, the
    /// response will only return instances in reachable locations and the
    /// "unreachable" field will be populated with a list of unreachable locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unordered list. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListInstancesResponse"
    }
}

impl gax::paginator::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A Filestore snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Snapshot {
    /// Output only. The resource name of the snapshot, in the format
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A description of the snapshot with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The snapshot state.
    pub state: crate::model::snapshot::State,

    /// Output only. The time when the snapshot was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The amount of bytes needed to allocate a full copy of the
    /// snapshot content
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub filesystem_used_bytes: i64,

    /// Optional. Input only. Immutable. Tag key-value pairs bound to this
    /// resource. Each key must be a namespaced name and each value a short name.
    /// Example:
    /// "123456789012/environment" : "production",
    /// "123456789013/costCenter" : "marketing"
    /// See the documentation for more information:
    ///
    /// - Namespaced name:
    ///   <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_key>
    /// - Short name:
    ///   <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_value>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Snapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Snapshot::state].
    pub fn set_state<T: std::convert::Into<crate::model::snapshot::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [filesystem_used_bytes][crate::model::Snapshot::filesystem_used_bytes].
    pub fn set_filesystem_used_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.filesystem_used_bytes = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Snapshot::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Snapshot::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Snapshot"
    }
}

/// Defines additional types related to Snapshot
pub mod snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// The snapshot state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Snapshot is being created.
        pub const CREATING: State = State::new(1);

        /// Snapshot is available for use.
        pub const READY: State = State::new(2);

        /// Snapshot is being deleted.
        pub const DELETING: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// CreateSnapshotRequest creates a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSnapshotRequest {
    /// Required. The Filestore Instance to create the snapshots of, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the snapshot.
    /// The ID must be unique within the specified instance.
    ///
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_id: std::string::String,

    /// Required. A snapshot resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,
}

impl CreateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::CreateSnapshotRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::CreateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for CreateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateSnapshotRequest"
    }
}

/// GetSnapshotRequest gets the state of a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetSnapshotRequest"
    }
}

/// DeleteSnapshotRequest deletes a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteSnapshotRequest"
    }
}

/// UpdateSnapshotRequest updates description and/or labels for a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSnapshotRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A snapshot resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,
}

impl UpdateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateSnapshotRequest"
    }
}

/// ListSnapshotsRequest lists snapshots.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The instance for which to retrieve snapshot information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. If true, allow partial responses for multi-regional Aggregated
    /// List requests.
    pub return_partial_success: bool,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSnapshotsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSnapshotsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [return_partial_success][crate::model::ListSnapshotsRequest::return_partial_success].
    pub fn set_return_partial_success<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_partial_success = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListSnapshotsRequest"
    }
}

/// ListSnapshotsResponse is the result of ListSnapshotsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// A list of snapshots in the project for the specified instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unordered list. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSnapshotsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListSnapshotsResponse"
    }
}

impl gax::paginator::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A Filestore backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The resource name of the backup, in the format
    /// `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A description of the backup with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The backup state.
    pub state: crate::model::backup::State,

    /// Output only. The time when the backup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Capacity of the source file share when the backup was created.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gb: i64,

    /// Output only. The size of the storage used by the backup. As backups share
    /// storage, this number is expected to change with backup creation/deletion.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub storage_bytes: i64,

    /// The resource name of the source Filestore instance, in the format
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`,
    /// used to create this backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_instance: std::string::String,

    /// Name of the file share in the source Filestore instance that the
    /// backup is created from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_file_share: std::string::String,

    /// Output only. The service tier of the source Filestore instance that this
    /// backup is created from.
    pub source_instance_tier: crate::model::instance::Tier,

    /// Output only. Amount of bytes that will be downloaded if the backup is
    /// restored. This may be different than storage bytes, since sequential
    /// backups of the same disk will share storage.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub download_bytes: i64,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// Immutable. KMS key name used for data encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// Optional. Input only. Immutable. Tag key-value pairs bound to this
    /// resource. Each key must be a namespaced name and each value a short name.
    /// Example:
    /// "123456789012/environment" : "production",
    /// "123456789013/costCenter" : "marketing"
    /// See the documentation for more information:
    ///
    /// - Namespaced name:
    ///   <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_key>
    /// - Short name:
    ///   <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_value>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The file system protocol of the source Filestore instance that
    /// this backup is created from.
    pub file_system_protocol: crate::model::instance::FileProtocol,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [capacity_gb][crate::model::Backup::capacity_gb].
    pub fn set_capacity_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gb = v.into();
        self
    }

    /// Sets the value of [storage_bytes][crate::model::Backup::storage_bytes].
    pub fn set_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.storage_bytes = v.into();
        self
    }

    /// Sets the value of [source_instance][crate::model::Backup::source_instance].
    pub fn set_source_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_instance = v.into();
        self
    }

    /// Sets the value of [source_file_share][crate::model::Backup::source_file_share].
    pub fn set_source_file_share<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_file_share = v.into();
        self
    }

    /// Sets the value of [source_instance_tier][crate::model::Backup::source_instance_tier].
    pub fn set_source_instance_tier<T: std::convert::Into<crate::model::instance::Tier>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_instance_tier = v.into();
        self
    }

    /// Sets the value of [download_bytes][crate::model::Backup::download_bytes].
    pub fn set_download_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.download_bytes = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Backup::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::Backup::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [file_system_protocol][crate::model::Backup::file_system_protocol].
    pub fn set_file_system_protocol<T: std::convert::Into<crate::model::instance::FileProtocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_system_protocol = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Backup::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.Backup"
    }
}

/// Defines additional types related to Backup
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// The backup state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Backup is being created.
        pub const CREATING: State = State::new(1);

        /// Backup has been taken and the operation is being finalized. At this
        /// point, changes to the file share will not be reflected in the backup.
        pub const FINALIZING: State = State::new(2);

        /// Backup is available for use.
        pub const READY: State = State::new(3);

        /// Backup is being deleted.
        pub const DELETING: State = State::new(4);

        /// Backup is not valid and cannot be used for creating new instances or
        /// restoring existing instances.
        pub const INVALID: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("FINALIZING"),
                3 => std::borrow::Cow::Borrowed("READY"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                5 => std::borrow::Cow::Borrowed("INVALID"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "FINALIZING" => std::option::Option::Some(Self::FINALIZING),
                "READY" => std::option::Option::Some(Self::READY),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "INVALID" => std::option::Option::Some(Self::INVALID),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// CreateBackupRequest creates a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. The backup's project and location, in the format
    /// `projects/{project_number}/locations/{location}`. In Filestore,
    /// backup locations map to Google Cloud regions, for example **us-west1**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A [backup resource][google.cloud.filestore.v1.Backup]
    ///
    /// [google.cloud.filestore.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. The ID to use for the backup.
    /// The ID must be unique within the specified project and location.
    ///
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    /// Values that do not match this pattern will trigger an INVALID_ARGUMENT
    /// error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_id: std::string::String,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.CreateBackupRequest"
    }
}

/// DeleteBackupRequest deletes a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_number}/locations/{location}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.DeleteBackupRequest"
    }
}

/// UpdateBackupRequest updates description and/or labels for a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. A [backup resource][google.cloud.filestore.v1.Backup]
    ///
    /// [google.cloud.filestore.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. Mask of fields to update.  At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.UpdateBackupRequest"
    }
}

/// PromoteReplicaRequest promotes a Filestore standby instance (replica).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PromoteReplicaRequest {
    /// Required. The resource name of the instance, in the format
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The resource name of the peer instance to promote, in the format
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}`.
    /// The peer instance is required if the operation is called on an active
    /// instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_instance: std::string::String,
}

impl PromoteReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PromoteReplicaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [peer_instance][crate::model::PromoteReplicaRequest::peer_instance].
    pub fn set_peer_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_instance = v.into();
        self
    }
}

impl wkt::message::Message for PromoteReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.PromoteReplicaRequest"
    }
}

/// GetBackupRequest gets the state of a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_number}/locations/{location}/backups/{backup_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.GetBackupRequest"
    }
}

/// ListBackupsRequest lists backups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The project and location for which to retrieve backup
    /// information, in the format
    /// `projects/{project_number}/locations/{location}`. In Filestore, backup
    /// locations map to Google Cloud regions, for example **us-west1**. To
    /// retrieve backup information for all locations, use "-" for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListBackupsRequest"
    }
}

/// ListBackupsResponse is the result of ListBackupsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project for the specified location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of backups from all locations. If any location is unreachable, the
    /// response will only return backups in reachable locations and the
    /// "unreachable" field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unordered list. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.filestore.v1.ListBackupsResponse"
    }
}

impl gax::paginator::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}
